{"CVE": "CVE-2022-1719", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "/*\n      .                              .o8                     oooo\n   .o8                             \"888                     `888\n .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n   888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n   888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n   888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n   \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n ========================================================================\n **/\n\nconst ticketSchema = require('../models/ticket')\nconst async = require('async')\nconst path = require('path')\nconst _ = require('lodash')\nconst winston = require('../logger')\nconst groupSchema = require('../models/group')\nconst departmentSchema = require('../models/department')\nconst permissions = require('../permissions')\nconst xss = require('xss')\n/**\n * @since 1.0\n * @author Chris Brame <polonel@gmail.com>\n * @copyright 2015 Chris Brame\n **/\n\n/**\n * @namespace\n * @description Controller for each Ticket View\n * @requires {@link Ticket}\n * @requires {@link Group}\n * @requires {@link TicketType}\n * @requires {@link Emitter}\n *\n */\nconst ticketsController = {}\n\n/**\n * @name ticketsController.content\n * @description Main Content sent to the view\n */\nticketsController.content = {}\n\nticketsController.pubNewIssue = function (req, res) {\n  const marked = require('marked')\n  const settings = require('../models/setting')\n  settings.getSettingByName('allowPublicTickets:enable', function (err, setting) {\n    if (err) return handleError(res, err)\n    if (setting && setting.value === true) {\n      settings.getSettingByName('legal:privacypolicy', function (err, privacyPolicy) {\n        if (err) return handleError(res, err)\n\n        const content = {}\n        content.title = 'New Issue'\n        content.layout = false\n        content.data = {}\n        if (privacyPolicy === null || _.isUndefined(privacyPolicy.value)) {\n          content.data.privacyPolicy = 'No Privacy Policy has been set.'\n        } else {\n          content.data.privacyPolicy = xss(marked.parse(privacyPolicy.value))\n        }\n\n        return res.render('pub_createTicket', content)\n      })\n    } else {\n      return res.redirect('/')\n    }\n  })\n}\n\n/**\n * Get Ticket View based on ticket status\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @param {function} next Sends the ```req.processor``` object to the processor\n * @see Ticket\n */\nticketsController.getByStatus = function (req, res, next) {\n  const url = require('url')\n  let page = req.params.page\n  if (_.isUndefined(page)) page = 0\n\n  const processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.subnav = 'tickets-'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'active'\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: []\n  }\n\n  const fullUrl = url.format({\n    protocol: req.protocol,\n    host: req.get('host'),\n    pathname: req.originalUrl\n  })\n\n  const pathname = new url.URL(fullUrl).pathname\n  const arr = pathname.split('/')\n  let tType = 'new'\n  let s = 0\n  if (_.size(arr) > 2) tType = arr[2]\n\n  switch (tType) {\n    case 'open':\n      s = 1\n      break\n    case 'pending':\n      s = 2\n      break\n    case 'closed':\n      s = 3\n      break\n  }\n\n  processor.subnav += tType\n  processor.pagetype = tType\n  processor.object.status.push(s)\n\n  req.processor = processor\n  return next()\n}\n\n/**\n * Get Ticket View based on ticket active tickets\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @param {function} next Sends the ```req.processor``` object to the processor\n * @see Ticket\n */\nticketsController.getActive = function (req, res, next) {\n  let page = req.params.page\n  if (_.isUndefined(page)) page = 0\n\n  const processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.subnav = 'tickets-active'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'active'\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: [0, 1, 2]\n  }\n\n  req.processor = processor\n\n  return next()\n}\n\n/**\n * Get Ticket View based on tickets assigned to a given user\n * _calls ```next()``` to send to processor_\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @param {callback} next Sends the ```req.processor``` object to the processor\n * @see Ticket\n */\nticketsController.getAssigned = function (req, res, next) {\n  let page = req.params.page\n  if (_.isUndefined(page)) page = 0\n\n  const processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.subnav = 'tickets-assigned'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'assigned'\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: [0, 1, 2],\n    assignedSelf: true,\n    user: req.user._id\n  }\n\n  req.processor = processor\n\n  return next()\n}\n\n/**\n * Get Ticket View based on tickets assigned to a given user\n * _calls ```next()``` to send to processor_\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @param {callback} next Sends the ```req.processor``` object to the processor\n * @see Ticket\n */\nticketsController.getUnassigned = function (req, res, next) {\n  let page = req.params.page\n  if (_.isUndefined(page)) page = 0\n\n  const processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.subnav = 'tickets-unassigned'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'unassigned'\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: [0, 1, 2],\n    unassigned: true,\n    user: req.user._id\n  }\n\n  req.processor = processor\n\n  return next()\n}\n\nticketsController.filter = function (req, res, next) {\n  let page = req.query.page\n  if (_.isUndefined(page)) page = 0\n\n  const queryString = req.query\n  const uid = queryString.uid\n  const subject = queryString.fs\n  const issue = queryString.it\n  const dateStart = queryString.ds\n  const dateEnd = queryString.de\n  let status = queryString.st\n  let priority = queryString.pr\n  let groups = queryString.gp\n  let types = queryString.tt\n  let tags = queryString.tag\n  let assignee = queryString.au\n\n  const rawNoPage = req.originalUrl.replace(/[?&]page=[^&#]*(#.*)?$/, '$1').replace(/([?&])page=[^&]*&/, '$1')\n\n  if (!_.isUndefined(status) && !_.isArray(status)) status = [status]\n  if (!_.isUndefined(priority) && !_.isArray(priority)) priority = [priority]\n  if (!_.isUndefined(groups) && !_.isArray(groups)) groups = [groups]\n  if (!_.isUndefined(types) && !_.isArray(types)) types = [types]\n  if (!_.isUndefined(tags) && !_.isArray(tags)) tags = [tags]\n  if (!_.isUndefined(assignee) && !_.isArray(assignee)) assignee = [assignee]\n\n  const filter = {\n    uid: uid,\n    subject: subject,\n    issue: issue,\n    date: {\n      start: dateStart,\n      end: dateEnd\n    },\n    status: status,\n    priority: priority,\n    groups: groups,\n    tags: tags,\n    types: types,\n    assignee: assignee,\n    raw: rawNoPage\n  }\n\n  const processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'filter'\n  processor.filter = filter\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: filter.status,\n    user: req.user._id,\n    filter: filter\n  }\n\n  req.processor = processor\n\n  return next()\n}\n\n/**\n * Process the ```req.processor``` object and render the correct view\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @return {View} Tickets View\n * @see Ticket\n */\nticketsController.processor = function (req, res) {\n  const processor = req.processor\n  if (_.isUndefined(processor)) return res.redirect('/')\n\n  const content = {}\n  content.title = processor.title\n  content.nav = processor.nav\n  content.subnav = processor.subnav\n  content.view = processor.pagetype\n\n  content.data = {}\n  content.data.user = req.user\n  content.data.common = req.viewdata\n\n  const object = processor.object\n  content.data.page = object.page\n  content.data.filter = object.filter\n\n  return res.render(processor.renderpage, content)\n}\n\nticketsController.pdf = function (req, res) {\n  const TicketPDFGenerator = require('../pdf/ticketGenerator')\n  let uid = null\n  try {\n    uid = parseInt(req.params.uid)\n  } catch (e) {\n    winston.warn(e)\n    return res.status(404).send('Invalid Ticket UID')\n  }\n\n  ticketSchema.getTicketByUid(uid, function (err, ticket) {\n    if (err) return handleError(res, err)\n\n    const ticketGenerator = new TicketPDFGenerator(ticket)\n\n    ticketGenerator.generate(function (err, obj) {\n      if (err) return res.redirect('/tickets')\n\n      return res.writeHead(200, obj.headers).end(obj.data)\n    })\n  })\n}\n\n/**\n * Print Ticket View\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @return {View} Subviews/PrintTicket View\n */\nticketsController.print = function (req, res) {\n  const user = req.user\n  let uid = null\n  try {\n    uid = parseInt(req.params.uid)\n  } catch (e) {\n    winston.warn(e)\n    return res.redirect('/tickets')\n  }\n\n  const content = {}\n  content.title = 'Tickets - ' + req.params.uid\n  content.nav = 'tickets'\n\n  content.data = {}\n  content.data.user = req.user\n  content.data.common = req.viewdata\n  content.data.ticket = {}\n\n  ticketSchema.getTicketByUid(uid, function (err, ticket) {\n    if (err) return handleError(res, err)\n    if (_.isNull(ticket) || _.isUndefined(ticket)) return res.redirect('/tickets')\n\n    const hasPublic = permissions.canThis(user.role, 'tickets:public')\n    let hasAccess = false\n    async.series(\n      [\n        function (next) {\n          if (user.role.isAdmin || user.role.isAgent) {\n            departmentSchema.getDepartmentGroupsOfUser(user._id, function (err, groups) {\n              if (err) return res.redirect('/tickets')\n              const gIds = groups.map(function (g) {\n                return g._id\n              })\n\n              if (_.some(gIds, ticket.group._id)) {\n                if (!permissions.canThis(user.role, 'tickets:notes')) {\n                  ticket.notes = []\n                }\n\n                hasAccess = true\n                return next()\n              } else {\n                return next('UNAUTHORIZED_GROUP_ACCESS')\n              }\n            })\n          } else {\n            return next()\n          }\n        },\n        function (next) {\n          if (hasAccess) return next()\n\n          const members = ticket.group.members.map(function (m) {\n            return m._id.toString()\n          })\n\n          if (!members.includes(user._id.toString())) {\n            if (ticket.group.public && hasPublic) {\n              // Blank to bypass\n            } else {\n              return next('UNAUTHORIZED_GROUP_ACCESS')\n            }\n          }\n\n          if (!permissions.canThis(user.role, 'tickets:notes')) {\n            ticket.notes = []\n          }\n\n          return next()\n        }\n      ],\n      function (err) {\n        if (err) {\n          if (err === 'UNAUTHORIZED_GROUP_ACCESS')\n            winston.warn(\n              'User tried to access ticket outside of group - UserId: ' + user._id + ' (' + user.username + ')'\n            )\n\n          return res.redirect('/tickets')\n        }\n\n        content.data.ticket = ticket\n        content.data.ticket.priorityname = ticket.priority.name\n        content.data.ticket.tagsArray = ticket.tags\n        content.data.ticket.commentCount = _.size(ticket.comments)\n        content.layout = 'layout/print'\n\n        return res.render('subviews/printticket', content)\n      }\n    )\n  })\n}\n\n/**\n * Get Single Ticket view based on UID\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @return {View} Single Ticket View\n * @see Ticket\n * @example\n * //Content Object\n * content.title = \"Tickets - \" + req.params.id;\n * content.nav = 'tickets';\n *\n * content.data = {};\n * content.data.user = req.user;\n * content.data.common = req.viewdata;\n *\n * //Ticket Data\n * content.data.ticket = ticket;\n * content.data.ticket.priorityname = getPriorityName(ticket.priority);\n * content.data.ticket.tagsArray = ticket.tags;\n * content.data.ticket.commentCount = _.size(ticket.comments);\n */\nticketsController.single = function (req, res) {\n  const user = req.user\n  const uid = req.params.id\n  if (isNaN(uid)) {\n    return res.redirect('/tickets')\n  }\n\n  const content = {}\n  content.title = 'Tickets - ' + req.params.id\n  content.nav = 'tickets'\n\n  content.data = {}\n  content.data.user = user\n  content.data.common = req.viewdata\n  content.data.ticket = {}\n\n  ticketSchema.getTicketByUid(uid, function (err, ticket) {\n    if (err) return handleError(res, err)\n    if (_.isNull(ticket) || _.isUndefined(ticket)) return res.redirect('/tickets')\n\n    const departmentSchema = require('../models/department')\n    async.waterfall(\n      [\n        function (next) {\n          if (!req.user.role.isAdmin && !req.user.role.isAgent) {\n            return groupSchema.getAllGroupsOfUserNoPopulate(req.user._id, next)\n          }\n\n          departmentSchema.getUserDepartments(req.user._id, function (err, departments) {\n            if (err) return next(err)\n            if (_.some(departments, { allGroups: true })) {\n              return groupSchema.find({}, next)\n            }\n\n            const groups = _.flattenDeep(\n              departments.map(function (d) {\n                return d.groups\n              })\n            )\n\n            return next(null, groups)\n          })\n        },\n        function (userGroups, next) {\n          const hasPublic = permissions.canThis(user.role, 'tickets:public')\n          const groupIds = userGroups.map(function (g) {\n            return g._id.toString()\n          })\n\n          if (!groupIds.includes(ticket.group._id.toString())) {\n            if (ticket.group.public && hasPublic) {\n              // Blank to bypass\n            } else {\n              winston.warn('User access ticket outside of group - UserId: ' + user._id)\n              return res.redirect('/tickets')\n            }\n          }\n\n          if (!permissions.canThis(user.role, 'comments:view')) ticket.comments = []\n\n          if (!permissions.canThis(user.role, 'tickets:notes')) ticket.notes = []\n\n          content.data.ticket = ticket\n          content.data.ticket.priorityname = ticket.priority.name\n\n          return next()\n        }\n      ],\n      function (err) {\n        if (err) {\n          winston.warn(err)\n          return res.redirect('/tickets')\n        }\n\n        return res.render('subviews/singleticket', content)\n      }\n    )\n  })\n}\n\nticketsController.uploadImageMDE = function (req, res) {\n  const Chance = require('chance')\n  const chance = new Chance()\n  const fs = require('fs-extra')\n  const Busboy = require('busboy')\n  const busboy = Busboy({\n    headers: req.headers,\n    limits: {\n      files: 1,\n      fileSize: 5 * 1024 * 1024 // 5mb limit\n    }\n  })\n\n  const object = {}\n  let error\n\n  object.ticketId = req.headers.ticketid\n  if (!object.ticketId) return res.status(400).json({ success: false })\n\n  busboy.on('file', function (name, file, info) {\n    const filename = info.filename\n    const mimetype = info.mimeType\n    if (mimetype.indexOf('image/') === -1) {\n      error = {\n        status: 500,\n        message: 'Invalid File Type'\n      }\n\n      return file.resume()\n    }\n\n    const ext = path.extname(filename)\n    const allowedExtensions = [\n      '.jpg',\n      '.jpeg',\n      '.jpe',\n      '.jif',\n      '.jfif',\n      '.jfi',\n      '.png',\n      '.gif',\n      '.webp',\n      '.tiff',\n      '.tif',\n      '.bmp',\n      '.dib',\n      '.heif',\n      '.heic'\n    ]\n\n    if (!allowedExtensions.includes(ext.toLocaleLowerCase())) {\n      error = {\n        status: 400,\n        message: 'Invalid File Type'\n      }\n\n      return file.resume()\n    }\n\n    const savePath = path.join(__dirname, '../../public/uploads/tickets', object.ticketId)\n    // const sanitizedFilename = filename.replace(/[^a-z0-9.]/gi, '_').toLowerCase();\n    const sanitizedFilename = chance.hash({ length: 20 }) + ext\n    if (!fs.existsSync(savePath)) fs.ensureDirSync(savePath)\n\n    object.filePath = path.join(savePath, 'inline_' + sanitizedFilename)\n    object.filename = sanitizedFilename\n    object.mimetype = mimetype\n\n    if (fs.existsSync(object.filePath)) {\n      error = {\n        status: 500,\n        message: 'File already exists'\n      }\n\n      return file.resume()\n    }\n\n    file.on('limit', function () {\n      error = {\n        status: 500,\n        message: 'File too large'\n      }\n\n      // Delete the temp file\n      if (fs.existsSync(object.filePath)) fs.unlinkSync(object.filePath)\n\n      return file.resume()\n    })\n\n    file.pipe(fs.createWriteStream(object.filePath))\n  })\n\n  busboy.on('finish', function () {\n    if (error) return res.status(error.status).send(error.message)\n\n    if (_.isUndefined(object.ticketId) || _.isUndefined(object.filename) || _.isUndefined(object.filePath)) {\n      return res.status(400).send('Invalid Form Data')\n    }\n\n    // Everything Checks out lets make sure the file exists and then add it to the attachments array\n    if (!fs.existsSync(object.filePath)) return res.status(500).send('File Failed to Save to Disk')\n\n    const fileUrl = '/uploads/tickets/' + object.ticketId + '/inline_' + object.filename\n\n    return res.json({ filename: fileUrl, ticketId: object.ticketId })\n  })\n\n  req.pipe(busboy)\n}\n\nticketsController.uploadAttachment = function (req, res) {\n  const fs = require('fs-extra')\n  const Busboy = require('busboy')\n  const busboy = Busboy({\n    headers: req.headers,\n    limits: {\n      files: 1,\n      fileSize: 10 * 1024 * 1024 // 10mb limit\n    }\n  })\n\n  const object = {\n    ownerId: req.user._id\n  }\n  let error\n\n  busboy.on('field', function (fieldname, val) {\n    if (fieldname === 'ticketId') object.ticketId = val\n    if (fieldname === 'ownerId') object.ownerId = val\n  })\n\n  busboy.on('file', function (name, file, info) {\n    const filename = info.filename\n    const mimetype = info.mimeType\n\n    if (\n      mimetype.indexOf('image/') === -1 &&\n      mimetype.indexOf('text/plain') === -1 &&\n      mimetype.indexOf('audio/mpeg') === -1 &&\n      mimetype.indexOf('audio/mp3') === -1 &&\n      mimetype.indexOf('audio/wav') === -1 &&\n      mimetype.indexOf('application/x-zip-compressed') === -1 &&\n      mimetype.indexOf('application/pdf') === -1 &&\n      //  Office Mime-Types\n      mimetype.indexOf('application/msword') === -1 &&\n      mimetype.indexOf('application/vnd.openxmlformats-officedocument.wordprocessingml.document') === -1 &&\n      mimetype.indexOf('application/vnd.ms-excel') === -1 &&\n      mimetype.indexOf('application/vnd.openxmlformats-officedocument.spreadsheetml.sheet') === -1\n    ) {\n      error = {\n        status: 400,\n        message: 'Invalid File Type'\n      }\n\n      return file.resume()\n    }\n\n    const savePath = path.join(__dirname, '../../public/uploads/tickets', object.ticketId)\n    const sanitizedFilename = filename.replace(/[^a-z0-9.]/gi, '_').toLowerCase()\n\n    const ext = path.extname(sanitizedFilename)\n    const badExts = ['.html', '.htm', '.js']\n\n    if (badExts.includes(ext)) {\n      error = {\n        status: 400,\n        message: 'Invalid File Type'\n      }\n\n      return file.resume()\n    }\n\n    if (!fs.existsSync(savePath)) fs.ensureDirSync(savePath)\n\n    object.filePath = path.join(savePath, 'attachment_' + sanitizedFilename)\n    object.filename = sanitizedFilename\n    object.mimetype = mimetype\n\n    if (fs.existsSync(object.filePath)) {\n      error = {\n        status: 500,\n        message: 'File already exists'\n      }\n\n      return file.resume()\n    }\n\n    file.on('limit', function () {\n      error = {\n        status: 500,\n        message: 'File too large'\n      }\n\n      // Delete the temp file\n      if (fs.existsSync(object.filePath)) fs.unlinkSync(object.filePath)\n\n      return file.resume()\n    })\n\n    file.pipe(fs.createWriteStream(object.filePath))\n  })\n\n  busboy.on('finish', function () {\n    if (error) return res.status(error.status).send(error.message)\n\n    if (_.isUndefined(object.ticketId) || _.isUndefined(object.ownerId) || _.isUndefined(object.filePath)) {\n      fs.unlinkSync(object.filePath)\n      return res.status(400).send('Invalid Form Data')\n    }\n\n    // Everything Checks out lets make sure the file exists and then add it to the attachments array\n    if (!fs.existsSync(object.filePath)) return res.status(500).send('File Failed to Save to Disk')\n\n    ticketSchema.getTicketById(object.ticketId, function (err, ticket) {\n      if (err) {\n        winston.warn(err)\n        return res.status(500).send(err.message)\n      }\n\n      const attachment = {\n        owner: object.ownerId,\n        name: object.filename,\n        path: '/uploads/tickets/' + object.ticketId + '/attachment_' + object.filename,\n        type: object.mimetype\n      }\n      ticket.attachments.push(attachment)\n\n      const historyItem = {\n        action: 'ticket:added:attachment',\n        description: 'Attachment ' + object.filename + ' was added.',\n        owner: object.ownerId\n      }\n      ticket.history.push(historyItem)\n\n      ticket.updated = Date.now()\n      ticket.save(function (err, t) {\n        if (err) {\n          fs.unlinkSync(object.filePath)\n          winston.warn(err)\n          return res.status(500).send(err.message)\n        }\n\n        const returnData = {\n          ticket: t\n        }\n\n        return res.json(returnData)\n      })\n    })\n  })\n\n  req.pipe(busboy)\n}\n\nfunction handleError (res, err) {\n  if (err) {\n    winston.warn(err)\n    if (!err.status) res.status = 500\n    else res.status = err.status\n    return res.render('error', {\n      layout: false,\n      error: err,\n      message: err.message\n    })\n  }\n}\n\nmodule.exports = ticketsController\n", "output": {"vulnerability_count": 1, "vulnerabilities": [{"description": "`Chance` is assigned twice; the first assignment is useless", "risk": "Medium", "conceptual_fix": "Not provided", "line": 532}]}}
{"CVE": "CVE-2022-21122", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "'use strict';\n\nconst metavm = require('metavm');\n\nconst getValue = (target, prop) => {\n  if (prop === 'Math') return Math;\n  const { expressions, data } = target;\n  if (!expressions.has(prop)) return data.get(prop);\n  const expression = expressions.get(prop);\n  return expression();\n};\n\nconst getCell = (target, prop) => {\n  const { expressions, data } = target;\n  const collection = expressions.has(prop) ? expressions : data;\n  return collection.get(prop);\n};\n\nconst setCell = (target, prop, value) => {\n  if (typeof value === 'string' && value[0] === '=') {\n    const src = '() => ' + value.substring(1);\n    const options = { context: target.context };\n    const script = metavm.createScript(prop, src, options);\n    target.expressions.set(prop, script.exports);\n  } else {\n    target.data.set(prop, value);\n  }\n  return true;\n};\n\nclass Sheet {\n  constructor() {\n    this.data = new Map();\n    this.expressions = new Map();\n    this.values = new Proxy(this, { get: getValue });\n    this.context = metavm.createContext(this.values);\n    this.cells = new Proxy(this, { get: getCell, set: setCell });\n  }\n}\n\nmodule.exports = { Sheet };\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2022-21671", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "import * as urllib from 'url';\nimport type { ConnectOptions, GovalMetadata } from '../types';\n\nconst BACKOFF_FACTOR = 1.7;\nconst MAX_BACKOFF = 15000;\n\n/**\n * Calculates the backoff for n retry\n */\nexport function getNextRetryDelay(retryNumber: number): number {\n  const randomMs = Math.floor(Math.random() * 500);\n  const backoff = BACKOFF_FACTOR ** retryNumber * 1000;\n\n  return Math.min(backoff, MAX_BACKOFF) + randomMs;\n}\n\nfunction isWebSocket(w: unknown): w is WebSocket {\n  if (typeof w !== 'object' && typeof w !== 'function') {\n    return false;\n  }\n\n  if (!w) {\n    return false;\n  }\n\n  return 'OPEN' in w && (w as WebSocket).OPEN === 1;\n}\n\n/**\n * Gets a websocket class from the global scope, or asserts if the supplied websocket follows the standard\n */\nexport function getWebSocketClass(\n  WebSocketClass: ConnectOptions<unknown>['WebSocketClass'],\n): typeof WebSocket {\n  if (WebSocketClass) {\n    if (!isWebSocket(WebSocketClass)) {\n      throw new Error('Passed in WebSocket does not look like a standard WebSocket');\n    }\n\n    return WebSocketClass;\n  }\n\n  if (typeof WebSocket !== 'undefined') {\n    if (!isWebSocket(WebSocket)) {\n      throw new Error('Global WebSocket does not look like a standard WebSocket');\n    }\n\n    return WebSocket;\n  }\n\n  throw new Error('Please pass in a WebSocket class or add it to global');\n}\n\n/**\n * Given connection metadata, creates a websocket connection string\n */\nexport function getConnectionStr(\n  connectionMetadata: GovalMetadata,\n  isPolling: boolean,\n  pollingHost?: string,\n): string {\n  const gurl = urllib.parse(connectionMetadata.gurl);\n  if (isPolling) {\n    const host = pollingHost ?? 'gp-v2.herokuapp.com';\n    gurl.hostname = host;\n    gurl.host = host;\n    gurl.pathname = `/wsv2/${connectionMetadata.token}/${encodeURIComponent(\n      connectionMetadata.gurl,\n    )}`;\n  } else {\n    gurl.pathname = `/wsv2/${connectionMetadata.token}`;\n  }\n\n  return urllib.format(gurl);\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2022-22116", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "import cookieParser from 'cookie-parser';\nimport express, { Request, Response, RequestHandler } from 'express';\nimport fse from 'fs-extra';\nimport path from 'path';\nimport qs from 'qs';\n\nimport activityRouter from './controllers/activity';\nimport assetsRouter from './controllers/assets';\nimport authRouter from './controllers/auth';\nimport collectionsRouter from './controllers/collections';\nimport dashboardsRouter from './controllers/dashboards';\nimport extensionsRouter from './controllers/extensions';\nimport fieldsRouter from './controllers/fields';\nimport filesRouter from './controllers/files';\nimport foldersRouter from './controllers/folders';\nimport graphqlRouter from './controllers/graphql';\nimport itemsRouter from './controllers/items';\nimport notFoundHandler from './controllers/not-found';\nimport panelsRouter from './controllers/panels';\nimport notificationsRouter from './controllers/notifications';\nimport permissionsRouter from './controllers/permissions';\nimport presetsRouter from './controllers/presets';\nimport relationsRouter from './controllers/relations';\nimport revisionsRouter from './controllers/revisions';\nimport rolesRouter from './controllers/roles';\nimport serverRouter from './controllers/server';\nimport settingsRouter from './controllers/settings';\nimport usersRouter from './controllers/users';\nimport utilsRouter from './controllers/utils';\nimport webhooksRouter from './controllers/webhooks';\nimport sharesRouter from './controllers/shares';\nimport { isInstalled, validateDatabaseConnection, validateDatabaseExtensions, validateMigrations } from './database';\nimport emitter from './emitter';\nimport env from './env';\nimport { InvalidPayloadException } from './exceptions';\nimport { getExtensionManager } from './extensions';\nimport logger, { expressLogger } from './logger';\nimport authenticate from './middleware/authenticate';\nimport getPermissions from './middleware/get-permissions';\nimport cache from './middleware/cache';\nimport { checkIP } from './middleware/check-ip';\nimport cors from './middleware/cors';\nimport errorHandler from './middleware/error-handler';\nimport extractToken from './middleware/extract-token';\nimport rateLimiter from './middleware/rate-limiter';\nimport sanitizeQuery from './middleware/sanitize-query';\nimport schema from './middleware/schema';\n\nimport { track } from './utils/track';\nimport { validateEnv } from './utils/validate-env';\nimport { validateStorage } from './utils/validate-storage';\nimport { register as registerWebhooks } from './webhooks';\nimport { flushCaches } from './cache';\nimport { registerAuthProviders } from './auth';\nimport { Url } from './utils/url';\n\nexport default async function createApp(): Promise<express.Application> {\n\tvalidateEnv(['KEY', 'SECRET']);\n\n\tif (!new Url(env.PUBLIC_URL).isAbsolute()) {\n\t\tlogger.warn('PUBLIC_URL should be a full URL');\n\t}\n\n\tawait validateStorage();\n\n\tawait validateDatabaseConnection();\n\tawait validateDatabaseExtensions();\n\n\tif ((await isInstalled()) === false) {\n\t\tlogger.error(`Database doesn't have Directus tables installed.`);\n\t\tprocess.exit(1);\n\t}\n\n\tif ((await validateMigrations()) === false) {\n\t\tlogger.warn(`Database migrations have not all been run`);\n\t}\n\n\tawait flushCaches();\n\n\tawait registerAuthProviders();\n\n\tconst extensionManager = getExtensionManager();\n\n\tawait extensionManager.initialize();\n\n\tconst app = express();\n\n\tapp.disable('x-powered-by');\n\tapp.set('trust proxy', env.IP_TRUST_PROXY);\n\tapp.set('query parser', (str: string) => qs.parse(str, { depth: 10 }));\n\n\tawait emitter.emitInit('app.before', { app });\n\n\tawait emitter.emitInit('middlewares.before', { app });\n\n\tapp.use(expressLogger);\n\n\tapp.use((req, res, next) => {\n\t\t(\n\t\t\texpress.json({\n\t\t\t\tlimit: env.MAX_PAYLOAD_SIZE,\n\t\t\t}) as RequestHandler\n\t\t)(req, res, (err: any) => {\n\t\t\tif (err) {\n\t\t\t\treturn next(new InvalidPayloadException(err.message));\n\t\t\t}\n\n\t\t\treturn next();\n\t\t});\n\t});\n\n\tapp.use(cookieParser());\n\n\tapp.use(extractToken);\n\n\tapp.use((_req, res, next) => {\n\t\tres.setHeader('X-Powered-By', 'Directus');\n\t\tnext();\n\t});\n\n\tif (env.CORS_ENABLED === true) {\n\t\tapp.use(cors);\n\t}\n\n\tapp.get('/', (_req, res, next) => {\n\t\tif (env.ROOT_REDIRECT) {\n\t\t\tres.redirect(env.ROOT_REDIRECT);\n\t\t} else {\n\t\t\tnext();\n\t\t}\n\t});\n\n\tif (env.SERVE_APP) {\n\t\tconst adminPath = require.resolve('@directus/app');\n\t\tconst adminUrl = new Url(env.PUBLIC_URL).addPath('admin');\n\n\t\t// Set the App's base path according to the APIs public URL\n\t\tconst html = await fse.readFile(adminPath, 'utf8');\n\t\tconst htmlWithBase = html.replace(/<base \\/>/, `<base href=\"${adminUrl.toString({ rootRelative: true })}/\" />`);\n\n\t\tconst noCacheIndexHtmlHandler = (_req: Request, res: Response) => {\n\t\t\tres.setHeader('Cache-Control', 'no-cache');\n\t\t\tres.send(htmlWithBase);\n\t\t};\n\n\t\tapp.get('/admin', noCacheIndexHtmlHandler);\n\t\tapp.use('/admin', express.static(path.join(adminPath, '..')));\n\t\tapp.use('/admin/*', noCacheIndexHtmlHandler);\n\t}\n\n\t// use the rate limiter - all routes for now\n\tif (env.RATE_LIMITER_ENABLED === true) {\n\t\tapp.use(rateLimiter);\n\t}\n\n\tapp.use(authenticate);\n\n\tapp.use(checkIP);\n\n\tapp.use(sanitizeQuery);\n\n\tapp.use(cache);\n\n\tapp.use(schema);\n\n\tapp.use(getPermissions);\n\n\tawait emitter.emitInit('middlewares.after', { app });\n\n\tawait emitter.emitInit('routes.before', { app });\n\n\tapp.use('/auth', authRouter);\n\n\tapp.use('/graphql', graphqlRouter);\n\n\tapp.use('/activity', activityRouter);\n\tapp.use('/assets', assetsRouter);\n\tapp.use('/collections', collectionsRouter);\n\tapp.use('/dashboards', dashboardsRouter);\n\tapp.use('/extensions', extensionsRouter);\n\tapp.use('/fields', fieldsRouter);\n\tapp.use('/files', filesRouter);\n\tapp.use('/folders', foldersRouter);\n\tapp.use('/items', itemsRouter);\n\tapp.use('/notifications', notificationsRouter);\n\tapp.use('/panels', panelsRouter);\n\tapp.use('/permissions', permissionsRouter);\n\tapp.use('/presets', presetsRouter);\n\tapp.use('/relations', relationsRouter);\n\tapp.use('/revisions', revisionsRouter);\n\tapp.use('/roles', rolesRouter);\n\tapp.use('/server', serverRouter);\n\tapp.use('/settings', settingsRouter);\n\tapp.use('/shares', sharesRouter);\n\tapp.use('/users', usersRouter);\n\tapp.use('/utils', utilsRouter);\n\tapp.use('/webhooks', webhooksRouter);\n\n\t// Register custom endpoints\n\tawait emitter.emitInit('routes.custom.before', { app });\n\tapp.use(extensionManager.getEndpointRouter());\n\tawait emitter.emitInit('routes.custom.after', { app });\n\n\tapp.use(notFoundHandler);\n\tapp.use(errorHandler);\n\n\tawait emitter.emitInit('routes.after', { app });\n\n\t// Register all webhooks\n\tawait registerWebhooks();\n\n\ttrack('serverStarted');\n\n\tawait emitter.emitInit('app.after', { app });\n\n\treturn app;\n}\n", "output": {"vulnerability_count": 3, "vulnerabilities": [{"description": "This looks like a JavaScript template string. Are you missing a '$' in front of '{...}'?", "risk": "Medium", "conceptual_fix": "Not provided", "line": 139}, {"description": "This template literal looks like HTML and has interpolated variables. These variables are not HTML-encoded by default. If the variables contain HTML tags, these may be interpreted by the browser, resulting in cross-site scripting (XSS).", "risk": "Medium", "conceptual_fix": "Not provided", "line": 139}, {"description": "This looks like a JavaScript template string. Are you missing a '$' in front of '{...}'?", "risk": "Medium", "conceptual_fix": "Not provided", "line": 139}]}}
{"CVE": "CVE-2022-22126", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "<template>\n<div class=\"l-iframe abs\">\n    <iframe :src=\"url\"></iframe>\n</div>\n</template>\n\n<script>\nconst sanitizeUrl = require(\"@braintree/sanitize-url\").sanitizeUrl;\n\nexport default {\n    inject: ['openmct', 'domainObject'],\n    data: function () {\n        return {\n            currentDomainObject: this.domainObject\n        };\n    },\n    computed: {\n        url() {\n            let url = this.currentDomainObject.url;\n            if (url) {\n                url = sanitizeUrl(url);\n            }\n\n            return url;\n        }\n    }\n};\n</script>\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2022-23054", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "define([\n    '../res/widgetTemplate.html',\n    './Rule',\n    './ConditionManager',\n    './TestDataManager',\n    './WidgetDnD',\n    './eventHelpers',\n    'objectUtils',\n    'lodash',\n    'zepto',\n    '@braintree/sanitize-url'\n], function (\n    widgetTemplate,\n    Rule,\n    ConditionManager,\n    TestDataManager,\n    WidgetDnD,\n    eventHelpers,\n    objectUtils,\n    _,\n    $,\n    urlSanitizeLib\n) {\n\n    //default css configuration for new rules\n    const DEFAULT_PROPS = {\n        'color': '#cccccc',\n        'background-color': '#666666',\n        'border-color': 'rgba(0,0,0,0)'\n    };\n\n    /**\n     * A Summary Widget object, which allows a user to configure rules based\n     * on telemetry producing domain objects, and update a compact display\n     * accordingly.\n     * @constructor\n     * @param {Object} domainObject The domain Object represented by this Widget\n     * @param {MCT} openmct An MCT instance\n     */\n    function SummaryWidget(domainObject, openmct) {\n        eventHelpers.extend(this);\n\n        this.domainObject = domainObject;\n        this.openmct = openmct;\n\n        this.domainObject.configuration = this.domainObject.configuration || {};\n        this.domainObject.configuration.ruleConfigById = this.domainObject.configuration.ruleConfigById || {};\n        this.domainObject.configuration.ruleOrder = this.domainObject.configuration.ruleOrder || ['default'];\n        this.domainObject.configuration.testDataConfig = this.domainObject.configuration.testDataConfig || [{\n            object: '',\n            key: '',\n            value: ''\n        }];\n\n        this.activeId = 'default';\n        this.rulesById = {};\n        this.domElement = $(widgetTemplate);\n        this.toggleRulesControl = $('.t-view-control-rules', this.domElement);\n        this.toggleTestDataControl = $('.t-view-control-test-data', this.domElement);\n        this.widgetButton = this.domElement.children('#widget');\n        this.editing = false;\n        this.container = '';\n        this.editListenerUnsubscribe = $.noop;\n\n        this.outerWrapper = $('.widget-edit-holder', this.domElement);\n        this.ruleArea = $('#ruleArea', this.domElement);\n        this.configAreaRules = $('.widget-rules-wrapper', this.domElement);\n\n        this.testDataArea = $('.widget-test-data', this.domElement);\n        this.addRuleButton = $('#addRule', this.domElement);\n\n        this.conditionManager = new ConditionManager(this.domainObject, this.openmct);\n        this.testDataManager = new TestDataManager(this.domainObject, this.conditionManager, this.openmct);\n\n        this.watchForChanges = this.watchForChanges.bind(this);\n        this.show = this.show.bind(this);\n        this.destroy = this.destroy.bind(this);\n        this.addRule = this.addRule.bind(this);\n\n        this.addHyperlink(domainObject.url, domainObject.openNewTab);\n        this.watchForChanges(openmct, domainObject);\n\n        const id = objectUtils.makeKeyString(this.domainObject.identifier);\n        const self = this;\n\n        /**\n         * Toggles the configuration area for test data in the view\n         * @private\n         */\n        function toggleTestData() {\n            self.outerWrapper.toggleClass('expanded-widget-test-data');\n            self.toggleTestDataControl.toggleClass('c-disclosure-triangle--expanded');\n        }\n\n        this.listenTo(this.toggleTestDataControl, 'click', toggleTestData);\n\n        /**\n         * Toggles the configuration area for rules in the view\n         * @private\n         */\n        function toggleRules() {\n            self.outerWrapper.toggleClass('expanded-widget-rules');\n            self.toggleRulesControl.toggleClass('c-disclosure-triangle--expanded');\n        }\n\n        this.listenTo(this.toggleRulesControl, 'click', toggleRules);\n\n        openmct.$injector.get('objectService')\n            .getObjects([id]);\n    }\n\n    /**\n     * adds or removes href to widget button and adds or removes openInNewTab\n     * @param {string} url String that denotes the url to be opened\n     * @param {string} openNewTab String that denotes wether to open link in new tab or not\n     */\n    SummaryWidget.prototype.addHyperlink = function (url, openNewTab) {\n        if (url) {\n            const sanitizeUrl = urlSanitizeLib.sanitizeUrl;\n            url = sanitizeUrl(url);\n            this.widgetButton.attr('href', url);\n        } else {\n            this.widgetButton.removeAttr('href');\n        }\n\n        if (openNewTab === 'newTab') {\n            this.widgetButton.attr('target', '_blank');\n        } else {\n            this.widgetButton.removeAttr('target');\n        }\n    };\n\n    /**\n     * adds a listener to the object to watch for any changes made by user\n     * only executes if changes are observed\n     * @param {openmct} Object Instance of OpenMCT\n     * @param {domainObject} Object instance of this object\n     */\n    SummaryWidget.prototype.watchForChanges = function (openmct, domainObject) {\n        this.watchForChangesUnsubscribe = openmct.objects.observe(domainObject, '*', function (newDomainObject) {\n            if (newDomainObject.url !== this.domainObject.url\n                    || newDomainObject.openNewTab !== this.domainObject.openNewTab) {\n                this.addHyperlink(newDomainObject.url, newDomainObject.openNewTab);\n            }\n        }.bind(this));\n    };\n\n    /**\n     * Builds the Summary Widget's DOM, performs other necessary setup, and attaches\n     * this Summary Widget's view to the supplied container.\n     * @param {element} container The DOM element that will contain this Summary\n     *                            Widget's view.\n     */\n    SummaryWidget.prototype.show = function (container) {\n        const self = this;\n        this.container = container;\n        $(container).append(this.domElement);\n        $('.widget-test-data', this.domElement).append(this.testDataManager.getDOM());\n        this.widgetDnD = new WidgetDnD(this.domElement, this.domainObject.configuration.ruleOrder, this.rulesById);\n        this.initRule('default', 'Default');\n        this.domainObject.configuration.ruleOrder.forEach(function (ruleId) {\n            if (ruleId !== 'default') {\n                self.initRule(ruleId);\n            }\n        });\n        this.refreshRules();\n        this.updateWidget();\n\n        this.listenTo(this.addRuleButton, 'click', this.addRule);\n        this.conditionManager.on('receiveTelemetry', this.executeRules, this);\n        this.widgetDnD.on('drop', this.reorder, this);\n    };\n\n    /**\n     * Unregister event listeners with the Open MCT APIs, unsubscribe from telemetry,\n     * and clean up event handlers\n     */\n    SummaryWidget.prototype.destroy = function (container) {\n        this.editListenerUnsubscribe();\n        this.conditionManager.destroy();\n        this.testDataManager.destroy();\n        this.widgetDnD.destroy();\n        this.watchForChangesUnsubscribe();\n        Object.values(this.rulesById).forEach(function (rule) {\n            rule.destroy();\n        });\n\n        this.stopListening();\n    };\n\n    /**\n     * Update the view from the current rule configuration and order\n     */\n    SummaryWidget.prototype.refreshRules = function () {\n        const self = this;\n        const ruleOrder = self.domainObject.configuration.ruleOrder;\n        const rules = self.rulesById;\n        self.ruleArea.html('');\n        Object.values(ruleOrder).forEach(function (ruleId) {\n            self.ruleArea.append(rules[ruleId].getDOM());\n        });\n\n        this.executeRules();\n        this.addOrRemoveDragIndicator();\n    };\n\n    SummaryWidget.prototype.addOrRemoveDragIndicator = function () {\n        const rules = this.domainObject.configuration.ruleOrder;\n        const rulesById = this.rulesById;\n\n        rules.forEach(function (ruleKey, index, array) {\n            if (array.length > 2 && index > 0) {\n                $('.t-grippy', rulesById[ruleKey].domElement).show();\n            } else {\n                $('.t-grippy', rulesById[ruleKey].domElement).hide();\n            }\n        });\n    };\n\n    /**\n     * Update the widget's appearance from the configuration of the active rule\n     */\n    SummaryWidget.prototype.updateWidget = function () {\n        const WIDGET_ICON_CLASS = 'c-sw__icon js-sw__icon';\n        const activeRule = this.rulesById[this.activeId];\n        this.applyStyle($('#widget', this.domElement), activeRule.getProperty('style'));\n        $('#widget', this.domElement).prop('title', activeRule.getProperty('message'));\n        $('#widgetLabel', this.domElement).html(activeRule.getProperty('label'));\n        $('#widgetIcon', this.domElement).removeClass().addClass(WIDGET_ICON_CLASS + ' ' + activeRule.getProperty('icon'));\n    };\n\n    /**\n     * Get the active rule and update the Widget's appearance.\n     */\n    SummaryWidget.prototype.executeRules = function () {\n        this.activeId = this.conditionManager.executeRules(\n            this.domainObject.configuration.ruleOrder,\n            this.rulesById\n        );\n        this.updateWidget();\n    };\n\n    /**\n     * Add a new rule to this widget\n     */\n    SummaryWidget.prototype.addRule = function () {\n        let ruleCount = 0;\n        let ruleId;\n        const ruleOrder = this.domainObject.configuration.ruleOrder;\n\n        while (Object.keys(this.rulesById).includes('rule' + ruleCount)) {\n            ruleCount++;\n        }\n\n        ruleId = 'rule' + ruleCount;\n        ruleOrder.push(ruleId);\n        this.domainObject.configuration.ruleOrder = ruleOrder;\n\n        this.initRule(ruleId, 'Rule');\n        this.updateDomainObject();\n        this.refreshRules();\n    };\n\n    /**\n     * Duplicate an existing widget rule from its configuration and splice it in\n     * after the rule it duplicates\n     * @param {Object} sourceConfig The configuration properties of the rule to be\n     *                              instantiated\n     */\n    SummaryWidget.prototype.duplicateRule = function (sourceConfig) {\n        let ruleCount = 0;\n        let ruleId;\n        const sourceRuleId = sourceConfig.id;\n        const ruleOrder = this.domainObject.configuration.ruleOrder;\n        const ruleIds = Object.keys(this.rulesById);\n\n        while (ruleIds.includes('rule' + ruleCount)) {\n            ruleCount = ++ruleCount;\n        }\n\n        ruleId = 'rule' + ruleCount;\n        sourceConfig.id = ruleId;\n        sourceConfig.name += ' Copy';\n        ruleOrder.splice(ruleOrder.indexOf(sourceRuleId) + 1, 0, ruleId);\n        this.domainObject.configuration.ruleOrder = ruleOrder;\n        this.domainObject.configuration.ruleConfigById[ruleId] = sourceConfig;\n        this.initRule(ruleId, sourceConfig.name);\n        this.updateDomainObject();\n        this.refreshRules();\n    };\n\n    /**\n     * Initialze a new rule from a default configuration, or build a {Rule} object\n     * from it if already exists\n     * @param {string} ruleId An key to be used to identify this ruleId, or the key\n                              of the rule to be instantiated\n     * @param {string} ruleName The initial human-readable name of this rule\n     */\n    SummaryWidget.prototype.initRule = function (ruleId, ruleName) {\n        let ruleConfig;\n        const styleObj = {};\n\n        Object.assign(styleObj, DEFAULT_PROPS);\n        if (!this.domainObject.configuration.ruleConfigById[ruleId]) {\n            this.domainObject.configuration.ruleConfigById[ruleId] = {\n                name: ruleName || 'Rule',\n                label: 'Unnamed Rule',\n                message: '',\n                id: ruleId,\n                icon: ' ',\n                style: styleObj,\n                description: ruleId === 'default' ? 'Default appearance for the widget' : 'A new rule',\n                conditions: [{\n                    object: '',\n                    key: '',\n                    operation: '',\n                    values: []\n                }],\n                jsCondition: '',\n                trigger: 'any',\n                expanded: 'true'\n            };\n\n        }\n\n        ruleConfig = this.domainObject.configuration.ruleConfigById[ruleId];\n        this.rulesById[ruleId] = new Rule(ruleConfig, this.domainObject, this.openmct,\n            this.conditionManager, this.widgetDnD, this.container);\n        this.rulesById[ruleId].on('remove', this.refreshRules, this);\n        this.rulesById[ruleId].on('duplicate', this.duplicateRule, this);\n        this.rulesById[ruleId].on('change', this.updateWidget, this);\n        this.rulesById[ruleId].on('conditionChange', this.executeRules, this);\n    };\n\n    /**\n     * Given two ruleIds, move the source rule after the target rule and update\n     * the view.\n     * @param {Object} event An event object representing this drop with draggingId\n     *                       and dropTarget fields\n     */\n    SummaryWidget.prototype.reorder = function (event) {\n        const ruleOrder = this.domainObject.configuration.ruleOrder;\n        const sourceIndex = ruleOrder.indexOf(event.draggingId);\n        let targetIndex;\n\n        if (event.draggingId !== event.dropTarget) {\n            ruleOrder.splice(sourceIndex, 1);\n            targetIndex = ruleOrder.indexOf(event.dropTarget);\n            ruleOrder.splice(targetIndex + 1, 0, event.draggingId);\n            this.domainObject.configuration.ruleOrder = ruleOrder;\n            this.updateDomainObject();\n        }\n\n        this.refreshRules();\n    };\n\n    /**\n     * Apply a list of css properties to an element\n     * @param {element} elem The DOM element to which the rules will be applied\n     * @param {object} style an object representing the style\n     */\n    SummaryWidget.prototype.applyStyle = function (elem, style) {\n        Object.keys(style).forEach(function (propId) {\n            elem.css(propId, style[propId]);\n        });\n    };\n\n    /**\n     * Mutate this domain object's configuration with the current local configuration\n     */\n    SummaryWidget.prototype.updateDomainObject = function () {\n        this.openmct.objects.mutate(this.domainObject, 'configuration', this.domainObject.configuration);\n    };\n\n    return SummaryWidget;\n});\n", "output": {"vulnerability_count": 6, "vulnerabilities": [{"description": "User controlled data in a `$(...)` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 57}, {"description": "User controlled data in a jQuery's `.append(...)` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 157}, {"description": "User controlled data in a `$(...)` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 157}, {"description": "User controlled data in a jQuery's `.append(...)` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 158}, {"description": "User controlled data in a jQuery's `.html(...)` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 228}, {"description": "JQuery's `html` function is susceptible to Cross Site Scripting (XSS) attacks. If you're just passing text, consider `text` instead. Otherwise, use a function that escapes HTML such as edX's `HtmlUtils.setHtml()`.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 228}]}}
{"CVE": "CVE-2022-23065", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "import { MiddlewareConsumer, NestModule, OnApplicationBootstrap } from '@nestjs/common';\nimport { Type } from '@vendure/common/lib/shared-types';\nimport {\n    AssetStorageStrategy,\n    Logger,\n    PluginCommonModule,\n    ProcessContext,\n    registerPluginStartupMessage,\n    RuntimeVendureConfig,\n    VendurePlugin,\n} from '@vendure/core';\nimport { createHash } from 'crypto';\nimport express, { NextFunction, Request, Response } from 'express';\nimport { fromBuffer } from 'file-type';\nimport fs from 'fs-extra';\nimport path from 'path';\n\nimport { loggerCtx } from './constants';\nimport { defaultAssetStorageStrategyFactory } from './default-asset-storage-strategy-factory';\nimport { HashedAssetNamingStrategy } from './hashed-asset-naming-strategy';\nimport { SharpAssetPreviewStrategy } from './sharp-asset-preview-strategy';\nimport { transformImage } from './transform-image';\nimport { AssetServerOptions, ImageTransformPreset } from './types';\n\n/**\n * @description\n * The `AssetServerPlugin` serves assets (images and other files) from the local file system, and can also be configured to use\n * other storage strategies (e.g. {@link S3AssetStorageStrategy}. It can also perform on-the-fly image transformations\n * and caches the results for subsequent calls.\n *\n * ## Installation\n *\n * `yarn add \\@vendure/asset-server-plugin`\n *\n * or\n *\n * `npm install \\@vendure/asset-server-plugin`\n *\n * @example\n * ```ts\n * import { AssetServerPlugin } from '\\@vendure/asset-server-plugin';\n *\n * const config: VendureConfig = {\n *   // Add an instance of the plugin to the plugins array\n *   plugins: [\n *     AssetServerPlugin.init({\n *       route: 'assets',\n *       assetUploadDir: path.join(__dirname, 'assets'),\n *     }),\n *   ],\n * };\n * ```\n *\n * The full configuration is documented at [AssetServerOptions]({{< relref \"asset-server-options\" >}})\n *\n * ## Image transformation\n *\n * Asset preview images can be transformed (resized & cropped) on the fly by appending query parameters to the url:\n *\n * `http://localhost:3000/assets/some-asset.jpg?w=500&h=300&mode=resize`\n *\n * The above URL will return `some-asset.jpg`, resized to fit in the bounds of a 500px x 300px rectangle.\n *\n * ### Preview mode\n *\n * The `mode` parameter can be either `crop` or `resize`. See the [ImageTransformMode]({{< relref \"image-transform-mode\" >}}) docs for details.\n *\n * ### Focal point\n *\n * When cropping an image (`mode=crop`), Vendure will attempt to keep the most \"interesting\" area of the image in the cropped frame. It does this\n * by finding the area of the image with highest entropy (the busiest area of the image). However, sometimes this does not yield a satisfactory\n * result - part or all of the main subject may still be cropped out.\n *\n * This is where specifying the focal point can help. The focal point of the image may be specified by passing the `fpx` and `fpy` query parameters.\n * These are normalized coordinates (i.e. a number between 0 and 1), so the `fpx=0&fpy=0` corresponds to the top left of the image.\n *\n * For example, let's say there is a very wide landscape image which we want to crop to be square. The main subject is a house to the far left of the\n * image. The following query would crop it to a square with the house centered:\n *\n * `http://localhost:3000/assets/landscape.jpg?w=150&h=150&mode=crop&fpx=0.2&fpy=0.7`\n *\n * ### Transform presets\n *\n * Presets can be defined which allow a single preset name to be used instead of specifying the width, height and mode. Presets are\n * configured via the AssetServerOptions [presets property]({{< relref \"asset-server-options\" >}}#presets).\n *\n * For example, defining the following preset:\n *\n * ```ts\n * AssetServerPlugin.init({\n *   // ...\n *   presets: [\n *     { name: 'my-preset', width: 85, height: 85, mode: 'crop' },\n *   ],\n * }),\n * ```\n *\n * means that a request to:\n *\n * `http://localhost:3000/assets/some-asset.jpg?preset=my-preset`\n *\n * is equivalent to:\n *\n * `http://localhost:3000/assets/some-asset.jpg?w=85&h=85&mode=crop`\n *\n * The AssetServerPlugin comes pre-configured with the following presets:\n *\n * name | width | height | mode\n * -----|-------|--------|-----\n * tiny | 50px | 50px | crop\n * thumb | 150px | 150px | crop\n * small | 300px | 300px | resize\n * medium | 500px | 500px | resize\n * large | 800px | 800px | resize\n *\n * ### Caching\n * By default, the AssetServerPlugin will cache every transformed image, so that the transformation only needs to be performed a single time for\n * a given configuration. Caching can be disabled per-request by setting the `?cache=false` query parameter.\n *\n * @docsCategory AssetServerPlugin\n */\n@VendurePlugin({\n    imports: [PluginCommonModule],\n    configuration: config => AssetServerPlugin.configure(config),\n})\nexport class AssetServerPlugin implements NestModule, OnApplicationBootstrap {\n    private static assetStorage: AssetStorageStrategy;\n    private readonly cacheDir = 'cache';\n    private presets: ImageTransformPreset[] = [\n        { name: 'tiny', width: 50, height: 50, mode: 'crop' },\n        { name: 'thumb', width: 150, height: 150, mode: 'crop' },\n        { name: 'small', width: 300, height: 300, mode: 'resize' },\n        { name: 'medium', width: 500, height: 500, mode: 'resize' },\n        { name: 'large', width: 800, height: 800, mode: 'resize' },\n    ];\n    private static options: AssetServerOptions;\n\n    /**\n     * @description\n     * Set the plugin options.\n     */\n    static init(options: AssetServerOptions): Type<AssetServerPlugin> {\n        AssetServerPlugin.options = options;\n        return this;\n    }\n\n    /** @internal */\n    static async configure(config: RuntimeVendureConfig) {\n        const storageStrategyFactory =\n            this.options.storageStrategyFactory || defaultAssetStorageStrategyFactory;\n        this.assetStorage = await storageStrategyFactory(this.options);\n        config.assetOptions.assetPreviewStrategy = new SharpAssetPreviewStrategy({\n            maxWidth: this.options.previewMaxWidth || 1600,\n            maxHeight: this.options.previewMaxHeight || 1600,\n        });\n        config.assetOptions.assetStorageStrategy = this.assetStorage;\n        config.assetOptions.assetNamingStrategy =\n            this.options.namingStrategy || new HashedAssetNamingStrategy();\n        return config;\n    }\n\n    constructor(private processContext: ProcessContext) {}\n\n    /** @internal */\n    onApplicationBootstrap(): void | Promise<void> {\n        if (this.processContext.isWorker) {\n            return;\n        }\n        if (AssetServerPlugin.options.presets) {\n            for (const preset of AssetServerPlugin.options.presets) {\n                const existingIndex = this.presets.findIndex(p => p.name === preset.name);\n                if (-1 < existingIndex) {\n                    this.presets.splice(existingIndex, 1, preset);\n                } else {\n                    this.presets.push(preset);\n                }\n            }\n        }\n\n        const cachePath = path.join(AssetServerPlugin.options.assetUploadDir, this.cacheDir);\n        fs.ensureDirSync(cachePath);\n    }\n\n    configure(consumer: MiddlewareConsumer) {\n        if (this.processContext.isWorker) {\n            return;\n        }\n        Logger.info('Creating asset server middleware', loggerCtx);\n        consumer.apply(this.createAssetServer()).forRoutes(AssetServerPlugin.options.route);\n        registerPluginStartupMessage('Asset server', AssetServerPlugin.options.route);\n    }\n\n    /**\n     * Creates the image server instance\n     */\n    private createAssetServer() {\n        const assetServer = express.Router();\n        assetServer.use(this.sendAsset(), this.generateTransformedImage());\n        return assetServer;\n    }\n\n    /**\n     * Reads the file requested and send the response to the browser.\n     */\n    private sendAsset() {\n        return async (req: Request, res: Response, next: NextFunction) => {\n            const key = this.getFileNameFromRequest(req);\n            try {\n                const file = await AssetServerPlugin.assetStorage.readFileToBuffer(key);\n                let mimeType = this.getMimeType(key);\n                if (!mimeType) {\n                    mimeType = (await fromBuffer(file))?.mime || 'application/octet-stream';\n                }\n                res.contentType(mimeType);\n                res.send(file);\n            } catch (e) {\n                const err = new Error('File not found');\n                (err as any).status = 404;\n                return next(err);\n            }\n        };\n    }\n\n    /**\n     * If an exception was thrown by the first handler, then it may be because a transformed image\n     * is being requested which does not yet exist. In this case, this handler will generate the\n     * transformed image, save it to cache, and serve the result as a response.\n     */\n    private generateTransformedImage() {\n        return async (err: any, req: Request, res: Response, next: NextFunction) => {\n            if (err && (err.status === 404 || err.statusCode === 404)) {\n                if (req.query) {\n                    const decodedReqPath = decodeURIComponent(req.path);\n                    Logger.debug(`Pre-cached Asset not found: ${decodedReqPath}`, loggerCtx);\n                    let file: Buffer;\n                    try {\n                        file = await AssetServerPlugin.assetStorage.readFileToBuffer(decodedReqPath);\n                    } catch (err) {\n                        res.status(404).send('Resource not found');\n                        return;\n                    }\n                    const image = await transformImage(file, req.query as any, this.presets || []);\n                    try {\n                        const imageBuffer = await image.toBuffer();\n                        if (!req.query.cache || req.query.cache === 'true') {\n                            const cachedFileName = this.getFileNameFromRequest(req);\n                            await AssetServerPlugin.assetStorage.writeFileFromBuffer(\n                                cachedFileName,\n                                imageBuffer,\n                            );\n                            Logger.debug(`Saved cached asset: ${cachedFileName}`, loggerCtx);\n                        }\n                        res.set('Content-Type', `image/${(await image.metadata()).format}`);\n                        res.send(imageBuffer);\n                        return;\n                    } catch (e) {\n                        Logger.error(e, 'AssetServerPlugin', e.stack);\n                        res.status(500).send(e.message);\n                        return;\n                    }\n                }\n            }\n            next();\n        };\n    }\n\n    private getFileNameFromRequest(req: Request): string {\n        const { w, h, mode, preset, fpx, fpy } = req.query;\n        const focalPoint = fpx && fpy ? `_fpx${fpx}_fpy${fpy}` : '';\n        let imageParamHash: string | null = null;\n        if (w || h) {\n            const width = w || '';\n            const height = h || '';\n            imageParamHash = this.md5(`_transform_w${width}_h${height}_m${mode}${focalPoint}`);\n        } else if (preset) {\n            if (this.presets && !!this.presets.find(p => p.name === preset)) {\n                imageParamHash = this.md5(`_transform_pre_${preset}${focalPoint}`);\n            }\n        }\n\n        const decodedReqPath = decodeURIComponent(req.path);\n        if (imageParamHash) {\n            return path.join(this.cacheDir, this.addSuffix(decodedReqPath, imageParamHash));\n        } else {\n            return decodedReqPath;\n        }\n    }\n\n    private md5(input: string): string {\n        return createHash('md5').update(input).digest('hex');\n    }\n\n    private addSuffix(fileName: string, suffix: string): string {\n        const ext = path.extname(fileName);\n        const baseName = path.basename(fileName, ext);\n        const dirName = path.dirname(fileName);\n        return path.join(dirName, `${baseName}${suffix}${ext}`);\n    }\n\n    /**\n     * Attempt to get the mime type from the file name.\n     */\n    private getMimeType(fileName: string): string | undefined {\n        const ext = path.extname(fileName);\n        switch (ext) {\n            case '.jpg':\n            case '.jpeg':\n                return 'image/jpeg';\n            case '.png':\n                return 'image/png';\n            case '.gif':\n                return 'image/gif';\n            case '.svg':\n                return 'image/svg+xml';\n            case '.tiff':\n                return 'image/tiff';\n            case '.webp':\n                return 'image/webp';\n        }\n    }\n}\n", "output": {"vulnerability_count": 3, "vulnerabilities": [{"description": "Detected possible user input going into a `path.join` or `path.resolve` function. This could possibly lead to a path traversal vulnerability,  where the attacker can access arbitrary files stored in the file system. Instead, be sure to sanitize or validate user input first.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 283}, {"description": "Detected possible user input going into a `path.join` or `path.resolve` function. This could possibly lead to a path traversal vulnerability,  where the attacker can access arbitrary files stored in the file system. Instead, be sure to sanitize or validate user input first.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 297}, {"description": "Detected possible user input going into a `path.join` or `path.resolve` function. This could possibly lead to a path traversal vulnerability,  where the attacker can access arbitrary files stored in the file system. Instead, be sure to sanitize or validate user input first.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 297}]}}
{"CVE": "CVE-2022-23073", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "<template>\n    <tr>\n        <template v-if=\"ingredient.is_header\">\n            <td colspan=\"5\" @click=\"done\">\n                <b>{{ ingredient.note }}</b>\n            </td>\n        </template>\n\n        <template v-else>\n            <td class=\"d-print-non\" v-if=\"detailed && !show_shopping\" @click=\"done\">\n                <i class=\"far fa-check-circle text-success\" v-if=\"ingredient.checked\"></i>\n                <i class=\"far fa-check-circle text-primary\" v-if=\"!ingredient.checked\"></i>\n            </td>\n            <td class=\"text-nowrap\" @click=\"done\">\n                <span v-if=\"ingredient.amount !== 0\" v-html=\"calculateAmount(ingredient.amount)\"></span>\n            </td>\n            <td @click=\"done\">\n                <span v-if=\"ingredient.unit !== null && !ingredient.no_amount\">{{ ingredient.unit.name }}</span>\n            </td>\n            <td @click=\"done\">\n                <template v-if=\"ingredient.food !== null\">\n                    <a :href=\"resolveDjangoUrl('view_recipe', ingredient.food.recipe.id)\" v-if=\"ingredient.food.recipe !== null\" target=\"_blank\" rel=\"noopener noreferrer\">{{ ingredient.food.name }}</a>\n                    <span v-if=\"ingredient.food.recipe === null\">{{ ingredient.food.name }}</span>\n                </template>\n            </td>\n            <td v-if=\"detailed && !show_shopping\">\n                <div v-if=\"ingredient.note\">\n                    <span v-b-popover.hover=\"ingredient.note\" class=\"d-print-none touchable p-0 pl-md-2 pr-md-2\">\n                        <i class=\"far fa-comment\"></i>\n                    </span>\n\n                    <div class=\"d-none d-print-block\"><i class=\"far fa-comment-alt d-print-none\"></i> {{ ingredient.note }}</div>\n                </div>\n            </td>\n            <td v-else-if=\"show_shopping\" class=\"text-right text-nowrap\">\n                <shopping-badge v-if=\"ingredient.food.ignore_shopping\" :item=\"shoppingBadgeFood\" />\n                <b-button\n                    v-if=\"!ingredient.food.ignore_shopping\"\n                    class=\"btn text-decoration-none fas fa-shopping-cart px-2 user-select-none\"\n                    variant=\"link\"\n                    v-b-popover.hover.click.blur.html.top=\"{ title: ShoppingPopover, variant: 'outline-dark' }\"\n                    :class=\"{\n                        'text-success': ingredient.shopping_status === true,\n                        'text-muted': ingredient.shopping_status === false,\n                        'text-warning': ingredient.shopping_status === null,\n                    }\"\n                />\n                <span v-if=\"!ingredient.food.ignore_shopping\" class=\"px-2\">\n                    <input type=\"checkbox\" class=\"align-middle\" v-model=\"shop\" @change=\"changeShopping\" />\n                </span>\n                <on-hand-badge v-if=\"!ingredient.food.ignore_shopping\" :item=\"ingredient.food\" />\n            </td>\n        </template>\n    </tr>\n</template>\n\n<script>\nimport { calculateAmount, ResolveUrlMixin, ApiMixin } from \"@/utils/utils\"\nimport OnHandBadge from \"@/components/Badges/OnHand\"\nimport ShoppingBadge from \"@/components/Badges/Shopping\"\n\nexport default {\n    name: \"IngredientComponent\",\n    components: { OnHandBadge, ShoppingBadge },\n    props: {\n        ingredient: Object,\n        ingredient_factor: { type: Number, default: 1 },\n        detailed: { type: Boolean, default: true },\n        show_shopping: { type: Boolean, default: false },\n    },\n    mixins: [ResolveUrlMixin, ApiMixin],\n    data() {\n        return {\n            checked: false,\n            shop: false, // in shopping list for this recipe: boolean\n            dirty: undefined,\n        }\n    },\n    watch: {\n        ingredient: {\n            handler() {},\n            deep: true,\n        },\n        \"ingredient.shop\": function (newVal) {\n            this.shop = newVal\n        },\n    },\n    mounted() {\n        this.shop = this.ingredient?.shop\n    },\n    computed: {\n        shoppingBadgeFood() {\n            // shopping badge is hidden when ignore_shopping=true.\n            // force true in this context to allow adding to shopping list from recipe view\n            return { ...this.ingredient.food, ignore_shopping: false }\n        },\n        ShoppingPopover() {\n            if (this.ingredient?.shopping_status == false) {\n                return this.$t(\"NotInShopping\", { food: this.ingredient.food.name })\n            } else {\n                let category = this.$t(\"Category\") + \": \" + this.ingredient?.category ?? this.$t(\"Undefined\")\n                let popover = []\n                ;(this.ingredient?.shopping_list ?? []).forEach((x) => {\n                    popover.push(\n                        [\n                            \"<tr style='border-bottom: 1px solid #ccc'>\",\n                            \"<td style='padding: 3px;'><em>\",\n                            x?.mealplan ?? \"\",\n                            \"</em></td>\",\n                            \"<td style='padding: 3px;'>\",\n                            x?.amount ?? \"\",\n                            \"</td>\",\n                            \"<td style='padding: 3px;'>\",\n                            x?.unit ?? \"\" + \"</td>\",\n                            \"<td style='padding: 3px;'>\",\n                            x?.food ?? \"\",\n                            \"</td></tr>\",\n                        ].join(\"\")\n                    )\n                })\n                return \"<table class='table-small'><th colspan='4'>\" + category + \"</th>\" + popover.join(\"\") + \"</table>\"\n            }\n        },\n    },\n    methods: {\n        calculateAmount: function (x) {\n            return calculateAmount(x, this.ingredient_factor)\n        },\n        // sends parent recipe ingredient to notify complete has been toggled\n        done: function () {\n            this.$emit(\"checked-state-changed\", this.ingredient)\n        },\n        // sends true/false to parent to save all ingredient shopping updates as a batch\n        changeShopping: function () {\n            this.$emit(\"add-to-shopping\", { item: this.ingredient, add: this.shop })\n        },\n    },\n}\n</script>\n\n<style scoped>\n/* increase size of hover/touchable space without changing spacing */\n.touchable {\n    padding-right: 2em;\n    padding-left: 2em;\n    margin-right: -2em;\n    margin-left: -2em;\n}\n</style>\n", "output": {"vulnerability_count": 1, "vulnerabilities": [{"description": "`if` is assigned twice; the first assignment is useless", "risk": "Medium", "conceptual_fix": "Not provided", "line": 23}]}}
{"CVE": "CVE-2022-23494", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "import {\n  AddEventsBehaviour, AlloyComponent, AlloyEvents, AlloyParts, AlloySpec, Behaviour, Button, Container, DomFactory, Focusing, Keying, ModalDialog,\n  NativeEvents, SketchSpec, SystemEvents, Tabstopping\n} from '@ephox/alloy';\nimport { Optional, Result } from '@ephox/katamari';\nimport { Class, SugarBody } from '@ephox/sugar';\n\nimport Env from 'tinymce/core/api/Env';\n\nimport { UiFactoryBackstageProviders } from '../../backstage/Backstage';\nimport * as NavigableObject from '../general/NavigableObject';\n\nconst isTouch = Env.deviceType.isTouch();\n\nconst hiddenHeader = (title: AlloyParts.ConfiguredPart, close: AlloyParts.ConfiguredPart): AlloySpec => ({\n  dom: {\n    tag: 'div',\n    styles: { display: 'none' },\n    classes: [ 'tox-dialog__header' ]\n  },\n  components: [\n    title,\n    close\n  ]\n});\n\nconst defaultHeader = (title: AlloyParts.ConfiguredPart, close: AlloyParts.ConfiguredPart): AlloySpec => ({\n  dom: {\n    tag: 'div',\n    classes: [ 'tox-dialog__header' ]\n  },\n  components: [\n    title,\n    close\n  ]\n});\n\nconst pClose = (onClose: () => void, providersBackstage: UiFactoryBackstageProviders): AlloyParts.ConfiguredPart => ModalDialog.parts.close(\n  // Need to find a way to make it clear in the docs whether parts can be sketches\n  Button.sketch({\n    dom: {\n      tag: 'button',\n      classes: [ 'tox-button', 'tox-button--icon', 'tox-button--naked' ],\n      attributes: {\n        'type': 'button',\n        'aria-label': providersBackstage.translate('Close')\n      }\n    },\n    action: onClose,\n    buttonBehaviours: Behaviour.derive([\n      Tabstopping.config({ })\n    ])\n  })\n);\n\nconst pUntitled = (): AlloyParts.ConfiguredPart => ModalDialog.parts.title({\n  dom: {\n    tag: 'div',\n    classes: [ 'tox-dialog__title' ],\n    innerHtml: '',\n    styles: {\n      display: 'none'\n    }\n  }\n});\n\nconst pBodyMessage = (message: string, providersBackstage: UiFactoryBackstageProviders): AlloyParts.ConfiguredPart => ModalDialog.parts.body({\n  dom: {\n    tag: 'div',\n    classes: [ 'tox-dialog__body' ]\n  },\n  components: [\n    {\n      dom: {\n        tag: 'div',\n        classes: [ 'tox-dialog__body-content' ]\n      },\n      components: [\n        {\n          dom: DomFactory.fromHtml(`<p>${providersBackstage.translate(message)}</p>`)\n        }\n      ]\n    }\n  ]\n});\n\nconst pFooter = (buttons: AlloySpec[]): AlloyParts.ConfiguredPart => ModalDialog.parts.footer({\n  dom: {\n    tag: 'div',\n    classes: [ 'tox-dialog__footer' ]\n  },\n  components: buttons\n});\n\nconst pFooterGroup = (startButtons: AlloySpec[], endButtons: AlloySpec[]): SketchSpec[] => [\n  Container.sketch({\n    dom: {\n      tag: 'div',\n      classes: [ 'tox-dialog__footer-start' ]\n    },\n    components: startButtons\n  }),\n  Container.sketch({\n    dom: {\n      tag: 'div',\n      classes: [ 'tox-dialog__footer-end' ]\n    },\n    components: endButtons\n  })\n];\n\nexport interface DialogSpec {\n  lazySink: () => Result<AlloyComponent, any>;\n  header: AlloySpec;\n  body: AlloyParts.ConfiguredPart;\n  footer: Optional<AlloyParts.ConfiguredPart>;\n  onEscape: (comp: AlloyComponent) => void;\n  extraClasses: string[];\n  extraBehaviours: Behaviour.NamedConfiguredBehaviour<any, any>[];\n  extraStyles: Record<string, string>;\n  dialogEvents: AlloyEvents.AlloyEventKeyAndHandler<any>[];\n  eventOrder: Record<string, string[]>;\n}\n\nconst renderDialog = (spec: DialogSpec): SketchSpec => {\n  const dialogClass = 'tox-dialog';\n  const blockerClass = dialogClass + '-wrap';\n  const blockerBackdropClass = blockerClass + '__backdrop';\n  const scrollLockClass = dialogClass + '__disable-scroll';\n\n  return ModalDialog.sketch(\n    {\n      lazySink: spec.lazySink,\n      onEscape: (comp) => {\n        spec.onEscape(comp);\n        // TODO: Make a strong type for Handled KeyEvent\n        return Optional.some(true);\n      },\n      useTabstopAt: (elem) => !NavigableObject.isPseudoStop(elem),\n      dom: {\n        tag: 'div',\n        classes: [ dialogClass ].concat(spec.extraClasses),\n        styles: {\n          position: 'relative',\n          ...spec.extraStyles\n        }\n      },\n      components: [\n        spec.header,\n        spec.body,\n        ...spec.footer.toArray()\n      ],\n      parts: {\n        blocker: {\n          dom: DomFactory.fromHtml(`<div class=\"${blockerClass}\"></div>`),\n          components: [\n            {\n              dom: {\n                tag: 'div',\n                classes: (isTouch ? [ blockerBackdropClass, blockerBackdropClass + '--opaque' ] : [ blockerBackdropClass ])\n              }\n            }\n          ]\n        }\n      },\n      dragBlockClass: blockerClass,\n\n      modalBehaviours: Behaviour.derive([\n        Focusing.config({}),\n        AddEventsBehaviour.config('dialog-events', spec.dialogEvents.concat([\n          // Note: `runOnSource` here will only listen to the event at the outer component level.\n          // Using just `run` instead will cause an infinite loop as `focusIn` would fire a `focusin` which would then get responded to and so forth.\n          AlloyEvents.runOnSource(NativeEvents.focusin(), (comp, _se) => {\n            Keying.focusIn(comp);\n          })\n        ])),\n        AddEventsBehaviour.config('scroll-lock', [\n          AlloyEvents.runOnAttached(() => {\n            Class.add(SugarBody.body(), scrollLockClass);\n          }),\n          AlloyEvents.runOnDetached(() => {\n            Class.remove(SugarBody.body(), scrollLockClass);\n          })\n        ]),\n        ...spec.extraBehaviours\n      ]),\n\n      eventOrder: {\n        [SystemEvents.execute()]: [ 'dialog-events' ],\n        [SystemEvents.attachedToDom()]: [ 'scroll-lock', 'dialog-events', 'alloy.base.behaviour' ],\n        [SystemEvents.detachedFromDom()]: [ 'alloy.base.behaviour', 'dialog-events', 'scroll-lock' ],\n        ...spec.eventOrder\n      }\n    }\n  );\n};\n\nexport { defaultHeader, hiddenHeader, pClose, pUntitled, pBodyMessage, pFooter, pFooterGroup, renderDialog };\n", "output": {"vulnerability_count": 2, "vulnerabilities": [{"description": "This template literal looks like HTML and has interpolated variables. These variables are not HTML-encoded by default. If the variables contain HTML tags, these may be interpreted by the browser, resulting in cross-site scripting (XSS).", "risk": "Medium", "conceptual_fix": "Not provided", "line": 80}, {"description": "This template literal looks like HTML and has interpolated variables. These variables are not HTML-encoded by default. If the variables contain HTML tags, these may be interpreted by the browser, resulting in cross-site scripting (XSS).", "risk": "Medium", "conceptual_fix": "Not provided", "line": 155}]}}
{"CVE": "CVE-2022-23552", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "import { css, cx } from '@emotion/css';\nimport BaseLayer from 'ol/layer/Base';\nimport React, { useMemo } from 'react';\nimport SVG from 'react-inlinesvg';\nimport { useObservable } from 'react-use';\nimport { of } from 'rxjs';\n\nimport { DataFrame, formattedValueToString, getFieldColorModeForField, GrafanaTheme2 } from '@grafana/data';\nimport { getMinMaxAndDelta } from '@grafana/data/src/field/scale';\nimport { useStyles2, VizLegendItem } from '@grafana/ui';\nimport { ColorScale } from 'app/core/components/ColorScale/ColorScale';\nimport { config } from 'app/core/config';\nimport { DimensionSupplier } from 'app/features/dimensions';\nimport { getThresholdItems } from 'app/plugins/panel/state-timeline/utils';\n\nimport { StyleConfigState } from '../style/types';\nimport { MapLayerState } from '../types';\n\nexport interface MarkersLegendProps {\n  size?: DimensionSupplier<number>;\n  layerName?: string;\n  styleConfig?: StyleConfigState;\n  layer?: BaseLayer;\n}\n\nexport function MarkersLegend(props: MarkersLegendProps) {\n  const { layerName, styleConfig, layer } = props;\n  const style = useStyles2(getStyles);\n\n  const hoverEvent = useObservable(((layer as any)?.__state as MapLayerState)?.mouseEvents ?? of(undefined));\n\n  const colorField = styleConfig?.dims?.color?.field;\n  const hoverValue = useMemo(() => {\n    if (!colorField || !hoverEvent) {\n      return undefined;\n    }\n\n    const props = hoverEvent.getProperties();\n    const frame = props.frame as DataFrame; // eslint-disable-line\n\n    if (!frame) {\n      return undefined;\n    }\n\n    const rowIndex = props.rowIndex as number; // eslint-disable-line\n    return colorField.values.get(rowIndex);\n  }, [hoverEvent, colorField]);\n\n  if (!styleConfig) {\n    return <></>;\n  }\n\n  const { color, opacity } = styleConfig?.base ?? {};\n  const symbol = styleConfig?.config.symbol?.fixed;\n\n  if (color && symbol && !colorField) {\n    return (\n      <div className={style.infoWrap}>\n        <div className={style.layerName}>{layerName}</div>\n        <div className={cx(style.layerBody, style.fixedColorContainer)}>\n          <SVG\n            src={`public/${symbol}`}\n            className={style.legendSymbol}\n            title={'Symbol'}\n            style={{ fill: color, opacity: opacity }}\n          />\n        </div>\n      </div>\n    );\n  }\n\n  if (!colorField) {\n    return <></>;\n  }\n\n  const colorMode = getFieldColorModeForField(colorField);\n\n  if (colorMode.isContinuous && colorMode.getColors) {\n    const colors = colorMode.getColors(config.theme2);\n    const colorRange = getMinMaxAndDelta(colorField);\n    // TODO: explore showing mean on the gradiant scale\n    // const stats = reduceField({\n    //   field: color.field!,\n    //   reducers: [\n    //     ReducerID.min,\n    //     ReducerID.max,\n    //     ReducerID.mean,\n    //     // std dev?\n    //   ]\n    // })\n\n    const display = colorField.display\n      ? (v: number) => formattedValueToString(colorField.display!(v))\n      : (v: number) => `${v}`;\n    return (\n      <div className={style.infoWrap}>\n        <div className={style.layerName}>{layerName}</div>\n        <div className={cx(style.layerBody, style.colorScaleWrapper)}>\n          <ColorScale\n            hoverValue={hoverValue}\n            colorPalette={colors}\n            min={colorRange.min as number}\n            max={colorRange.max as number}\n            display={display}\n            useStopsPercentage={false}\n          />\n        </div>\n      </div>\n    );\n  }\n\n  const thresholds = colorField?.config?.thresholds;\n  if (!thresholds || thresholds.steps.length < 2) {\n    return <div></div>; // don't show anything in the legend\n  }\n\n  const items = getThresholdItems(colorField!.config, config.theme2);\n  return (\n    <div className={style.infoWrap}>\n      <div className={style.layerName}>{layerName}</div>\n      <div className={cx(style.layerBody, style.legend)}>\n        {items.map((item: VizLegendItem, idx: number) => (\n          <div key={`${idx}/${item.label}`} className={style.legendItem}>\n            <i style={{ background: item.color }}></i>\n            {item.label}\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}\n\nconst getStyles = (theme: GrafanaTheme2) => ({\n  infoWrap: css`\n    display: flex;\n    flex-direction: column;\n    background: ${theme.colors.background.secondary};\n    border-radius: 1px;\n    padding: ${theme.spacing(1)};\n    border-bottom: 2px solid ${theme.colors.border.strong};\n    min-width: 150px;\n  `,\n  layerName: css`\n    font-size: ${theme.typography.body.fontSize};\n  `,\n  layerBody: css`\n    padding-left: 10px;\n  `,\n  legend: css`\n    line-height: 18px;\n    display: flex;\n    flex-direction: column;\n    font-size: ${theme.typography.bodySmall.fontSize};\n    padding: 5px 10px 0;\n\n    i {\n      width: 15px;\n      height: 15px;\n      float: left;\n      margin-right: 8px;\n      opacity: 0.7;\n      border-radius: 50%;\n    }\n  `,\n  legendItem: css`\n    white-space: nowrap;\n  `,\n  fixedColorContainer: css`\n    min-width: 80px;\n    font-size: ${theme.typography.bodySmall.fontSize};\n    padding-top: 5px;\n  `,\n  legendSymbol: css`\n    height: 18px;\n    width: 18px;\n    margin: auto;\n  `,\n  colorScaleWrapper: css`\n    min-width: 200px;\n    font-size: ${theme.typography.bodySmall.fontSize};\n    padding-top: 10px;\n  `,\n});\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2022-23656", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "import $ from \"jquery\";\n\nimport render_recent_topic_row from \"../templates/recent_topic_row.hbs\";\nimport render_recent_topics_filters from \"../templates/recent_topics_filters.hbs\";\nimport render_recent_topics_body from \"../templates/recent_topics_table.hbs\";\n\nimport * as compose_closed_ui from \"./compose_closed_ui\";\nimport * as hash_util from \"./hash_util\";\nimport {$t} from \"./i18n\";\nimport * as ListWidget from \"./list_widget\";\nimport * as loading from \"./loading\";\nimport {localstorage} from \"./localstorage\";\nimport * as message_store from \"./message_store\";\nimport * as message_util from \"./message_util\";\nimport * as message_view_header from \"./message_view_header\";\nimport * as muted_topics from \"./muted_topics\";\nimport * as narrow from \"./narrow\";\nimport * as narrow_state from \"./narrow_state\";\nimport * as navbar_alerts from \"./navbar_alerts\";\nimport * as navigate from \"./navigate\";\nimport * as people from \"./people\";\nimport * as recent_senders from \"./recent_senders\";\nimport {get, process_message, topics} from \"./recent_topics_data\";\nimport {get_topic_key, is_in_focus, is_visible, set_visible} from \"./recent_topics_util\";\nimport * as stream_data from \"./stream_data\";\nimport * as stream_list from \"./stream_list\";\nimport * as sub_store from \"./sub_store\";\nimport * as timerender from \"./timerender\";\nimport * as top_left_corner from \"./top_left_corner\";\nimport * as unread from \"./unread\";\n\nlet topics_widget;\n// Sets the number of avatars to display.\n// Rest of the avatars, if present, are displayed as {+x}\nconst MAX_AVATAR = 4;\nconst MAX_EXTRA_SENDERS = 10;\n\n// Use this to set the focused element.\n//\n// We set it's value to `table` in case the\n// focus in one of the table rows, since the\n// table rows are constantly updated and tracking\n// the selected element in them would be tedious via\n// jquery.\n//\n// So, we use table as a grid system and\n// track the coordinates of the focus element via\n// `row_focus` and `col_focus`.\nexport let current_focus_elem = \"table\";\n\n// If user clicks a topic in recent topics, then\n// we store that topic here so that we can restore focus\n// to that topic when user revisits.\nlet last_visited_topic = \"\";\nlet row_focus = 0;\n// Start focus on the topic column, so Down+Enter works to visit a topic.\nlet col_focus = 1;\n\nexport const COLUMNS = {\n    stream: 0,\n    topic: 1,\n    mute: 2,\n    read: 3,\n};\n\n// The number of selectable actions in a recent_topics.  Used to\n// implement wraparound of elements with the right/left keys.  Must be\n// increased when we add new actions, or rethought if we add optional\n// actions that only appear in some rows.\nconst MAX_SELECTABLE_COLS = 4;\n\n// we use localstorage to persist the recent topic filters\nconst ls_key = \"recent_topic_filters\";\nconst ls = localstorage();\n\nlet filters = new Set();\n\nexport function clear_for_tests() {\n    filters.clear();\n    topics.clear();\n    topics_widget = undefined;\n}\n\nexport function save_filters() {\n    ls.set(ls_key, Array.from(filters));\n}\n\nexport function load_filters() {\n    filters = new Set(ls.get(ls_key));\n}\n\nexport function set_default_focus() {\n    // If at any point we are confused about the currently\n    // focused element, we switch focus to search.\n    current_focus_elem = $(\"#recent_topics_search\");\n    current_focus_elem.trigger(\"focus\");\n    compose_closed_ui.set_standard_text_for_reply_button();\n}\n\nfunction get_min_load_count(already_rendered_count, load_count) {\n    const extra_rows_for_viewing_pleasure = 15;\n    if (row_focus > already_rendered_count + load_count) {\n        return row_focus + extra_rows_for_viewing_pleasure - already_rendered_count;\n    }\n    return load_count;\n}\n\nfunction is_table_focused() {\n    return current_focus_elem === \"table\";\n}\n\nfunction set_table_focus(row, col, using_keyboard) {\n    const topic_rows = $(\"#recent_topics_table table tbody tr\");\n    if (topic_rows.length === 0 || row < 0 || row >= topic_rows.length) {\n        row_focus = 0;\n        // return focus back to filters if we cannot focus on the table.\n        set_default_focus();\n        return true;\n    }\n\n    const topic_row = topic_rows.eq(row);\n    // We need to allow table to render first before setting focus.\n    setTimeout(\n        () => topic_row.find(\".recent_topics_focusable\").eq(col).children().trigger(\"focus\"),\n        0,\n    );\n    current_focus_elem = \"table\";\n\n    if (using_keyboard) {\n        const scroll_element = document.querySelector(\n            \"#recent_topics_table .table_fix_head .simplebar-content-wrapper\",\n        );\n        const half_height_of_visible_area = scroll_element.offsetHeight / 2;\n        const topic_offset = topic_offset_to_visible_area(topic_row);\n\n        if (topic_offset === \"above\") {\n            scroll_element.scrollBy({top: -1 * half_height_of_visible_area});\n        } else if (topic_offset === \"below\") {\n            scroll_element.scrollBy({top: half_height_of_visible_area});\n        }\n    }\n\n    const message = {\n        stream: topic_row.find(\".recent_topic_stream a\").text(),\n        topic: topic_row.find(\".recent_topic_name a\").text(),\n    };\n    compose_closed_ui.update_reply_recipient_label(message);\n    return true;\n}\n\nexport function get_focused_row_message() {\n    if (is_table_focused()) {\n        const recent_topic_id_prefix_len = \"recent_topic:\".length;\n        const topic_rows = $(\"#recent_topics_table table tbody tr\");\n        if (topic_rows.length === 0) {\n            return undefined;\n        }\n\n        const topic_row = topic_rows.eq(row_focus);\n        const topic_id = topic_row.attr(\"id\").slice(recent_topic_id_prefix_len);\n        const topic_last_msg_id = topics.get(topic_id).last_msg_id;\n        return message_store.get(topic_last_msg_id);\n    }\n    return undefined;\n}\n\nexport function revive_current_focus() {\n    // After re-render, the current_focus_elem is no longer linked\n    // to the focused element, this function attempts to revive the\n    // link and focus to the element prior to the rerender.\n\n    // We try to avoid setting focus when user\n    // is not focused on recent topics.\n    if (!is_in_focus()) {\n        return false;\n    }\n\n    if (!current_focus_elem) {\n        set_default_focus();\n        return false;\n    }\n\n    if (is_table_focused()) {\n        if (last_visited_topic) {\n            const topic_last_msg_id = topics.get(last_visited_topic).last_msg_id;\n            const current_list = topics_widget.get_current_list();\n            const last_visited_topic_index = current_list.findIndex(\n                (topic) => topic.last_msg_id === topic_last_msg_id,\n            );\n            if (last_visited_topic_index >= 0) {\n                row_focus = last_visited_topic_index;\n            }\n            last_visited_topic = \"\";\n        }\n\n        set_table_focus(row_focus, col_focus);\n        return true;\n    }\n\n    const filter_button = current_focus_elem.data(\"filter\");\n    if (!filter_button) {\n        set_default_focus();\n    } else {\n        current_focus_elem = $(\"#recent_topics_filter_buttons\").find(\n            `[data-filter='${CSS.escape(filter_button)}']`,\n        );\n        current_focus_elem.trigger(\"focus\");\n    }\n    return true;\n}\n\nexport function show_loading_indicator() {\n    loading.make_indicator($(\"#recent_topics_loading_messages_indicator\"));\n}\n\nexport function hide_loading_indicator() {\n    $(\"#recent_topics_bottom_whitespace\").hide();\n    loading.destroy_indicator($(\"#recent_topics_loading_messages_indicator\"), {\n        abs_positioned: false,\n    });\n    // Show empty table text if there are no messages fetched.\n    $(\"#recent_topics_table tbody\").addClass(\"required-text\");\n}\n\nexport function process_messages(messages) {\n    // While this is inexpensive and handles all the cases itself,\n    // the UX can be bad if user wants to scroll down the list as\n    // the UI will be returned to the beginning of the list on every\n    // update.\n    //\n    // Only rerender if topic_data actually\n    // changed.\n    let topic_data_changed = false;\n    for (const msg of messages) {\n        if (process_message(msg)) {\n            topic_data_changed = true;\n        }\n    }\n\n    if (topic_data_changed) {\n        complete_rerender();\n    }\n}\n\nfunction format_topic(topic_data) {\n    const last_msg = message_store.get(topic_data.last_msg_id);\n    const stream = last_msg.stream;\n    const stream_id = last_msg.stream_id;\n    const stream_info = sub_store.get(stream_id);\n    if (stream_info === undefined) {\n        // stream was deleted\n        return {};\n    }\n    const topic = last_msg.topic;\n    const time = new Date(last_msg.timestamp * 1000);\n    const last_msg_time = timerender.format_time_modern(time);\n    const full_datetime = timerender.get_full_datetime(time);\n\n    // We hide the row according to filters or if it's muted.\n    // We only supply the data to the topic rows and let jquery\n    // display / hide them according to filters instead of\n    // doing complete re-render.\n    const topic_muted = Boolean(muted_topics.is_topic_muted(stream_id, topic));\n    const stream_muted = stream_data.is_muted(stream_id);\n    const muted = topic_muted || stream_muted;\n    const unread_count = unread.num_unread_for_topic(stream_id, topic);\n\n    // Display in most recent sender first order\n    const all_senders = recent_senders.get_topic_recent_senders(stream_id, topic);\n    const senders = all_senders.slice(-MAX_AVATAR);\n    const senders_info = people.sender_info_for_recent_topics_row(senders);\n\n    // Collect extra senders fullname for tooltip.\n    const extra_sender_ids = all_senders.slice(0, -MAX_AVATAR);\n    const displayed_other_senders = extra_sender_ids.slice(-MAX_EXTRA_SENDERS);\n    const displayed_other_names = people.get_display_full_names(displayed_other_senders.reverse());\n\n    if (extra_sender_ids.length > MAX_EXTRA_SENDERS) {\n        // We display only 10 extra senders in tooltips,\n        // and just display remaining number of senders.\n        const remaining_senders = extra_sender_ids.length - MAX_EXTRA_SENDERS;\n        // Pluralization syntax from:\n        // https://formatjs.io/docs/core-concepts/icu-syntax/#plural-format\n        displayed_other_names.push(\n            $t(\n                {\n                    defaultMessage:\n                        \"and {remaining_senders, plural, one {1 other} other {# others}}.\",\n                },\n                {remaining_senders},\n            ),\n        );\n    }\n    const other_sender_names = displayed_other_names.join(\"<br/>\");\n\n    return {\n        // stream info\n        stream_id,\n        stream,\n        stream_color: stream_info.color,\n        invite_only: stream_info.invite_only,\n        is_web_public: stream_info.is_web_public,\n        stream_url: hash_util.by_stream_uri(stream_id),\n\n        topic,\n        topic_key: get_topic_key(stream_id, topic),\n        unread_count,\n        last_msg_time,\n        topic_url: hash_util.by_stream_topic_uri(stream_id, topic),\n        senders: senders_info,\n        other_senders_count: Math.max(0, all_senders.length - MAX_AVATAR),\n        other_sender_names,\n        muted,\n        topic_muted,\n        participated: topic_data.participated,\n        full_last_msg_date_time: full_datetime,\n    };\n}\n\nfunction get_topic_row(topic_data) {\n    const msg = message_store.get(topic_data.last_msg_id);\n    const topic_key = get_topic_key(msg.stream_id, msg.topic);\n    return $(`#${CSS.escape(\"recent_topic:\" + topic_key)}`);\n}\n\nexport function process_topic_edit(old_stream_id, old_topic, new_topic, new_stream_id) {\n    // See `recent_senders.process_topic_edit` for\n    // logic behind this and important notes on use of this function.\n    topics.delete(get_topic_key(old_stream_id, old_topic));\n\n    const old_topic_msgs = message_util.get_messages_in_topic(old_stream_id, old_topic);\n    process_messages(old_topic_msgs);\n\n    new_stream_id = new_stream_id || old_stream_id;\n    const new_topic_msgs = message_util.get_messages_in_topic(new_stream_id, new_topic);\n    process_messages(new_topic_msgs);\n}\n\nexport function topic_in_search_results(keyword, stream, topic) {\n    if (keyword === \"\") {\n        return true;\n    }\n    const text = (stream + \" \" + topic).toLowerCase();\n    const search_words = keyword.toLowerCase().split(/\\s+/);\n    return search_words.every((word) => text.includes(word));\n}\n\nexport function update_topics_of_deleted_message_ids(message_ids) {\n    const topics_to_rerender = message_util.get_topics_for_message_ids(message_ids);\n\n    for (const [stream_id, topic] of topics_to_rerender.values()) {\n        topics.delete(get_topic_key(stream_id, topic));\n        const msgs = message_util.get_messages_in_topic(stream_id, topic);\n        process_messages(msgs);\n    }\n}\n\nexport function filters_should_hide_topic(topic_data) {\n    const msg = message_store.get(topic_data.last_msg_id);\n    const sub = sub_store.get(msg.stream_id);\n\n    if (sub === undefined || !sub.subscribed) {\n        // Never try to process deactivated & unsubscribed stream msgs.\n        return true;\n    }\n\n    if (filters.has(\"unread\")) {\n        const unreadCount = unread.num_unread_for_topic(msg.stream_id, msg.topic);\n        if (unreadCount === 0) {\n            return true;\n        }\n    }\n\n    if (!topic_data.participated && filters.has(\"participated\")) {\n        return true;\n    }\n\n    if (!filters.has(\"include_muted\")) {\n        const topic_muted = Boolean(muted_topics.is_topic_muted(msg.stream_id, msg.topic));\n        const stream_muted = stream_data.is_muted(msg.stream_id);\n        if (topic_muted || stream_muted) {\n            return true;\n        }\n    }\n\n    const search_keyword = $(\"#recent_topics_search\").val();\n    if (!topic_in_search_results(search_keyword, msg.stream, msg.topic)) {\n        return true;\n    }\n\n    return false;\n}\n\nexport function inplace_rerender(topic_key) {\n    if (!is_visible()) {\n        return false;\n    }\n    if (!topics.has(topic_key)) {\n        return false;\n    }\n\n    const topic_data = topics.get(topic_key);\n    topics_widget.render_item(topic_data);\n    const topic_row = get_topic_row(topic_data);\n\n    if (filters_should_hide_topic(topic_data)) {\n        topic_row.hide();\n    } else {\n        topic_row.show();\n    }\n    revive_current_focus();\n    return true;\n}\n\nexport function update_topic_is_muted(stream_id, topic) {\n    const key = get_topic_key(stream_id, topic);\n    if (!topics.has(key)) {\n        // we receive mute request for a topic we are\n        // not tracking currently\n        return false;\n    }\n\n    inplace_rerender(key);\n    return true;\n}\n\nexport function update_topic_unread_count(message) {\n    const topic_key = get_topic_key(message.stream_id, message.topic);\n    inplace_rerender(topic_key);\n}\n\nexport function set_filter(filter) {\n    // This function updates the `filters` variable\n    // after user clicks on one of the filter buttons\n    // based on `btn-recent-selected` class and current\n    // set `filters`.\n\n    // Get the button which was clicked.\n    const filter_elem = $(\"#recent_topics_filter_buttons\").find(\n        `[data-filter=\"${CSS.escape(filter)}\"]`,\n    );\n\n    // If user clicks `All`, we clear all filters.\n    if (filter === \"all\" && filters.size !== 0) {\n        filters = new Set();\n        // If the button was already selected, remove the filter.\n    } else if (filter_elem.hasClass(\"btn-recent-selected\")) {\n        filters.delete(filter);\n        // If the button was not selected, we add the filter.\n    } else {\n        filters.add(filter);\n    }\n\n    save_filters();\n}\n\nfunction show_selected_filters() {\n    // Add `btn-selected-filter` to the buttons to show\n    // which filters are applied.\n    if (filters.size === 0) {\n        $(\"#recent_topics_filter_buttons\")\n            .find('[data-filter=\"all\"]')\n            .addClass(\"btn-recent-selected\")\n            .attr(\"aria-checked\", \"true\");\n    } else {\n        for (const filter of filters) {\n            $(\"#recent_topics_filter_buttons\")\n                .find(`[data-filter=\"${CSS.escape(filter)}\"]`)\n                .addClass(\"btn-recent-selected\")\n                .attr(\"aria-checked\", \"true\");\n        }\n    }\n}\n\nexport function update_filters_view() {\n    const rendered_filters = render_recent_topics_filters({\n        filter_participated: filters.has(\"participated\"),\n        filter_unread: filters.has(\"unread\"),\n        filter_muted: filters.has(\"include_muted\"),\n    });\n    $(\"#recent_filters_group\").html(rendered_filters);\n    show_selected_filters();\n\n    topics_widget.hard_redraw();\n}\n\nfunction stream_sort(a, b) {\n    const a_stream = message_store.get(a.last_msg_id).stream;\n    const b_stream = message_store.get(b.last_msg_id).stream;\n    if (a_stream > b_stream) {\n        return 1;\n    } else if (a_stream === b_stream) {\n        return 0;\n    }\n    return -1;\n}\n\nfunction topic_sort(a, b) {\n    const a_topic = message_store.get(a.last_msg_id).topic;\n    const b_topic = message_store.get(b.last_msg_id).topic;\n    if (a_topic > b_topic) {\n        return 1;\n    } else if (a_topic === b_topic) {\n        return 0;\n    }\n    return -1;\n}\n\nfunction topic_offset_to_visible_area(topic_row) {\n    const scroll_container = $(\"#recent_topics_table .table_fix_head\");\n    const thead_height = 30;\n    const under_closed_compose_region_height = 50;\n\n    const scroll_container_top = $(scroll_container).offset().top + thead_height;\n    const scroll_container_bottom =\n        scroll_container_top + $(scroll_container).height() - under_closed_compose_region_height;\n\n    const topic_row_top = $(topic_row).offset().top;\n    const topic_row_bottom = topic_row_top + $(topic_row).height();\n\n    // Topic is above the visible scroll region.\n    if (topic_row_top < scroll_container_top) {\n        return \"above\";\n        // Topic is below the visible scroll region.\n    } else if (topic_row_bottom > scroll_container_bottom) {\n        return \"below\";\n    }\n\n    // Topic is visible\n    return \"visible\";\n}\n\nfunction set_focus_to_element_in_center() {\n    const table_wrapper_element = document.querySelector(\"#recent_topics_table .table_fix_head\");\n    const topic_rows = $(\"#recent_topics_table table tbody tr\");\n\n    if (row_focus > topic_rows.length) {\n        // User used a filter which reduced\n        // the number of visible rows.\n        return;\n    }\n    let topic_row = topic_rows.eq(row_focus);\n    const topic_offset = topic_offset_to_visible_area(topic_row);\n    if (topic_offset !== \"visible\") {\n        // Get the element at the center of the table.\n        const position = table_wrapper_element.getBoundingClientRect();\n        const topic_center_x = (position.left + position.right) / 2;\n        const topic_center_y = (position.top + position.bottom) / 2;\n\n        topic_row = $(document.elementFromPoint(topic_center_x, topic_center_y)).closest(\"tr\");\n\n        row_focus = topic_rows.index(topic_row);\n        set_table_focus(row_focus, col_focus);\n    }\n}\n\nfunction is_scroll_position_for_render(scroll_container) {\n    const table_bottom_margin = 100; // Extra margin at the bottom of table.\n    const table_row_height = 50;\n    return (\n        scroll_container.scrollTop +\n            scroll_container.clientHeight +\n            table_bottom_margin +\n            table_row_height >\n        scroll_container.scrollHeight\n    );\n}\n\nexport function complete_rerender() {\n    if (!is_visible()) {\n        return;\n    }\n\n    // Update header\n    load_filters();\n    show_selected_filters();\n\n    // Show topics list\n    const mapped_topic_values = Array.from(get().values()).map((value) => value);\n\n    if (topics_widget) {\n        topics_widget.replace_list_data(mapped_topic_values);\n        return;\n    }\n\n    const rendered_body = render_recent_topics_body({\n        filter_participated: filters.has(\"participated\"),\n        filter_unread: filters.has(\"unread\"),\n        filter_muted: filters.has(\"include_muted\"),\n        search_val: $(\"#recent_topics_search\").val() || \"\",\n    });\n    $(\"#recent_topics_table\").html(rendered_body);\n    const container = $(\"#recent_topics_table table tbody\");\n    container.empty();\n    topics_widget = ListWidget.create(container, mapped_topic_values, {\n        name: \"recent_topics_table\",\n        parent_container: $(\"#recent_topics_table\"),\n        modifier(item) {\n            return render_recent_topic_row(format_topic(item));\n        },\n        filter: {\n            // We use update_filters_view & filters_should_hide_topic to do all the\n            // filtering for us, which is called using click_handlers.\n            predicate(topic_data) {\n                return !filters_should_hide_topic(topic_data);\n            },\n        },\n        sort_fields: {\n            stream_sort,\n            topic_sort,\n        },\n        html_selector: get_topic_row,\n        simplebar_container: $(\"#recent_topics_table .table_fix_head\"),\n        callback_after_render: revive_current_focus,\n        is_scroll_position_for_render,\n        post_scroll__pre_render_callback: set_focus_to_element_in_center,\n        get_min_load_count,\n    });\n}\n\nexport function show() {\n    if (is_visible()) {\n        // If we're already visible, E.g. because the user hit Esc\n        // while already in the recent topics view, do nothing.\n        return;\n    }\n    // Hide selected elements in the left sidebar.\n    top_left_corner.narrow_to_recent_topics();\n    stream_list.handle_narrow_deactivated();\n\n    // Hide \"middle-column\" which has html for rendering\n    // a messages narrow. We hide it and show recent topics.\n    $(\"#message_feed_container\").hide();\n    $(\"#recent_topics_view\").show();\n    set_visible(true);\n    $(\"#message_view_header_underpadding\").hide();\n    $(\".header\").css(\"padding-bottom\", \"0px\");\n\n    narrow.hide_mark_as_read_turned_off_banner();\n\n    // We want to show `new stream message` instead of\n    // `new topic`, which we are already doing in this\n    // function. So, we reuse it here.\n    compose_closed_ui.update_buttons_for_recent_topics();\n\n    narrow_state.reset_current_filter();\n    narrow.set_narrow_title(\"Recent topics\");\n    message_view_header.render_title_area();\n\n    complete_rerender();\n}\n\nfunction filter_buttons() {\n    return $(\"#recent_filters_group\").children();\n}\n\nexport function hide() {\n    // On firefox (and flaky on other browsers), focus\n    // remains on the focused element even after it is hidden. We\n    // forcefully blur it so that focus returns to the visible\n    // focused element.\n    const focused_element = $(document.activeElement);\n    if ($(\"#recent_topics_view\").has(focused_element)) {\n        focused_element.trigger(\"blur\");\n    }\n\n    $(\"#message_view_header_underpadding\").show();\n    $(\"#message_feed_container\").show();\n    $(\"#recent_topics_view\").hide();\n    set_visible(false);\n\n    $(\".header\").css(\"padding-bottom\", \"10px\");\n\n    // This solves a bug with message_view_header\n    // being broken sometimes when we narrow\n    // to a filter and back to recent topics\n    // before it completely re-rerenders.\n    message_view_header.render_title_area();\n\n    // Fixes misaligned message_view and hidden\n    // floating_recipient_bar.\n    navbar_alerts.resize_app();\n\n    // This makes sure user lands on the selected message\n    // and not always at the top of the narrow.\n    navigate.plan_scroll_to_selected();\n}\n\nfunction is_focus_at_last_table_row() {\n    const topic_rows = $(\"#recent_topics_table table tbody tr\");\n    return row_focus === topic_rows.length - 1;\n}\n\nexport function focus_clicked_element(topic_row_index, col, topic_key) {\n    current_focus_elem = \"table\";\n    col_focus = col;\n    row_focus = topic_row_index;\n\n    if (col === COLUMNS.topic) {\n        last_visited_topic = topic_key;\n    }\n    // Set compose_closed_ui reply button text.  The rest of the table\n    // focus logic should be a noop.\n    set_table_focus(row_focus, col_focus);\n}\n\nexport function change_focused_element($elt, input_key) {\n    // Called from hotkeys.js; like all logic in that module,\n    // returning true will cause the caller to do\n    // preventDefault/stopPropagation; false will let the browser\n    // handle the key.\n\n    if ($elt.attr(\"id\") === \"recent_topics_search\") {\n        // Since the search box a text area, we want the browser to handle\n        // Left/Right and selection within the widget; but if the user\n        // arrows off the edges, we should move focus to the adjacent widgets..\n        const textInput = $(\"#recent_topics_search\").get(0);\n        const start = textInput.selectionStart;\n        const end = textInput.selectionEnd;\n        const text_length = textInput.value.length;\n        let is_selected = false;\n        if (end - start > 0) {\n            is_selected = true;\n        }\n\n        switch (input_key) {\n            //  Allow browser to handle all\n            //  character keypresses.\n            case \"vim_left\":\n            case \"vim_right\":\n            case \"vim_down\":\n            case \"vim_up\":\n            case \"open_recent_topics\":\n                return false;\n            case \"shift_tab\":\n                current_focus_elem = filter_buttons().last();\n                break;\n            case \"left_arrow\":\n                if (start !== 0 || is_selected) {\n                    return false;\n                }\n                current_focus_elem = filter_buttons().last();\n                break;\n            case \"tab\":\n                current_focus_elem = filter_buttons().first();\n                break;\n            case \"right_arrow\":\n                if (end !== text_length || is_selected) {\n                    return false;\n                }\n                current_focus_elem = filter_buttons().first();\n                break;\n            case \"down_arrow\":\n                set_table_focus(row_focus, col_focus);\n                return true;\n            case \"click\":\n                // Note: current_focus_elem can be different here, so we just\n                // set current_focus_elem to the input box, we don't want .trigger(\"focus\") on\n                // it since it is already focused.\n                // We only do this for search because we don't want the focus to\n                // go away from the input box when `revive_current_focus` is called\n                // on rerender when user is typing.\n                current_focus_elem = $(\"#recent_topics_search\");\n                compose_closed_ui.set_standard_text_for_reply_button();\n                return true;\n            case \"escape\":\n                if (is_table_focused()) {\n                    return false;\n                }\n                set_table_focus(row_focus, col_focus);\n                return true;\n        }\n    } else if ($elt.hasClass(\"btn-recent-filters\")) {\n        switch (input_key) {\n            case \"click\":\n                current_focus_elem = $elt;\n                return true;\n            case \"shift_tab\":\n            case \"vim_left\":\n            case \"left_arrow\":\n                if (filter_buttons().first()[0] === $elt[0]) {\n                    current_focus_elem = $(\"#recent_topics_search\");\n                } else {\n                    current_focus_elem = $elt.prev();\n                }\n                break;\n            case \"tab\":\n            case \"vim_right\":\n            case \"right_arrow\":\n                if (filter_buttons().last()[0] === $elt[0]) {\n                    current_focus_elem = $(\"#recent_topics_search\");\n                } else {\n                    current_focus_elem = $elt.next();\n                }\n                break;\n            case \"vim_down\":\n            case \"down_arrow\":\n                set_table_focus(row_focus, col_focus);\n                return true;\n            case \"escape\":\n                if (is_table_focused()) {\n                    return false;\n                }\n                set_table_focus(row_focus, col_focus);\n                return true;\n        }\n    } else if (is_table_focused()) {\n        // For arrowing around the table of topics, we implement left/right\n        // wraparound.  Going off the top or the bottom takes one\n        // to the navigation at the top (see set_table_focus).\n        switch (input_key) {\n            case \"escape\":\n                return false;\n            case \"open_recent_topics\":\n                set_default_focus();\n                return true;\n            case \"shift_tab\":\n            case \"vim_left\":\n            case \"left_arrow\":\n                col_focus -= 1;\n                if (col_focus < 0) {\n                    col_focus = MAX_SELECTABLE_COLS - 1;\n                }\n                break;\n            case \"tab\":\n            case \"vim_right\":\n            case \"right_arrow\":\n                col_focus += 1;\n                if (col_focus >= MAX_SELECTABLE_COLS) {\n                    col_focus = 0;\n                }\n                break;\n            case \"vim_down\":\n                // We stop user at last table row\n                // so that user doesn't end up in\n                // input box where it is impossible to\n                // get out of using vim_up / vim_down\n                // keys. This also blocks the user from\n                // having `jjjj` typed in the input box\n                // when continuously pressing `j`.\n                if (is_focus_at_last_table_row()) {\n                    return true;\n                }\n                row_focus += 1;\n                break;\n            case \"down_arrow\":\n                row_focus += 1;\n                break;\n            case \"vim_up\":\n                // See comment on vim_down.\n                // Similarly, blocks the user from\n                // having `kkkk` typed in the input box\n                // when continuously pressing `k`.\n                if (row_focus === 0) {\n                    return true;\n                }\n                row_focus -= 1;\n                break;\n            case \"up_arrow\":\n                row_focus -= 1;\n        }\n        set_table_focus(row_focus, col_focus, true);\n        return true;\n    }\n    if (current_focus_elem && input_key !== \"escape\") {\n        current_focus_elem.trigger(\"focus\");\n        if (current_focus_elem.hasClass(\"btn-recent-filters\")) {\n            compose_closed_ui.set_standard_text_for_reply_button();\n        }\n        return true;\n    }\n\n    return false;\n}\n", "output": {"vulnerability_count": 6, "vulnerabilities": [{"description": "User controlled data in a jQuery's `.html(...)` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 481}, {"description": "JQuery's `html` function is susceptible to Cross Site Scripting (XSS) attacks. If you're just passing text, consider `text` instead. Otherwise, use a function that escapes HTML such as edX's `HtmlUtils.setHtml()`.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 481}, {"description": "User controlled data in a `$(...)` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 518}, {"description": "User controlled data in a `$(...)` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 519}, {"description": "User controlled data in a jQuery's `.html(...)` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 592}, {"description": "JQuery's `html` function is susceptible to Cross Site Scripting (XSS) attacks. If you're just passing text, consider `text` instead. Otherwise, use a function that escapes HTML such as edX's `HtmlUtils.setHtml()`.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 592}]}}
{"CVE": "CVE-2022-24728", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n( function() {\n\tvar removeReservedKeywords;\n\n\t/**\n\t * Represents an HTML data processor, which is responsible for translating and\n\t * transforming the editor data on input and output.\n\t *\n\t * @class\n\t * @extends CKEDITOR.dataProcessor\n\t * @constructor Creates an htmlDataProcessor class instance.\n\t * @param {CKEDITOR.editor} editor\n\t */\n\tCKEDITOR.htmlDataProcessor = function( editor ) {\n\t\tvar dataFilter, htmlFilter,\n\t\t\tthat = this;\n\n\t\tthis.editor = editor;\n\n\t\t/**\n\t\t * Data filter used when processing input by {@link #toHtml}.\n\t\t *\n\t\t * @property {CKEDITOR.htmlParser.filter}\n\t\t */\n\t\tthis.dataFilter = dataFilter = new CKEDITOR.htmlParser.filter();\n\n\t\t/**\n\t\t * HTML filter used when processing output by {@link #toDataFormat}.\n\t\t *\n\t\t * @property {CKEDITOR.htmlParser.filter}\n\t\t */\n\t\tthis.htmlFilter = htmlFilter = new CKEDITOR.htmlParser.filter();\n\n\t\t/**\n\t\t * The HTML writer used by this data processor to format the output.\n\t\t *\n\t\t * @property {CKEDITOR.htmlParser.basicWriter}\n\t\t */\n\t\tthis.writer = new CKEDITOR.htmlParser.basicWriter();\n\n\t\tdataFilter.addRules( defaultDataFilterRulesEditableOnly );\n\t\tdataFilter.addRules( defaultDataFilterRulesForAll, { applyToAll: true } );\n\t\tdataFilter.addRules( createBogusAndFillerRules( editor, 'data' ), { applyToAll: true } );\n\t\thtmlFilter.addRules( defaultHtmlFilterRulesEditableOnly );\n\t\thtmlFilter.addRules( defaultHtmlFilterRulesForAll, { applyToAll: true } );\n\t\thtmlFilter.addRules( createBogusAndFillerRules( editor, 'html' ), { applyToAll: true } );\n\n\t\teditor.on( 'toHtml', function( evt ) {\n\t\t\tvar evtData = evt.data,\n\t\t\t\tdata = evtData.dataValue,\n\t\t\t\tfixBodyTag;\n\n\t\t\t// Before we start protecting markup, make sure there are no externally injected\n\t\t\t// protection keywords.\n\t\t\tdata = removeReservedKeywords( data );\n\n\t\t\t// The source data is already HTML, but we need to clean\n\t\t\t// it up and apply the filter.\n\t\t\tdata = protectSource( data, editor );\n\n\t\t\t// Protect content of textareas. (https://dev.ckeditor.com/ticket/9995)\n\t\t\t// Do this before protecting attributes to avoid breaking:\n\t\t\t// <textarea><img src=\"...\" /></textarea>\n\t\t\tdata = protectElements( data, protectTextareaRegex );\n\n\t\t\t// Before anything, we must protect the URL attributes as the\n\t\t\t// browser may changing them when setting the innerHTML later in\n\t\t\t// the code.\n\t\t\tdata = protectAttributes( data );\n\n\t\t\t// Protect elements than can't be set inside a DIV. E.g. IE removes\n\t\t\t// style tags from innerHTML. (https://dev.ckeditor.com/ticket/3710)\n\t\t\tdata = protectElements( data, protectElementsRegex );\n\n\t\t\t// Certain elements has problem to go through DOM operation, protect\n\t\t\t// them by prefixing 'cke' namespace. (https://dev.ckeditor.com/ticket/3591)\n\t\t\tdata = protectElementsNames( data );\n\n\t\t\t// All none-IE browsers ignore self-closed custom elements,\n\t\t\t// protecting them into open-close. (https://dev.ckeditor.com/ticket/3591)\n\t\t\tdata = protectSelfClosingElements( data );\n\n\t\t\t// Compensate one leading line break after <pre> open as browsers\n\t\t\t// eat it up. (https://dev.ckeditor.com/ticket/5789)\n\t\t\tdata = protectPreFormatted( data );\n\n\t\t\t// There are attributes which may execute JavaScript code inside fixBin.\n\t\t\t// Encode them greedily. They will be unprotected right after getting HTML from fixBin. (https://dev.ckeditor.com/ticket/10)\n\t\t\tdata = protectInsecureAttributes( data );\n\n\t\t\tvar fixBin = evtData.context || editor.editable().getName(),\n\t\t\t\tisPre;\n\n\t\t\t// Old IEs loose formats when load html into <pre>.\n\t\t\tif ( CKEDITOR.env.ie && CKEDITOR.env.version < 9 && fixBin == 'pre' ) {\n\t\t\t\tfixBin = 'div';\n\t\t\t\tdata = '<pre>' + data + '</pre>';\n\t\t\t\tisPre = 1;\n\t\t\t}\n\n\t\t\t// Call the browser to help us fixing a possibly invalid HTML\n\t\t\t// structure.\n\t\t\tvar el = editor.document.createElement( fixBin );\n\t\t\t// Add fake character to workaround IE comments bug. (https://dev.ckeditor.com/ticket/3801)\n\t\t\tel.setHtml( 'a' + data );\n\t\t\tdata = el.getHtml().substr( 1 );\n\n\t\t\t// Restore shortly protected attribute names.\n\t\t\tdata = data.replace( new RegExp( 'data-cke-' + CKEDITOR.rnd + '-', 'ig' ), '' );\n\n\t\t\tisPre && ( data = data.replace( /^<pre>|<\\/pre>$/gi, '' ) );\n\n\t\t\t// Unprotect \"some\" of the protected elements at this point.\n\t\t\tdata = unprotectElementNames( data );\n\n\t\t\tdata = unprotectElements( data );\n\n\t\t\t// Restore the comments that have been protected, in this way they\n\t\t\t// can be properly filtered.\n\t\t\tdata = unprotectRealComments( data );\n\n\t\t\tif ( evtData.fixForBody === false ) {\n\t\t\t\tfixBodyTag = false;\n\t\t\t} else {\n\t\t\t\tfixBodyTag = getFixBodyTag( evtData.enterMode, editor.config.autoParagraph );\n\t\t\t}\n\n\t\t\t// Now use our parser to make further fixes to the structure, as\n\t\t\t// well as apply the filter.\n\t\t\tdata = CKEDITOR.htmlParser.fragment.fromHtml( data, evtData.context, fixBodyTag );\n\n\t\t\t// The empty root element needs to be fixed by adding 'p' or 'div' into it.\n\t\t\t// This avoids the need to create that element on the first focus (https://dev.ckeditor.com/ticket/12630).\n\t\t\tif ( fixBodyTag ) {\n\t\t\t\tfixEmptyRoot( data, fixBodyTag );\n\t\t\t}\n\n\t\t\tevtData.dataValue = data;\n\t\t}, null, null, 5 );\n\n\t\t// Filter incoming \"data\".\n\t\t// Add element filter before htmlDataProcessor.dataFilter when purifying input data to correct html.\n\t\teditor.on( 'toHtml', function( evt ) {\n\t\t\tif ( evt.data.filter.applyTo( evt.data.dataValue, true, evt.data.dontFilter, evt.data.enterMode ) )\n\t\t\t\teditor.fire( 'dataFiltered' );\n\t\t}, null, null, 6 );\n\n\t\teditor.on( 'toHtml', function( evt ) {\n\t\t\tevt.data.dataValue.filterChildren( that.dataFilter, true );\n\t\t}, null, null, 10 );\n\n\t\teditor.on( 'toHtml', function( evt ) {\n\t\t\tvar evtData = evt.data,\n\t\t\t\tdata = evtData.dataValue,\n\t\t\t\twriter = new CKEDITOR.htmlParser.basicWriter();\n\n\t\t\tdata.writeChildrenHtml( writer );\n\t\t\tdata = writer.getHtml( true );\n\n\t\t\t// Protect the real comments again.\n\t\t\tevtData.dataValue = protectRealComments( data );\n\t\t}, null, null, 15 );\n\n\n\t\teditor.on( 'toDataFormat', function( evt ) {\n\t\t\tvar data = evt.data.dataValue;\n\n\t\t\t// https://dev.ckeditor.com/ticket/10854 - we need to strip leading blockless <br> which FF adds\n\t\t\t// automatically when editable contains only non-editable content.\n\t\t\t// We do that for every browser (so it's a constant behavior) and\n\t\t\t// not in BR mode, in which chance of valid leading blockless <br> is higher.\n\t\t\tif ( evt.data.enterMode != CKEDITOR.ENTER_BR )\n\t\t\t\tdata = data.replace( /^<br *\\/?>/i, '' );\n\n\t\t\tevt.data.dataValue = CKEDITOR.htmlParser.fragment.fromHtml(\n\t\t\t\tdata, evt.data.context, getFixBodyTag( evt.data.enterMode, editor.config.autoParagraph ) );\n\t\t}, null, null, 5 );\n\n\t\teditor.on( 'toDataFormat', function( evt ) {\n\t\t\tevt.data.dataValue.filterChildren( that.htmlFilter, true );\n\t\t}, null, null, 10 );\n\n\t\t// Transform outcoming \"data\".\n\t\t// Add element filter after htmlDataProcessor.htmlFilter when preparing output data HTML.\n\t\teditor.on( 'toDataFormat', function( evt ) {\n\t\t\tevt.data.filter.applyTo( evt.data.dataValue, false, true );\n\t\t}, null, null, 11 );\n\n\t\teditor.on( 'toDataFormat', function( evt ) {\n\t\t\tvar data = evt.data.dataValue,\n\t\t\t\twriter = that.writer;\n\n\t\t\twriter.reset();\n\t\t\tdata.writeChildrenHtml( writer );\n\t\t\tdata = writer.getHtml( true );\n\n\t\t\t// Restore those non-HTML protected source. (https://dev.ckeditor.com/ticket/4475,https://dev.ckeditor.com/ticket/4880)\n\t\t\tdata = unprotectRealComments( data );\n\t\t\tdata = unprotectSource( data, editor );\n\n\t\t\tevt.data.dataValue = data;\n\t\t}, null, null, 15 );\n\t};\n\n\tCKEDITOR.htmlDataProcessor.prototype = {\n\t\t/**\n\t\t * Processes the (potentially malformed) input HTML to a purified form which\n\t\t * is suitable for using in the WYSIWYG editable.\n\t\t *\n\t\t * This method fires the {@link CKEDITOR.editor#toHtml} event which makes it possible\n\t\t * to hook into the process at various stages.\n\t\t *\n\t\t * **Note:** Since CKEditor 4.3.0 the signature of this method changed and all options\n\t\t * are now grouped in one `options` object. Previously `context`, `fixForBody` and `dontFilter`\n\t\t * were passed separately.\n\t\t *\n\t\t * @param {String} data The raw data.\n\t\t * @param {Object} [options] The options object.\n\t\t * @param {String} [options.context] The tag name of a context element within which\n\t\t * the input is to be processed, defaults to the editable element.\n\t\t * If `null` is passed, then data will be parsed without context (as children of {@link CKEDITOR.htmlParser.fragment}).\n\t\t * See {@link CKEDITOR.htmlParser.fragment#fromHtml} for more details.\n\t\t * @param {Boolean} [options.fixForBody=true] Whether to trigger the auto paragraph for non-block content.\n\t\t * @param {CKEDITOR.filter} [options.filter] When specified, instead of using the {@link CKEDITOR.editor#filter main filter},\n\t\t * the passed instance will be used to filter the content.\n\t\t * @param {Boolean} [options.dontFilter] Do not filter data with {@link CKEDITOR.filter} (note: transformations\n\t\t * will still be applied).\n\t\t * @param {Number} [options.enterMode] When specified, it will be used instead of the {@link CKEDITOR.editor#enterMode main enterMode}.\n\t\t * @param {Boolean} [options.protectedWhitespaces] Indicates that content was wrapped with `<span>` elements to preserve\n\t\t * leading and trailing whitespaces. Option used by the {@link CKEDITOR.editor#method-insertHtml} method.\n\t\t * @returns {String}\n\t\t */\n\t\ttoHtml: function( data, options, fixForBody, dontFilter ) {\n\t\t\tvar editor = this.editor,\n\t\t\t\tcontext, filter, enterMode, protectedWhitespaces;\n\n\t\t\t// Typeof null == 'object', so check truthiness of options too.\n\t\t\tif ( options && typeof options == 'object' ) {\n\t\t\t\tcontext = options.context;\n\t\t\t\tfixForBody = options.fixForBody;\n\t\t\t\tdontFilter = options.dontFilter;\n\t\t\t\tfilter = options.filter;\n\t\t\t\tenterMode = options.enterMode;\n\t\t\t\tprotectedWhitespaces = options.protectedWhitespaces;\n\t\t\t}\n\t\t\t// Backward compatibility. Since CKEDITOR 4.3.0 every option was a separate argument.\n\t\t\telse {\n\t\t\t\tcontext = options;\n\t\t\t}\n\n\t\t\t// Fall back to the editable as context if not specified.\n\t\t\tif ( !context && context !== null )\n\t\t\t\tcontext = editor.editable().getName();\n\n\t\t\treturn editor.fire( 'toHtml', {\n\t\t\t\tdataValue: data,\n\t\t\t\tcontext: context,\n\t\t\t\tfixForBody: fixForBody,\n\t\t\t\tdontFilter: dontFilter,\n\t\t\t\tfilter: filter || editor.filter,\n\t\t\t\tenterMode: enterMode || editor.enterMode,\n\t\t\t\tprotectedWhitespaces: protectedWhitespaces\n\t\t\t} ).dataValue;\n\t\t},\n\n\t\t/**\n\t\t * See {@link CKEDITOR.dataProcessor#toDataFormat}.\n\t\t *\n\t\t * This method fires the {@link CKEDITOR.editor#toDataFormat} event which makes it possible\n\t\t * to hook into the process at various stages.\n\t\t *\n\t\t * @param {String} html\n\t\t * @param {Object} [options] The options object.\n\t\t * @param {String} [options.context] The tag name of the context element within which\n\t\t * the input is to be processed, defaults to the editable element.\n\t\t * @param {CKEDITOR.filter} [options.filter] When specified, instead of using the {@link CKEDITOR.editor#filter main filter},\n\t\t * the passed instance will be used to apply content transformations to the content.\n\t\t * @param {Number} [options.enterMode] When specified, it will be used instead of the {@link CKEDITOR.editor#enterMode main enterMode}.\n\t\t * @returns {String}\n\t\t */\n\t\ttoDataFormat: function( html, options ) {\n\t\t\tvar context, filter, enterMode;\n\n\t\t\t// Do not shorten this to `options && options.xxx`, because\n\t\t\t// falsy `options` will be passed instead of undefined.\n\t\t\tif ( options ) {\n\t\t\t\tcontext = options.context;\n\t\t\t\tfilter = options.filter;\n\t\t\t\tenterMode = options.enterMode;\n\t\t\t}\n\n\t\t\t// Fall back to the editable as context if not specified.\n\t\t\tif ( !context && context !== null )\n\t\t\t\tcontext = this.editor.editable().getName();\n\n\t\t\treturn this.editor.fire( 'toDataFormat', {\n\t\t\t\tdataValue: html,\n\t\t\t\tfilter: filter || this.editor.filter,\n\t\t\t\tcontext: context,\n\t\t\t\tenterMode: enterMode || this.editor.enterMode\n\t\t\t} ).dataValue;\n\t\t},\n\n\t\t/**\n\t\t * @since 4.16.1\n\t\t * @private\n\t\t * @param {String} data\n\t\t */\n\t\tprotectSource: function( data ) {\n\t\t\treturn protectSource( data, this.editor );\n\t\t},\n\n\t\t/**\n\t\t * @since 4.16.1\n\t\t * @private\n\t\t * @param {String} html\n\t\t */\n\t\tunprotectSource: function( html ) {\n\t\t\treturn unprotectSource( html, this.editor );\n\t\t},\n\n\t\t/**\n\t\t * @since 4.16.2\n\t\t * @private\n\t\t * @param {String} html\n\t\t */\n\t\tunprotectRealComments: function( html ) {\n\t\t\treturn unprotectRealComments( html );\n\t\t}\n\t};\n\n\t// Produce a set of filtering rules that handles bogus and filler node at the\n\t// end of block/pseudo block, in the following consequence:\n\t// 1. elements:<block> - this filter removes any bogus node, then check\n\t// if it's an empty block that requires a filler.\n\t// 2. elements:<br> - After cleaned with bogus, this filter checks the real\n\t// line-break BR to compensate a filler after it.\n\t//\n\t// Terms definitions:\n\t// filler: An element that's either <BR> or &NBSP; at the end of block that established line height.\n\t// bogus: Whenever a filler is proceeded with inline content, it becomes a bogus which is subjected to be removed.\n\t//\n\t// Various forms of the filler:\n\t// In output HTML: Filler should be consistently &NBSP; <BR> at the end of block is always considered as bogus.\n\t// In Wysiwyg HTML: Browser dependent - see env.needsBrFiller. Either BR for when needsBrFiller is true, or &NBSP; otherwise.\n\t// <BR> is NEVER considered as bogus when needsBrFiller is true.\n\tfunction createBogusAndFillerRules( editor, type ) {\n\t\tfunction createFiller( isOutput ) {\n\t\t\treturn isOutput || CKEDITOR.env.needsNbspFiller ?\n\t\t\t\tnew CKEDITOR.htmlParser.text( '\\xa0' ) :\n\t\t\t\tnew CKEDITOR.htmlParser.element( 'br', { 'data-cke-bogus': 1 } );\n\t\t}\n\n\t\t// This text block filter, remove any bogus and create the filler on demand.\n\t\tfunction blockFilter( isOutput, fillEmptyBlock ) {\n\n\t\t\treturn function( block ) {\n\t\t\t\t// DO NOT apply the filler if it's a fragment node.\n\t\t\t\tif ( block.type == CKEDITOR.NODE_DOCUMENT_FRAGMENT )\n\t\t\t\t\treturn;\n\n\t\t\t\tcleanBogus( block );\n\n\t\t\t\t// Add fillers to input (always) and to output (if fillEmptyBlock is ok with that).\n\t\t\t\tvar shouldFillBlock = !isOutput ||\n\t\t\t\t\t( typeof fillEmptyBlock == 'function' ? fillEmptyBlock( block ) : fillEmptyBlock ) !== false;\n\n\t\t\t\tif ( shouldFillBlock && isEmptyBlockNeedFiller( block ) ) {\n\t\t\t\t\tblock.add( createFiller( isOutput ) );\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t// Append a filler right after the last line-break BR, found at the end of block.\n\t\tfunction brFilter( isOutput ) {\n\t\t\treturn function( br ) {\n\t\t\t\t// DO NOT apply the filer if parent's a fragment node.\n\t\t\t\tif ( br.parent.type == CKEDITOR.NODE_DOCUMENT_FRAGMENT )\n\t\t\t\t\treturn;\n\n\t\t\t\tvar attrs = br.attributes;\n\t\t\t\t// Dismiss BRs that are either bogus or eol marker.\n\t\t\t\tif ( 'data-cke-bogus' in attrs || 'data-cke-eol' in attrs ) {\n\t\t\t\t\tdelete attrs [ 'data-cke-bogus' ];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Judge the tail line-break BR, and to insert bogus after it.\n\t\t\t\tvar next = getNext( br ), previous = getPrevious( br );\n\n\t\t\t\tif ( !next && isBlockBoundary( br.parent ) )\n\t\t\t\t\tappend( br.parent, createFiller( isOutput ) );\n\t\t\t\telse if ( isBlockBoundary( next ) && previous && !isBlockBoundary( previous ) )\n\t\t\t\t\tcreateFiller( isOutput ).insertBefore( next );\n\t\t\t};\n\t\t}\n\n\t\t// Determinate whether this node is potentially a bogus node.\n\t\tfunction maybeBogus( node, atBlockEnd ) {\n\n\t\t\t// BR that's not from IE<11 DOM, except for a EOL marker.\n\t\t\tif ( !( isOutput && !CKEDITOR.env.needsBrFiller ) &&\n\t\t\t\t\tnode.type == CKEDITOR.NODE_ELEMENT && node.name == 'br' &&\n\t\t\t\t\t!node.attributes[ 'data-cke-eol' ] ) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tvar match;\n\n\t\t\t// NBSP, possibly.\n\t\t\tif ( node.type == CKEDITOR.NODE_TEXT && ( match = node.value.match( tailNbspRegex ) ) ) {\n\t\t\t\t// We need to separate tail NBSP out of a text node, for later removal.\n\t\t\t\tif ( match.index ) {\n\t\t\t\t\t( new CKEDITOR.htmlParser.text( node.value.substring( 0, match.index ) ) ).insertBefore( node );\n\t\t\t\t\tnode.value = match[ 0 ];\n\t\t\t\t}\n\n\t\t\t\t// From IE<11 DOM, at the end of a text block, or before block boundary.\n\t\t\t\tif ( !CKEDITOR.env.needsBrFiller && isOutput && ( !atBlockEnd || node.parent.name in textBlockTags ) )\n\t\t\t\t\treturn true;\n\n\t\t\t\t// From the output.\n\t\t\t\tif ( !isOutput ) {\n\t\t\t\t\tvar previous = node.previous;\n\n\t\t\t\t\t// Following a line-break at the end of block.\n\t\t\t\t\tif ( previous && previous.name == 'br' )\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t// Or a single NBSP between two blocks.\n\t\t\t\t\tif ( !previous || isBlockBoundary( previous ) )\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\t// Removes all bogus inside of this block, and to convert fillers into the proper form.\n\t\tfunction cleanBogus( block ) {\n\t\t\tvar bogus = [];\n\t\t\tvar last = getLast( block ), node, previous;\n\n\t\t\tif ( last ) {\n\t\t\t\t// Check for bogus at the end of this block.\n\t\t\t\t// e.g. <p>foo<br /></p>\n\t\t\t\tmaybeBogus( last, 1 ) && bogus.push( last );\n\n\t\t\t\twhile ( last ) {\n\t\t\t\t\t// Check for bogus at the end of any pseudo block contained.\n\t\t\t\t\tif ( isBlockBoundary( last ) && ( node = getPrevious( last ) ) && maybeBogus( node ) ) {\n\t\t\t\t\t\t// Bogus must have inline proceeding, instead single BR between two blocks,\n\t\t\t\t\t\t// is considered as filler, e.g. <hr /><br /><hr />\n\t\t\t\t\t\tif ( ( previous = getPrevious( node ) ) && !isBlockBoundary( previous ) )\n\t\t\t\t\t\t\tbogus.push( node );\n\t\t\t\t\t\t// Convert the filler into appropriate form.\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcreateFiller( isOutput ).insertAfter( node );\n\t\t\t\t\t\t\tnode.remove();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlast = last.previous;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Now remove all bogus collected from above.\n\t\t\tfor ( var i = 0 ; i < bogus.length ; i++ )\n\t\t\t\tbogus[ i ].remove();\n\t\t}\n\n\t\t// Judge whether it's an empty block that requires a filler node.\n\t\tfunction isEmptyBlockNeedFiller( block ) {\n\n\t\t\t// DO NOT fill empty editable in IE<11.\n\t\t\tif ( !isOutput && !CKEDITOR.env.needsBrFiller && block.type == CKEDITOR.NODE_DOCUMENT_FRAGMENT )\n\t\t\t\treturn false;\n\n\t\t\t// 1. For IE version >=8,  empty blocks are displayed correctly themself in wysiwiyg;\n\t\t\t// 2. For the rest, at least table cell and list item need no filler space. (https://dev.ckeditor.com/ticket/6248)\n\t\t\tif ( !isOutput && !CKEDITOR.env.needsBrFiller &&\n\t\t\t\t( document.documentMode > 7 ||\n\t\t\t\t\tblock.name in CKEDITOR.dtd.tr ||\n\t\t\t\t\tblock.name in CKEDITOR.dtd.$listItem ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar last = getLast( block );\n\t\t\treturn !last || block.name == 'form' && last.name == 'input' ;\n\t\t}\n\n\t\tvar rules = { elements: {} },\n\t\t\tisOutput = type == 'html',\n\t\t\ttextBlockTags = CKEDITOR.tools.extend( {}, blockLikeTags );\n\n\t\t// Build the list of text blocks.\n\t\tfor ( var i in textBlockTags ) {\n\t\t\tif ( !( '#' in dtd[ i ] ) )\n\t\t\t\tdelete textBlockTags[ i ];\n\t\t}\n\n\t\tfor ( i in textBlockTags )\n\t\t\trules.elements[ i ] = blockFilter( isOutput, editor.config.fillEmptyBlocks );\n\n\t\t// Editable element has to be checked separately.\n\t\trules.root = blockFilter( isOutput, false );\n\t\trules.elements.br = brFilter( isOutput );\n\t\treturn rules;\n\t}\n\n\tfunction getFixBodyTag( enterMode, autoParagraph ) {\n\t\treturn ( enterMode != CKEDITOR.ENTER_BR && autoParagraph !== false ) ? enterMode == CKEDITOR.ENTER_DIV ? 'div' : 'p' : false;\n\t}\n\n\t// Regex to scan for &nbsp; at the end of blocks, which are actually placeholders.\n\t// Safari transforms the &nbsp; to \\xa0. (https://dev.ckeditor.com/ticket/4172)\n\tvar tailNbspRegex = /(?:&nbsp;|\\xa0)$/;\n\n\tvar protectedSourceMarker = '{cke_protected}';\n\n\tfunction getLast( node ) {\n\t\tvar last = node.children[ node.children.length - 1 ];\n\t\twhile ( last && isEmpty( last ) )\n\t\t\tlast = last.previous;\n\t\treturn last;\n\t}\n\n\tfunction getNext( node ) {\n\t\tvar next = node.next;\n\t\twhile ( next && isEmpty( next ) )\n\t\t\tnext = next.next;\n\t\treturn next;\n\t}\n\n\tfunction getPrevious( node ) {\n\t\tvar previous = node.previous;\n\t\twhile ( previous && isEmpty( previous ) )\n\t\t\tprevious = previous.previous;\n\t\treturn previous;\n\t}\n\n\t// Judge whether the node is an ghost node to be ignored, when traversing.\n\tfunction isEmpty( node ) {\n\t\treturn node.type == CKEDITOR.NODE_TEXT &&\n\t\t\t!CKEDITOR.tools.trim( node.value ) ||\n\t\t\tnode.type == CKEDITOR.NODE_ELEMENT &&\n\t\t\tnode.attributes[ 'data-cke-bookmark' ];\n\t}\n\n\t// Judge whether the node is a block-like element.\n\tfunction isBlockBoundary( node ) {\n\t\treturn node &&\n\t\t\t( node.type == CKEDITOR.NODE_ELEMENT && node.name in blockLikeTags ||\n\t\t\tnode.type == CKEDITOR.NODE_DOCUMENT_FRAGMENT );\n\t}\n\n\tfunction append( parent, node ) {\n\t\tvar last = parent.children[ parent.children.length - 1 ];\n\t\tparent.children.push( node );\n\t\tnode.parent = parent;\n\t\tif ( last ) {\n\t\t\tlast.next = node;\n\t\t\tnode.previous = last;\n\t\t}\n\t}\n\n\tfunction getNodeIndex( node ) {\n\t\treturn node.parent ? node.getIndex() : -1;\n\t}\n\n\tvar dtd = CKEDITOR.dtd,\n\t\t// Define orders of table elements.\n\t\ttableOrder = [ 'caption', 'colgroup', 'col', 'thead', 'tfoot', 'tbody' ],\n\t\t// List of all block elements.\n\t\tblockLikeTags = CKEDITOR.tools.extend( {}, dtd.$blockLimit, dtd.$block );\n\n\t//\n\t// DATA filter rules ------------------------------------------------------\n\t//\n\n\tvar defaultDataFilterRulesEditableOnly = {\n\t\telements: {\n\t\t\tinput: protectReadOnly,\n\t\t\ttextarea: protectReadOnly\n\t\t}\n\t};\n\n\t// These rules will also be applied to non-editable content.\n\tvar defaultDataFilterRulesForAll = {\n\t\tattributeNames: [\n\t\t\t// Event attributes (onXYZ) must not be directly set. They can become\n\t\t\t// active in the editing area (IE|WebKit).\n\t\t\t[ ( /^on/ ), 'data-cke-pa-on' ],\n\n\t\t\t// Prevent iframe's srcdoc attribute from being evaluated in the editable.\n\t\t\t[ ( /^srcdoc/ ), 'data-cke-pa-srcdoc' ],\n\n\t\t\t// Don't let some old expando enter editor. Concerns only IE8,\n\t\t\t// but for consistency remove on all browsers.\n\t\t\t[ ( /^data-cke-expando$/ ), '' ]\n\t\t],\n\n\t\telements: {\n\t\t\t// Prevent iframe's src attribute with javascript code or data protocol from being evaluated in the editable.\n\t\t\tiframe: function( element ) {\n\t\t\t\tif ( element.attributes && element.attributes.src ) {\n\n\t\t\t\t\tvar src = element.attributes.src.toLowerCase().replace( /[^a-z]/gi, '' );\n\t\t\t\t\tif ( src.indexOf( 'javascript' ) === 0 || src.indexOf( 'data' ) === 0 ) {\n\t\t\t\t\t\telement.attributes[ 'data-cke-pa-src' ] = element.attributes.src;\n\t\t\t\t\t\tdelete element.attributes.src;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t// Disable form elements editing mode provided by some browsers. (https://dev.ckeditor.com/ticket/5746)\n\tfunction protectReadOnly( element ) {\n\t\tvar attrs = element.attributes;\n\n\t\t// We should flag that the element was locked by our code so\n\t\t// it'll be editable by the editor functions (https://dev.ckeditor.com/ticket/6046).\n\t\tif ( attrs.contenteditable != 'false' )\n\t\t\tattrs[ 'data-cke-editable' ] = attrs.contenteditable ? 'true' : 1;\n\n\t\tattrs.contenteditable = 'false';\n\t}\n\n\t//\n\t// HTML filter rules ------------------------------------------------------\n\t//\n\n\tvar defaultHtmlFilterRulesEditableOnly = {\n\t\telements: {\n\t\t\tembed: function( element ) {\n\t\t\t\tvar parent = element.parent;\n\n\t\t\t\t// If the <embed> is child of a <object>, copy the width\n\t\t\t\t// and height attributes from it.\n\t\t\t\tif ( parent && parent.name == 'object' ) {\n\t\t\t\t\tvar parentWidth = parent.attributes.width,\n\t\t\t\t\t\tparentHeight = parent.attributes.height;\n\t\t\t\t\tif ( parentWidth )\n\t\t\t\t\t\telement.attributes.width = parentWidth;\n\t\t\t\t\tif ( parentHeight )\n\t\t\t\t\t\telement.attributes.height = parentHeight;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Remove empty link but not empty anchor. (https://dev.ckeditor.com/ticket/3829, https://dev.ckeditor.com/ticket/13516)\n\t\t\ta: function( element ) {\n\t\t\t\tvar attrs = element.attributes;\n\n\t\t\t\tif ( !( element.children.length || attrs.name || attrs.id || element.attributes[ 'data-cke-saved-name' ] ) )\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t};\n\n\t// These rules will also be applied to non-editable content.\n\tvar defaultHtmlFilterRulesForAll = {\n\t\telementNames: [\n\t\t\t// Remove the \"cke:\" namespace prefix.\n\t\t\t[ ( /^cke:/ ), '' ],\n\n\t\t\t// Ignore <?xml:namespace> tags.\n\t\t\t[ ( /^\\?xml:namespace$/ ), '' ]\n\t\t],\n\n\t\tattributeNames: [\n\t\t\t// Attributes saved for changes and protected attributes.\n\t\t\t[ ( /^data-cke-(saved|pa)-/ ), '' ],\n\n\t\t\t// All \"data-cke-\" attributes are to be ignored.\n\t\t\t[ ( /^data-cke-.*/ ), '' ],\n\n\t\t\t[ 'hidefocus', '' ]\n\t\t],\n\n\t\telements: {\n\t\t\t$: function( element ) {\n\t\t\t\tvar attribs = element.attributes;\n\n\t\t\t\tif ( attribs ) {\n\t\t\t\t\t// Elements marked as temporary are to be ignored.\n\t\t\t\t\tif ( attribs[ 'data-cke-temp' ] )\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t// Remove duplicated attributes - https://dev.ckeditor.com/ticket/3789.\n\t\t\t\t\tvar attributeNames = [ 'name', 'href', 'src' ],\n\t\t\t\t\t\tsavedAttributeName;\n\t\t\t\t\tfor ( var i = 0; i < attributeNames.length; i++ ) {\n\t\t\t\t\t\tsavedAttributeName = 'data-cke-saved-' + attributeNames[ i ];\n\t\t\t\t\t\tsavedAttributeName in attribs && ( delete attribs[ attributeNames[ i ] ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn element;\n\t\t\t},\n\n\t\t\t// The contents of table should be in correct order (https://dev.ckeditor.com/ticket/4809).\n\t\t\ttable: function( element ) {\n\t\t\t\t// Clone the array as it would become empty during the sort call.\n\t\t\t\tvar children = element.children.slice( 0 );\n\n\t\t\t\tchildren.sort( function( node1, node2 ) {\n\t\t\t\t\tvar index1, index2;\n\n\t\t\t\t\t// Compare in the predefined order.\n\t\t\t\t\tif ( node1.type == CKEDITOR.NODE_ELEMENT && node2.type == node1.type ) {\n\t\t\t\t\t\tindex1 = CKEDITOR.tools.indexOf( tableOrder, node1.name );\n\t\t\t\t\t\tindex2 = CKEDITOR.tools.indexOf( tableOrder, node2.name );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Make sure the sort is stable, if no order can be established above.\n\t\t\t\t\tif ( !( index1 > -1 && index2 > -1 && index1 != index2 ) ) {\n\t\t\t\t\t\tindex1 = getNodeIndex( node1 );\n\t\t\t\t\t\tindex2 = getNodeIndex( node2 );\n\t\t\t\t\t}\n\n\t\t\t\t\treturn index1 > index2 ? 1 : -1;\n\t\t\t\t} );\n\t\t\t},\n\n\t\t\t// Restore param elements into self-closing.\n\t\t\tparam: function( param ) {\n\t\t\t\tparam.children = [];\n\t\t\t\tparam.isEmpty = true;\n\t\t\t\treturn param;\n\t\t\t},\n\n\t\t\t// Remove dummy span in webkit.\n\t\t\tspan: function( element ) {\n\t\t\t\tif ( element.attributes[ 'class' ] == 'Apple-style-span' )\n\t\t\t\t\tdelete element.name;\n\t\t\t},\n\n\t\t\thtml: function( element ) {\n\t\t\t\tdelete element.attributes.contenteditable;\n\t\t\t\tdelete element.attributes[ 'class' ];\n\t\t\t},\n\n\t\t\tbody: function( element ) {\n\t\t\t\tdelete element.attributes.spellcheck;\n\t\t\t\tdelete element.attributes.contenteditable;\n\t\t\t},\n\n\t\t\tstyle: function( element ) {\n\t\t\t\tvar child = element.children[ 0 ];\n\t\t\t\tif ( child && child.value )\n\t\t\t\t\tchild.value = CKEDITOR.tools.trim( child.value );\n\n\t\t\t\tif ( !element.attributes.type )\n\t\t\t\t\telement.attributes.type = 'text/css';\n\t\t\t},\n\n\t\t\ttitle: function( element ) {\n\t\t\t\tvar titleText = element.children[ 0 ];\n\n\t\t\t\t// Append text-node to title tag if not present (i.e. non-IEs) (https://dev.ckeditor.com/ticket/9882).\n\t\t\t\t!titleText && append( element, titleText = new CKEDITOR.htmlParser.text() );\n\n\t\t\t\t// Transfer data-saved title to title tag.\n\t\t\t\ttitleText.value = element.attributes[ 'data-cke-title' ] || '';\n\t\t\t},\n\n\t\t\tinput: unprotectReadyOnly,\n\t\t\ttextarea: unprotectReadyOnly\n\t\t},\n\n\t\tattributes: {\n\t\t\t'class': function( value ) {\n\t\t\t\t// Remove all class names starting with \"cke_\".\n\t\t\t\treturn CKEDITOR.tools.ltrim( value.replace( /(?:^|\\s+)cke_[^\\s]*/g, '' ) ) || false;\n\t\t\t}\n\t\t}\n\t};\n\n\tif ( CKEDITOR.env.ie ) {\n\t\t// IE outputs style attribute in capital letters. We should convert\n\t\t// them back to lower case, while not hurting the values (https://dev.ckeditor.com/ticket/5930)\n\t\tdefaultHtmlFilterRulesForAll.attributes.style = function( value ) {\n\t\t\treturn value.replace( /(^|;)([^\\:]+)/g, function( match ) {\n\t\t\t\treturn match.toLowerCase();\n\t\t\t} );\n\t\t};\n\t}\n\n\t// Disable form elements editing mode provided by some browsers. (https://dev.ckeditor.com/ticket/5746)\n\tfunction unprotectReadyOnly( element ) {\n\t\tvar attrs = element.attributes;\n\t\tswitch ( attrs[ 'data-cke-editable' ] ) {\n\t\t\tcase 'true':\n\t\t\t\tattrs.contenteditable = 'true';\n\t\t\t\tbreak;\n\t\t\tcase '1':\n\t\t\t\tdelete attrs.contenteditable;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t//\n\t// Preprocessor filters ---------------------------------------------------\n\t//\n\n\tvar protectElementRegex = /<(a|area|img|input|source)\\b([^>]*)>/gi,\n\t\t// Be greedy while looking for protected attributes. This will let us avoid an unfortunate\n\t\t// situation when \"nested attributes\", which may appear valid, are also protected.\n\t\t// I.e. if we consider the following HTML:\n\t\t//\n\t\t// \t<img data-x=\"&lt;a href=&quot;X&quot;\" />\n\t\t//\n\t\t// then the \"non-greedy match\" returns:\n\t\t//\n\t\t// \t'href' => '&quot;X&quot;' // It's wrong! Href is not an attribute of <img>.\n\t\t//\n\t\t// while greedy match returns:\n\t\t//\n\t\t// \t'data-x' => '&lt;a href=&quot;X&quot;'\n\t\t//\n\t\t// which, can be easily filtered out (https://dev.ckeditor.com/ticket/11508).\n\t\tprotectAttributeRegex = /([\\w-:]+)\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|(?:[^ \"'>]+))/gi,\n\t\tprotectAttributeNameRegex = /^(href|src|name)$/i;\n\n\t\t// Note: we use lazy star '*?' to prevent eating everything up to the last occurrence of </style> or </textarea>.\n\tvar protectElementsRegex = /(?:<style(?=[ >])[^>]*>[\\s\\S]*?<\\/style>)|(?:<(:?link|meta|base)[^>]*>)/gi,\n\t\tprotectTextareaRegex = /(<textarea(?=[ >])[^>]*>)([\\s\\S]*?)(?:<\\/textarea>)/gi,\n\t\tencodedElementsRegex = /<cke:encoded>([^<]*)<\\/cke:encoded>/gi;\n\n\t\t// Element name should be followed by space or closing angle bracket '>' to not protect custom tags (#988).\n\tvar protectElementNamesRegex = /(<\\/?)((?:object|embed|param|html|body|head|title)([\\s][^>]*)?>)/gi,\n\t\tunprotectElementNamesRegex = /(<\\/?)cke:((?:html|body|head|title)[^>]*>)/gi;\n\n\tvar protectSelfClosingRegex = /<cke:(param|embed)([^>]*?)\\/?>(?!\\s*<\\/cke:\\1)/gi;\n\n\tfunction protectAttributes( html ) {\n\t\treturn html.replace( protectElementRegex, function( element, tag, attributes ) {\n\t\t\treturn '<' + tag + attributes.replace( protectAttributeRegex, function( fullAttr, attrName ) {\n\t\t\t\t// Avoid corrupting the inline event attributes (https://dev.ckeditor.com/ticket/7243).\n\t\t\t\t// We should not rewrite the existed protected attributes, e.g. clipboard content from editor. (https://dev.ckeditor.com/ticket/5218)\n\t\t\t\tif ( protectAttributeNameRegex.test( attrName ) && attributes.indexOf( 'data-cke-saved-' + attrName ) == -1 )\n\t\t\t\t\treturn ' data-cke-saved-' + fullAttr + ' data-cke-' + CKEDITOR.rnd + '-' + fullAttr;\n\n\t\t\t\treturn fullAttr;\n\t\t\t} ) + '>';\n\t\t} );\n\t}\n\n\tfunction protectElements( html, regex ) {\n\t\treturn html.replace( regex, function( match, tag, content ) {\n\t\t\t// Encode < and > in textarea because this won't be done by a browser, since\n\t\t\t// textarea will be protected during passing data through fix bin.\n\t\t\tif ( match.indexOf( '<textarea' ) === 0 )\n\t\t\t\tmatch = tag + unprotectRealComments( content ).replace( /</g, '&lt;' ).replace( />/g, '&gt;' ) + '</textarea>';\n\n\t\t\treturn '<cke:encoded>' + encodeURIComponent( match ) + '</cke:encoded>';\n\t\t} );\n\t}\n\n\tfunction unprotectElements( html ) {\n\t\treturn html.replace( encodedElementsRegex, function( match, encoded ) {\n\t\t\treturn decodeURIComponent( encoded );\n\t\t} );\n\t}\n\n\tfunction protectElementsNames( html ) {\n\t\treturn html.replace( protectElementNamesRegex, '$1cke:$2' );\n\t}\n\n\tfunction unprotectElementNames( html ) {\n\t\treturn html.replace( unprotectElementNamesRegex, '$1$2' );\n\t}\n\n\tfunction protectSelfClosingElements( html ) {\n\t\treturn html.replace( protectSelfClosingRegex, '<cke:$1$2></cke:$1>' );\n\t}\n\n\tfunction protectPreFormatted( html ) {\n\t\treturn html.replace( /(<pre\\b[^>]*>)(\\r\\n|\\n)/g, '$1$2$2' );\n\t}\n\n\tfunction protectRealComments( html ) {\n\t\treturn html.replace( /<!--(?!{cke_protected})[\\s\\S]+?-->/g, function( match ) {\n\t\t\treturn '<!--' + protectedSourceMarker +\n\t\t\t\t'{C}' +\n\t\t\t\tencodeURIComponent( match ).replace( /--/g, '%2D%2D' ) +\n\t\t\t\t'-->';\n\t\t} );\n\t}\n\n\t// Replace all \"on\\w{3,}\" strings which are not:\n\t// * opening tags - e.g. `<onfoo`,\n\t// * closing tags - e.g. </onfoo> (tested in \"false positive 1\"),\n\t// * part of other attribute - e.g. `data-onfoo` or `fonfoo`.\n\tfunction protectInsecureAttributes( html ) {\n\t\treturn html.replace( /([^a-z0-9<\\-])(on\\w{3,})(?!>)/gi, '$1data-cke-' + CKEDITOR.rnd + '-$2' );\n\t}\n\n\tfunction unprotectRealComments( html ) {\n\t\treturn html.replace( /<!--\\{cke_protected\\}\\{C\\}([\\s\\S]+?)-->/g, function( match, data ) {\n\t\t\treturn decodeURIComponent( data );\n\t\t} );\n\t}\n\n\tfunction unprotectSource( html, editor ) {\n\t\tvar store = editor._.dataStore;\n\n\t\treturn html.replace( /<!--\\{cke_protected\\}([\\s\\S]+?)-->/g, function( match, data ) {\n\t\t\treturn decodeURIComponent( data );\n\t\t} ).replace( /\\{cke_protected_(\\d+)\\}/g, function( match, id ) {\n\t\t\treturn store && store[ id ] || '';\n\t\t} );\n\t}\n\n\tfunction protectSource( data, editor ) {\n\t\tvar protectedHtml = [],\n\t\t\tprotectRegexes = editor.config.protectedSource,\n\t\t\tstore = editor._.dataStore || ( editor._.dataStore = { id: 1 } ),\n\t\t\ttempRegex = /<\\!--\\{cke_temp(comment)?\\}(\\d*?)-->/g;\n\n\t\tvar regexes = [\n\t\t\t// Script tags will also be forced to be protected, otherwise\n\t\t\t// IE will execute them.\n\t\t\t( /<script[\\s\\S]*?(<\\/script>|$)/gi ),\n\n\t\t\t// <noscript> tags (get lost in IE and messed up in FF).\n\t\t\t/<noscript[\\s\\S]*?<\\/noscript>/gi,\n\n\t\t\t// Avoid meta tags being stripped (https://dev.ckeditor.com/ticket/8117).\n\t\t\t/<meta[\\s\\S]*?\\/?>/gi\n\t\t].concat( protectRegexes );\n\n\t\t// First of any other protection, we must protect all comments\n\t\t// to avoid loosing them (of course, IE related).\n\t\t// Note that we use a different tag for comments, as we need to\n\t\t// transform them when applying filters.\n\t\tdata = data.replace( ( /<!--[\\s\\S]*?-->/g ), function( match ) {\n\t\t\treturn '<!--{cke_tempcomment}' + ( protectedHtml.push( match ) - 1 ) + '-->';\n\t\t} );\n\n\t\tfor ( var i = 0; i < regexes.length; i++ ) {\n\t\t\tdata = data.replace( regexes[ i ], function( match ) {\n\t\t\t\tmatch = match.replace( tempRegex, // There could be protected source inside another one. (https://dev.ckeditor.com/ticket/3869).\n\t\t\t\tfunction( $, isComment, id ) {\n\t\t\t\t\treturn protectedHtml[ id ];\n\t\t\t\t} );\n\n\t\t\t\t// Avoid protecting over protected, e.g. /\\{.*?\\}/\n\t\t\t\treturn ( /cke_temp(comment)?/ ).test( match ) ? match : '<!--{cke_temp}' + ( protectedHtml.push( match ) - 1 ) + '-->';\n\t\t\t} );\n\t\t}\n\t\tdata = data.replace( tempRegex, function( $, isComment, id ) {\n\t\t\treturn '<!--' + protectedSourceMarker +\n\t\t\t\t( isComment ? '{C}' : '' ) +\n\t\t\t\tencodeURIComponent( protectedHtml[ id ] ).replace( /--/g, '%2D%2D' ) +\n\t\t\t\t'-->';\n\t\t} );\n\n\t\t// Different protection pattern is used for those that\n\t\t// live in attributes to avoid from being HTML encoded.\n\t\t// Why so serious? See https://dev.ckeditor.com/ticket/9205, https://dev.ckeditor.com/ticket/8216, https://dev.ckeditor.com/ticket/7805,\n\t\t// https://dev.ckeditor.com/ticket/11754, https://dev.ckeditor.com/ticket/11846.\n\t\tdata = data.replace( /<\\w+(?:\\s+(?:(?:[^\\s=>]+\\s*=\\s*(?:[^'\"\\s>]+|'[^']*'|\"[^\"]*\"))|[^\\s=\\/>]+))+\\s*\\/?>/g, function( match ) {\n\t\t\treturn match.replace( /<!--\\{cke_protected\\}([^>]*)-->/g, function( match, data ) {\n\t\t\t\tstore[ store.id ] = decodeURIComponent( data );\n\t\t\t\treturn '{cke_protected_' + ( store.id++ ) + '}';\n\t\t\t} );\n\t\t} );\n\n\t\t// This RegExp searches for innerText in all the title/iframe/textarea elements.\n\t\t// This is because browser doesn't allow HTML in these elements, that's why we can't\n\t\t// nest comments in there. (https://dev.ckeditor.com/ticket/11223)\n\t\tdata = data.replace( /<(title|iframe|textarea)([^>]*)>([\\s\\S]*?)<\\/\\1>/g, function( match, tagName, tagAttributes, innerText ) {\n\t\t\treturn '<' + tagName + tagAttributes + '>' + unprotectSource( unprotectRealComments( innerText ), editor ) + '</' + tagName + '>';\n\t\t} );\n\n\t\treturn data;\n\t}\n\n\t// Creates a block if the root element is empty.\n\tfunction fixEmptyRoot( root, fixBodyTag ) {\n\t\tif ( !root.children.length && CKEDITOR.dtd[ root.name ][ fixBodyTag ] ) {\n\t\t\tvar fixBodyElement = new CKEDITOR.htmlParser.element( fixBodyTag );\n\t\t\troot.add( fixBodyElement );\n\t\t}\n\t}\n\n\t// Removes reserved htmldataprocessor keywords ensuring that they are only used internally.\n\t// This function produces very complicated regex code. Using IIFE ensures that the regex\n\t// is build only once for this module.\n\tremoveReservedKeywords = ( function() {\n\t\tvar regexes = [\n\t\t\tcreateEncodedKeywordRegex(),\n\t\t\tcreateSourceKeywordRegex(),\n\t\t\tcreateIncorrectCommentRegex()\n\t\t];\n\n\t\treturn function( data ) {\n\t\t\twhile( isContentMatchingAnyPattern( regexes, data ) ) {\n\t\t\t\tdata = removeMatchingContent( regexes, data );\n\t\t\t}\n\n\t\t\treturn data;\n\t\t};\n\n\t\tfunction isContentMatchingAnyPattern( regexes, data ) {\n\t\t\tfor ( var i = 0; i < regexes.length; i++ ) {\n\t\t\t\tvar regex = regexes[ i ];\n\n\t\t\t\tregex.lastIndex = 0;\n\n\t\t\t\tif ( regex.test( data ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction removeMatchingContent( regexes, data ) {\n\t\t\tfor ( var i = 0; i < regexes.length; i++ ) {\n\t\t\t\tdata = data.replace( regexes[ i ], '' );\n\t\t\t}\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction createIncorrectCommentRegex() {\n\t\t\treturn /<!(?:\\s*-\\s*){2,3}!?\\s*>/g;\n\t\t}\n\n\t\t// Produces regex matching `cke:encoded` element.\n\t\tfunction createEncodedKeywordRegex() {\n\t\t\treturn new RegExp( '(' +\n\t\t\t\t// Create closed element regex i.e `<cke:encoded>xxx</cke:encoded>`.\n\t\t\t\tcreateEncodedRegex( '<cke:encoded>' ) +\n\t\t\t\t'(.*?)' +\n\t\t\t\tcreateEncodedRegex( '</cke:encoded>' ) +\n\t\t\t\t')|(' +\n\t\t\t\t// Create unclosed element regex i.e `<cke:encoded>xxx` or `xxx</cke:encoded>` to make sure that\n\t\t\t\t// element won't be closed by HTML parser and matched by `unprotectElements` function.\n\t\t\t\tcreateEncodedRegex( '<' ) +\n\t\t\t\tcreateEncodedRegex( '/' ) + '?' +\n\t\t\t\tcreateEncodedRegex( 'cke:encoded>' ) +\n\t\t\t\t')', 'gi' );\n\t\t}\n\n\t\t// Produces regex matching `{cke_protected}` and `{cke_protected_id}` keywords.\n\t\tfunction createSourceKeywordRegex() {\n\t\t\treturn new RegExp( '((' +\n\t\t\t\tcreateEncodedRegex( '{cke_protected' ) +\n\t\t\t\t')(_[0-9]*)?' +\n\t\t\t\tcreateEncodedRegex( '}' ) +\n\t\t\t\t')' , 'gi' );\n\t\t}\n\n\t\tfunction createEncodedRegex( str ) {\n\t\t\treturn CKEDITOR.tools.array.reduce( str.split( '' ), function( cur, character ) {\n\t\t\t\t// Produce case insensitive regex. `i` flag is not enough thus code entities differs\n\t\t\t\t// depending on case sensitivity.\n\t\t\t\tvar lowerCase = character.toLowerCase(),\n\t\t\t\t\tupperCase = character.toUpperCase(),\n\t\t\t\t\tregex = createCharacterEncodedRegex( lowerCase );\n\n\t\t\t\tif ( lowerCase !== upperCase ) {\n\t\t\t\t\tregex += '|' + createCharacterEncodedRegex( upperCase );\n\t\t\t\t}\n\n\t\t\t\tcur += '(' + regex + ')';\n\n\t\t\t\treturn cur;\n\t\t\t}, '' );\n\t\t}\n\n\t\tfunction createCharacterEncodedRegex( character ) {\n\t\t\tvar map = getCharRegexMap( character ),\n\t\t\t\tcharRegex = character;\n\n\t\t\tfor ( var code in map ) {\n\t\t\t\tif ( map[ code ] ) {\n\t\t\t\t\tcharRegex += '|' + map[ code ];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn charRegex;\n\t\t}\n\n\t\tfunction getCharRegexMap( character ) {\n\t\t\tvar entities = {\n\t\t\t\t'<': '&lt;',\n\t\t\t\t'>': '&gt;',\n\t\t\t\t':': '&colon;'\n\t\t\t},\n\t\t\t\tcharCode = character.charCodeAt( 0 ),\n\t\t\t\thex = charCode.toString( 16 );\n\n\t\t\treturn {\n\t\t\t\t// `;` is optional and HTML parser is able to recognize codes without it.\n\t\t\t\thtmlCode: '&#' + charCode + ';?',\n\t\t\t\t// Hexadecimal value is valid despite leading zero padding e.g. `&#x0065` === `&#x65`.\n\t\t\t\thex: '&#x0*' + hex + ';?',\n\t\t\t\tentity: entities[ character ]\n\t\t\t};\n\t\t}\n\t} )();\n} )();\n\n/**\n * Whether a filler text (non-breaking space entity &mdash; `&nbsp;`) will be\n * inserted into empty block elements in HTML output.\n * This is used to render block elements properly with `line-height`.\n * When a function is specified instead, it will be passed a {@link CKEDITOR.htmlParser.element}\n * to decide whether adding the filler text by expecting a Boolean return value.\n *\n *\t\tconfig.fillEmptyBlocks = false; // Prevent filler nodes in all empty blocks.\n *\n *\t\t// Prevent filler node only in float cleaners.\n *\t\tconfig.fillEmptyBlocks = function( element ) {\n *\t\t\tif ( element.attributes[ 'class' ].indexOf( 'clear-both' ) != -1 )\n *\t\t\t\treturn false;\n *\t\t};\n *\n * @since 3.5.0\n * @cfg {Boolean/Function} [fillEmptyBlocks=true]\n * @member CKEDITOR.config\n */\n\n/**\n * This event is fired by the {@link CKEDITOR.htmlDataProcessor} when input HTML\n * is to be purified by the {@link CKEDITOR.htmlDataProcessor#toHtml} method.\n *\n * By adding listeners with different priorities it is possible\n * to process input HTML on different stages:\n *\n *\t* 1-4: Data is available in the original string format.\n *\t* 5: Data is initially filtered with regexp patterns and parsed to\n *\t\t{@link CKEDITOR.htmlParser.fragment} {@link CKEDITOR.htmlParser.element}.\n *\t* 5-9: Data is available in the parsed format, but {@link CKEDITOR.htmlDataProcessor#dataFilter}\n *\t\tis not applied yet.\n *\t* 6: Data is filtered with the {@link CKEDITOR.filter content filter}.\n *\t* 10: Data is processed with {@link CKEDITOR.htmlDataProcessor#dataFilter}.\n *\t* 10-14: Data is available in the parsed format and {@link CKEDITOR.htmlDataProcessor#dataFilter}\n *\t\thas already been applied.\n *\t* 15: Data is written back to an HTML string.\n *\t* 15-*: Data is available in an HTML string.\n *\n * For example to be able to process parsed, but not yet filtered data add listener this way:\n *\n *\t\teditor.on( 'toHtml', function( evt) {\n *\t\t\tevt.data.dataValue; // -> CKEDITOR.htmlParser.fragment instance\n *\t\t}, null, null, 7 );\n *\n * @since 4.1.0\n * @event toHtml\n * @member CKEDITOR.editor\n * @param {CKEDITOR.editor} editor This editor instance.\n * @param data\n * @param {String/CKEDITOR.htmlParser.fragment/CKEDITOR.htmlParser.element} data.dataValue Input data to be purified.\n * @param {String} data.context See {@link CKEDITOR.htmlDataProcessor#toHtml} The `context` argument.\n * @param {Boolean} data.fixForBody See {@link CKEDITOR.htmlDataProcessor#toHtml} The `fixForBody` argument.\n * @param {Boolean} data.dontFilter See {@link CKEDITOR.htmlDataProcessor#toHtml} The `dontFilter` argument.\n * @param {Boolean} data.filter See {@link CKEDITOR.htmlDataProcessor#toHtml} The `filter` argument.\n * @param {Boolean} data.enterMode See {@link CKEDITOR.htmlDataProcessor#toHtml} The `enterMode` argument.\n * @param {Boolean} [data.protectedWhitespaces] See {@link CKEDITOR.htmlDataProcessor#toHtml} The `protectedWhitespaces` argument.\n */\n\n/**\n * This event is fired when {@link CKEDITOR.htmlDataProcessor} is converting\n * internal HTML to output data HTML.\n *\n * By adding listeners with different priorities it is possible\n * to process input HTML on different stages:\n *\n *\t* 1-4: Data is available in the original string format.\n *\t* 5: Data is initially filtered with regexp patterns and parsed to\n *\t\t{@link CKEDITOR.htmlParser.fragment} {@link CKEDITOR.htmlParser.element}.\n *\t* 5-9: Data is available in the parsed format, but {@link CKEDITOR.htmlDataProcessor#htmlFilter}\n *\t\tis not applied yet.\n *\t* 10: Data is filtered with {@link CKEDITOR.htmlDataProcessor#htmlFilter}.\n *  * 11: Data is filtered with the {CKEDITOR.filter content filter} (on output the content filter makes\n *\t\tonly transformations, without filtering).\n *\t* 10-14: Data is available in the parsed format and {@link CKEDITOR.htmlDataProcessor#htmlFilter}\n *\t\thas already been applied.\n *\t* 15: Data is written back to an HTML string.\n *\t* 15-*: Data is available in an HTML string.\n *\n * For example to be able to process parsed and already processed data add listener this way:\n *\n *\t\teditor.on( 'toDataFormat', function( evt) {\n *\t\t\tevt.data.dataValue; // -> CKEDITOR.htmlParser.fragment instance\n *\t\t}, null, null, 12 );\n *\n * @since 4.1.0\n * @event toDataFormat\n * @member CKEDITOR.editor\n * @param {CKEDITOR.editor} editor This editor instance.\n * @param data\n * @param {String/CKEDITOR.htmlParser.fragment/CKEDITOR.htmlParser.element} data.dataValue Output data to be prepared.\n * @param {String} data.context See {@link CKEDITOR.htmlDataProcessor#toDataFormat} The `context` argument.\n * @param {Boolean} data.filter See {@link CKEDITOR.htmlDataProcessor#toDataFormat} The `filter` argument.\n * @param {Boolean} data.enterMode See {@link CKEDITOR.htmlDataProcessor#toDataFormat} The `enterMode` argument.\n */\n", "output": {"vulnerability_count": 1, "vulnerabilities": [{"description": "`titleText` is assigned twice; the first assignment is useless", "risk": "Medium", "conceptual_fix": "Not provided", "line": 763}]}}
{"CVE": "CVE-2022-24773", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "/**\n * Javascript implementation of basic RSA algorithms.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\n *\n * The only algorithm currently supported for PKI is RSA.\n *\n * An RSA key is often stored in ASN.1 DER format. The SubjectPublicKeyInfo\n * ASN.1 structure is composed of an algorithm of type AlgorithmIdentifier\n * and a subjectPublicKey of type bit string.\n *\n * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters\n * for the algorithm, if any. In the case of RSA, there aren't any.\n *\n * SubjectPublicKeyInfo ::= SEQUENCE {\n *   algorithm AlgorithmIdentifier,\n *   subjectPublicKey BIT STRING\n * }\n *\n * AlgorithmIdentifer ::= SEQUENCE {\n *   algorithm OBJECT IDENTIFIER,\n *   parameters ANY DEFINED BY algorithm OPTIONAL\n * }\n *\n * For an RSA public key, the subjectPublicKey is:\n *\n * RSAPublicKey ::= SEQUENCE {\n *   modulus            INTEGER,    -- n\n *   publicExponent     INTEGER     -- e\n * }\n *\n * PrivateKeyInfo ::= SEQUENCE {\n *   version                   Version,\n *   privateKeyAlgorithm       PrivateKeyAlgorithmIdentifier,\n *   privateKey                PrivateKey,\n *   attributes           [0]  IMPLICIT Attributes OPTIONAL\n * }\n *\n * Version ::= INTEGER\n * PrivateKeyAlgorithmIdentifier ::= AlgorithmIdentifier\n * PrivateKey ::= OCTET STRING\n * Attributes ::= SET OF Attribute\n *\n * An RSA private key as the following structure:\n *\n * RSAPrivateKey ::= SEQUENCE {\n *   version Version,\n *   modulus INTEGER, -- n\n *   publicExponent INTEGER, -- e\n *   privateExponent INTEGER, -- d\n *   prime1 INTEGER, -- p\n *   prime2 INTEGER, -- q\n *   exponent1 INTEGER, -- d mod (p-1)\n *   exponent2 INTEGER, -- d mod (q-1)\n *   coefficient INTEGER -- (inverse of q) mod p\n * }\n *\n * Version ::= INTEGER\n *\n * The OID for the RSA key algorithm is: 1.2.840.113549.1.1.1\n */\nvar forge = require('./forge');\nrequire('./asn1');\nrequire('./jsbn');\nrequire('./oids');\nrequire('./pkcs1');\nrequire('./prime');\nrequire('./random');\nrequire('./util');\n\nif(typeof BigInteger === 'undefined') {\n  var BigInteger = forge.jsbn.BigInteger;\n}\n\nvar _crypto = forge.util.isNodejs ? require('crypto') : null;\n\n// shortcut for asn.1 API\nvar asn1 = forge.asn1;\n\n// shortcut for util API\nvar util = forge.util;\n\n/*\n * RSA encryption and decryption, see RFC 2313.\n */\nforge.pki = forge.pki || {};\nmodule.exports = forge.pki.rsa = forge.rsa = forge.rsa || {};\nvar pki = forge.pki;\n\n// for finding primes, which are 30k+i for i = 1, 7, 11, 13, 17, 19, 23, 29\nvar GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];\n\n// validator for a PrivateKeyInfo structure\nvar privateKeyValidator = {\n  // PrivateKeyInfo\n  name: 'PrivateKeyInfo',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    // Version (INTEGER)\n    name: 'PrivateKeyInfo.version',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'privateKeyVersion'\n  }, {\n    // privateKeyAlgorithm\n    name: 'PrivateKeyInfo.privateKeyAlgorithm',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [{\n      name: 'AlgorithmIdentifier.algorithm',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.OID,\n      constructed: false,\n      capture: 'privateKeyOid'\n    }]\n  }, {\n    // PrivateKey\n    name: 'PrivateKeyInfo',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OCTETSTRING,\n    constructed: false,\n    capture: 'privateKey'\n  }]\n};\n\n// validator for an RSA private key\nvar rsaPrivateKeyValidator = {\n  // RSAPrivateKey\n  name: 'RSAPrivateKey',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    // Version (INTEGER)\n    name: 'RSAPrivateKey.version',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'privateKeyVersion'\n  }, {\n    // modulus (n)\n    name: 'RSAPrivateKey.modulus',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'privateKeyModulus'\n  }, {\n    // publicExponent (e)\n    name: 'RSAPrivateKey.publicExponent',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'privateKeyPublicExponent'\n  }, {\n    // privateExponent (d)\n    name: 'RSAPrivateKey.privateExponent',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'privateKeyPrivateExponent'\n  }, {\n    // prime1 (p)\n    name: 'RSAPrivateKey.prime1',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'privateKeyPrime1'\n  }, {\n    // prime2 (q)\n    name: 'RSAPrivateKey.prime2',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'privateKeyPrime2'\n  }, {\n    // exponent1 (d mod (p-1))\n    name: 'RSAPrivateKey.exponent1',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'privateKeyExponent1'\n  }, {\n    // exponent2 (d mod (q-1))\n    name: 'RSAPrivateKey.exponent2',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'privateKeyExponent2'\n  }, {\n    // coefficient ((inverse of q) mod p)\n    name: 'RSAPrivateKey.coefficient',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'privateKeyCoefficient'\n  }]\n};\n\n// validator for an RSA public key\nvar rsaPublicKeyValidator = {\n  // RSAPublicKey\n  name: 'RSAPublicKey',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    // modulus (n)\n    name: 'RSAPublicKey.modulus',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'publicKeyModulus'\n  }, {\n    // publicExponent (e)\n    name: 'RSAPublicKey.exponent',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'publicKeyExponent'\n  }]\n};\n\n// validator for an SubjectPublicKeyInfo structure\n// Note: Currently only works with an RSA public key\nvar publicKeyValidator = forge.pki.rsa.publicKeyValidator = {\n  name: 'SubjectPublicKeyInfo',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  captureAsn1: 'subjectPublicKeyInfo',\n  value: [{\n    name: 'SubjectPublicKeyInfo.AlgorithmIdentifier',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [{\n      name: 'AlgorithmIdentifier.algorithm',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.OID,\n      constructed: false,\n      capture: 'publicKeyOid'\n    }]\n  }, {\n    // subjectPublicKey\n    name: 'SubjectPublicKeyInfo.subjectPublicKey',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.BITSTRING,\n    constructed: false,\n    value: [{\n      // RSAPublicKey\n      name: 'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      constructed: true,\n      optional: true,\n      captureAsn1: 'rsaPublicKey'\n    }]\n  }]\n};\n\n/**\n * Wrap digest in DigestInfo object.\n *\n * This function implements EMSA-PKCS1-v1_5-ENCODE as per RFC 3447.\n *\n * DigestInfo ::= SEQUENCE {\n *   digestAlgorithm DigestAlgorithmIdentifier,\n *   digest Digest\n * }\n *\n * DigestAlgorithmIdentifier ::= AlgorithmIdentifier\n * Digest ::= OCTET STRING\n *\n * @param md the message digest object with the hash to sign.\n *\n * @return the encoded message (ready for RSA encrytion)\n */\nvar emsaPkcs1v15encode = function(md) {\n  // get the oid for the algorithm\n  var oid;\n  if(md.algorithm in pki.oids) {\n    oid = pki.oids[md.algorithm];\n  } else {\n    var error = new Error('Unknown message digest algorithm.');\n    error.algorithm = md.algorithm;\n    throw error;\n  }\n  var oidBytes = asn1.oidToDer(oid).getBytes();\n\n  // create the digest info\n  var digestInfo = asn1.create(\n    asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n  var digestAlgorithm = asn1.create(\n    asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);\n  digestAlgorithm.value.push(asn1.create(\n    asn1.Class.UNIVERSAL, asn1.Type.OID, false, oidBytes));\n  digestAlgorithm.value.push(asn1.create(\n    asn1.Class.UNIVERSAL, asn1.Type.NULL, false, ''));\n  var digest = asn1.create(\n    asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING,\n    false, md.digest().getBytes());\n  digestInfo.value.push(digestAlgorithm);\n  digestInfo.value.push(digest);\n\n  // encode digest info\n  return asn1.toDer(digestInfo).getBytes();\n};\n\n/**\n * Performs x^c mod n (RSA encryption or decryption operation).\n *\n * @param x the number to raise and mod.\n * @param key the key to use.\n * @param pub true if the key is public, false if private.\n *\n * @return the result of x^c mod n.\n */\nvar _modPow = function(x, key, pub) {\n  if(pub) {\n    return x.modPow(key.e, key.n);\n  }\n\n  if(!key.p || !key.q) {\n    // allow calculation without CRT params (slow)\n    return x.modPow(key.d, key.n);\n  }\n\n  // pre-compute dP, dQ, and qInv if necessary\n  if(!key.dP) {\n    key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));\n  }\n  if(!key.dQ) {\n    key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));\n  }\n  if(!key.qInv) {\n    key.qInv = key.q.modInverse(key.p);\n  }\n\n  /* Chinese remainder theorem (CRT) states:\n\n    Suppose n1, n2, ..., nk are positive integers which are pairwise\n    coprime (n1 and n2 have no common factors other than 1). For any\n    integers x1, x2, ..., xk there exists an integer x solving the\n    system of simultaneous congruences (where ~= means modularly\n    congruent so a ~= b mod n means a mod n = b mod n):\n\n    x ~= x1 mod n1\n    x ~= x2 mod n2\n    ...\n    x ~= xk mod nk\n\n    This system of congruences has a single simultaneous solution x\n    between 0 and n - 1. Furthermore, each xk solution and x itself\n    is congruent modulo the product n = n1*n2*...*nk.\n    So x1 mod n = x2 mod n = xk mod n = x mod n.\n\n    The single simultaneous solution x can be solved with the following\n    equation:\n\n    x = sum(xi*ri*si) mod n where ri = n/ni and si = ri^-1 mod ni.\n\n    Where x is less than n, xi = x mod ni.\n\n    For RSA we are only concerned with k = 2. The modulus n = pq, where\n    p and q are coprime. The RSA decryption algorithm is:\n\n    y = x^d mod n\n\n    Given the above:\n\n    x1 = x^d mod p\n    r1 = n/p = q\n    s1 = q^-1 mod p\n    x2 = x^d mod q\n    r2 = n/q = p\n    s2 = p^-1 mod q\n\n    So y = (x1r1s1 + x2r2s2) mod n\n         = ((x^d mod p)q(q^-1 mod p) + (x^d mod q)p(p^-1 mod q)) mod n\n\n    According to Fermat's Little Theorem, if the modulus P is prime,\n    for any integer A not evenly divisible by P, A^(P-1) ~= 1 mod P.\n    Since A is not divisible by P it follows that if:\n    N ~= M mod (P - 1), then A^N mod P = A^M mod P. Therefore:\n\n    A^N mod P = A^(M mod (P - 1)) mod P. (The latter takes less effort\n    to calculate). In order to calculate x^d mod p more quickly the\n    exponent d mod (p - 1) is stored in the RSA private key (the same\n    is done for x^d mod q). These values are referred to as dP and dQ\n    respectively. Therefore we now have:\n\n    y = ((x^dP mod p)q(q^-1 mod p) + (x^dQ mod q)p(p^-1 mod q)) mod n\n\n    Since we'll be reducing x^dP by modulo p (same for q) we can also\n    reduce x by p (and q respectively) before hand. Therefore, let\n\n    xp = ((x mod p)^dP mod p), and\n    xq = ((x mod q)^dQ mod q), yielding:\n\n    y = (xp*q*(q^-1 mod p) + xq*p*(p^-1 mod q)) mod n\n\n    This can be further reduced to a simple algorithm that only\n    requires 1 inverse (the q inverse is used) to be used and stored.\n    The algorithm is called Garner's algorithm. If qInv is the\n    inverse of q, we simply calculate:\n\n    y = (qInv*(xp - xq) mod p) * q + xq\n\n    However, there are two further complications. First, we need to\n    ensure that xp > xq to prevent signed BigIntegers from being used\n    so we add p until this is true (since we will be mod'ing with\n    p anyway). Then, there is a known timing attack on algorithms\n    using the CRT. To mitigate this risk, \"cryptographic blinding\"\n    should be used. This requires simply generating a random number r\n    between 0 and n-1 and its inverse and multiplying x by r^e before\n    calculating y and then multiplying y by r^-1 afterwards. Note that\n    r must be coprime with n (gcd(r, n) === 1) in order to have an\n    inverse.\n  */\n\n  // cryptographic blinding\n  var r;\n  do {\n    r = new BigInteger(\n      forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength() / 8)),\n      16);\n  } while(r.compareTo(key.n) >= 0 || !r.gcd(key.n).equals(BigInteger.ONE));\n  x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);\n\n  // calculate xp and xq\n  var xp = x.mod(key.p).modPow(key.dP, key.p);\n  var xq = x.mod(key.q).modPow(key.dQ, key.q);\n\n  // xp must be larger than xq to avoid signed bit usage\n  while(xp.compareTo(xq) < 0) {\n    xp = xp.add(key.p);\n  }\n\n  // do last step\n  var y = xp.subtract(xq)\n    .multiply(key.qInv).mod(key.p)\n    .multiply(key.q).add(xq);\n\n  // remove effect of random for cryptographic blinding\n  y = y.multiply(r.modInverse(key.n)).mod(key.n);\n\n  return y;\n};\n\n/**\n * NOTE: THIS METHOD IS DEPRECATED, use 'sign' on a private key object or\n * 'encrypt' on a public key object instead.\n *\n * Performs RSA encryption.\n *\n * The parameter bt controls whether to put padding bytes before the\n * message passed in. Set bt to either true or false to disable padding\n * completely (in order to handle e.g. EMSA-PSS encoding seperately before),\n * signaling whether the encryption operation is a public key operation\n * (i.e. encrypting data) or not, i.e. private key operation (data signing).\n *\n * For PKCS#1 v1.5 padding pass in the block type to use, i.e. either 0x01\n * (for signing) or 0x02 (for encryption). The key operation mode (private\n * or public) is derived from this flag in that case).\n *\n * @param m the message to encrypt as a byte string.\n * @param key the RSA key to use.\n * @param bt for PKCS#1 v1.5 padding, the block type to use\n *   (0x01 for private key, 0x02 for public),\n *   to disable padding: true = public key, false = private key.\n *\n * @return the encrypted bytes as a string.\n */\npki.rsa.encrypt = function(m, key, bt) {\n  var pub = bt;\n  var eb;\n\n  // get the length of the modulus in bytes\n  var k = Math.ceil(key.n.bitLength() / 8);\n\n  if(bt !== false && bt !== true) {\n    // legacy, default to PKCS#1 v1.5 padding\n    pub = (bt === 0x02);\n    eb = _encodePkcs1_v1_5(m, key, bt);\n  } else {\n    eb = forge.util.createBuffer();\n    eb.putBytes(m);\n  }\n\n  // load encryption block as big integer 'x'\n  // FIXME: hex conversion inefficient, get BigInteger w/byte strings\n  var x = new BigInteger(eb.toHex(), 16);\n\n  // do RSA encryption\n  var y = _modPow(x, key, pub);\n\n  // convert y into the encrypted data byte string, if y is shorter in\n  // bytes than k, then prepend zero bytes to fill up ed\n  // FIXME: hex conversion inefficient, get BigInteger w/byte strings\n  var yhex = y.toString(16);\n  var ed = forge.util.createBuffer();\n  var zeros = k - Math.ceil(yhex.length / 2);\n  while(zeros > 0) {\n    ed.putByte(0x00);\n    --zeros;\n  }\n  ed.putBytes(forge.util.hexToBytes(yhex));\n  return ed.getBytes();\n};\n\n/**\n * NOTE: THIS METHOD IS DEPRECATED, use 'decrypt' on a private key object or\n * 'verify' on a public key object instead.\n *\n * Performs RSA decryption.\n *\n * The parameter ml controls whether to apply PKCS#1 v1.5 padding\n * or not.  Set ml = false to disable padding removal completely\n * (in order to handle e.g. EMSA-PSS later on) and simply pass back\n * the RSA encryption block.\n *\n * @param ed the encrypted data to decrypt in as a byte string.\n * @param key the RSA key to use.\n * @param pub true for a public key operation, false for private.\n * @param ml the message length, if known, false to disable padding.\n *\n * @return the decrypted message as a byte string.\n */\npki.rsa.decrypt = function(ed, key, pub, ml) {\n  // get the length of the modulus in bytes\n  var k = Math.ceil(key.n.bitLength() / 8);\n\n  // error if the length of the encrypted data ED is not k\n  if(ed.length !== k) {\n    var error = new Error('Encrypted message length is invalid.');\n    error.length = ed.length;\n    error.expected = k;\n    throw error;\n  }\n\n  // convert encrypted data into a big integer\n  // FIXME: hex conversion inefficient, get BigInteger w/byte strings\n  var y = new BigInteger(forge.util.createBuffer(ed).toHex(), 16);\n\n  // y must be less than the modulus or it wasn't the result of\n  // a previous mod operation (encryption) using that modulus\n  if(y.compareTo(key.n) >= 0) {\n    throw new Error('Encrypted message is invalid.');\n  }\n\n  // do RSA decryption\n  var x = _modPow(y, key, pub);\n\n  // create the encryption block, if x is shorter in bytes than k, then\n  // prepend zero bytes to fill up eb\n  // FIXME: hex conversion inefficient, get BigInteger w/byte strings\n  var xhex = x.toString(16);\n  var eb = forge.util.createBuffer();\n  var zeros = k - Math.ceil(xhex.length / 2);\n  while(zeros > 0) {\n    eb.putByte(0x00);\n    --zeros;\n  }\n  eb.putBytes(forge.util.hexToBytes(xhex));\n\n  if(ml !== false) {\n    // legacy, default to PKCS#1 v1.5 padding\n    return _decodePkcs1_v1_5(eb.getBytes(), key, pub);\n  }\n\n  // return message\n  return eb.getBytes();\n};\n\n/**\n * Creates an RSA key-pair generation state object. It is used to allow\n * key-generation to be performed in steps. It also allows for a UI to\n * display progress updates.\n *\n * @param bits the size for the private key in bits, defaults to 2048.\n * @param e the public exponent to use, defaults to 65537 (0x10001).\n * @param [options] the options to use.\n *          prng a custom crypto-secure pseudo-random number generator to use,\n *            that must define \"getBytesSync\".\n *          algorithm the algorithm to use (default: 'PRIMEINC').\n *\n * @return the state object to use to generate the key-pair.\n */\npki.rsa.createKeyPairGenerationState = function(bits, e, options) {\n  // TODO: migrate step-based prime generation code to forge.prime\n\n  // set default bits\n  if(typeof(bits) === 'string') {\n    bits = parseInt(bits, 10);\n  }\n  bits = bits || 2048;\n\n  // create prng with api that matches BigInteger secure random\n  options = options || {};\n  var prng = options.prng || forge.random;\n  var rng = {\n    // x is an array to fill with bytes\n    nextBytes: function(x) {\n      var b = prng.getBytesSync(x.length);\n      for(var i = 0; i < x.length; ++i) {\n        x[i] = b.charCodeAt(i);\n      }\n    }\n  };\n\n  var algorithm = options.algorithm || 'PRIMEINC';\n\n  // create PRIMEINC algorithm state\n  var rval;\n  if(algorithm === 'PRIMEINC') {\n    rval = {\n      algorithm: algorithm,\n      state: 0,\n      bits: bits,\n      rng: rng,\n      eInt: e || 65537,\n      e: new BigInteger(null),\n      p: null,\n      q: null,\n      qBits: bits >> 1,\n      pBits: bits - (bits >> 1),\n      pqState: 0,\n      num: null,\n      keys: null\n    };\n    rval.e.fromInt(rval.eInt);\n  } else {\n    throw new Error('Invalid key generation algorithm: ' + algorithm);\n  }\n\n  return rval;\n};\n\n/**\n * Attempts to runs the key-generation algorithm for at most n seconds\n * (approximately) using the given state. When key-generation has completed,\n * the keys will be stored in state.keys.\n *\n * To use this function to update a UI while generating a key or to prevent\n * causing browser lockups/warnings, set \"n\" to a value other than 0. A\n * simple pattern for generating a key and showing a progress indicator is:\n *\n * var state = pki.rsa.createKeyPairGenerationState(2048);\n * var step = function() {\n *   // step key-generation, run algorithm for 100 ms, repeat\n *   if(!forge.pki.rsa.stepKeyPairGenerationState(state, 100)) {\n *     setTimeout(step, 1);\n *   } else {\n *     // key-generation complete\n *     // TODO: turn off progress indicator here\n *     // TODO: use the generated key-pair in \"state.keys\"\n *   }\n * };\n * // TODO: turn on progress indicator here\n * setTimeout(step, 0);\n *\n * @param state the state to use.\n * @param n the maximum number of milliseconds to run the algorithm for, 0\n *          to run the algorithm to completion.\n *\n * @return true if the key-generation completed, false if not.\n */\npki.rsa.stepKeyPairGenerationState = function(state, n) {\n  // set default algorithm if not set\n  if(!('algorithm' in state)) {\n    state.algorithm = 'PRIMEINC';\n  }\n\n  // TODO: migrate step-based prime generation code to forge.prime\n  // TODO: abstract as PRIMEINC algorithm\n\n  // do key generation (based on Tom Wu's rsa.js, see jsbn.js license)\n  // with some minor optimizations and designed to run in steps\n\n  // local state vars\n  var THIRTY = new BigInteger(null);\n  THIRTY.fromInt(30);\n  var deltaIdx = 0;\n  var op_or = function(x, y) {return x | y;};\n\n  // keep stepping until time limit is reached or done\n  var t1 = +new Date();\n  var t2;\n  var total = 0;\n  while(state.keys === null && (n <= 0 || total < n)) {\n    // generate p or q\n    if(state.state === 0) {\n      /* Note: All primes are of the form:\n\n        30k+i, for i < 30 and gcd(30, i)=1, where there are 8 values for i\n\n        When we generate a random number, we always align it at 30k + 1. Each\n        time the number is determined not to be prime we add to get to the\n        next 'i', eg: if the number was at 30k + 1 we add 6. */\n      var bits = (state.p === null) ? state.pBits : state.qBits;\n      var bits1 = bits - 1;\n\n      // get a random number\n      if(state.pqState === 0) {\n        state.num = new BigInteger(bits, state.rng);\n        // force MSB set\n        if(!state.num.testBit(bits1)) {\n          state.num.bitwiseTo(\n            BigInteger.ONE.shiftLeft(bits1), op_or, state.num);\n        }\n        // align number on 30k+1 boundary\n        state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);\n        deltaIdx = 0;\n\n        ++state.pqState;\n      } else if(state.pqState === 1) {\n        // try to make the number a prime\n        if(state.num.bitLength() > bits) {\n          // overflow, try again\n          state.pqState = 0;\n          // do primality test\n        } else if(state.num.isProbablePrime(\n          _getMillerRabinTests(state.num.bitLength()))) {\n          ++state.pqState;\n        } else {\n          // get next potential prime\n          state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);\n        }\n      } else if(state.pqState === 2) {\n        // ensure number is coprime with e\n        state.pqState =\n          (state.num.subtract(BigInteger.ONE).gcd(state.e)\n            .compareTo(BigInteger.ONE) === 0) ? 3 : 0;\n      } else if(state.pqState === 3) {\n        // store p or q\n        state.pqState = 0;\n        if(state.p === null) {\n          state.p = state.num;\n        } else {\n          state.q = state.num;\n        }\n\n        // advance state if both p and q are ready\n        if(state.p !== null && state.q !== null) {\n          ++state.state;\n        }\n        state.num = null;\n      }\n    } else if(state.state === 1) {\n      // ensure p is larger than q (swap them if not)\n      if(state.p.compareTo(state.q) < 0) {\n        state.num = state.p;\n        state.p = state.q;\n        state.q = state.num;\n      }\n      ++state.state;\n    } else if(state.state === 2) {\n      // compute phi: (p - 1)(q - 1) (Euler's totient function)\n      state.p1 = state.p.subtract(BigInteger.ONE);\n      state.q1 = state.q.subtract(BigInteger.ONE);\n      state.phi = state.p1.multiply(state.q1);\n      ++state.state;\n    } else if(state.state === 3) {\n      // ensure e and phi are coprime\n      if(state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {\n        // phi and e are coprime, advance\n        ++state.state;\n      } else {\n        // phi and e aren't coprime, so generate a new p and q\n        state.p = null;\n        state.q = null;\n        state.state = 0;\n      }\n    } else if(state.state === 4) {\n      // create n, ensure n is has the right number of bits\n      state.n = state.p.multiply(state.q);\n\n      // ensure n is right number of bits\n      if(state.n.bitLength() === state.bits) {\n        // success, advance\n        ++state.state;\n      } else {\n        // failed, get new q\n        state.q = null;\n        state.state = 0;\n      }\n    } else if(state.state === 5) {\n      // set keys\n      var d = state.e.modInverse(state.phi);\n      state.keys = {\n        privateKey: pki.rsa.setPrivateKey(\n          state.n, state.e, d, state.p, state.q,\n          d.mod(state.p1), d.mod(state.q1),\n          state.q.modInverse(state.p)),\n        publicKey: pki.rsa.setPublicKey(state.n, state.e)\n      };\n    }\n\n    // update timing\n    t2 = +new Date();\n    total += t2 - t1;\n    t1 = t2;\n  }\n\n  return state.keys !== null;\n};\n\n/**\n * Generates an RSA public-private key pair in a single call.\n *\n * To generate a key-pair in steps (to allow for progress updates and to\n * prevent blocking or warnings in slow browsers) then use the key-pair\n * generation state functions.\n *\n * To generate a key-pair asynchronously (either through web-workers, if\n * available, or by breaking up the work on the main thread), pass a\n * callback function.\n *\n * @param [bits] the size for the private key in bits, defaults to 2048.\n * @param [e] the public exponent to use, defaults to 65537.\n * @param [options] options for key-pair generation, if given then 'bits'\n *            and 'e' must *not* be given:\n *          bits the size for the private key in bits, (default: 2048).\n *          e the public exponent to use, (default: 65537 (0x10001)).\n *          workerScript the worker script URL.\n *          workers the number of web workers (if supported) to use,\n *            (default: 2).\n *          workLoad the size of the work load, ie: number of possible prime\n *            numbers for each web worker to check per work assignment,\n *            (default: 100).\n *          prng a custom crypto-secure pseudo-random number generator to use,\n *            that must define \"getBytesSync\". Disables use of native APIs.\n *          algorithm the algorithm to use (default: 'PRIMEINC').\n * @param [callback(err, keypair)] called once the operation completes.\n *\n * @return an object with privateKey and publicKey properties.\n */\npki.rsa.generateKeyPair = function(bits, e, options, callback) {\n  // (bits), (options), (callback)\n  if(arguments.length === 1) {\n    if(typeof bits === 'object') {\n      options = bits;\n      bits = undefined;\n    } else if(typeof bits === 'function') {\n      callback = bits;\n      bits = undefined;\n    }\n  } else if(arguments.length === 2) {\n    // (bits, e), (bits, options), (bits, callback), (options, callback)\n    if(typeof bits === 'number') {\n      if(typeof e === 'function') {\n        callback = e;\n        e = undefined;\n      } else if(typeof e !== 'number') {\n        options = e;\n        e = undefined;\n      }\n    } else {\n      options = bits;\n      callback = e;\n      bits = undefined;\n      e = undefined;\n    }\n  } else if(arguments.length === 3) {\n    // (bits, e, options), (bits, e, callback), (bits, options, callback)\n    if(typeof e === 'number') {\n      if(typeof options === 'function') {\n        callback = options;\n        options = undefined;\n      }\n    } else {\n      callback = options;\n      options = e;\n      e = undefined;\n    }\n  }\n  options = options || {};\n  if(bits === undefined) {\n    bits = options.bits || 2048;\n  }\n  if(e === undefined) {\n    e = options.e || 0x10001;\n  }\n\n  // use native code if permitted, available, and parameters are acceptable\n  if(!forge.options.usePureJavaScript && !options.prng &&\n    bits >= 256 && bits <= 16384 && (e === 0x10001 || e === 3)) {\n    if(callback) {\n      // try native async\n      if(_detectNodeCrypto('generateKeyPair')) {\n        return _crypto.generateKeyPair('rsa', {\n          modulusLength: bits,\n          publicExponent: e,\n          publicKeyEncoding: {\n            type: 'spki',\n            format: 'pem'\n          },\n          privateKeyEncoding: {\n            type: 'pkcs8',\n            format: 'pem'\n          }\n        }, function(err, pub, priv) {\n          if(err) {\n            return callback(err);\n          }\n          callback(null, {\n            privateKey: pki.privateKeyFromPem(priv),\n            publicKey: pki.publicKeyFromPem(pub)\n          });\n        });\n      }\n      if(_detectSubtleCrypto('generateKey') &&\n        _detectSubtleCrypto('exportKey')) {\n        // use standard native generateKey\n        return util.globalScope.crypto.subtle.generateKey({\n          name: 'RSASSA-PKCS1-v1_5',\n          modulusLength: bits,\n          publicExponent: _intToUint8Array(e),\n          hash: {name: 'SHA-256'}\n        }, true /* key can be exported*/, ['sign', 'verify'])\n        .then(function(pair) {\n          return util.globalScope.crypto.subtle.exportKey(\n            'pkcs8', pair.privateKey);\n        // avoiding catch(function(err) {...}) to support IE <= 8\n        }).then(undefined, function(err) {\n          callback(err);\n        }).then(function(pkcs8) {\n          if(pkcs8) {\n            var privateKey = pki.privateKeyFromAsn1(\n              asn1.fromDer(forge.util.createBuffer(pkcs8)));\n            callback(null, {\n              privateKey: privateKey,\n              publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)\n            });\n          }\n        });\n      }\n      if(_detectSubtleMsCrypto('generateKey') &&\n        _detectSubtleMsCrypto('exportKey')) {\n        var genOp = util.globalScope.msCrypto.subtle.generateKey({\n          name: 'RSASSA-PKCS1-v1_5',\n          modulusLength: bits,\n          publicExponent: _intToUint8Array(e),\n          hash: {name: 'SHA-256'}\n        }, true /* key can be exported*/, ['sign', 'verify']);\n        genOp.oncomplete = function(e) {\n          var pair = e.target.result;\n          var exportOp = util.globalScope.msCrypto.subtle.exportKey(\n            'pkcs8', pair.privateKey);\n          exportOp.oncomplete = function(e) {\n            var pkcs8 = e.target.result;\n            var privateKey = pki.privateKeyFromAsn1(\n              asn1.fromDer(forge.util.createBuffer(pkcs8)));\n            callback(null, {\n              privateKey: privateKey,\n              publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)\n            });\n          };\n          exportOp.onerror = function(err) {\n            callback(err);\n          };\n        };\n        genOp.onerror = function(err) {\n          callback(err);\n        };\n        return;\n      }\n    } else {\n      // try native sync\n      if(_detectNodeCrypto('generateKeyPairSync')) {\n        var keypair = _crypto.generateKeyPairSync('rsa', {\n          modulusLength: bits,\n          publicExponent: e,\n          publicKeyEncoding: {\n            type: 'spki',\n            format: 'pem'\n          },\n          privateKeyEncoding: {\n            type: 'pkcs8',\n            format: 'pem'\n          }\n        });\n        return {\n          privateKey: pki.privateKeyFromPem(keypair.privateKey),\n          publicKey: pki.publicKeyFromPem(keypair.publicKey)\n        };\n      }\n    }\n  }\n\n  // use JavaScript implementation\n  var state = pki.rsa.createKeyPairGenerationState(bits, e, options);\n  if(!callback) {\n    pki.rsa.stepKeyPairGenerationState(state, 0);\n    return state.keys;\n  }\n  _generateKeyPair(state, options, callback);\n};\n\n/**\n * Sets an RSA public key from BigIntegers modulus and exponent.\n *\n * @param n the modulus.\n * @param e the exponent.\n *\n * @return the public key.\n */\npki.setRsaPublicKey = pki.rsa.setPublicKey = function(n, e) {\n  var key = {\n    n: n,\n    e: e\n  };\n\n  /**\n   * Encrypts the given data with this public key. Newer applications\n   * should use the 'RSA-OAEP' decryption scheme, 'RSAES-PKCS1-V1_5' is for\n   * legacy applications.\n   *\n   * @param data the byte string to encrypt.\n   * @param scheme the encryption scheme to use:\n   *          'RSAES-PKCS1-V1_5' (default),\n   *          'RSA-OAEP',\n   *          'RAW', 'NONE', or null to perform raw RSA encryption,\n   *          an object with an 'encode' property set to a function\n   *          with the signature 'function(data, key)' that returns\n   *          a binary-encoded string representing the encoded data.\n   * @param schemeOptions any scheme-specific options.\n   *\n   * @return the encrypted byte string.\n   */\n  key.encrypt = function(data, scheme, schemeOptions) {\n    if(typeof scheme === 'string') {\n      scheme = scheme.toUpperCase();\n    } else if(scheme === undefined) {\n      scheme = 'RSAES-PKCS1-V1_5';\n    }\n\n    if(scheme === 'RSAES-PKCS1-V1_5') {\n      scheme = {\n        encode: function(m, key, pub) {\n          return _encodePkcs1_v1_5(m, key, 0x02).getBytes();\n        }\n      };\n    } else if(scheme === 'RSA-OAEP' || scheme === 'RSAES-OAEP') {\n      scheme = {\n        encode: function(m, key) {\n          return forge.pkcs1.encode_rsa_oaep(key, m, schemeOptions);\n        }\n      };\n    } else if(['RAW', 'NONE', 'NULL', null].indexOf(scheme) !== -1) {\n      scheme = {encode: function(e) {return e;}};\n    } else if(typeof scheme === 'string') {\n      throw new Error('Unsupported encryption scheme: \"' + scheme + '\".');\n    }\n\n    // do scheme-based encoding then rsa encryption\n    var e = scheme.encode(data, key, true);\n    return pki.rsa.encrypt(e, key, true);\n  };\n\n  /**\n   * Verifies the given signature against the given digest.\n   *\n   * PKCS#1 supports multiple (currently two) signature schemes:\n   * RSASSA-PKCS1-V1_5 and RSASSA-PSS.\n   *\n   * By default this implementation uses the \"old scheme\", i.e.\n   * RSASSA-PKCS1-V1_5, in which case once RSA-decrypted, the\n   * signature is an OCTET STRING that holds a DigestInfo.\n   *\n   * DigestInfo ::= SEQUENCE {\n   *   digestAlgorithm DigestAlgorithmIdentifier,\n   *   digest Digest\n   * }\n   * DigestAlgorithmIdentifier ::= AlgorithmIdentifier\n   * Digest ::= OCTET STRING\n   *\n   * To perform PSS signature verification, provide an instance\n   * of Forge PSS object as the scheme parameter.\n   *\n   * @param digest the message digest hash to compare against the signature,\n   *          as a binary-encoded string.\n   * @param signature the signature to verify, as a binary-encoded string.\n   * @param scheme signature verification scheme to use:\n   *          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,\n   *          a Forge PSS object for RSASSA-PSS,\n   *          'NONE' or null for none, DigestInfo will not be expected, but\n   *            PKCS#1 v1.5 padding will still be used.\n   *\n   * @return true if the signature was verified, false if not.\n   */\n  key.verify = function(digest, signature, scheme) {\n    if(typeof scheme === 'string') {\n      scheme = scheme.toUpperCase();\n    } else if(scheme === undefined) {\n      scheme = 'RSASSA-PKCS1-V1_5';\n    }\n\n    if(scheme === 'RSASSA-PKCS1-V1_5') {\n      scheme = {\n        verify: function(digest, d) {\n          // remove padding\n          d = _decodePkcs1_v1_5(d, key, true);\n          // d is ASN.1 BER-encoded DigestInfo\n          var obj = asn1.fromDer(d);\n          // compare the given digest to the decrypted one\n          return digest === obj.value[1].value;\n        }\n      };\n    } else if(scheme === 'NONE' || scheme === 'NULL' || scheme === null) {\n      scheme = {\n        verify: function(digest, d) {\n          // remove padding\n          d = _decodePkcs1_v1_5(d, key, true);\n          return digest === d;\n        }\n      };\n    }\n\n    // do rsa decryption w/o any decoding, then verify -- which does decoding\n    var d = pki.rsa.decrypt(signature, key, true, false);\n    return scheme.verify(digest, d, key.n.bitLength());\n  };\n\n  return key;\n};\n\n/**\n * Sets an RSA private key from BigIntegers modulus, exponent, primes,\n * prime exponents, and modular multiplicative inverse.\n *\n * @param n the modulus.\n * @param e the public exponent.\n * @param d the private exponent ((inverse of e) mod n).\n * @param p the first prime.\n * @param q the second prime.\n * @param dP exponent1 (d mod (p-1)).\n * @param dQ exponent2 (d mod (q-1)).\n * @param qInv ((inverse of q) mod p)\n *\n * @return the private key.\n */\npki.setRsaPrivateKey = pki.rsa.setPrivateKey = function(\n  n, e, d, p, q, dP, dQ, qInv) {\n  var key = {\n    n: n,\n    e: e,\n    d: d,\n    p: p,\n    q: q,\n    dP: dP,\n    dQ: dQ,\n    qInv: qInv\n  };\n\n  /**\n   * Decrypts the given data with this private key. The decryption scheme\n   * must match the one used to encrypt the data.\n   *\n   * @param data the byte string to decrypt.\n   * @param scheme the decryption scheme to use:\n   *          'RSAES-PKCS1-V1_5' (default),\n   *          'RSA-OAEP',\n   *          'RAW', 'NONE', or null to perform raw RSA decryption.\n   * @param schemeOptions any scheme-specific options.\n   *\n   * @return the decrypted byte string.\n   */\n  key.decrypt = function(data, scheme, schemeOptions) {\n    if(typeof scheme === 'string') {\n      scheme = scheme.toUpperCase();\n    } else if(scheme === undefined) {\n      scheme = 'RSAES-PKCS1-V1_5';\n    }\n\n    // do rsa decryption w/o any decoding\n    var d = pki.rsa.decrypt(data, key, false, false);\n\n    if(scheme === 'RSAES-PKCS1-V1_5') {\n      scheme = {decode: _decodePkcs1_v1_5};\n    } else if(scheme === 'RSA-OAEP' || scheme === 'RSAES-OAEP') {\n      scheme = {\n        decode: function(d, key) {\n          return forge.pkcs1.decode_rsa_oaep(key, d, schemeOptions);\n        }\n      };\n    } else if(['RAW', 'NONE', 'NULL', null].indexOf(scheme) !== -1) {\n      scheme = {decode: function(d) {return d;}};\n    } else {\n      throw new Error('Unsupported encryption scheme: \"' + scheme + '\".');\n    }\n\n    // decode according to scheme\n    return scheme.decode(d, key, false);\n  };\n\n  /**\n   * Signs the given digest, producing a signature.\n   *\n   * PKCS#1 supports multiple (currently two) signature schemes:\n   * RSASSA-PKCS1-V1_5 and RSASSA-PSS.\n   *\n   * By default this implementation uses the \"old scheme\", i.e.\n   * RSASSA-PKCS1-V1_5. In order to generate a PSS signature, provide\n   * an instance of Forge PSS object as the scheme parameter.\n   *\n   * @param md the message digest object with the hash to sign.\n   * @param scheme the signature scheme to use:\n   *          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,\n   *          a Forge PSS object for RSASSA-PSS,\n   *          'NONE' or null for none, DigestInfo will not be used but\n   *            PKCS#1 v1.5 padding will still be used.\n   *\n   * @return the signature as a byte string.\n   */\n  key.sign = function(md, scheme) {\n    /* Note: The internal implementation of RSA operations is being\n      transitioned away from a PKCS#1 v1.5 hard-coded scheme. Some legacy\n      code like the use of an encoding block identifier 'bt' will eventually\n      be removed. */\n\n    // private key operation\n    var bt = false;\n\n    if(typeof scheme === 'string') {\n      scheme = scheme.toUpperCase();\n    }\n\n    if(scheme === undefined || scheme === 'RSASSA-PKCS1-V1_5') {\n      scheme = {encode: emsaPkcs1v15encode};\n      bt = 0x01;\n    } else if(scheme === 'NONE' || scheme === 'NULL' || scheme === null) {\n      scheme = {encode: function() {return md;}};\n      bt = 0x01;\n    }\n\n    // encode and then encrypt\n    var d = scheme.encode(md, key.n.bitLength());\n    return pki.rsa.encrypt(d, key, bt);\n  };\n\n  return key;\n};\n\n/**\n * Wraps an RSAPrivateKey ASN.1 object in an ASN.1 PrivateKeyInfo object.\n *\n * @param rsaKey the ASN.1 RSAPrivateKey.\n *\n * @return the ASN.1 PrivateKeyInfo.\n */\npki.wrapRsaPrivateKey = function(rsaKey) {\n  // PrivateKeyInfo\n  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // version (0)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n      asn1.integerToDer(0).getBytes()),\n    // privateKeyAlgorithm\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n      asn1.create(\n        asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n        asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\n    ]),\n    // PrivateKey\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\n      asn1.toDer(rsaKey).getBytes())\n  ]);\n};\n\n/**\n * Converts a private key from an ASN.1 object.\n *\n * @param obj the ASN.1 representation of a PrivateKeyInfo containing an\n *          RSAPrivateKey or an RSAPrivateKey.\n *\n * @return the private key.\n */\npki.privateKeyFromAsn1 = function(obj) {\n  // get PrivateKeyInfo\n  var capture = {};\n  var errors = [];\n  if(asn1.validate(obj, privateKeyValidator, capture, errors)) {\n    obj = asn1.fromDer(forge.util.createBuffer(capture.privateKey));\n  }\n\n  // get RSAPrivateKey\n  capture = {};\n  errors = [];\n  if(!asn1.validate(obj, rsaPrivateKeyValidator, capture, errors)) {\n    var error = new Error('Cannot read private key. ' +\n      'ASN.1 object does not contain an RSAPrivateKey.');\n    error.errors = errors;\n    throw error;\n  }\n\n  // Note: Version is currently ignored.\n  // capture.privateKeyVersion\n  // FIXME: inefficient, get a BigInteger that uses byte strings\n  var n, e, d, p, q, dP, dQ, qInv;\n  n = forge.util.createBuffer(capture.privateKeyModulus).toHex();\n  e = forge.util.createBuffer(capture.privateKeyPublicExponent).toHex();\n  d = forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex();\n  p = forge.util.createBuffer(capture.privateKeyPrime1).toHex();\n  q = forge.util.createBuffer(capture.privateKeyPrime2).toHex();\n  dP = forge.util.createBuffer(capture.privateKeyExponent1).toHex();\n  dQ = forge.util.createBuffer(capture.privateKeyExponent2).toHex();\n  qInv = forge.util.createBuffer(capture.privateKeyCoefficient).toHex();\n\n  // set private key\n  return pki.setRsaPrivateKey(\n    new BigInteger(n, 16),\n    new BigInteger(e, 16),\n    new BigInteger(d, 16),\n    new BigInteger(p, 16),\n    new BigInteger(q, 16),\n    new BigInteger(dP, 16),\n    new BigInteger(dQ, 16),\n    new BigInteger(qInv, 16));\n};\n\n/**\n * Converts a private key to an ASN.1 RSAPrivateKey.\n *\n * @param key the private key.\n *\n * @return the ASN.1 representation of an RSAPrivateKey.\n */\npki.privateKeyToAsn1 = pki.privateKeyToRSAPrivateKey = function(key) {\n  // RSAPrivateKey\n  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // version (0 = only 2 primes, 1 multiple primes)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n      asn1.integerToDer(0).getBytes()),\n    // modulus (n)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n      _bnToBytes(key.n)),\n    // publicExponent (e)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n      _bnToBytes(key.e)),\n    // privateExponent (d)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n      _bnToBytes(key.d)),\n    // privateKeyPrime1 (p)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n      _bnToBytes(key.p)),\n    // privateKeyPrime2 (q)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n      _bnToBytes(key.q)),\n    // privateKeyExponent1 (dP)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n      _bnToBytes(key.dP)),\n    // privateKeyExponent2 (dQ)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n      _bnToBytes(key.dQ)),\n    // coefficient (qInv)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n      _bnToBytes(key.qInv))\n  ]);\n};\n\n/**\n * Converts a public key from an ASN.1 SubjectPublicKeyInfo or RSAPublicKey.\n *\n * @param obj the asn1 representation of a SubjectPublicKeyInfo or RSAPublicKey.\n *\n * @return the public key.\n */\npki.publicKeyFromAsn1 = function(obj) {\n  // get SubjectPublicKeyInfo\n  var capture = {};\n  var errors = [];\n  if(asn1.validate(obj, publicKeyValidator, capture, errors)) {\n    // get oid\n    var oid = asn1.derToOid(capture.publicKeyOid);\n    if(oid !== pki.oids.rsaEncryption) {\n      var error = new Error('Cannot read public key. Unknown OID.');\n      error.oid = oid;\n      throw error;\n    }\n    obj = capture.rsaPublicKey;\n  }\n\n  // get RSA params\n  errors = [];\n  if(!asn1.validate(obj, rsaPublicKeyValidator, capture, errors)) {\n    var error = new Error('Cannot read public key. ' +\n      'ASN.1 object does not contain an RSAPublicKey.');\n    error.errors = errors;\n    throw error;\n  }\n\n  // FIXME: inefficient, get a BigInteger that uses byte strings\n  var n = forge.util.createBuffer(capture.publicKeyModulus).toHex();\n  var e = forge.util.createBuffer(capture.publicKeyExponent).toHex();\n\n  // set public key\n  return pki.setRsaPublicKey(\n    new BigInteger(n, 16),\n    new BigInteger(e, 16));\n};\n\n/**\n * Converts a public key to an ASN.1 SubjectPublicKeyInfo.\n *\n * @param key the public key.\n *\n * @return the asn1 representation of a SubjectPublicKeyInfo.\n */\npki.publicKeyToAsn1 = pki.publicKeyToSubjectPublicKeyInfo = function(key) {\n  // SubjectPublicKeyInfo\n  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // AlgorithmIdentifier\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n      // algorithm\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\n        asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),\n      // parameters (null)\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\n    ]),\n    // subjectPublicKey\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [\n      pki.publicKeyToRSAPublicKey(key)\n    ])\n  ]);\n};\n\n/**\n * Converts a public key to an ASN.1 RSAPublicKey.\n *\n * @param key the public key.\n *\n * @return the asn1 representation of a RSAPublicKey.\n */\npki.publicKeyToRSAPublicKey = function(key) {\n  // RSAPublicKey\n  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n    // modulus (n)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n      _bnToBytes(key.n)),\n    // publicExponent (e)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n      _bnToBytes(key.e))\n  ]);\n};\n\n/**\n * Encodes a message using PKCS#1 v1.5 padding.\n *\n * @param m the message to encode.\n * @param key the RSA key to use.\n * @param bt the block type to use, i.e. either 0x01 (for signing) or 0x02\n *          (for encryption).\n *\n * @return the padded byte buffer.\n */\nfunction _encodePkcs1_v1_5(m, key, bt) {\n  var eb = forge.util.createBuffer();\n\n  // get the length of the modulus in bytes\n  var k = Math.ceil(key.n.bitLength() / 8);\n\n  /* use PKCS#1 v1.5 padding */\n  if(m.length > (k - 11)) {\n    var error = new Error('Message is too long for PKCS#1 v1.5 padding.');\n    error.length = m.length;\n    error.max = k - 11;\n    throw error;\n  }\n\n  /* A block type BT, a padding string PS, and the data D shall be\n    formatted into an octet string EB, the encryption block:\n\n    EB = 00 || BT || PS || 00 || D\n\n    The block type BT shall be a single octet indicating the structure of\n    the encryption block. For this version of the document it shall have\n    value 00, 01, or 02. For a private-key operation, the block type\n    shall be 00 or 01. For a public-key operation, it shall be 02.\n\n    The padding string PS shall consist of k-3-||D|| octets. For block\n    type 00, the octets shall have value 00; for block type 01, they\n    shall have value FF; and for block type 02, they shall be\n    pseudorandomly generated and nonzero. This makes the length of the\n    encryption block EB equal to k. */\n\n  // build the encryption block\n  eb.putByte(0x00);\n  eb.putByte(bt);\n\n  // create the padding\n  var padNum = k - 3 - m.length;\n  var padByte;\n  // private key op\n  if(bt === 0x00 || bt === 0x01) {\n    padByte = (bt === 0x00) ? 0x00 : 0xFF;\n    for(var i = 0; i < padNum; ++i) {\n      eb.putByte(padByte);\n    }\n  } else {\n    // public key op\n    // pad with random non-zero values\n    while(padNum > 0) {\n      var numZeros = 0;\n      var padBytes = forge.random.getBytes(padNum);\n      for(var i = 0; i < padNum; ++i) {\n        padByte = padBytes.charCodeAt(i);\n        if(padByte === 0) {\n          ++numZeros;\n        } else {\n          eb.putByte(padByte);\n        }\n      }\n      padNum = numZeros;\n    }\n  }\n\n  // zero followed by message\n  eb.putByte(0x00);\n  eb.putBytes(m);\n\n  return eb;\n}\n\n/**\n * Decodes a message using PKCS#1 v1.5 padding.\n *\n * @param em the message to decode.\n * @param key the RSA key to use.\n * @param pub true if the key is a public key, false if it is private.\n * @param ml the message length, if specified.\n *\n * @return the decoded bytes.\n */\nfunction _decodePkcs1_v1_5(em, key, pub, ml) {\n  // get the length of the modulus in bytes\n  var k = Math.ceil(key.n.bitLength() / 8);\n\n  /* It is an error if any of the following conditions occurs:\n\n    1. The encryption block EB cannot be parsed unambiguously.\n    2. The padding string PS consists of fewer than eight octets\n      or is inconsisent with the block type BT.\n    3. The decryption process is a public-key operation and the block\n      type BT is not 00 or 01, or the decryption process is a\n      private-key operation and the block type is not 02.\n   */\n\n  // parse the encryption block\n  var eb = forge.util.createBuffer(em);\n  var first = eb.getByte();\n  var bt = eb.getByte();\n  if(first !== 0x00 ||\n    (pub && bt !== 0x00 && bt !== 0x01) ||\n    (!pub && bt != 0x02) ||\n    (pub && bt === 0x00 && typeof(ml) === 'undefined')) {\n    throw new Error('Encryption block is invalid.');\n  }\n\n  var padNum = 0;\n  if(bt === 0x00) {\n    // check all padding bytes for 0x00\n    padNum = k - 3 - ml;\n    for(var i = 0; i < padNum; ++i) {\n      if(eb.getByte() !== 0x00) {\n        throw new Error('Encryption block is invalid.');\n      }\n    }\n  } else if(bt === 0x01) {\n    // find the first byte that isn't 0xFF, should be after all padding\n    padNum = 0;\n    while(eb.length() > 1) {\n      if(eb.getByte() !== 0xFF) {\n        --eb.read;\n        break;\n      }\n      ++padNum;\n    }\n  } else if(bt === 0x02) {\n    // look for 0x00 byte\n    padNum = 0;\n    while(eb.length() > 1) {\n      if(eb.getByte() === 0x00) {\n        --eb.read;\n        break;\n      }\n      ++padNum;\n    }\n  }\n\n  // zero must be 0x00 and padNum must be (k - 3 - message length)\n  var zero = eb.getByte();\n  if(zero !== 0x00 || padNum !== (k - 3 - eb.length())) {\n    throw new Error('Encryption block is invalid.');\n  }\n\n  return eb.getBytes();\n}\n\n/**\n * Runs the key-generation algorithm asynchronously, either in the background\n * via Web Workers, or using the main thread and setImmediate.\n *\n * @param state the key-pair generation state.\n * @param [options] options for key-pair generation:\n *          workerScript the worker script URL.\n *          workers the number of web workers (if supported) to use,\n *            (default: 2, -1 to use estimated cores minus one).\n *          workLoad the size of the work load, ie: number of possible prime\n *            numbers for each web worker to check per work assignment,\n *            (default: 100).\n * @param callback(err, keypair) called once the operation completes.\n */\nfunction _generateKeyPair(state, options, callback) {\n  if(typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n\n  var opts = {\n    algorithm: {\n      name: options.algorithm || 'PRIMEINC',\n      options: {\n        workers: options.workers || 2,\n        workLoad: options.workLoad || 100,\n        workerScript: options.workerScript\n      }\n    }\n  };\n  if('prng' in options) {\n    opts.prng = options.prng;\n  }\n\n  generate();\n\n  function generate() {\n    // find p and then q (done in series to simplify)\n    getPrime(state.pBits, function(err, num) {\n      if(err) {\n        return callback(err);\n      }\n      state.p = num;\n      if(state.q !== null) {\n        return finish(err, state.q);\n      }\n      getPrime(state.qBits, finish);\n    });\n  }\n\n  function getPrime(bits, callback) {\n    forge.prime.generateProbablePrime(bits, opts, callback);\n  }\n\n  function finish(err, num) {\n    if(err) {\n      return callback(err);\n    }\n\n    // set q\n    state.q = num;\n\n    // ensure p is larger than q (swap them if not)\n    if(state.p.compareTo(state.q) < 0) {\n      var tmp = state.p;\n      state.p = state.q;\n      state.q = tmp;\n    }\n\n    // ensure p is coprime with e\n    if(state.p.subtract(BigInteger.ONE).gcd(state.e)\n      .compareTo(BigInteger.ONE) !== 0) {\n      state.p = null;\n      generate();\n      return;\n    }\n\n    // ensure q is coprime with e\n    if(state.q.subtract(BigInteger.ONE).gcd(state.e)\n      .compareTo(BigInteger.ONE) !== 0) {\n      state.q = null;\n      getPrime(state.qBits, finish);\n      return;\n    }\n\n    // compute phi: (p - 1)(q - 1) (Euler's totient function)\n    state.p1 = state.p.subtract(BigInteger.ONE);\n    state.q1 = state.q.subtract(BigInteger.ONE);\n    state.phi = state.p1.multiply(state.q1);\n\n    // ensure e and phi are coprime\n    if(state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {\n      // phi and e aren't coprime, so generate a new p and q\n      state.p = state.q = null;\n      generate();\n      return;\n    }\n\n    // create n, ensure n is has the right number of bits\n    state.n = state.p.multiply(state.q);\n    if(state.n.bitLength() !== state.bits) {\n      // failed, get new q\n      state.q = null;\n      getPrime(state.qBits, finish);\n      return;\n    }\n\n    // set keys\n    var d = state.e.modInverse(state.phi);\n    state.keys = {\n      privateKey: pki.rsa.setPrivateKey(\n        state.n, state.e, d, state.p, state.q,\n        d.mod(state.p1), d.mod(state.q1),\n        state.q.modInverse(state.p)),\n      publicKey: pki.rsa.setPublicKey(state.n, state.e)\n    };\n\n    callback(null, state.keys);\n  }\n}\n\n/**\n * Converts a positive BigInteger into 2's-complement big-endian bytes.\n *\n * @param b the big integer to convert.\n *\n * @return the bytes.\n */\nfunction _bnToBytes(b) {\n  // prepend 0x00 if first byte >= 0x80\n  var hex = b.toString(16);\n  if(hex[0] >= '8') {\n    hex = '00' + hex;\n  }\n  var bytes = forge.util.hexToBytes(hex);\n\n  // ensure integer is minimally-encoded\n  if(bytes.length > 1 &&\n    // leading 0x00 for positive integer\n    ((bytes.charCodeAt(0) === 0 &&\n    (bytes.charCodeAt(1) & 0x80) === 0) ||\n    // leading 0xFF for negative integer\n    (bytes.charCodeAt(0) === 0xFF &&\n    (bytes.charCodeAt(1) & 0x80) === 0x80))) {\n    return bytes.substr(1);\n  }\n  return bytes;\n}\n\n/**\n * Returns the required number of Miller-Rabin tests to generate a\n * prime with an error probability of (1/2)^80.\n *\n * See Handbook of Applied Cryptography Chapter 4, Table 4.4.\n *\n * @param bits the bit size.\n *\n * @return the required number of iterations.\n */\nfunction _getMillerRabinTests(bits) {\n  if(bits <= 100) return 27;\n  if(bits <= 150) return 18;\n  if(bits <= 200) return 15;\n  if(bits <= 250) return 12;\n  if(bits <= 300) return 9;\n  if(bits <= 350) return 8;\n  if(bits <= 400) return 7;\n  if(bits <= 500) return 6;\n  if(bits <= 600) return 5;\n  if(bits <= 800) return 4;\n  if(bits <= 1250) return 3;\n  return 2;\n}\n\n/**\n * Performs feature detection on the Node crypto interface.\n *\n * @param fn the feature (function) to detect.\n *\n * @return true if detected, false if not.\n */\nfunction _detectNodeCrypto(fn) {\n  return forge.util.isNodejs && typeof _crypto[fn] === 'function';\n}\n\n/**\n * Performs feature detection on the SubtleCrypto interface.\n *\n * @param fn the feature (function) to detect.\n *\n * @return true if detected, false if not.\n */\nfunction _detectSubtleCrypto(fn) {\n  return (typeof util.globalScope !== 'undefined' &&\n    typeof util.globalScope.crypto === 'object' &&\n    typeof util.globalScope.crypto.subtle === 'object' &&\n    typeof util.globalScope.crypto.subtle[fn] === 'function');\n}\n\n/**\n * Performs feature detection on the deprecated Microsoft Internet Explorer\n * outdated SubtleCrypto interface. This function should only be used after\n * checking for the modern, standard SubtleCrypto interface.\n *\n * @param fn the feature (function) to detect.\n *\n * @return true if detected, false if not.\n */\nfunction _detectSubtleMsCrypto(fn) {\n  return (typeof util.globalScope !== 'undefined' &&\n    typeof util.globalScope.msCrypto === 'object' &&\n    typeof util.globalScope.msCrypto.subtle === 'object' &&\n    typeof util.globalScope.msCrypto.subtle[fn] === 'function');\n}\n\nfunction _intToUint8Array(x) {\n  var bytes = forge.util.hexToBytes(x.toString(16));\n  var buffer = new Uint8Array(bytes.length);\n  for(var i = 0; i < bytes.length; ++i) {\n    buffer[i] = bytes.charCodeAt(i);\n  }\n  return buffer;\n}\n\nfunction _privateKeyFromJwk(jwk) {\n  if(jwk.kty !== 'RSA') {\n    throw new Error(\n      'Unsupported key algorithm \"' + jwk.kty + '\"; algorithm must be \"RSA\".');\n  }\n  return pki.setRsaPrivateKey(\n    _base64ToBigInt(jwk.n),\n    _base64ToBigInt(jwk.e),\n    _base64ToBigInt(jwk.d),\n    _base64ToBigInt(jwk.p),\n    _base64ToBigInt(jwk.q),\n    _base64ToBigInt(jwk.dp),\n    _base64ToBigInt(jwk.dq),\n    _base64ToBigInt(jwk.qi));\n}\n\nfunction _publicKeyFromJwk(jwk) {\n  if(jwk.kty !== 'RSA') {\n    throw new Error('Key algorithm must be \"RSA\".');\n  }\n  return pki.setRsaPublicKey(\n    _base64ToBigInt(jwk.n),\n    _base64ToBigInt(jwk.e));\n}\n\nfunction _base64ToBigInt(b64) {\n  return new BigInteger(forge.util.bytesToHex(forge.util.decode64(b64)), 16);\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2022-24799", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "/*\n * Wire\n * Copyright (C) 2019 Wire Swiss GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see http://www.gnu.org/licenses/.\n *\n */\n\nimport hljs from 'highlight.js';\nimport MarkdownIt from 'markdown-it';\nimport type Token from 'markdown-it/lib/token';\nimport {escape} from 'underscore';\n\nimport {replaceInRange} from './StringUtil';\n\nimport {QualifiedId} from '@wireapp/api-client/src/user';\nimport type {MentionEntity} from '../message/MentionEntity';\n\ninterface MentionText {\n  domain: string | null;\n  isSelfMentioned: boolean;\n  text: string;\n  userId: string;\n}\n\ninterface MarkdownItWithOptions extends MarkdownIt {\n  options: MarkdownIt.Options;\n}\n\n// Note: We are using \"Underscore.js\" to escape HTML in the original message\nconst markdownit = new MarkdownIt('zero', {\n  breaks: true,\n  html: false,\n  langPrefix: 'lang-',\n  linkify: true,\n}).enable(['autolink', 'backticks', 'code', 'emphasis', 'escape', 'fence', 'heading', 'link', 'linkify', 'newline']);\n\nconst originalFenceRule = markdownit.renderer.rules.fence;\n\nmarkdownit.renderer.rules.fence = (tokens, idx, options, env, self) => {\n  const highlighted = originalFenceRule(tokens, idx, options, env, self);\n  tokens[idx].map[1] += 1;\n  return highlighted.replace(/\\n$/, '');\n};\n\nmarkdownit.renderer.rules.heading_open = () => '<div class=\"md-heading\">';\nmarkdownit.renderer.rules.heading_close = () => '</div>';\n\nmarkdownit.renderer.rules.softbreak = () => '<br>';\nmarkdownit.renderer.rules.hardbreak = () => '<br>';\nmarkdownit.renderer.rules.paragraph_open = (tokens, idx) => {\n  const [position] = tokens[idx].map;\n  const previousWithMap = tokens\n    .slice(0, idx)\n    .reverse()\n    .find(({map}) => map?.length);\n  const previousPosition = previousWithMap ? previousWithMap.map[1] - 1 : 0;\n  const count = position - previousPosition;\n  return '<br>'.repeat(Math.max(count, 0));\n};\nmarkdownit.renderer.rules.paragraph_close = () => '';\n\n// https://github.com/markdown-it/markdown-it/issues/458#issuecomment-401221267\nfunction modifyMarkdownLinks(markdown: string): string {\n  const matches = markdownit.linkify.match(markdown);\n  if (!matches || matches.length === 0) {\n    return markdown;\n  }\n  const result = [];\n  let prevEndIndex = 0;\n  for (const match of matches) {\n    const startsWithProto = /^https?:\\/\\//i.test(match.raw);\n    const noStartBracket = match.index === 0 || markdown[match.index - 1] !== '<';\n    const noEndBracket = match.lastIndex === markdown.length || markdown[match.lastIndex] !== '>';\n    const shouldInsertBrackets = startsWithProto && noStartBracket && noEndBracket;\n\n    result.push(markdown.slice(prevEndIndex, match.index));\n    result.push(shouldInsertBrackets ? `<${match.raw}>` : match.raw);\n    prevEndIndex = match.lastIndex;\n  }\n  result.push(markdown.slice(prevEndIndex));\n  return result.join('');\n}\n\nmarkdownit.normalizeLinkText = text => text;\n\nexport const renderMessage = (message: string, selfId: QualifiedId | null, mentionEntities: MentionEntity[] = []) => {\n  const createMentionHash = (mention: MentionEntity) => `@@${window.btoa(JSON.stringify(mention)).replace(/=/g, '')}`;\n  const renderMention = (mentionData: MentionText) => {\n    const elementClasses = mentionData.isSelfMentioned ? ' self-mention' : '';\n    let elementAttributes = mentionData.isSelfMentioned\n      ? ' data-uie-name=\"label-self-mention\"'\n      : ` data-uie-name=\"label-other-mention\" data-user-id=\"${mentionData.userId}\"`;\n    if (!mentionData.isSelfMentioned && mentionData.domain) {\n      elementAttributes += ` data-user-domain=\"${mentionData.domain}\"`;\n    }\n\n    const mentionText = mentionData.text.replace(/^@/, '');\n    const content = `<span class=\"mention-at-sign\">@</span>${escape(mentionText)}`;\n    return `<span class=\"message-mention${elementClasses}\"${elementAttributes}>${content}</span>`;\n  };\n\n  const mentionTexts: Record<string, MentionText> = {};\n\n  let mentionlessText = mentionEntities\n    .slice()\n    // sort mentions to start with the latest mention first (in order not to have to recompute the index every time we modify the original text)\n    .sort((mention1, mention2) => mention2.startIndex - mention1.startIndex)\n    .reduce((strippedText, mention) => {\n      const mentionText = message.slice(mention.startIndex, mention.startIndex + mention.length);\n      const mentionKey = createMentionHash(mention);\n      mentionTexts[mentionKey] = {\n        domain: mention.domain,\n        isSelfMentioned: !!selfId && mention.targetsUser(selfId),\n        text: mentionText,\n        userId: mention.userId,\n      };\n      return replaceInRange(strippedText, mentionKey, mention.startIndex, mention.startIndex + mention.length);\n    }, message);\n\n  markdownit.set({\n    highlight: function (code): string {\n      const containsMentions = mentionEntities.some(mention => {\n        const hash = createMentionHash(mention);\n        return code.includes(hash);\n      });\n      if (containsMentions) {\n        // disable code highlighting if there is a mention in there\n        // highlighting will be wrong anyway because this is not valid code\n        return code;\n      }\n      return hljs.highlightAuto(code).value;\n    },\n  });\n\n  markdownit.renderer.rules.link_open = (tokens, idx, options, env, self) => {\n    const cleanString = (hashedString: string) =>\n      escape(\n        Object.entries(mentionTexts).reduce(\n          (text, [mentionHash, mention]) => text.replace(mentionHash, mention.text),\n          hashedString,\n        ),\n      );\n    const link = tokens[idx];\n    const href = cleanString(link.attrGet('href'));\n    const isEmail = href.startsWith('mailto:');\n    const isWireDeepLink = href.toLowerCase().startsWith('wire://');\n    const nextToken = tokens[idx + 1];\n    const text = nextToken?.type === 'text' ? nextToken.content : '';\n\n    if (!href || !text.trim()) {\n      nextToken.content = '';\n      const closeToken = tokens.slice(idx).find(token => token.type === 'link_close');\n      closeToken.type = 'text';\n      closeToken.content = '';\n      return `[${cleanString(text)}](${cleanString(href)})`;\n    }\n    if (isEmail) {\n      link.attrPush(['data-email-link', 'true']);\n    } else {\n      link.attrPush(['target', '_blank']);\n      link.attrPush(['rel', 'nofollow noopener noreferrer']);\n    }\n    if (!isWireDeepLink && !['autolink', 'linkify'].includes(link.markup)) {\n      const title = link.attrGet('title');\n      if (title) {\n        link.attrSet('title', cleanString(title));\n      }\n      link.attrSet('href', cleanString(href));\n      if (nextToken?.type === 'text') {\n        nextToken.content = text;\n      }\n      link.attrPush(['data-md-link', 'true']);\n      link.attrPush(['data-uie-name', 'markdown-link']);\n    }\n    if (isWireDeepLink) {\n      link.attrPush(['data-uie-name', 'wire-deep-link']);\n    }\n    if (link.markup === 'linkify') {\n      nextToken.content = encodeURI(nextToken.content);\n    }\n    return self.renderToken(tokens, idx, options);\n  };\n  const originalTokens = markdownit.parse(mentionlessText, {});\n  mentionlessText = modifyMarkdownLinks(mentionlessText);\n  const modifiedLinksTokens = markdownit.parse(mentionlessText, {});\n  const fixCodeTokens = (modifiedTokens: Token[], originalTokens: Token[]) =>\n    modifiedTokens.map((modifiedToken, index) => {\n      const originalToken = originalTokens[index];\n      if (modifiedToken.tag === 'code') {\n        return originalToken;\n      }\n      if (modifiedToken.children) {\n        modifiedToken.children = fixCodeTokens(modifiedToken.children, originalToken.children);\n      }\n      return modifiedToken;\n    });\n  const fixedTokens = fixCodeTokens(modifiedLinksTokens, originalTokens);\n  mentionlessText = markdownit.renderer.render(fixedTokens, (markdownit as MarkdownItWithOptions).options, {});\n  // Remove <br> and \\n if it is the last thing in a message\n  mentionlessText = mentionlessText.replace(/(<br>|\\n)*$/, '');\n\n  const parsedText = Object.keys(mentionTexts).reduce((text, mentionHash) => {\n    const mentionMarkup = renderMention(mentionTexts[mentionHash]);\n\n    return text.replace(mentionHash, mentionMarkup);\n  }, mentionlessText);\n  return parsedText;\n};\n\nexport const getRenderedTextContent = (text: string): string => {\n  const renderedMessage = renderMessage(text, {domain: '', id: ''});\n  const messageWithLinebreaks = renderedMessage.replace(/<br>/g, '\\n');\n  const strippedMessage = messageWithLinebreaks.replace(/<.+?>/g, '');\n  return markdownit.utils.unescapeAll(strippedMessage);\n};\n", "output": {"vulnerability_count": 2, "vulnerabilities": [{"description": "This template literal looks like HTML and has interpolated variables. These variables are not HTML-encoded by default. If the variables contain HTML tags, these may be interpreted by the browser, resulting in cross-site scripting (XSS).", "risk": "Medium", "conceptual_fix": "Not provided", "line": 110}, {"description": "This template literal looks like HTML and has interpolated variables. These variables are not HTML-encoded by default. If the variables contain HTML tags, these may be interpreted by the browser, resulting in cross-site scripting (XSS).", "risk": "Medium", "conceptual_fix": "Not provided", "line": 111}]}}
{"CVE": "CVE-2022-24802", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "import type {\n  DeepMergeBuiltInMetaData,\n  DeepMergeHKT,\n  DeepMergeArraysDefaultHKT,\n  DeepMergeMergeFunctionsDefaultURIs,\n  DeepMergeMapsDefaultHKT,\n  DeepMergeMergeFunctionsURIs,\n  DeepMergeOptions,\n  DeepMergeRecordsDefaultHKT,\n  DeepMergeSetsDefaultHKT,\n  DeepMergeMergeFunctionUtils,\n  GetDeepMergeMergeFunctionsURIs,\n} from \"./types\";\nimport {\n  getIterableOfIterables,\n  getKeys,\n  getObjectType,\n  ObjectType,\n  objectHasProperty,\n} from \"./utils\";\n\nconst defaultMergeFunctions = {\n  mergeMaps: defaultMergeMaps,\n  mergeSets: defaultMergeSets,\n  mergeArrays: defaultMergeArrays,\n  mergeRecords: defaultMergeRecords,\n  mergeOthers: leaf,\n} as const;\n\n/**\n * Special values that tell deepmerge-ts to perform a certain action.\n */\nconst actions = {\n  defaultMerge: Symbol(\"deepmerge-ts: default merge\"),\n  skip: Symbol(\"deepmerge-ts: skip\"),\n} as const;\n\n/**\n * The default function to update meta data.\n */\nfunction defaultMetaDataUpdater<M>(\n  previousMeta: M,\n  metaMeta: DeepMergeBuiltInMetaData\n): DeepMergeBuiltInMetaData {\n  return metaMeta;\n}\n\n/**\n * The default merge functions.\n */\nexport type DeepMergeMergeFunctionsDefaults = typeof defaultMergeFunctions;\n\n/**\n * Deeply merge objects.\n *\n * @param objects - The objects to merge.\n */\nexport function deepmerge<Ts extends Readonly<ReadonlyArray<unknown>>>(\n  ...objects: readonly [...Ts]\n): DeepMergeHKT<\n  Ts,\n  DeepMergeMergeFunctionsDefaultURIs,\n  DeepMergeBuiltInMetaData\n> {\n  return deepmergeCustom({})(...objects) as DeepMergeHKT<\n    Ts,\n    DeepMergeMergeFunctionsDefaultURIs,\n    DeepMergeBuiltInMetaData\n  >;\n}\n\n/**\n * Deeply merge two or more objects using the given options.\n *\n * @param options - The options on how to customize the merge function.\n */\nexport function deepmergeCustom<\n  PMF extends Partial<DeepMergeMergeFunctionsURIs>\n>(\n  options: DeepMergeOptions<DeepMergeBuiltInMetaData, DeepMergeBuiltInMetaData>\n): <Ts extends ReadonlyArray<unknown>>(\n  ...objects: Ts\n) => DeepMergeHKT<\n  Ts,\n  GetDeepMergeMergeFunctionsURIs<PMF>,\n  DeepMergeBuiltInMetaData\n>;\n\n/**\n * Deeply merge two or more objects using the given options and meta data.\n *\n * @param options - The options on how to customize the merge function.\n * @param rootMetaData - The meta data passed to the root items' being merged.\n */\nexport function deepmergeCustom<\n  PMF extends Partial<DeepMergeMergeFunctionsURIs>,\n  MetaData,\n  MetaMetaData extends DeepMergeBuiltInMetaData = DeepMergeBuiltInMetaData\n>(\n  options: DeepMergeOptions<MetaData, MetaMetaData>,\n  rootMetaData?: MetaData\n): <Ts extends ReadonlyArray<unknown>>(\n  ...objects: Ts\n) => DeepMergeHKT<Ts, GetDeepMergeMergeFunctionsURIs<PMF>, MetaData>;\n\nexport function deepmergeCustom<\n  PMF extends Partial<DeepMergeMergeFunctionsURIs>,\n  MetaData,\n  MetaMetaData extends DeepMergeBuiltInMetaData\n>(\n  options: DeepMergeOptions<MetaData, MetaMetaData>,\n  rootMetaData?: MetaData\n): <Ts extends ReadonlyArray<unknown>>(\n  ...objects: Ts\n) => DeepMergeHKT<Ts, GetDeepMergeMergeFunctionsURIs<PMF>, MetaData> {\n  /**\n   * The type of the customized deepmerge function.\n   */\n  type CustomizedDeepmerge = <Ts extends ReadonlyArray<unknown>>(\n    ...objects: Ts\n  ) => DeepMergeHKT<Ts, GetDeepMergeMergeFunctionsURIs<PMF>, MetaData>;\n\n  const utils: DeepMergeMergeFunctionUtils<MetaData, MetaMetaData> = getUtils(\n    options,\n    customizedDeepmerge as CustomizedDeepmerge\n  );\n\n  /**\n   * The customized deepmerge function.\n   */\n  function customizedDeepmerge(...objects: ReadonlyArray<unknown>) {\n    return mergeUnknowns<\n      ReadonlyArray<unknown>,\n      typeof utils,\n      GetDeepMergeMergeFunctionsURIs<PMF>,\n      MetaData,\n      MetaMetaData\n    >(objects, utils, rootMetaData);\n  }\n\n  return customizedDeepmerge as CustomizedDeepmerge;\n}\n\n/**\n * The the full options with defaults apply.\n *\n * @param options - The options the user specified\n */\nfunction getUtils<M, MM extends DeepMergeBuiltInMetaData>(\n  options: DeepMergeOptions<M, MM>,\n  customizedDeepmerge: DeepMergeMergeFunctionUtils<M, MM>[\"deepmerge\"]\n): DeepMergeMergeFunctionUtils<M, MM> {\n  return {\n    defaultMergeFunctions,\n    mergeFunctions: {\n      ...defaultMergeFunctions,\n      ...Object.fromEntries(\n        Object.entries(options)\n          .filter(([key, option]) =>\n            Object.prototype.hasOwnProperty.call(defaultMergeFunctions, key)\n          )\n          .map(([key, option]) =>\n            option === false ? [key, leaf] : [key, option]\n          )\n      ),\n    } as DeepMergeMergeFunctionUtils<M, MM>[\"mergeFunctions\"],\n    metaDataUpdater: (options.metaDataUpdater ??\n      defaultMetaDataUpdater) as unknown as DeepMergeMergeFunctionUtils<\n      M,\n      MM\n    >[\"metaDataUpdater\"],\n    deepmerge: customizedDeepmerge,\n    useImplicitDefaultMerging: options.enableImplicitDefaultMerging ?? false,\n    actions,\n  };\n}\n\n/**\n * Merge unknown things.\n *\n * @param values - The values.\n */\nfunction mergeUnknowns<\n  Ts extends ReadonlyArray<unknown>,\n  U extends DeepMergeMergeFunctionUtils<M, MM>,\n  MF extends DeepMergeMergeFunctionsURIs,\n  M,\n  MM extends DeepMergeBuiltInMetaData\n>(values: Ts, utils: U, meta: M | undefined): DeepMergeHKT<Ts, MF, M> {\n  if (values.length === 0) {\n    return undefined as DeepMergeHKT<Ts, MF, M>;\n  }\n  if (values.length === 1) {\n    return mergeOthers<U, M, MM>(values, utils, meta) as DeepMergeHKT<\n      Ts,\n      MF,\n      M\n    >;\n  }\n\n  const type = getObjectType(values[0]);\n\n  // eslint-disable-next-line functional/no-conditional-statement -- add an early escape for better performance.\n  if (type !== ObjectType.NOT && type !== ObjectType.OTHER) {\n    // eslint-disable-next-line functional/no-loop-statement -- using a loop here is more performant than mapping every value and then testing every value.\n    for (let mutableIndex = 1; mutableIndex < values.length; mutableIndex++) {\n      if (getObjectType(values[mutableIndex]) === type) {\n        continue;\n      }\n\n      return mergeOthers<U, M, MM>(values, utils, meta) as DeepMergeHKT<\n        Ts,\n        MF,\n        M\n      >;\n    }\n  }\n\n  switch (type) {\n    case ObjectType.RECORD:\n      return mergeRecords<U, MF, M, MM>(\n        values as ReadonlyArray<Readonly<Record<PropertyKey, unknown>>>,\n        utils,\n        meta\n      ) as DeepMergeHKT<Ts, MF, M>;\n\n    case ObjectType.ARRAY:\n      return mergeArrays<U, M, MM>(\n        values as ReadonlyArray<Readonly<ReadonlyArray<unknown>>>,\n        utils,\n        meta\n      ) as DeepMergeHKT<Ts, MF, M>;\n\n    case ObjectType.SET:\n      return mergeSets<U, M, MM>(\n        values as ReadonlyArray<Readonly<ReadonlySet<unknown>>>,\n        utils,\n        meta\n      ) as DeepMergeHKT<Ts, MF, M>;\n\n    case ObjectType.MAP:\n      return mergeMaps<U, M, MM>(\n        values as ReadonlyArray<Readonly<ReadonlyMap<unknown, unknown>>>,\n        utils,\n        meta\n      ) as DeepMergeHKT<Ts, MF, M>;\n\n    default:\n      return mergeOthers<U, M, MM>(values, utils, meta) as DeepMergeHKT<\n        Ts,\n        MF,\n        M\n      >;\n  }\n}\n\n/**\n * Merge records.\n *\n * @param values - The records.\n */\nfunction mergeRecords<\n  U extends DeepMergeMergeFunctionUtils<M, MM>,\n  MF extends DeepMergeMergeFunctionsURIs,\n  M,\n  MM extends DeepMergeBuiltInMetaData\n>(\n  values: ReadonlyArray<Readonly<Record<PropertyKey, unknown>>>,\n  utils: U,\n  meta: M | undefined\n) {\n  const result = utils.mergeFunctions.mergeRecords(values, utils, meta);\n\n  if (\n    result === actions.defaultMerge ||\n    (utils.useImplicitDefaultMerging &&\n      result === undefined &&\n      utils.mergeFunctions.mergeRecords !==\n        utils.defaultMergeFunctions.mergeRecords)\n  ) {\n    return utils.defaultMergeFunctions.mergeRecords<\n      ReadonlyArray<Readonly<Record<PropertyKey, unknown>>>,\n      U,\n      MF,\n      M,\n      MM\n    >(values, utils, meta);\n  }\n\n  return result;\n}\n\n/**\n * Merge arrays.\n *\n * @param values - The arrays.\n */\nfunction mergeArrays<\n  U extends DeepMergeMergeFunctionUtils<M, MM>,\n  M,\n  MM extends DeepMergeBuiltInMetaData\n>(\n  values: ReadonlyArray<Readonly<ReadonlyArray<unknown>>>,\n  utils: U,\n  meta: M | undefined\n) {\n  const result = utils.mergeFunctions.mergeArrays(values, utils, meta);\n\n  if (\n    result === actions.defaultMerge ||\n    (utils.useImplicitDefaultMerging &&\n      result === undefined &&\n      utils.mergeFunctions.mergeArrays !==\n        utils.defaultMergeFunctions.mergeArrays)\n  ) {\n    return utils.defaultMergeFunctions.mergeArrays(values);\n  }\n  return result;\n}\n\n/**\n * Merge sets.\n *\n * @param values - The sets.\n */\nfunction mergeSets<\n  U extends DeepMergeMergeFunctionUtils<M, MM>,\n  M,\n  MM extends DeepMergeBuiltInMetaData\n>(\n  values: ReadonlyArray<Readonly<ReadonlySet<unknown>>>,\n  utils: U,\n  meta: M | undefined\n) {\n  const result = utils.mergeFunctions.mergeSets(values, utils, meta);\n\n  if (\n    result === actions.defaultMerge ||\n    (utils.useImplicitDefaultMerging &&\n      result === undefined &&\n      utils.mergeFunctions.mergeSets !== utils.defaultMergeFunctions.mergeSets)\n  ) {\n    return utils.defaultMergeFunctions.mergeSets(values);\n  }\n  return result;\n}\n\n/**\n * Merge maps.\n *\n * @param values - The maps.\n */\nfunction mergeMaps<\n  U extends DeepMergeMergeFunctionUtils<M, MM>,\n  M,\n  MM extends DeepMergeBuiltInMetaData\n>(\n  values: ReadonlyArray<Readonly<ReadonlyMap<unknown, unknown>>>,\n  utils: U,\n  meta: M | undefined\n) {\n  const result = utils.mergeFunctions.mergeMaps(values, utils, meta);\n\n  if (\n    result === actions.defaultMerge ||\n    (utils.useImplicitDefaultMerging &&\n      result === undefined &&\n      utils.mergeFunctions.mergeMaps !== utils.defaultMergeFunctions.mergeMaps)\n  ) {\n    return utils.defaultMergeFunctions.mergeMaps(values);\n  }\n  return result;\n}\n\n/**\n * Merge other things.\n *\n * @param values - The other things.\n */\nfunction mergeOthers<\n  U extends DeepMergeMergeFunctionUtils<M, MM>,\n  M,\n  MM extends DeepMergeBuiltInMetaData\n>(values: ReadonlyArray<unknown>, utils: U, meta: M | undefined) {\n  const result = utils.mergeFunctions.mergeOthers(values, utils, meta);\n\n  if (\n    result === actions.defaultMerge ||\n    (utils.useImplicitDefaultMerging &&\n      result === undefined &&\n      utils.mergeFunctions.mergeOthers !==\n        utils.defaultMergeFunctions.mergeOthers)\n  ) {\n    return utils.defaultMergeFunctions.mergeOthers(values);\n  }\n  return result;\n}\n\n/**\n * The default strategy to merge records.\n *\n * @param values - The records.\n */\nfunction defaultMergeRecords<\n  Ts extends ReadonlyArray<Record<PropertyKey, unknown>>,\n  U extends DeepMergeMergeFunctionUtils<M, MM>,\n  MF extends DeepMergeMergeFunctionsURIs,\n  M,\n  MM extends DeepMergeBuiltInMetaData\n>(values: Ts, utils: U, meta: M | undefined) {\n  const result: Record<PropertyKey, unknown> = {};\n\n  /* eslint-disable functional/no-loop-statement, functional/no-conditional-statement -- using a loop here is more performant. */\n\n  for (const key of getKeys(values)) {\n    const propValues = [];\n\n    for (const value of values) {\n      if (objectHasProperty(value, key)) {\n        propValues.push(value[key]);\n      }\n    }\n\n    // assert(propValues.length > 0);\n\n    const updatedMeta = utils.metaDataUpdater(meta, {\n      key,\n      parents: values,\n    } as unknown as MM);\n\n    const propertyResult = mergeUnknowns<ReadonlyArray<unknown>, U, MF, M, MM>(\n      propValues,\n      utils,\n      updatedMeta\n    );\n\n    if (propertyResult === actions.skip) {\n      continue;\n    }\n\n    result[key] = propertyResult;\n  }\n\n  /* eslint-enable functional/no-loop-statement, functional/no-conditional-statement */\n\n  return result as DeepMergeRecordsDefaultHKT<Ts, MF, M>;\n}\n\n/**\n * The default strategy to merge arrays.\n *\n * @param values - The arrays.\n */\nfunction defaultMergeArrays<\n  Ts extends ReadonlyArray<ReadonlyArray<unknown>>,\n  MF extends DeepMergeMergeFunctionsURIs,\n  M\n>(values: Ts) {\n  return values.flat() as DeepMergeArraysDefaultHKT<Ts, MF, M>;\n}\n\n/**\n * The default strategy to merge sets.\n *\n * @param values - The sets.\n */\nfunction defaultMergeSets<\n  Ts extends ReadonlyArray<Readonly<ReadonlySet<unknown>>>\n>(values: Ts) {\n  return new Set(getIterableOfIterables(values)) as DeepMergeSetsDefaultHKT<Ts>;\n}\n\n/**\n * The default strategy to merge maps.\n *\n * @param values - The maps.\n */\nfunction defaultMergeMaps<\n  Ts extends ReadonlyArray<Readonly<ReadonlyMap<unknown, unknown>>>\n>(values: Ts) {\n  return new Map(getIterableOfIterables(values)) as DeepMergeMapsDefaultHKT<Ts>;\n}\n\n/**\n * Get the last value in the given array.\n */\nfunction leaf<Ts extends ReadonlyArray<unknown>>(values: Ts) {\n  return values[values.length - 1];\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2022-24833", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "/**\n * PrivateBin\n *\n * a zero-knowledge paste bin\n *\n * @see       {@link https://github.com/PrivateBin/PrivateBin}\n * @copyright 2012 Sbastien SAUVAGE ({@link http://sebsauvage.net})\n * @license   {@link https://www.opensource.org/licenses/zlib-license.php The zlib/libpng License}\n * @version   1.3.5\n * @name      PrivateBin\n * @namespace\n */\n\n// global Base64, DOMPurify, FileReader, RawDeflate, history, navigator, prettyPrint, prettyPrintOne, showdown, kjua\n\njQuery.fn.draghover = function() {\n    'use strict';\n    return this.each(function() {\n        let collection = $(),\n            self = $(this);\n\n        self.on('dragenter', function(e) {\n            if (collection.length === 0) {\n                self.trigger('draghoverstart');\n            }\n            collection = collection.add(e.target);\n        });\n\n        self.on('dragleave drop', function(e) {\n            collection = collection.not(e.target);\n            if (collection.length === 0) {\n                self.trigger('draghoverend');\n            }\n        });\n    });\n};\n\n// main application start, called when DOM is fully loaded\njQuery(document).ready(function() {\n    'use strict';\n    // run main controller\n    $.PrivateBin.Controller.init();\n});\n\njQuery.PrivateBin = (function($, RawDeflate) {\n    'use strict';\n\n    /**\n     * zlib library interface\n     *\n     * @private\n     */\n    let z;\n\n    /**\n     * CryptoData class\n     *\n     * bundles helper fuctions used in both paste and comment formats\n     *\n     * @name CryptoData\n     * @class\n     */\n    function CryptoData(data) {\n        this.v = 1;\n        // store all keys in the default locations for drop-in replacement\n        for (let key in data) {\n            this[key] = data[key];\n        }\n\n        /**\n         * gets the cipher data (cipher text + adata)\n         *\n         * @name Paste.getCipherData\n         * @function\n         * @return {Array}|{string}\n         */\n        this.getCipherData = function()\n        {\n            return this.v === 1 ? this.data : [this.ct, this.adata];\n        }\n    }\n\n    /**\n     * Paste class\n     *\n     * bundles helper fuctions around the paste formats\n     *\n     * @name Paste\n     * @class\n     */\n    function Paste(data) {\n        // inherit constructor and methods of CryptoData\n        CryptoData.call(this, data);\n\n        /**\n         * gets the used formatter\n         *\n         * @name Paste.getFormat\n         * @function\n         * @return {string}\n         */\n        this.getFormat = function()\n        {\n            return this.v === 1 ? this.meta.formatter : this.adata[1];\n        }\n\n        /**\n         * gets the remaining seconds before the paste expires\n         *\n         * returns 0 if there is no expiration\n         *\n         * @name Paste.getTimeToLive\n         * @function\n         * @return {string}\n         */\n        this.getTimeToLive = function()\n        {\n            return (this.v === 1 ? this.meta.remaining_time : this.meta.time_to_live) || 0;\n        }\n\n        /**\n         * is burn-after-reading enabled\n         *\n         * @name Paste.isBurnAfterReadingEnabled\n         * @function\n         * @return {bool}\n         */\n        this.isBurnAfterReadingEnabled = function()\n        {\n            return (this.v === 1 ? this.meta.burnafterreading : this.adata[3]);\n        }\n\n        /**\n         * are discussions enabled\n         *\n         * @name Paste.isDiscussionEnabled\n         * @function\n         * @return {bool}\n         */\n        this.isDiscussionEnabled = function()\n        {\n            return (this.v === 1 ? this.meta.opendiscussion : this.adata[2]);\n        }\n    }\n\n    /**\n     * Comment class\n     *\n     * bundles helper fuctions around the comment formats\n     *\n     * @name Comment\n     * @class\n     */\n    function Comment(data) {\n        // inherit constructor and methods of CryptoData\n        CryptoData.call(this, data);\n\n        /**\n         * gets the UNIX timestamp of the comment creation\n         *\n         * @name Paste.getCreated\n         * @function\n         * @return {int}\n         */\n        this.getCreated = function()\n        {\n            return this.meta[this.v === 1 ? 'postdate' : 'created'];\n        }\n\n        /**\n         * gets the icon of the comment submitter\n         *\n         * @name Paste.getIcon\n         * @function\n         * @return {string}\n         */\n        this.getIcon = function()\n        {\n            return this.meta[this.v === 1 ? 'vizhash' : 'icon'] || '';\n        }\n    }\n\n    /**\n     * static Helper methods\n     *\n     * @name Helper\n     * @class\n     */\n    const Helper = (function () {\n        const me = {};\n\n        /**\n         * character to HTML entity lookup table\n         *\n         * @see    {@link https://github.com/janl/mustache.js/blob/master/mustache.js#L60}\n         * @name Helper.entityMap\n         * @private\n         * @enum   {Object}\n         * @readonly\n         */\n        const entityMap = {\n            '&': '&amp;',\n            '<': '&lt;',\n            '>': '&gt;',\n            '\"': '&quot;',\n            \"'\": '&#39;',\n            '/': '&#x2F;',\n            '`': '&#x60;',\n            '=': '&#x3D;'\n        };\n\n        /**\n         * number of seconds in a minute\n         *\n         * @name Helper.minute\n         * @private\n         * @enum   {number}\n         * @readonly\n         */\n        const minute = 60;\n\n        /**\n         * number of seconds in an hour\n         *\n         * = 60 * 60 seconds\n         *\n         * @name Helper.minute\n         * @private\n         * @enum   {number}\n         * @readonly\n         */\n        const hour = 3600;\n\n        /**\n         * number of seconds in a day\n         *\n         * = 60 * 60 * 24 seconds\n         *\n         * @name Helper.day\n         * @private\n         * @enum   {number}\n         * @readonly\n         */\n        const day = 86400;\n\n        /**\n         * number of seconds in a week\n         *\n         * = 60 * 60 * 24 * 7 seconds\n         *\n         * @name Helper.week\n         * @private\n         * @enum   {number}\n         * @readonly\n         */\n        const week = 604800;\n\n        /**\n         * number of seconds in a month (30 days, an approximation)\n         *\n         * = 60 * 60 * 24 * 30 seconds\n         *\n         * @name Helper.month\n         * @private\n         * @enum   {number}\n         * @readonly\n         */\n        const month = 2592000;\n\n        /**\n         * number of seconds in a non-leap year\n         *\n         * = 60 * 60 * 24 * 365 seconds\n         *\n         * @name Helper.year\n         * @private\n         * @enum   {number}\n         * @readonly\n         */\n        const year = 31536000;\n\n        /**\n         * cache for script location\n         *\n         * @name Helper.baseUri\n         * @private\n         * @enum   {string|null}\n         */\n        let baseUri = null;\n\n        /**\n         * converts a duration (in seconds) into human friendly approximation\n         *\n         * @name Helper.secondsToHuman\n         * @function\n         * @param  {number} seconds\n         * @return {Array}\n         */\n        me.secondsToHuman = function(seconds)\n        {\n            let v;\n            if (seconds < minute)\n            {\n                v = Math.floor(seconds);\n                return [v, 'second'];\n            }\n            if (seconds < hour)\n            {\n                v = Math.floor(seconds / minute);\n                return [v, 'minute'];\n            }\n            if (seconds < day)\n            {\n                v = Math.floor(seconds / hour);\n                return [v, 'hour'];\n            }\n            // If less than 2 months, display in days:\n            if (seconds < (2 * month))\n            {\n                v = Math.floor(seconds / day);\n                return [v, 'day'];\n            }\n            v = Math.floor(seconds / month);\n            return [v, 'month'];\n        };\n\n        /**\n         * converts a duration string into seconds\n         *\n         * The string is expected to be optional digits, followed by a time.\n         * Supported times are: min, hour, day, month, year, never\n         * Examples: 5min, 13hour, never\n         *\n         * @name Helper.durationToSeconds\n         * @function\n         * @param  {String} duration\n         * @return {number}\n         */\n        me.durationToSeconds = function(duration)\n        {\n            let pieces   = duration.split(/(\\D+)/),\n                factor   = pieces[0] || 0,\n                timespan = pieces[1] || pieces[0];\n            switch (timespan)\n            {\n                case 'min':\n                    return factor * minute;\n                case 'hour':\n                    return factor * hour;\n                case 'day':\n                    return factor * day;\n                case 'week':\n                    return factor * week;\n                case 'month':\n                    return factor * month;\n                case 'year':\n                    return factor * year;\n                case 'never':\n                    return 0;\n                default:\n                    return factor;\n            }\n        };\n\n        /**\n         * text range selection\n         *\n         * @see    {@link https://stackoverflow.com/questions/985272/jquery-selecting-text-in-an-element-akin-to-highlighting-with-your-mouse}\n         * @name   Helper.selectText\n         * @function\n         * @param  {HTMLElement} element\n         */\n        me.selectText = function(element)\n        {\n            let range, selection;\n\n            // MS\n            if (document.body.createTextRange) {\n                range = document.body.createTextRange();\n                range.moveToElementText(element);\n                range.select();\n            } else if (window.getSelection) {\n                selection = window.getSelection();\n                range = document.createRange();\n                range.selectNodeContents(element);\n                selection.removeAllRanges();\n                selection.addRange(range);\n            }\n        };\n\n        /**\n         * convert URLs to clickable links in the provided element.\n         *\n         * URLs to handle:\n         * <pre>\n         *     magnet:?xt.1=urn:sha1:YNCKHTQCWBTRNJIV4WNAE52SJUQCZO5C&xt.2=urn:sha1:TXGCZQTH26NL6OUQAJJPFALHG2LTGBC7\n         *     https://example.com:8800/zero/?6f09182b8ea51997#WtLEUO5Epj9UHAV9JFs+6pUQZp13TuspAUjnF+iM+dM=\n         *     http://user:example.com@localhost:8800/zero/?6f09182b8ea51997#WtLEUO5Epj9UHAV9JFs+6pUQZp13TuspAUjnF+iM+dM=\n         * </pre>\n         *\n         * @name   Helper.urls2links\n         * @function\n         * @param  {HTMLElement} element\n         */\n        me.urls2links = function(element)\n        {\n            element.html(\n                DOMPurify.sanitize(\n                    element.html().replace(\n                        /(((https?|ftp):\\/\\/[\\w?!=&.\\/-;#@~%+*-]+(?![\\w\\s?!&.\\/;#~%\"=-]>))|((magnet):[\\w?=&.\\/-;#@~%+*-]+))/ig,\n                        '<a href=\"$1\" rel=\"nofollow noopener noreferrer\">$1</a>'\n                    )\n                )\n            );\n        };\n\n        /**\n         * minimal sprintf emulation for %s and %d formats\n         *\n         * Note that this function needs the parameters in the same order as the\n         * format strings appear in the string, contrary to the original.\n         *\n         * @see    {@link https://stackoverflow.com/questions/610406/javascript-equivalent-to-printf-string-format#4795914}\n         * @name   Helper.sprintf\n         * @function\n         * @param  {string} format\n         * @param  {...*} args - one or multiple parameters injected into format string\n         * @return {string}\n         */\n        me.sprintf = function()\n        {\n            const args = Array.prototype.slice.call(arguments);\n            let format = args[0],\n                i = 1;\n            return format.replace(/%(s|d)/g, function (m) {\n                let val = args[i];\n                if (m === '%d') {\n                    val = parseFloat(val);\n                    if (isNaN(val)) {\n                        val = 0;\n                    }\n                }\n                ++i;\n                return val;\n            });\n        };\n\n        /**\n         * get value of cookie, if it was set, empty string otherwise\n         *\n         * @see    {@link http://www.w3schools.com/js/js_cookies.asp}\n         * @name   Helper.getCookie\n         * @function\n         * @param  {string} cname - may not be empty\n         * @return {string}\n         */\n        me.getCookie = function(cname) {\n            const name = cname + '=',\n                  ca   = document.cookie.split(';');\n            for (let i = 0; i < ca.length; ++i) {\n                let c = ca[i];\n                while (c.charAt(0) === ' ')\n                {\n                    c = c.substring(1);\n                }\n                if (c.indexOf(name) === 0)\n                {\n                    return c.substring(name.length, c.length);\n                }\n            }\n            return '';\n        };\n\n        /**\n         * get the current location (without search or hash part of the URL),\n         * eg. https://example.com/path/?aaaa#bbbb --> https://example.com/path/\n         *\n         * @name   Helper.baseUri\n         * @function\n         * @return {string}\n         */\n        me.baseUri = function()\n        {\n            // check for cached version\n            if (baseUri !== null) {\n                return baseUri;\n            }\n\n            baseUri = window.location.origin + window.location.pathname;\n            return baseUri;\n        };\n\n        /**\n         * wrap an object into a Paste, used for mocking in the unit tests\n         *\n         * @name   Helper.PasteFactory\n         * @function\n         * @param  {object} data\n         * @return {Paste}\n         */\n        me.PasteFactory = function(data)\n        {\n            return new Paste(data);\n        };\n\n        /**\n         * wrap an object into a Comment, used for mocking in the unit tests\n         *\n         * @name   Helper.CommentFactory\n         * @function\n         * @param  {object} data\n         * @return {Comment}\n         */\n        me.CommentFactory = function(data)\n        {\n            return new Comment(data);\n        };\n\n        /**\n         * convert all applicable characters to HTML entities\n         *\n         * @see    {@link https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html}\n         * @name   Helper.htmlEntities\n         * @function\n         * @param  {string} str\n         * @return {string} escaped HTML\n         */\n        me.htmlEntities = function(str) {\n            return String(str).replace(\n                /[&<>\"'`=\\/]/g, function(s) {\n                    return entityMap[s];\n                }\n            );\n        }\n\n        /**\n         * calculate expiration date given initial date and expiration period\n         *\n         * @name   Helper.calculateExpirationDate\n         * @function\n         * @param  {Date} initialDate - may not be empty\n         * @param  {string|number} expirationDisplayStringOrSecondsToExpire - may not be empty\n         * @return {Date}\n         */\n        me.calculateExpirationDate = function(initialDate, expirationDisplayStringOrSecondsToExpire) {\n            let expirationDate      = new Date(initialDate),\n                secondsToExpiration = expirationDisplayStringOrSecondsToExpire;\n            if (typeof expirationDisplayStringOrSecondsToExpire === 'string') {\n                secondsToExpiration = me.durationToSeconds(expirationDisplayStringOrSecondsToExpire);\n            }\n\n            if (typeof secondsToExpiration !== 'number') {\n                throw new Error('Cannot calculate expiration date.');\n            }\n            if (secondsToExpiration === 0) {\n                return null;\n            }\n\n            expirationDate = expirationDate.setUTCSeconds(expirationDate.getUTCSeconds() + secondsToExpiration);\n            return expirationDate;\n        };\n\n        /**\n         * resets state, used for unit testing\n         *\n         * @name   Helper.reset\n         * @function\n         */\n        me.reset = function()\n        {\n            baseUri = null;\n        };\n\n        return me;\n    })();\n\n    /**\n     * internationalization module\n     *\n     * @name I18n\n     * @class\n     */\n    const I18n = (function () {\n        const me = {};\n\n        /**\n         * const for string of loaded language\n         *\n         * @name I18n.languageLoadedEvent\n         * @private\n         * @prop   {string}\n         * @readonly\n         */\n        const languageLoadedEvent = 'languageLoaded';\n\n        /**\n         * supported languages, minus the built in 'en'\n         *\n         * @name I18n.supportedLanguages\n         * @private\n         * @prop   {string[]}\n         * @readonly\n         */\n        const supportedLanguages = ['bg', 'ca', 'co', 'cs', 'de', 'es', 'et', 'fr', 'he', 'hu', 'id', 'it', 'jbo', 'lt', 'no', 'nl', 'pl', 'pt', 'oc', 'ru', 'sl', 'uk', 'zh'];\n\n        /**\n         * built in language\n         *\n         * @name I18n.language\n         * @private\n         * @prop   {string|null}\n         */\n        let language = null;\n\n        /**\n         * translation cache\n         *\n         * @name I18n.translations\n         * @private\n         * @enum   {Object}\n         */\n        let translations = {};\n\n        /**\n         * translate a string, alias for I18n.translate\n         *\n         * @name   I18n._\n         * @function\n         * @param  {jQuery} $element - optional\n         * @param  {string} messageId\n         * @param  {...*} args - one or multiple parameters injected into placeholders\n         * @return {string}\n         */\n        me._ = function()\n        {\n            return me.translate.apply(this, arguments);\n        };\n\n        /**\n         * translate a string\n         *\n         * Optionally pass a jQuery element as the first parameter, to automatically\n         * let the text of this element be replaced. In case the (asynchronously\n         * loaded) language is not downloaded yet, this will make sure the string\n         * is replaced when it eventually gets loaded. Using this is both simpler\n         * and more secure, as it avoids potential XSS when inserting text.\n         * The next parameter is the message ID, matching the ones found in\n         * the translation files under the i18n directory.\n         * Any additional parameters will get inserted into the message ID in\n         * place of %s (strings) or %d (digits), applying the appropriate plural\n         * in case of digits. See also Helper.sprintf().\n         *\n         * @name   I18n.translate\n         * @function\n         * @param  {jQuery} $element - optional\n         * @param  {string} messageId\n         * @param  {...*} args - one or multiple parameters injected into placeholders\n         * @return {string}\n         */\n        me.translate = function()\n        {\n            // convert parameters to array\n            let args = Array.prototype.slice.call(arguments),\n                messageId,\n                $element = null;\n\n            // parse arguments\n            if (args[0] instanceof jQuery) {\n                // optional jQuery element as first parameter\n                $element = args[0];\n                args.shift();\n            }\n\n            // extract messageId from arguments\n            let usesPlurals = $.isArray(args[0]);\n            if (usesPlurals) {\n                // use the first plural form as messageId, otherwise the singular\n                messageId = args[0].length > 1 ? args[0][1] : args[0][0];\n            } else {\n                messageId = args[0];\n            }\n\n            if (messageId.length === 0) {\n                return messageId;\n            }\n\n            // if no translation string cannot be found (in translations object)\n            if (!translations.hasOwnProperty(messageId) || language === null) {\n                // if language is still loading and we have an elemt assigned\n                if (language === null && $element !== null) {\n                    // handle the error by attaching the language loaded event\n                    let orgArguments = arguments;\n                    $(document).on(languageLoadedEvent, function () {\n                        // re-execute this function\n                        me.translate.apply(this, orgArguments);\n                    });\n\n                    // and fall back to English for now until the real language\n                    // file is loaded\n                }\n\n                // for all other languages than English for which this behaviour\n                // is expected as it is built-in, log error\n                if (language !== null && language !== 'en') {\n                    console.error('Missing translation for: \\'' + messageId + '\\' in language ' + language);\n                    // fallback to English\n                }\n\n                // save English translation (should be the same on both sides)\n                translations[messageId] = args[0];\n            }\n\n            // lookup plural translation\n            if (usesPlurals && $.isArray(translations[messageId])) {\n                let n = parseInt(args[1] || 1, 10),\n                    key = me.getPluralForm(n),\n                    maxKey = translations[messageId].length - 1;\n                if (key > maxKey) {\n                    key = maxKey;\n                }\n                args[0] = translations[messageId][key];\n                args[1] = n;\n            } else {\n                // lookup singular translation\n                args[0] = translations[messageId];\n            }\n\n            // messageID may contain links, but should be from a trusted source (code or translation JSON files)\n            let containsLinks = args[0].indexOf('<a') !== -1;\n\n            // prevent double encoding, when we insert into a text node\n            if (containsLinks || $element === null) {\n                for (let i = 0; i < args.length; ++i) {\n                    // parameters (i > 0) may never contain HTML as they may come from untrusted parties\n                    if ((containsLinks ? i > 1 : i > 0) || !containsLinks) {\n                        args[i] = Helper.htmlEntities(args[i]);\n                    }\n                }\n            }\n            // format string\n            let output = Helper.sprintf.apply(this, args);\n\n            if (containsLinks) {\n                // only allow tags/attributes we actually use in translations\n                output = DOMPurify.sanitize(\n                    output, {\n                        ALLOWED_TAGS: ['a', 'i', 'span'],\n                        ALLOWED_ATTR: ['href', 'id']\n                    }\n                );\n            }\n\n            // if $element is given, insert translation\n            if ($element !== null) {\n                if (containsLinks) {\n                    $element.html(output);\n                } else {\n                    // text node takes care of entity encoding\n                    $element.text(output);\n                }\n                return '';\n            }\n\n            return output;\n        };\n\n        /**\n         * per language functions to use to determine the plural form\n         *\n         * @see    {@link https://localization-guide.readthedocs.org/en/latest/l10n/pluralforms.html}\n         * @name   I18n.getPluralForm\n         * @function\n         * @param  {int} n\n         * @return {int} array key\n         */\n        me.getPluralForm = function(n) {\n            switch (language)\n            {\n                case 'cs':\n                    return n === 1 ? 0 : (n >= 2 && n <=4 ? 1 : 2);\n                case 'co':\n                case 'fr':\n                case 'oc':\n                case 'zh':\n                    return n > 1 ? 1 : 0;\n                case 'he':\n                    return n === 1 ? 0 : (n === 2 ? 1 : ((n < 0 || n > 10) && (n % 10 === 0) ? 2 : 3));\n                case 'id':\n                case 'jbo':\n                    return 0;\n                case 'lt':\n                    return n % 10 === 1 && n % 100 !== 11 ? 0 : ((n % 10 >= 2 && n % 100 < 10 || n % 100 >= 20) ? 1 : 2);\n                case 'pl':\n                    return n === 1 ? 0 : (n % 10 >= 2 && n %10 <=4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);\n                case 'ru':\n                case 'uk':\n                    return n % 10 === 1 && n % 100 !== 11 ? 0 : (n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);\n                case 'sl':\n                    return n % 100 === 1 ? 1 : (n % 100 === 2 ? 2 : (n % 100 === 3 || n % 100 === 4 ? 3 : 0));\n                // bg, ca, de, en, es, et, hu, it, nl, no, pt\n                default:\n                    return n !== 1 ? 1 : 0;\n            }\n        };\n\n        /**\n         * load translations into cache\n         *\n         * @name   I18n.loadTranslations\n         * @function\n         */\n        me.loadTranslations = function()\n        {\n            let newLanguage = Helper.getCookie('lang');\n\n            // auto-select language based on browser settings\n            if (newLanguage.length === 0) {\n                newLanguage = (navigator.language || navigator.userLanguage || 'en').substring(0, 2);\n            }\n\n            // if language is already used skip update\n            if (newLanguage === language) {\n                return;\n            }\n\n            // if language is built-in (English) skip update\n            if (newLanguage === 'en') {\n                language = 'en';\n                return;\n            }\n\n            // if language is not supported, show error\n            if (supportedLanguages.indexOf(newLanguage) === -1) {\n                console.error('Language \\'%s\\' is not supported. Translation failed, fallback to English.', newLanguage);\n                language = 'en';\n                return;\n            }\n\n            // load strings from JSON\n            $.getJSON('i18n/' + newLanguage + '.json', function(data) {\n                language = newLanguage;\n                translations = data;\n                $(document).triggerHandler(languageLoadedEvent);\n            }).fail(function (data, textStatus, errorMsg) {\n                console.error('Language \\'%s\\' could not be loaded (%s: %s). Translation failed, fallback to English.', newLanguage, textStatus, errorMsg);\n                language = 'en';\n            });\n        };\n\n        /**\n         * resets state, used for unit testing\n         *\n         * @name   I18n.reset\n         * @function\n         */\n        me.reset = function(mockLanguage, mockTranslations)\n        {\n            language = mockLanguage || null;\n            translations = mockTranslations || {};\n        };\n\n        return me;\n    })();\n\n    /**\n     * handles everything related to en/decryption\n     *\n     * @name CryptTool\n     * @class\n     */\n    const CryptTool = (function () {\n        const me = {};\n\n        /**\n         * base58 encoder & decoder\n         *\n         * @private\n         */\n        let base58 = new baseX('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\n\n        /**\n         * convert UTF-8 string stored in a DOMString to a standard UTF-16 DOMString\n         *\n         * Iterates over the bytes of the message, converting them all hexadecimal\n         * percent encoded representations, then URI decodes them all\n         *\n         * @name   CryptTool.utf8To16\n         * @function\n         * @private\n         * @param  {string} message UTF-8 string\n         * @return {string} UTF-16 string\n         */\n        function utf8To16(message)\n        {\n            return decodeURIComponent(\n                message.split('').map(\n                    function(character)\n                    {\n                        return '%' + ('00' + character.charCodeAt(0).toString(16)).slice(-2);\n                    }\n                ).join('')\n            );\n        }\n\n        /**\n         * convert DOMString (UTF-16) to a UTF-8 string stored in a DOMString\n         *\n         * URI encodes the message, then finds the percent encoded characters\n         * and transforms these hexadecimal representation back into bytes\n         *\n         * @name   CryptTool.utf16To8\n         * @function\n         * @private\n         * @param  {string} message UTF-16 string\n         * @return {string} UTF-8 string\n         */\n        function utf16To8(message)\n        {\n            return encodeURIComponent(message).replace(\n                /%([0-9A-F]{2})/g,\n                function (match, hexCharacter)\n                {\n                    return String.fromCharCode('0x' + hexCharacter);\n                }\n            );\n        }\n\n        /**\n         * convert ArrayBuffer into a UTF-8 string\n         *\n         * Iterates over the bytes of the array, catenating them into a string\n         *\n         * @name   CryptTool.arraybufferToString\n         * @function\n         * @private\n         * @param  {ArrayBuffer} messageArray\n         * @return {string} message\n         */\n        function arraybufferToString(messageArray)\n        {\n            const array = new Uint8Array(messageArray);\n            let message = '',\n                i       = 0;\n            while(i < array.length) {\n                message += String.fromCharCode(array[i++]);\n            }\n            return message;\n        }\n\n        /**\n         * convert UTF-8 string into a Uint8Array\n         *\n         * Iterates over the bytes of the message, writing them to the array\n         *\n         * @name   CryptTool.stringToArraybuffer\n         * @function\n         * @private\n         * @param  {string} message UTF-8 string\n         * @return {Uint8Array} array\n         */\n        function stringToArraybuffer(message)\n        {\n            const messageArray = new Uint8Array(message.length);\n            for (let i = 0; i < message.length; ++i) {\n                messageArray[i] = message.charCodeAt(i);\n            }\n            return messageArray;\n        }\n\n        /**\n         * compress a string (deflate compression), returns buffer\n         *\n         * @name   CryptTool.compress\n         * @async\n         * @function\n         * @private\n         * @param  {string} message\n         * @param  {string} mode\n         * @param  {object} zlib\n         * @throws {string}\n         * @return {ArrayBuffer} data\n         */\n        async function compress(message, mode, zlib)\n        {\n            message = stringToArraybuffer(\n                utf16To8(message)\n            );\n            if (mode === 'zlib') {\n                if (typeof zlib === 'undefined') {\n                    throw 'Error compressing paste, due to missing WebAssembly support.'\n                }\n                return zlib.deflate(message).buffer;\n            }\n            return message;\n        }\n\n        /**\n         * decompress potentially base64 encoded, deflate compressed buffer, returns string\n         *\n         * @name   CryptTool.decompress\n         * @async\n         * @function\n         * @private\n         * @param  {ArrayBuffer} data\n         * @param  {string} mode\n         * @param  {object} zlib\n         * @throws {string}\n         * @return {string} message\n         */\n        async function decompress(data, mode, zlib)\n        {\n            if (mode === 'zlib' || mode === 'none') {\n                if (mode === 'zlib') {\n                    if (typeof zlib === 'undefined') {\n                        throw 'Error decompressing paste, due to missing WebAssembly support.'\n                    }\n                    data = zlib.inflate(\n                        new Uint8Array(data)\n                    ).buffer;\n                }\n                return utf8To16(\n                    arraybufferToString(data)\n                );\n            }\n            // detect presence of Base64.js, indicating legacy ZeroBin paste\n            if (typeof Base64 === 'undefined') {\n                return utf8To16(\n                    RawDeflate.inflate(\n                        utf8To16(\n                            atob(\n                                arraybufferToString(data)\n                            )\n                        )\n                    )\n                );\n            } else {\n                return Base64.btou(\n                    RawDeflate.inflate(\n                        Base64.fromBase64(\n                            arraybufferToString(data)\n                        )\n                    )\n                );\n            }\n        }\n\n        /**\n         * returns specified number of random bytes\n         *\n         * @name   CryptTool.getRandomBytes\n         * @function\n         * @private\n         * @param  {int} length number of random bytes to fetch\n         * @throws {string}\n         * @return {string} random bytes\n         */\n        function getRandomBytes(length)\n        {\n            let bytes       = '';\n            const byteArray = new Uint8Array(length);\n            window.crypto.getRandomValues(byteArray);\n            for (let i = 0; i < length; ++i) {\n                bytes += String.fromCharCode(byteArray[i]);\n            }\n            return bytes;\n        }\n\n        /**\n         * derive cryptographic key from key string and password\n         *\n         * @name   CryptTool.deriveKey\n         * @async\n         * @function\n         * @private\n         * @param  {string} key\n         * @param  {string} password\n         * @param  {array}  spec cryptographic specification\n         * @return {CryptoKey} derived key\n         */\n        async function deriveKey(key, password, spec)\n        {\n            let keyArray = stringToArraybuffer(key);\n            if (password.length > 0) {\n                // version 1 pastes did append the passwords SHA-256 hash in hex\n                if (spec[7] === 'rawdeflate') {\n                    let passwordBuffer = await window.crypto.subtle.digest(\n                        {name: 'SHA-256'},\n                        stringToArraybuffer(\n                            utf16To8(password)\n                        )\n                    ).catch(Alert.showError);\n                    password = Array.prototype.map.call(\n                        new Uint8Array(passwordBuffer),\n                        x => ('00' + x.toString(16)).slice(-2)\n                    ).join('');\n                }\n                let passwordArray = stringToArraybuffer(password),\n                    newKeyArray = new Uint8Array(keyArray.length + passwordArray.length);\n                newKeyArray.set(keyArray, 0);\n                newKeyArray.set(passwordArray, keyArray.length);\n                keyArray = newKeyArray;\n            }\n\n            // import raw key\n            const importedKey = await window.crypto.subtle.importKey(\n                'raw', // only 'raw' is allowed\n                keyArray,\n                {name: 'PBKDF2'}, // we use PBKDF2 for key derivation\n                false, // the key may not be exported\n                ['deriveKey'] // we may only use it for key derivation\n            ).catch(Alert.showError);\n\n            // derive a stronger key for use with AES\n            return window.crypto.subtle.deriveKey(\n                {\n                    name: 'PBKDF2', // we use PBKDF2 for key derivation\n                    salt: stringToArraybuffer(spec[1]), // salt used in HMAC\n                    iterations: spec[2], // amount of iterations to apply\n                    hash: {name: 'SHA-256'} // can be \"SHA-1\", \"SHA-256\", \"SHA-384\" or \"SHA-512\"\n                },\n                importedKey,\n                {\n                    name: 'AES-' + spec[6].toUpperCase(), // can be any supported AES algorithm (\"AES-CTR\", \"AES-CBC\", \"AES-CMAC\", \"AES-GCM\", \"AES-CFB\", \"AES-KW\", \"ECDH\", \"DH\" or \"HMAC\")\n                    length: spec[3] // can be 128, 192 or 256\n                },\n                false, // the key may not be exported\n                ['encrypt', 'decrypt'] // we may only use it for en- and decryption\n            ).catch(Alert.showError);\n        }\n\n        /**\n         * gets crypto settings from specification and authenticated data\n         *\n         * @name   CryptTool.cryptoSettings\n         * @function\n         * @private\n         * @param  {string} adata authenticated data\n         * @param  {array}  spec cryptographic specification\n         * @return {object} crypto settings\n         */\n        function cryptoSettings(adata, spec)\n        {\n            return {\n                name: 'AES-' + spec[6].toUpperCase(), // can be any supported AES algorithm (\"AES-CTR\", \"AES-CBC\", \"AES-CMAC\", \"AES-GCM\", \"AES-CFB\", \"AES-KW\", \"ECDH\", \"DH\" or \"HMAC\")\n                iv: stringToArraybuffer(spec[0]), // the initialization vector you used to encrypt\n                additionalData: stringToArraybuffer(adata), // the addtional data you used during encryption (if any)\n                tagLength: spec[4] // the length of the tag you used to encrypt (if any)\n            };\n        }\n\n        /**\n         * compress, then encrypt message with given key and password\n         *\n         * @name   CryptTool.cipher\n         * @async\n         * @function\n         * @param  {string} key\n         * @param  {string} password\n         * @param  {string} message\n         * @param  {array}  adata\n         * @return {array}  encrypted message in base64 encoding & adata containing encryption spec\n         */\n        me.cipher = async function(key, password, message, adata)\n        {\n            let zlib = (await z);\n            // AES in Galois Counter Mode, keysize 256 bit,\n            // authentication tag 128 bit, 10000 iterations in key derivation\n            const compression = (\n                    typeof zlib === 'undefined' ?\n                    'none' : // client lacks support for WASM\n                    ($('body').data('compression') || 'zlib')\n                ),\n                spec = [\n                    getRandomBytes(16), // initialization vector\n                    getRandomBytes(8),  // salt\n                    100000,             // iterations\n                    256,                // key size\n                    128,                // tag size\n                    'aes',              // algorithm\n                    'gcm',              // algorithm mode\n                    compression         // compression\n                ], encodedSpec = [];\n            for (let i = 0; i < spec.length; ++i) {\n                encodedSpec[i] = i < 2 ? btoa(spec[i]) : spec[i];\n            }\n            if (adata.length === 0) {\n                // comment\n                adata = encodedSpec;\n            } else if (adata[0] === null) {\n                // paste\n                adata[0] = encodedSpec;\n            }\n\n            // finally, encrypt message\n            return [\n                btoa(\n                    arraybufferToString(\n                        await window.crypto.subtle.encrypt(\n                            cryptoSettings(JSON.stringify(adata), spec),\n                            await deriveKey(key, password, spec),\n                            await compress(message, compression, zlib)\n                        ).catch(Alert.showError)\n                    )\n                ),\n                adata\n            ];\n        };\n\n        /**\n         * decrypt message with key, then decompress\n         *\n         * @name   CryptTool.decipher\n         * @async\n         * @function\n         * @param  {string} key\n         * @param  {string} password\n         * @param  {string|object} data encrypted message\n         * @return {string} decrypted message, empty if decryption failed\n         */\n        me.decipher = async function(key, password, data)\n        {\n            let adataString, spec, cipherMessage, plaintext;\n            let zlib = (await z);\n            if (data instanceof Array) {\n                // version 2\n                adataString = JSON.stringify(data[1]);\n                // clone the array instead of passing the reference\n                spec = (data[1][0] instanceof Array ? data[1][0] : data[1]).slice();\n                cipherMessage = data[0];\n            } else if (typeof data === 'string') {\n                // version 1\n                let object = JSON.parse(data);\n                adataString = atob(object.adata);\n                spec = [\n                    object.iv,\n                    object.salt,\n                    object.iter,\n                    object.ks,\n                    object.ts,\n                    object.cipher,\n                    object.mode,\n                    'rawdeflate'\n                ];\n                cipherMessage = object.ct;\n            } else {\n                throw 'unsupported message format';\n            }\n            spec[0] = atob(spec[0]);\n            spec[1] = atob(spec[1]);\n            if (spec[7] === 'zlib') {\n                if (typeof zlib === 'undefined') {\n                    throw 'Error decompressing paste, due to missing WebAssembly support.'\n                }\n            }\n            try {\n                plaintext = await window.crypto.subtle.decrypt(\n                    cryptoSettings(adataString, spec),\n                    await deriveKey(key, password, spec),\n                    stringToArraybuffer(\n                        atob(cipherMessage)\n                    )\n                );\n            } catch(err) {\n                console.error(err);\n                return '';\n            }\n            try {\n                return await decompress(plaintext, spec[7], zlib);\n            } catch(err) {\n                Alert.showError(err);\n                return err;\n            }\n        };\n\n        /**\n         * returns a random symmetric key\n         *\n         * generates 256 bit long keys (8 Bits * 32) for AES with 256 bit long blocks\n         *\n         * @name   CryptTool.getSymmetricKey\n         * @function\n         * @throws {string}\n         * @return {string} raw bytes\n         */\n        me.getSymmetricKey = function()\n        {\n            return getRandomBytes(32);\n        };\n\n        /**\n         * base58 encode a DOMString (UTF-16)\n         *\n         * @name   CryptTool.base58encode\n         * @function\n         * @param  {string} input\n         * @return {string} output\n         */\n        me.base58encode = function(input)\n        {\n            return base58.encode(\n                stringToArraybuffer(input)\n            );\n        }\n\n        /**\n         * base58 decode a DOMString (UTF-16)\n         *\n         * @name   CryptTool.base58decode\n         * @function\n         * @param  {string} input\n         * @return {string} output\n         */\n        me.base58decode = function(input)\n        {\n            return arraybufferToString(\n                base58.decode(input)\n            );\n        }\n\n        return me;\n    })();\n\n    /**\n     * (Model) Data source (aka MVC)\n     *\n     * @name   Model\n     * @class\n     */\n    const Model = (function () {\n        const me = {};\n\n        let id = null,\n            pasteData = null,\n            symmetricKey = null,\n            $templates;\n\n        /**\n         * returns the expiration set in the HTML\n         *\n         * @name   Model.getExpirationDefault\n         * @function\n         * @return string\n         */\n        me.getExpirationDefault = function()\n        {\n            return $('#pasteExpiration').val();\n        };\n\n        /**\n         * returns the format set in the HTML\n         *\n         * @name   Model.getFormatDefault\n         * @function\n         * @return string\n         */\n        me.getFormatDefault = function()\n        {\n            return $('#pasteFormatter').val();\n        };\n\n        /**\n         * returns the paste data (including the cipher data)\n         *\n         * @name   Model.getPasteData\n         * @function\n         * @param {function} callback (optional) Called when data is available\n         * @param {function} useCache (optional) Whether to use the cache or\n         *                            force a data reload. Default: true\n         * @return string\n         */\n        me.getPasteData = function(callback, useCache)\n        {\n            // use cache if possible/allowed\n            if (useCache !== false && pasteData !== null) {\n                //execute callback\n                if (typeof callback === 'function') {\n                    return callback(pasteData);\n                }\n\n                // alternatively just using inline\n                return pasteData;\n            }\n\n            // reload data\n            ServerInteraction.prepare();\n            ServerInteraction.setUrl(Helper.baseUri() + '?pasteid=' + me.getPasteId());\n\n            ServerInteraction.setFailure(function (status, data) {\n                // revert loading status\n                Alert.hideLoading();\n                TopNav.showViewButtons();\n\n                // show error message\n                Alert.showError(ServerInteraction.parseUploadError(status, data, 'get paste data'));\n            });\n            ServerInteraction.setSuccess(function (status, data) {\n                pasteData = new Paste(data);\n\n                if (typeof callback === 'function') {\n                    return callback(pasteData);\n                }\n            });\n            ServerInteraction.run();\n        };\n\n        /**\n         * get the pastes unique identifier from the URL,\n         * eg. https://example.com/path/?c05354954c49a487#dfdsdgdgdfgdf returns c05354954c49a487\n         *\n         * @name   Model.getPasteId\n         * @function\n         * @return {string} unique identifier\n         * @throws {string}\n         */\n        me.getPasteId = function()\n        {\n            const idRegEx = /^[a-z0-9]{16}$/;\n\n            // return cached value\n            if (id !== null) {\n                return id;\n            }\n\n            // do use URL interface, if possible\n            const url = new URL(window.location);\n\n            for (const param of url.searchParams) {\n                const key = param[0];\n                const value = param[1];\n\n                if (value === '' && idRegEx.test(key)) {\n                    // safe, as the whole regex is matched\n                    id = key;\n                    return key;\n                }\n            }\n\n            if (id === null) {\n                throw 'no paste id given';\n            }\n\n            return id;\n        }\n\n        /**\n         * returns true, when the URL has a delete token and the current call was used for deleting a paste.\n         *\n         * @name   Model.hasDeleteToken\n         * @function\n         * @return {bool}\n         */\n        me.hasDeleteToken = function()\n        {\n            return window.location.search.indexOf('deletetoken') !== -1;\n        }\n\n        /**\n         * return the deciphering key stored in anchor part of the URL\n         *\n         * @name   Model.getPasteKey\n         * @function\n         * @return {string|null} key\n         * @throws {string}\n         */\n        me.getPasteKey = function()\n        {\n            if (symmetricKey === null) {\n                let newKey = window.location.hash.substring(1);\n                if (newKey === '') {\n                    throw 'no encryption key given';\n                }\n\n                // Some web 2.0 services and redirectors add data AFTER the anchor\n                // (such as &utm_source=...). We will strip any additional data.\n                let ampersandPos = newKey.indexOf('&');\n                if (ampersandPos > -1)\n                {\n                    newKey = newKey.substring(0, ampersandPos);\n                }\n\n                // version 2 uses base58, version 1 uses base64 without decoding\n                try {\n                    // base58 encode strips NULL bytes at the beginning of the\n                    // string, so we re-add them if necessary\n                    symmetricKey = CryptTool.base58decode(newKey).padStart(32, '\\u0000');\n                } catch(e) {\n                    symmetricKey = newKey;\n                }\n            }\n\n            return symmetricKey;\n        };\n\n        /**\n         * returns a jQuery copy of the HTML template\n         *\n         * @name Model.getTemplate\n         * @function\n         * @param  {string} name - the name of the template\n         * @return {jQuery}\n         */\n        me.getTemplate = function(name)\n        {\n            // find template\n            let $element = $templates.find('#' + name + 'template').clone(true);\n            // change ID to avoid collisions (one ID should really be unique)\n            return $element.prop('id', name);\n        };\n\n        /**\n         * resets state, used for unit testing\n         *\n         * @name   Model.reset\n         * @function\n         */\n        me.reset = function()\n        {\n            pasteData = $templates = id = symmetricKey = null;\n        };\n\n        /**\n         * init navigation manager\n         *\n         * preloads jQuery elements\n         *\n         * @name   Model.init\n         * @function\n         */\n        me.init = function()\n        {\n            $templates = $('#templates');\n        };\n\n        return me;\n    })();\n\n    /**\n     * Helper functions for user interface\n     *\n     * everything directly UI-related, which fits nowhere else\n     *\n     * @name   UiHelper\n     * @class\n     */\n    const UiHelper = (function () {\n        const me = {};\n\n        /**\n         * handle history (pop) state changes\n         *\n         * currently this does only handle redirects to the home page.\n         *\n         * @name   UiHelper.historyChange\n         * @private\n         * @function\n         * @param  {Event} event\n         */\n        function historyChange(event)\n        {\n            let currentLocation = Helper.baseUri();\n            if (event.originalEvent.state === null && // no state object passed\n                event.target.location.href === currentLocation && // target location is home page\n                window.location.href === currentLocation // and we are not already on the home page\n            ) {\n                // redirect to home page\n                window.location.href = currentLocation;\n            }\n        }\n\n        /**\n         * reload the page\n         *\n         * This takes the user to the PrivateBin homepage.\n         *\n         * @name   UiHelper.reloadHome\n         * @function\n         */\n        me.reloadHome = function()\n        {\n            window.location.href = Helper.baseUri();\n        };\n\n        /**\n         * checks whether the element is currently visible in the viewport (so\n         * the user can actually see it)\n         *\n         * @see    {@link https://stackoverflow.com/a/40658647}\n         * @name   UiHelper.isVisible\n         * @function\n         * @param  {jQuery} $element The link hash to move to.\n         */\n        me.isVisible = function($element)\n        {\n            let elementTop     = $element.offset().top,\n                viewportTop    = $(window).scrollTop(),\n                viewportBottom = viewportTop + $(window).height();\n            return elementTop > viewportTop && elementTop < viewportBottom;\n        };\n\n        /**\n         * scrolls to a specific element\n         *\n         * @see    {@link https://stackoverflow.com/questions/4198041/jquery-smooth-scroll-to-an-anchor#answer-12714767}\n         * @name   UiHelper.scrollTo\n         * @function\n         * @param  {jQuery}           $element        The link hash to move to.\n         * @param  {(number|string)}  animationDuration passed to jQuery .animate, when set to 0 the animation is skipped\n         * @param  {string}           animationEffect   passed to jQuery .animate\n         * @param  {function}         finishedCallback  function to call after animation finished\n         */\n        me.scrollTo = function($element, animationDuration, animationEffect, finishedCallback)\n        {\n            let $body = $('html, body'),\n                margin = 50,\n                callbackCalled = false,\n                dest = 0;\n\n            // calculate destination place\n            // if it would scroll out of the screen at the bottom only scroll it as\n            // far as the screen can go\n            if ($element.offset().top > $(document).height() - $(window).height()) {\n                dest = $(document).height() - $(window).height();\n            } else {\n                dest = $element.offset().top - margin;\n            }\n            // skip animation if duration is set to 0\n            if (animationDuration === 0) {\n                window.scrollTo(0, dest);\n            } else {\n                // stop previous animation\n                $body.stop();\n                // scroll to destination\n                $body.animate({\n                    scrollTop: dest\n                }, animationDuration, animationEffect);\n            }\n\n            // as we have finished we can enable scrolling again\n            $body.queue(function (next) {\n                if (!callbackCalled) {\n                    // call user function if needed\n                    if (typeof finishedCallback !== 'undefined') {\n                        finishedCallback();\n                    }\n\n                    // prevent calling this function twice\n                    callbackCalled = true;\n                }\n                next();\n            });\n        };\n\n        /**\n         * trigger a history (pop) state change\n         *\n         * used to test the UiHelper.historyChange private function\n         *\n         * @name   UiHelper.mockHistoryChange\n         * @function\n         * @param  {string} state   (optional) state to mock\n         */\n        me.mockHistoryChange = function(state)\n        {\n            if (typeof state === 'undefined') {\n                state = null;\n            }\n            historyChange($.Event('popstate', {originalEvent: new PopStateEvent('popstate', {state: state}), target: window}));\n        };\n\n        /**\n         * initialize\n         *\n         * @name   UiHelper.init\n         * @function\n         */\n        me.init = function()\n        {\n            // update link to home page\n            $('.reloadlink').prop('href', Helper.baseUri());\n\n            $(window).on('popstate', historyChange);\n        };\n\n        return me;\n    })();\n\n    /**\n     * Alert/error manager\n     *\n     * @name   Alert\n     * @class\n     */\n    const Alert = (function () {\n        const me = {};\n\n        let $errorMessage,\n            $loadingIndicator,\n            $statusMessage,\n            $remainingTime,\n            currentIcon,\n            customHandler;\n\n        const alertType = [\n            'loading', // not in bootstrap CSS, but using a plausible value here\n            'info',    // status icon\n            'warning', // warning icon\n            'danger'   // error icon\n        ];\n\n        /**\n         * forwards a request to the i18n module and shows the element\n         *\n         * @name   Alert.handleNotification\n         * @private\n         * @function\n         * @param  {int} id - id of notification\n         * @param  {jQuery} $element - jQuery object\n         * @param  {string|array} args\n         * @param  {string|null} icon - optional, icon\n         */\n        function handleNotification(id, $element, args, icon)\n        {\n            // basic parsing/conversion of parameters\n            if (typeof icon === 'undefined') {\n                icon = null;\n            }\n            if (typeof args === 'undefined') {\n                args = null;\n            } else if (typeof args === 'string') {\n                // convert string to array if needed\n                args = [args];\n            } else if (args  instanceof Error) {\n                // extract message into array if needed\n                args = [args.message];\n            }\n\n            // pass to custom handler if defined\n            if (typeof customHandler === 'function') {\n                let handlerResult = customHandler(alertType[id], $element, args, icon);\n                if (handlerResult === true) {\n                    // if it returns true, skip own handler\n                    return;\n                }\n                if (handlerResult instanceof jQuery) {\n                    // continue processing with new element\n                    $element = handlerResult;\n                    icon = null; // icons not supported in this case\n                }\n            }\n            let $translationTarget = $element;\n\n            // handle icon, if template uses one\n            const $glyphIcon = $element.find(':first');\n            if ($glyphIcon.length) {\n                // if there is an icon, we need to provide an inner element\n                // to translate the message into, instead of the parent\n                $translationTarget = $('<span>');\n                $element.html(' ').prepend($glyphIcon).append($translationTarget);\n\n                if (icon !== null && // icon was passed\n                    icon !== currentIcon[id] // and it differs from current icon\n                ) {\n                    // remove (previous) icon\n                    $glyphIcon.removeClass(currentIcon[id]);\n\n                    // any other thing as a string (e.g. 'null') (only) removes the icon\n                    if (typeof icon === 'string') {\n                        // set new icon\n                        currentIcon[id] = 'glyphicon-' + icon;\n                        $glyphIcon.addClass(currentIcon[id]);\n                    }\n                }\n            }\n\n            // show text\n            if (args !== null) {\n                // add jQuery object to it as first parameter\n                args.unshift($translationTarget);\n                // pass it to I18n\n                I18n._.apply(this, args);\n            }\n\n            // show notification\n            $element.removeClass('hidden');\n        }\n\n        /**\n         * display a status message\n         *\n         * This automatically passes the text to I18n for translation.\n         *\n         * @name   Alert.showStatus\n         * @function\n         * @param  {string|array} message     string, use an array for %s/%d options\n         * @param  {string|null}  icon        optional, the icon to show,\n         *                                    default: leave previous icon\n         */\n        me.showStatus = function(message, icon)\n        {\n            handleNotification(1, $statusMessage, message, icon);\n        };\n\n        /**\n         * display a warning message\n         *\n         * This automatically passes the text to I18n for translation.\n         *\n         * @name   Alert.showWarning\n         * @function\n         * @param  {string|array} message     string, use an array for %s/%d options\n         * @param  {string|null}  icon        optional, the icon to show, default:\n         *                                    leave previous icon\n         */\n        me.showWarning = function(message, icon)\n        {\n            $errorMessage.find(':first')\n                         .removeClass(currentIcon[3])\n                         .addClass(currentIcon[2]);\n            handleNotification(2, $errorMessage, message, icon);\n        };\n\n        /**\n         * display an error message\n         *\n         * This automatically passes the text to I18n for translation.\n         *\n         * @name   Alert.showError\n         * @function\n         * @param  {string|array} message     string, use an array for %s/%d options\n         * @param  {string|null}  icon        optional, the icon to show, default:\n         *                                    leave previous icon\n         */\n        me.showError = function(message, icon)\n        {\n            handleNotification(3, $errorMessage, message, icon);\n        };\n\n        /**\n         * display remaining message\n         *\n         * This automatically passes the text to I18n for translation.\n         *\n         * @name   Alert.showRemaining\n         * @function\n         * @param  {string|array} message     string, use an array for %s/%d options\n         */\n        me.showRemaining = function(message)\n        {\n            handleNotification(1, $remainingTime, message);\n        };\n\n        /**\n         * shows a loading message, optionally with a percentage\n         *\n         * This automatically passes all texts to the i10s module.\n         *\n         * @name   Alert.showLoading\n         * @function\n         * @param  {string|array|null} message      optional, use an array for %s/%d options, default: 'Loading'\n         * @param  {string|null}       icon         optional, the icon to show, default: leave previous icon\n         */\n        me.showLoading = function(message, icon)\n        {\n            // default message text\n            if (typeof message === 'undefined') {\n                message = 'Loading';\n            }\n\n            handleNotification(0, $loadingIndicator, message, icon);\n\n            // show loading status (cursor)\n            $('body').addClass('loading');\n        };\n\n        /**\n         * hides the loading message\n         *\n         * @name   Alert.hideLoading\n         * @function\n         */\n        me.hideLoading = function()\n        {\n            $loadingIndicator.addClass('hidden');\n\n            // hide loading cursor\n            $('body').removeClass('loading');\n        };\n\n        /**\n         * hides any status/error messages\n         *\n         * This does not include the loading message.\n         *\n         * @name   Alert.hideMessages\n         * @function\n         */\n        me.hideMessages = function()\n        {\n            $statusMessage.addClass('hidden');\n            $errorMessage.addClass('hidden');\n        };\n\n        /**\n         * set a custom handler, which gets all notifications.\n         *\n         * This handler gets the following arguments:\n         * alertType (see array), $element, args, icon\n         * If it returns true, the own processing will be stopped so the message\n         * will not be displayed. Otherwise it will continue.\n         * As an aditional feature it can return q jQuery element, which will\n         * then be used to add the message there. Icons are not supported in\n         * that case and will be ignored.\n         * Pass 'null' to reset/delete the custom handler.\n         * Note that there is no notification when a message is supposed to get\n         * hidden.\n         *\n         * @name   Alert.setCustomHandler\n         * @function\n         * @param {function|null} newHandler\n         */\n        me.setCustomHandler = function(newHandler)\n        {\n            customHandler = newHandler;\n        };\n\n        /**\n         * init status manager\n         *\n         * preloads jQuery elements\n         *\n         * @name   Alert.init\n         * @function\n         */\n        me.init = function()\n        {\n            // hide \"no javascript\" error message\n            $('#noscript').hide();\n\n            // not a reset, but first set of the elements\n            $errorMessage = $('#errormessage');\n            $loadingIndicator = $('#loadingindicator');\n            $statusMessage = $('#status');\n            $remainingTime = $('#remainingtime');\n\n            currentIcon = [\n                'glyphicon-time', // loading icon\n                'glyphicon-info-sign', // status icon\n                'glyphicon-warning-sign', // warning icon\n                'glyphicon-alert' // error icon\n            ];\n        };\n\n        return me;\n    })();\n\n    /**\n     * handles paste status/result\n     *\n     * @name   PasteStatus\n     * @class\n     */\n    const PasteStatus = (function () {\n        const me = {};\n\n        let $pasteSuccess,\n            $pasteUrl,\n            $remainingTime,\n            $shortenButton;\n\n        /**\n         * forward to URL shortener\n         *\n         * @name   PasteStatus.sendToShortener\n         * @private\n         * @function\n         */\n        function sendToShortener()\n        {\n            if ($shortenButton.hasClass('buttondisabled')) {\n                return;\n            }\n            $.ajax({\n                type: 'GET',\n                url: `${$shortenButton.data('shortener')}${encodeURIComponent($pasteUrl.attr('href'))}`,\n                headers: {'Accept': 'text/html, application/xhtml+xml, application/xml, application/json'},\n                processData: false,\n                timeout: 10000,\n                xhrFields: {\n                    withCredentials: false\n                },\n                success: function(response) {\n                    let responseString = response;\n                    if (typeof responseString === 'object') {\n                        responseString = JSON.stringify(responseString);\n                    }\n                    if (typeof responseString === 'string' && responseString.length > 0) {\n                        const shortUrlMatcher = /https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)/g;\n                        const shortUrl = (responseString.match(shortUrlMatcher) || []).sort(function(a, b) {\n                            return a.length - b.length;\n                        })[0];\n                        if (typeof shortUrl === 'string' && shortUrl.length > 0) {\n                            // we disable the button to avoid calling shortener again\n                            $shortenButton.addClass('buttondisabled');\n                            // update link\n                            $pasteUrl.text(shortUrl);\n                            $pasteUrl.prop('href', shortUrl);\n                            // we pre-select the link so that the user only has to [Ctrl]+[c] the link\n                            Helper.selectText($pasteUrl[0]);\n                            return;\n                        }\n                    }\n                    Alert.showError('Cannot parse response from URL shortener.');\n                }\n            })\n            .fail(function(data, textStatus, errorThrown) {\n                console.error(textStatus, errorThrown);\n                // we don't know why it failed, could be CORS of the external\n                // server not setup properly, in which case we follow old\n                // behavior to open it in new tab\n                window.open(\n                    `${$shortenButton.data('shortener')}${encodeURIComponent($pasteUrl.attr('href'))}`,\n                    '_blank',\n                    'noopener, noreferrer'\n                );\n            });\n        }\n\n        /**\n         * Forces opening the paste if the link does not do this automatically.\n         *\n         * This is necessary as browsers will not reload the page when it is\n         * already loaded (which is fake as it is set via history.pushState()).\n         *\n         * @name   PasteStatus.pasteLinkClick\n         * @function\n         */\n        function pasteLinkClick()\n        {\n            // check if location is (already) shown in URL bar\n            if (window.location.href === $pasteUrl.attr('href')) {\n                // if so we need to load link by reloading the current site\n                window.location.reload(true);\n            }\n        }\n\n        /**\n         * creates a notification after a successfull paste upload\n         *\n         * @name   PasteStatus.createPasteNotification\n         * @function\n         * @param  {string} url\n         * @param  {string} deleteUrl\n         */\n        me.createPasteNotification = function(url, deleteUrl)\n        {\n            I18n._(\n                $('#pastelink'),\n                'Your paste is <a id=\"pasteurl\" href=\"%s\">%s</a> <span id=\"copyhint\">(Hit [Ctrl]+[c] to copy)</span>',\n                url, url\n            );\n            // save newly created element\n            $pasteUrl = $('#pasteurl');\n            // and add click event\n            $pasteUrl.click(pasteLinkClick);\n\n            // delete link\n            $('#deletelink').html('<a href=\"' + deleteUrl + '\"></a>');\n            I18n._($('#deletelink a').first(), 'Delete data');\n\n            // enable shortener button\n            $shortenButton.removeClass('buttondisabled');\n\n            // show result\n            $pasteSuccess.removeClass('hidden');\n            // we pre-select the link so that the user only has to [Ctrl]+[c] the link\n            Helper.selectText($pasteUrl[0]);\n        };\n\n        /**\n         * shows the remaining time\n         *\n         * @name PasteStatus.showRemainingTime\n         * @function\n         * @param {Paste} paste\n         */\n        me.showRemainingTime = function(paste)\n        {\n            if (paste.isBurnAfterReadingEnabled()) {\n                // display paste \"for your eyes only\" if it is deleted\n\n                // the paste has been deleted when the JSON with the ciphertext\n                // has been downloaded\n\n                Alert.showRemaining('FOR YOUR EYES ONLY. Don\\'t close this window, this message can\\'t be displayed again.');\n                $remainingTime.addClass('foryoureyesonly');\n            } else if (paste.getTimeToLive() > 0) {\n                // display paste expiration\n                let expiration = Helper.secondsToHuman(paste.getTimeToLive()),\n                    expirationLabel = [\n                        'This document will expire in %d ' + expiration[1] + '.',\n                        'This document will expire in %d ' + expiration[1] + 's.'\n                    ];\n\n                Alert.showRemaining([expirationLabel, expiration[0]]);\n                $remainingTime.removeClass('foryoureyesonly');\n            } else {\n                // never expires\n                return;\n            }\n\n            // in the end, display notification\n            $remainingTime.removeClass('hidden');\n        };\n\n        /**\n         * hides the remaining time and successful upload notification\n         *\n         * @name PasteStatus.hideMessages\n         * @function\n         */\n        me.hideMessages = function()\n        {\n            $remainingTime.addClass('hidden');\n            $pasteSuccess.addClass('hidden');\n        };\n\n        /**\n         * init status manager\n         *\n         * preloads jQuery elements\n         *\n         * @name   PasteStatus.init\n         * @function\n         */\n        me.init = function()\n        {\n            $pasteSuccess = $('#pastesuccess');\n            // $pasteUrl is saved in me.createPasteNotification() after creation\n            $remainingTime = $('#remainingtime');\n            $shortenButton = $('#shortenbutton');\n\n            // bind elements\n            $shortenButton.click(sendToShortener);\n        };\n\n        return me;\n    })();\n\n    /**\n     * password prompt\n     *\n     * @name Prompt\n     * @class\n     */\n    const Prompt = (function () {\n        const me = {};\n\n        let $passwordDecrypt,\n            $passwordForm,\n            $passwordModal,\n            password = '';\n\n        /**\n         * submit a password in the modal dialog\n         *\n         * @name Prompt.submitPasswordModal\n         * @private\n         * @function\n         * @param  {Event} event\n         */\n        function submitPasswordModal(event)\n        {\n            event.preventDefault();\n\n            // get input\n            password = $passwordDecrypt.val();\n\n            // hide modal\n            $passwordModal.modal('hide');\n\n            PasteDecrypter.run();\n        }\n\n        /**\n         * ask the user for the password and set it\n         *\n         * @name Prompt.requestPassword\n         * @function\n         */\n        me.requestPassword = function()\n        {\n            // show new bootstrap method (if available)\n            if ($passwordModal.length !== 0) {\n                $passwordModal.modal({\n                    backdrop: 'static',\n                    keyboard: false\n                });\n                return;\n            }\n\n            // fallback to old method for page template\n            password = prompt(I18n._('Please enter the password for this paste:'), '');\n            if (password === null) {\n                throw 'password prompt canceled';\n            }\n            if (password.length === 0) {\n                // recurse\n                return me.requestPassword();\n            }\n            PasteDecrypter.run();\n        };\n\n        /**\n         * get the cached password\n         *\n         * If you do not get a password with this function\n         * (returns an empty string), use requestPassword.\n         *\n         * @name   Prompt.getPassword\n         * @function\n         * @return {string}\n         */\n        me.getPassword = function()\n        {\n            return password;\n        };\n\n        /**\n         * resets the password to an empty string\n         *\n         * @name   Prompt.reset\n         * @function\n         */\n        me.reset = function()\n        {\n            // reset internal\n            password = '';\n\n            // and also reset UI\n            $passwordDecrypt.val('');\n        }\n\n        /**\n         * init status manager\n         *\n         * preloads jQuery elements\n         *\n         * @name   Prompt.init\n         * @function\n         */\n        me.init = function()\n        {\n            $passwordDecrypt = $('#passworddecrypt');\n            $passwordForm = $('#passwordform');\n            $passwordModal = $('#passwordmodal');\n\n            // bind events\n\n            // focus password input when it is shown\n            $passwordModal.on('shown.bs.Model', function () {\n                $passwordDecrypt.focus();\n            });\n            // handle Model password submission\n            $passwordForm.submit(submitPasswordModal);\n        };\n\n        return me;\n    })();\n\n    /**\n     * Manage paste/message input, and preview tab\n     *\n     * Note that the actual preview is handled by PasteViewer.\n     *\n     * @name   Editor\n     * @class\n     */\n    const Editor = (function () {\n        const me = {};\n\n        let $editorTabs,\n            $messageEdit,\n            $messagePreview,\n            $message,\n            isPreview = false;\n\n        /**\n         * support input of tab character\n         *\n         * @name   Editor.supportTabs\n         * @function\n         * @param  {Event} event\n         * @this $message (but not used, so it is jQuery-free, possibly faster)\n         */\n        function supportTabs(event)\n        {\n            const keyCode = event.keyCode || event.which;\n            // tab was pressed\n            if (keyCode === 9) {\n                // get caret position & selection\n                const val   = this.value,\n                      start = this.selectionStart,\n                      end   = this.selectionEnd;\n                // set textarea value to: text before caret + tab + text after caret\n                this.value = val.substring(0, start) + '\\t' + val.substring(end);\n                // put caret at right position again\n                this.selectionStart = this.selectionEnd = start + 1;\n                // prevent the textarea to lose focus\n                event.preventDefault();\n            }\n        }\n\n        /**\n         * view the Editor tab\n         *\n         * @name   Editor.viewEditor\n         * @function\n         * @param  {Event} event - optional\n         */\n        function viewEditor(event)\n        {\n            // toggle buttons\n            $messageEdit.addClass('active');\n            $messagePreview.removeClass('active');\n\n            $('#messageedit').attr('aria-selected','true');\n            $('#messagepreview').attr('aria-selected','false');\n\n            PasteViewer.hide();\n\n            // reshow input\n            $message.removeClass('hidden');\n\n            me.focusInput();\n\n            // finish\n            isPreview = false;\n\n            // prevent jumping of page to top\n            if (typeof event !== 'undefined') {\n                event.preventDefault();\n            }\n        }\n\n        /**\n         * view the preview tab\n         *\n         * @name   Editor.viewPreview\n         * @function\n         * @param  {Event} event\n         */\n        function viewPreview(event)\n        {\n            // toggle buttons\n            $messageEdit.removeClass('active');\n            $messagePreview.addClass('active');\n\n            $('#messageedit').attr('aria-selected','false');\n            $('#messagepreview').attr('aria-selected','true');\n\n            // hide input as now preview is shown\n            $message.addClass('hidden');\n\n            // show preview\n            PasteViewer.setText($message.val());\n            if (AttachmentViewer.hasAttachmentData()) {\n                const attachment = AttachmentViewer.getAttachment();\n                AttachmentViewer.handleBlobAttachmentPreview(\n                    AttachmentViewer.getAttachmentPreview(),\n                    attachment[0], attachment[1]\n                );\n            }\n            PasteViewer.run();\n\n            // finish\n            isPreview = true;\n\n            // prevent jumping of page to top\n            if (typeof event !== 'undefined') {\n                event.preventDefault();\n            }\n        }\n\n        /**\n         * get the state of the preview\n         *\n         * @name   Editor.isPreview\n         * @function\n         */\n        me.isPreview = function()\n        {\n            return isPreview;\n        };\n\n        /**\n         * reset the Editor view\n         *\n         * @name   Editor.resetInput\n         * @function\n         */\n        me.resetInput = function()\n        {\n            // go back to input\n            if (isPreview) {\n                viewEditor();\n            }\n\n            // clear content\n            $message.val('');\n        };\n\n        /**\n         * shows the Editor\n         *\n         * @name   Editor.show\n         * @function\n         */\n        me.show = function()\n        {\n            $message.removeClass('hidden');\n            $editorTabs.removeClass('hidden');\n        };\n\n        /**\n         * hides the Editor\n         *\n         * @name   Editor.hide\n         * @function\n         */\n        me.hide = function()\n        {\n            $message.addClass('hidden');\n            $editorTabs.addClass('hidden');\n        };\n\n        /**\n         * focuses the message input\n         *\n         * @name   Editor.focusInput\n         * @function\n         */\n        me.focusInput = function()\n        {\n            $message.focus();\n        };\n\n        /**\n         * sets a new text\n         *\n         * @name   Editor.setText\n         * @function\n         * @param {string} newText\n         */\n        me.setText = function(newText)\n        {\n            $message.val(newText);\n        };\n\n        /**\n         * returns the current text\n         *\n         * @name   Editor.getText\n         * @function\n         * @return {string}\n         */\n        me.getText = function()\n        {\n            return $message.val();\n        };\n\n        /**\n         * init status manager\n         *\n         * preloads jQuery elements\n         *\n         * @name   Editor.init\n         * @function\n         */\n        me.init = function()\n        {\n            $editorTabs = $('#editorTabs');\n            $message = $('#message');\n\n            // bind events\n            $message.keydown(supportTabs);\n\n            // bind click events to tab switchers (a), but save parent of them\n            // (li)\n            $messageEdit = $('#messageedit').click(viewEditor).parent();\n            $messagePreview = $('#messagepreview').click(viewPreview).parent();\n        };\n\n        return me;\n    })();\n\n    /**\n     * (view) Parse and show paste.\n     *\n     * @name   PasteViewer\n     * @class\n     */\n    const PasteViewer = (function () {\n        const me = {};\n\n        let $placeholder,\n            $prettyMessage,\n            $prettyPrint,\n            $plainText,\n            text,\n            format = 'plaintext',\n            isDisplayed = false,\n            isChanged = true; // by default true as nothing was parsed yet\n\n        /**\n         * apply the set format on paste and displays it\n         *\n         * @name   PasteViewer.parsePaste\n         * @private\n         * @function\n         */\n        function parsePaste()\n        {\n            // skip parsing if no text is given\n            if (text === '') {\n                return;\n            }\n\n            if (format === 'markdown') {\n                const converter = new showdown.Converter({\n                    strikethrough: true,\n                    tables: true,\n                    tablesHeaderId: true,\n                    simplifiedAutoLink: true,\n                    excludeTrailingPunctuationFromURLs: true\n                });\n                // let showdown convert the HTML and sanitize HTML *afterwards*!\n                $plainText.html(\n                    DOMPurify.sanitize(\n                        converter.makeHtml(text)\n                    )\n                );\n                // add table classes from bootstrap css\n                $plainText.find('table').addClass('table-condensed table-bordered');\n            } else {\n                if (format === 'syntaxhighlighting') {\n                    // yes, this is really needed to initialize the environment\n                    if (typeof prettyPrint === 'function')\n                    {\n                        prettyPrint();\n                    }\n\n                    $prettyPrint.html(\n                        prettyPrintOne(\n                            Helper.htmlEntities(text), null, true\n                        )\n                    );\n                } else {\n                    // = 'plaintext'\n                    $prettyPrint.text(text);\n                }\n                Helper.urls2links($prettyPrint);\n                $prettyPrint.css('white-space', 'pre-wrap');\n                $prettyPrint.css('word-break', 'normal');\n                $prettyPrint.removeClass('prettyprint');\n            }\n        }\n\n        /**\n         * displays the paste\n         *\n         * @name   PasteViewer.showPaste\n         * @private\n         * @function\n         */\n        function showPaste()\n        {\n            // instead of \"nothing\" better display a placeholder\n            if (text === '') {\n                $placeholder.removeClass('hidden');\n                return;\n            }\n            // otherwise hide the placeholder\n            $placeholder.addClass('hidden');\n\n            switch (format) {\n                case 'markdown':\n                    $plainText.removeClass('hidden');\n                    $prettyMessage.addClass('hidden');\n                    break;\n                default:\n                    $plainText.addClass('hidden');\n                    $prettyMessage.removeClass('hidden');\n                    break;\n            }\n        }\n\n        /**\n         * sets the format in which the text is shown\n         *\n         * @name   PasteViewer.setFormat\n         * @function\n         * @param {string} newFormat the new format\n         */\n        me.setFormat = function(newFormat)\n        {\n            // skip if there is no update\n            if (format === newFormat) {\n                return;\n            }\n\n            // needs to update display too, if we switch from or to Markdown\n            if (format === 'markdown' || newFormat === 'markdown') {\n                isDisplayed = false;\n            }\n\n            format = newFormat;\n            isChanged = true;\n        };\n\n        /**\n         * returns the current format\n         *\n         * @name   PasteViewer.getFormat\n         * @function\n         * @return {string}\n         */\n        me.getFormat = function()\n        {\n            return format;\n        };\n\n        /**\n         * returns whether the current view is pretty printed\n         *\n         * @name   PasteViewer.isPrettyPrinted\n         * @function\n         * @return {bool}\n         */\n        me.isPrettyPrinted = function()\n        {\n            return $prettyPrint.hasClass('prettyprinted');\n        };\n\n        /**\n         * sets the text to show\n         *\n         * @name   PasteViewer.setText\n         * @function\n         * @param {string} newText the text to show\n         */\n        me.setText = function(newText)\n        {\n            if (text !== newText) {\n                text = newText;\n                isChanged = true;\n            }\n        };\n\n        /**\n         * gets the current cached text\n         *\n         * @name   PasteViewer.getText\n         * @function\n         * @return {string}\n         */\n        me.getText = function()\n        {\n            return text;\n        };\n\n        /**\n         * show/update the parsed text (preview)\n         *\n         * @name   PasteViewer.run\n         * @function\n         */\n        me.run = function()\n        {\n            if (isChanged) {\n                parsePaste();\n                isChanged = false;\n            }\n\n            if (!isDisplayed) {\n                showPaste();\n                isDisplayed = true;\n            }\n        };\n\n        /**\n         * hide parsed text (preview)\n         *\n         * @name   PasteViewer.hide\n         * @function\n         */\n        me.hide = function()\n        {\n            if (!isDisplayed) {\n                return;\n            }\n\n            $plainText.addClass('hidden');\n            $prettyMessage.addClass('hidden');\n            $placeholder.addClass('hidden');\n            AttachmentViewer.hideAttachmentPreview();\n\n            isDisplayed = false;\n        };\n\n        /**\n         * init status manager\n         *\n         * preloads jQuery elements\n         *\n         * @name   PasteViewer.init\n         * @function\n         */\n        me.init = function()\n        {\n            $placeholder = $('#placeholder');\n            $plainText = $('#plaintext');\n            $prettyMessage = $('#prettymessage');\n            $prettyPrint = $('#prettyprint');\n\n            // get default option from template/HTML or fall back to set value\n            format = Model.getFormatDefault() || format;\n            text = '';\n            isDisplayed = false;\n            isChanged = true;\n        };\n\n        return me;\n    })();\n\n    /**\n     * (view) Show attachment and preview if possible\n     *\n     * @name   AttachmentViewer\n     * @class\n     */\n    const AttachmentViewer = (function () {\n        const me = {};\n\n        let $attachmentLink,\n            $attachmentPreview,\n            $attachment,\n            attachmentData,\n            file,\n            $fileInput,\n            $dragAndDropFileName,\n            attachmentHasPreview = false,\n            $dropzone;\n\n        /**\n         * sets the attachment but does not yet show it\n         *\n         * @name   AttachmentViewer.setAttachment\n         * @function\n         * @param {string} attachmentData - base64-encoded data of file\n         * @param {string} fileName - optional, file name\n         */\n        me.setAttachment = function(attachmentData, fileName)\n        {\n            // data URI format: data:[<mediaType>][;base64],<data>\n\n            // position in data URI string of where data begins\n            const base64Start = attachmentData.indexOf(',') + 1;\n            // position in data URI string of where mediaType ends\n            const mediaTypeEnd = attachmentData.indexOf(';');\n\n            // extract mediaType\n            const mediaType = attachmentData.substring(5, mediaTypeEnd);\n            // extract data and convert to binary\n            const rawData = attachmentData.substring(base64Start);\n            const decodedData = rawData.length > 0 ? atob(rawData) : '';\n\n            // Transform into a Blob\n            const buf = new Uint8Array(decodedData.length);\n            for (let i = 0; i < decodedData.length; ++i) {\n                buf[i] = decodedData.charCodeAt(i);\n            }\n            const blob = new window.Blob([ buf ], { type: mediaType });\n\n            // Get Blob URL\n            const blobUrl = window.URL.createObjectURL(blob);\n\n            // IE does not support setting a data URI on an a element\n            // Using msSaveBlob to download\n            if (window.Blob && navigator.msSaveBlob) {\n                $attachmentLink.off('click').on('click', function () {\n                    navigator.msSaveBlob(blob, fileName);\n                });\n            } else {\n                $attachmentLink.attr('href', blobUrl);\n            }\n\n            if (typeof fileName !== 'undefined') {\n                $attachmentLink.attr('download', fileName);\n            }\n\n            me.handleBlobAttachmentPreview($attachmentPreview, blobUrl, mediaType);\n        };\n\n        /**\n         * displays the attachment\n         *\n         * @name AttachmentViewer.showAttachment\n         * @function\n         */\n        me.showAttachment = function()\n        {\n            $attachment.removeClass('hidden');\n\n            if (attachmentHasPreview) {\n                $attachmentPreview.removeClass('hidden');\n            }\n        };\n\n        /**\n         * removes the attachment\n         *\n         * This automatically hides the attachment containers too, to\n         * prevent an inconsistent display.\n         *\n         * @name AttachmentViewer.removeAttachment\n         * @function\n         */\n        me.removeAttachment = function()\n        {\n            if (!$attachment.length) {\n                return;\n            }\n            me.hideAttachment();\n            me.hideAttachmentPreview();\n            $attachmentLink.removeAttr('href');\n            $attachmentLink.removeAttr('download');\n            $attachmentLink.off('click');\n            $attachmentPreview.html('');\n            $dragAndDropFileName.text('');\n\n            AttachmentViewer.removeAttachmentData();\n        };\n\n        /**\n         * removes the attachment data\n         *\n         * This removes the data, which would be uploaded otherwise.\n         *\n         * @name AttachmentViewer.removeAttachmentData\n         * @function\n         */\n        me.removeAttachmentData = function()\n        {\n            file = undefined;\n            attachmentData = undefined;\n        };\n\n        /**\n         * Cleares the drag & drop data.\n         *\n         * @name AttachmentViewer.clearDragAndDrop\n         * @function\n         */\n        me.clearDragAndDrop = function()\n        {\n            $dragAndDropFileName.text('');\n        };\n\n        /**\n         * hides the attachment\n         *\n         * This will not hide the preview (see AttachmentViewer.hideAttachmentPreview\n         * for that) nor will it hide the attachment link if it was moved somewhere\n         * else (see AttachmentViewer.moveAttachmentTo).\n         *\n         * @name AttachmentViewer.hideAttachment\n         * @function\n         */\n        me.hideAttachment = function()\n        {\n            $attachment.addClass('hidden');\n        };\n\n        /**\n         * hides the attachment preview\n         *\n         * @name AttachmentViewer.hideAttachmentPreview\n         * @function\n         */\n        me.hideAttachmentPreview = function()\n        {\n            if ($attachmentPreview) {\n                $attachmentPreview.addClass('hidden');\n            }\n        };\n\n        /**\n         * checks if there is an attachment displayed\n         *\n         * @name   AttachmentViewer.hasAttachment\n         * @function\n         */\n        me.hasAttachment = function()\n        {\n            if (!$attachment.length) {\n                return false;\n            }\n            const link = $attachmentLink.prop('href');\n            return (typeof link !== 'undefined' && link !== '');\n        };\n\n        /**\n         * checks if there is attachment data (for preview!) available\n         *\n         * It returns true, when there is data that needs to be encrypted.\n         *\n         * @name   AttachmentViewer.hasAttachmentData\n         * @function\n         */\n        me.hasAttachmentData = function()\n        {\n            if ($attachment.length) {\n                return true;\n            }\n            return false;\n        };\n\n        /**\n         * return the attachment\n         *\n         * @name   AttachmentViewer.getAttachment\n         * @function\n         * @returns {array}\n         */\n        me.getAttachment = function()\n        {\n            return [\n                $attachmentLink.prop('href'),\n                $attachmentLink.prop('download')\n            ];\n        };\n\n        /**\n         * moves the attachment link to another element\n         *\n         * It is advisable to hide the attachment afterwards (AttachmentViewer.hideAttachment)\n         *\n         * @name   AttachmentViewer.moveAttachmentTo\n         * @function\n         * @param {jQuery} $element - the wrapper/container element where this should be moved to\n         * @param {string} label - the text to show (%s will be replaced with the file name), will automatically be translated\n         */\n        me.moveAttachmentTo = function($element, label)\n        {\n            // move elemement to new place\n            $attachmentLink.appendTo($element);\n\n            // update text - ensuring no HTML is inserted into the text node\n            I18n._($attachmentLink, label, $attachmentLink.attr('download'));\n        };\n\n        /**\n         * read file data as data URL using the FileReader API\n         *\n         * @name   AttachmentViewer.readFileData\n         * @private\n         * @function\n         * @param {object} loadedFile (optional) loaded file object\n         * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/FileReader#readAsDataURL()}\n         */\n        function readFileData(loadedFile) {\n            if (typeof FileReader === 'undefined') {\n                // revert loading status\n                me.hideAttachment();\n                me.hideAttachmentPreview();\n                Alert.showWarning('Your browser does not support uploading encrypted files. Please use a newer browser.');\n                return;\n            }\n\n            const fileReader = new FileReader();\n            if (loadedFile === undefined) {\n                loadedFile = $fileInput[0].files[0];\n                $dragAndDropFileName.text('');\n            } else {\n                $dragAndDropFileName.text(loadedFile.name);\n            }\n\n            if (typeof loadedFile !== 'undefined') {\n                file = loadedFile;\n                fileReader.onload = function (event) {\n                    const dataURL = event.target.result;\n                    attachmentData = dataURL;\n\n                    if (Editor.isPreview()) {\n                        me.handleAttachmentPreview($attachmentPreview, dataURL);\n                        $attachmentPreview.removeClass('hidden');\n                    }\n\n                    TopNav.highlightFileupload();\n                };\n                fileReader.readAsDataURL(loadedFile);\n            } else {\n                me.removeAttachmentData();\n            }\n        }\n\n        /**\n         * handle the preview of files decoded to blob that can either be an image, video, audio or pdf element\n         *\n         * @name   AttachmentViewer.handleBlobAttachmentPreview\n         * @function\n         * @argument {jQuery} $targetElement element where the preview should be appended\n         * @argument {string} file as a blob URL\n         * @argument {string} mime type\n         */\n        me.handleBlobAttachmentPreview = function ($targetElement, blobUrl, mimeType) {\n            if (blobUrl) {\n                attachmentHasPreview = true;\n                if (mimeType.match(/image\\//i)) {\n                    $targetElement.html(\n                        $(document.createElement('img'))\n                            .attr('src', blobUrl)\n                            .attr('class', 'img-thumbnail')\n                    );\n                } else if (mimeType.match(/video\\//i)) {\n                    $targetElement.html(\n                        $(document.createElement('video'))\n                            .attr('controls', 'true')\n                            .attr('autoplay', 'true')\n                            .attr('class', 'img-thumbnail')\n\n                            .append($(document.createElement('source'))\n                            .attr('type', mimeType)\n                            .attr('src', blobUrl))\n                    );\n                } else if (mimeType.match(/audio\\//i)) {\n                    $targetElement.html(\n                        $(document.createElement('audio'))\n                            .attr('controls', 'true')\n                            .attr('autoplay', 'true')\n\n                            .append($(document.createElement('source'))\n                            .attr('type', mimeType)\n                            .attr('src', blobUrl))\n                    );\n                } else if (mimeType.match(/\\/pdf/i)) {\n                    // Fallback for browsers, that don't support the vh unit\n                    const clientHeight = $(window).height();\n\n                    $targetElement.html(\n                        $(document.createElement('embed'))\n                            .attr('src', blobUrl)\n                            .attr('type', 'application/pdf')\n                            .attr('class', 'pdfPreview')\n                            .css('height', clientHeight)\n                    );\n                } else {\n                    attachmentHasPreview = false;\n                }\n            }\n        };\n\n        /**\n         * attaches the file attachment drag & drop handler to the page\n         *\n         * @name   AttachmentViewer.addDragDropHandler\n         * @private\n         * @function\n         */\n        function addDragDropHandler() {\n            if (typeof $fileInput === 'undefined' || $fileInput.length === 0) {\n                return;\n            }\n\n            const handleDragEnterOrOver = function(event) {\n                event.stopPropagation();\n                event.preventDefault();\n                return false;\n            };\n\n            const handleDrop = function(event) {\n                const evt = event.originalEvent;\n                evt.stopPropagation();\n                evt.preventDefault();\n\n                if (TopNav.isAttachmentReadonly()) {\n                    return false;\n                }\n\n                if ($fileInput) {\n                    const file = evt.dataTransfer.files[0];\n                    //Clear the file input:\n                    $fileInput.wrap('<form>').closest('form').get(0).reset();\n                    $fileInput.unwrap();\n                    //Only works in Chrome:\n                    //fileInput[0].files = e.dataTransfer.files;\n\n                    readFileData(file);\n                }\n            };\n\n            $(document).draghover().on({\n                'draghoverstart': function(e) {\n                    if (TopNav.isAttachmentReadonly()) {\n                        e.stopPropagation();\n                        e.preventDefault();\n                        return false;\n                    }\n                    // show dropzone to indicate drop support\n                    $dropzone.removeClass('hidden');\n                },\n                'draghoverend': function() {\n                    $dropzone.addClass('hidden');\n                }\n            });\n\n            $(document).on('drop', handleDrop);\n            $(document).on('dragenter dragover', handleDragEnterOrOver);\n\n            $fileInput.on('change', function () {\n                readFileData();\n            });\n        }\n\n        /**\n         * attaches the clipboard attachment handler to the page\n         *\n         * @name   AttachmentViewer.addClipboardEventHandler\n         * @private\n         * @function\n         */\n        function addClipboardEventHandler() {\n            $(document).on('paste', function (event) {\n                const items = (event.clipboardData || event.originalEvent.clipboardData).items;\n                const lastItem = items[items.length - 1];\n                if (lastItem.kind === 'file') {\n                    if (TopNav.isAttachmentReadonly()) {\n                        event.stopPropagation();\n                        event.preventDefault();\n                        return false;\n                    } else {\n                        readFileData(lastItem.getAsFile());\n                    }\n                }\n            });\n        }\n\n\n        /**\n         * getter for attachment data\n         *\n         * @name   AttachmentViewer.getAttachmentData\n         * @function\n         * @return {jQuery}\n         */\n        me.getAttachmentData = function () {\n            return attachmentData;\n        };\n\n        /**\n         * getter for attachment link\n         *\n         * @name   AttachmentViewer.getAttachmentLink\n         * @function\n         * @return {jQuery}\n         */\n        me.getAttachmentLink = function () {\n            return $attachmentLink;\n        };\n\n        /**\n         * getter for attachment preview\n         *\n         * @name   AttachmentViewer.getAttachmentPreview\n         * @function\n         * @return {jQuery}\n         */\n        me.getAttachmentPreview = function () {\n            return $attachmentPreview;\n        };\n\n        /**\n         * getter for file data, returns the file contents\n         *\n         * @name   AttachmentViewer.getFile\n         * @function\n         * @return {string}\n         */\n        me.getFile = function () {\n            return file;\n        };\n\n        /**\n         * initiate\n         *\n         * preloads jQuery elements\n         *\n         * @name   AttachmentViewer.init\n         * @function\n         */\n        me.init = function()\n        {\n            $attachment = $('#attachment');\n            $dragAndDropFileName = $('#dragAndDropFileName');\n            $dropzone = $('#dropzone');\n            $attachmentLink = $('#attachment a') || $('<a>');\n            if($attachment.length) {\n                $attachmentPreview = $('#attachmentPreview');\n\n                $fileInput = $('#file');\n                addDragDropHandler();\n                addClipboardEventHandler();\n            }\n        }\n\n        return me;\n    })();\n\n    /**\n     * (view) Shows discussion thread and handles replies\n     *\n     * @name   DiscussionViewer\n     * @class\n     */\n    const DiscussionViewer = (function () {\n        const me = {};\n\n        let $commentTail,\n            $discussion,\n            $reply,\n            $replyMessage,\n            $replyNickname,\n            $replyStatus,\n            $commentContainer,\n            replyCommentId;\n\n        /**\n         * initializes the templates\n         *\n         * @name   DiscussionViewer.initTemplates\n         * @private\n         * @function\n         */\n        function initTemplates()\n        {\n            $reply = Model.getTemplate('reply');\n            $replyMessage = $reply.find('#replymessage');\n            $replyNickname = $reply.find('#nickname');\n            $replyStatus = $reply.find('#replystatus');\n\n            // cache jQuery elements\n            $commentTail = Model.getTemplate('commenttail');\n        }\n\n        /**\n         * open the comment entry when clicking the \"Reply\" button of a comment\n         *\n         * @name   DiscussionViewer.openReply\n         * @private\n         * @function\n         * @param  {Event} event\n         */\n        function openReply(event)\n        {\n            const $source = $(event.target);\n\n            // clear input\n            $replyMessage.val('');\n            $replyNickname.val('');\n\n            // get comment id from source element\n            replyCommentId = $source.parent().prop('id').split('_')[1];\n\n            // move to correct position\n            $source.after($reply);\n\n            // show\n            $reply.removeClass('hidden');\n            $replyMessage.focus();\n\n            event.preventDefault();\n        }\n\n        /**\n         * custom handler for displaying notifications in own status message area\n         *\n         * @name   DiscussionViewer.handleNotification\n         * @function\n         * @param  {string} alertType\n         * @return {bool|jQuery}\n         */\n        me.handleNotification = function(alertType)\n        {\n            // ignore loading messages\n            if (alertType === 'loading') {\n                return false;\n            }\n\n            if (alertType === 'danger') {\n                $replyStatus.removeClass('alert-info');\n                $replyStatus.addClass('alert-danger');\n                $replyStatus.find(':first').removeClass('glyphicon-alert');\n                $replyStatus.find(':first').addClass('glyphicon-info-sign');\n            } else {\n                $replyStatus.removeClass('alert-danger');\n                $replyStatus.addClass('alert-info');\n                $replyStatus.find(':first').removeClass('glyphicon-info-sign');\n                $replyStatus.find(':first').addClass('glyphicon-alert');\n            }\n\n            return $replyStatus;\n        };\n\n        /**\n         * adds another comment\n         *\n         * @name   DiscussionViewer.addComment\n         * @function\n         * @param {Comment} comment\n         * @param {string} commentText\n         * @param {string} nickname\n         */\n        me.addComment = function(comment, commentText, nickname)\n        {\n            if (commentText === '') {\n                commentText = 'comment decryption failed';\n            }\n\n            // create new comment based on template\n            const $commentEntry = Model.getTemplate('comment');\n            $commentEntry.prop('id', 'comment_' + comment.id);\n            const $commentEntryData = $commentEntry.find('div.commentdata');\n\n            // set & parse text\n            $commentEntryData.text(commentText);\n            Helper.urls2links($commentEntryData);\n\n            // set nickname\n            if (nickname.length > 0) {\n                $commentEntry.find('span.nickname').text(nickname);\n            } else {\n                $commentEntry.find('span.nickname').html('<i></i>');\n                I18n._($commentEntry.find('span.nickname i'), 'Anonymous');\n            }\n\n            // set date\n            $commentEntry.find('span.commentdate')\n                      .text(' (' + (new Date(comment.getCreated() * 1000).toLocaleString()) + ')')\n                      .attr('title', 'CommentID: ' + comment.id);\n\n            // if an avatar is available, display it\n            const icon = comment.getIcon();\n            if (icon) {\n                $commentEntry.find('span.nickname')\n                             .before(\n                                '<img src=\"' + icon + '\" class=\"vizhash\" /> '\n                             );\n                $(document).on('languageLoaded', function () {\n                    $commentEntry.find('img.vizhash')\n                                 .prop('title', I18n._('Avatar generated from IP address'));\n                });\n            }\n\n            // starting point (default value/fallback)\n            let $place = $commentContainer;\n\n            // if parent comment exists\n            const $parentComment = $('#comment_' + comment.parentid);\n            if ($parentComment.length) {\n                // use parent as position for new comment, so it is shifted\n                // to the right\n                $place = $parentComment;\n            }\n\n            // finally append comment\n            $place.append($commentEntry);\n        };\n\n        /**\n         * finishes the discussion area after last comment\n         *\n         * @name   DiscussionViewer.finishDiscussion\n         * @function\n         */\n        me.finishDiscussion = function()\n        {\n            // add 'add new comment' area\n            $commentContainer.append($commentTail);\n\n            // show discussions\n            $discussion.removeClass('hidden');\n        };\n\n        /**\n         * removes the old discussion and prepares everything for creating a new\n         * one.\n         *\n         * @name   DiscussionViewer.prepareNewDiscussion\n         * @function\n         */\n        me.prepareNewDiscussion = function()\n        {\n            $commentContainer.html('');\n            $discussion.addClass('hidden');\n\n            // (re-)init templates\n            initTemplates();\n        };\n\n        /**\n         * returns the users message from the reply form\n         *\n         * @name   DiscussionViewer.getReplyMessage\n         * @function\n         * @return {String}\n         */\n        me.getReplyMessage = function()\n        {\n            return $replyMessage.val();\n        };\n\n        /**\n         * returns the users nickname (if any) from the reply form\n         *\n         * @name   DiscussionViewer.getReplyNickname\n         * @function\n         * @return {String}\n         */\n        me.getReplyNickname = function()\n        {\n            return $replyNickname.val();\n        };\n\n        /**\n         * returns the id of the parent comment the user is replying to\n         *\n         * @name   DiscussionViewer.getReplyCommentId\n         * @function\n         * @return {int|undefined}\n         */\n        me.getReplyCommentId = function()\n        {\n            return replyCommentId;\n        };\n\n        /**\n         * highlights a specific comment and scrolls to it if necessary\n         *\n         * @name   DiscussionViewer.highlightComment\n         * @function\n         * @param {string} commentId\n         * @param {bool} fadeOut - whether to fade out the comment\n         */\n        me.highlightComment = function(commentId, fadeOut)\n        {\n            const $comment = $('#comment_' + commentId);\n            // in case comment does not exist, cancel\n            if ($comment.length === 0) {\n                return;\n            }\n\n            $comment.addClass('highlight');\n            const highlightComment = function () {\n                if (fadeOut === true) {\n                    setTimeout(function () {\n                        $comment.removeClass('highlight');\n\n                    }, 300);\n                }\n            };\n\n            if (UiHelper.isVisible($comment)) {\n                return highlightComment();\n            }\n\n            UiHelper.scrollTo($comment, 100, 'swing', highlightComment);\n        };\n\n        /**\n         * initiate\n         *\n         * preloads jQuery elements\n         *\n         * @name   DiscussionViewer.init\n         * @function\n         */\n        me.init = function()\n        {\n            // bind events to templates (so they are later cloned)\n            $('#commenttailtemplate, #commenttemplate').find('button').on('click', openReply);\n            $('#replytemplate').find('button').on('click', PasteEncrypter.sendComment);\n\n            $commentContainer = $('#commentcontainer');\n            $discussion = $('#discussion');\n        };\n\n        return me;\n    })();\n\n    /**\n     * Manage top (navigation) bar\n     *\n     * @name   TopNav\n     * @param  {object} window\n     * @param  {object} document\n     * @class\n     */\n    const TopNav = (function (window, document) {\n        const me = {};\n\n        let createButtonsDisplayed = false,\n            viewButtonsDisplayed = false,\n            burnAfterReadingDefault = false,\n            openDiscussionDefault = false,\n            $attach,\n            $burnAfterReading,\n            $burnAfterReadingOption,\n            $cloneButton,\n            $customAttachment,\n            $expiration,\n            $fileRemoveButton,\n            $fileWrap,\n            $formatter,\n            $newButton,\n            $openDiscussion,\n            $openDiscussionOption,\n            $password,\n            $passwordInput,\n            $rawTextButton,\n            $downloadTextButton,\n            $qrCodeLink,\n            $emailLink,\n            $sendButton,\n            $retryButton,\n            pasteExpiration = null,\n            retryButtonCallback;\n\n        /**\n         * set the expiration on bootstrap templates in dropdown\n         *\n         * @name   TopNav.updateExpiration\n         * @private\n         * @function\n         * @param  {Event} event\n         */\n        function updateExpiration(event)\n        {\n            // get selected option\n            const target = $(event.target);\n\n            // update dropdown display and save new expiration time\n            $('#pasteExpirationDisplay').text(target.text());\n            pasteExpiration = target.data('expiration');\n\n            event.preventDefault();\n        }\n\n        /**\n         * set the format on bootstrap templates in dropdown from user interaction\n         *\n         * @name   TopNav.updateFormat\n         * @private\n         * @function\n         * @param  {Event} event\n         */\n        function updateFormat(event)\n        {\n            // get selected option\n            const $target = $(event.target);\n\n            // update dropdown display and save new format\n            const newFormat = $target.data('format');\n            $('#pasteFormatterDisplay').text($target.text());\n            PasteViewer.setFormat(newFormat);\n\n            // update preview\n            if (Editor.isPreview()) {\n                PasteViewer.run();\n            }\n\n            event.preventDefault();\n        }\n\n        /**\n         * when \"burn after reading\" is checked, disable discussion\n         *\n         * @name   TopNav.changeBurnAfterReading\n         * @private\n         * @function\n         */\n        function changeBurnAfterReading()\n        {\n            if ($burnAfterReading.is(':checked')) {\n                $openDiscussionOption.addClass('buttondisabled');\n                $openDiscussion.prop('checked', false);\n\n                // if button is actually disabled, force-enable it and uncheck other button\n                $burnAfterReadingOption.removeClass('buttondisabled');\n            } else {\n                $openDiscussionOption.removeClass('buttondisabled');\n            }\n        }\n\n        /**\n         * when discussion is checked, disable \"burn after reading\"\n         *\n         * @name   TopNav.changeOpenDiscussion\n         * @private\n         * @function\n         */\n        function changeOpenDiscussion()\n        {\n            if ($openDiscussion.is(':checked')) {\n                $burnAfterReadingOption.addClass('buttondisabled');\n                $burnAfterReading.prop('checked', false);\n\n                // if button is actually disabled, force-enable it and uncheck other button\n                $openDiscussionOption.removeClass('buttondisabled');\n            } else {\n                $burnAfterReadingOption.removeClass('buttondisabled');\n            }\n        }\n\n\n        /**\n         * Clear the attachment input in the top navigation.\n         *\n         * @name   TopNav.clearAttachmentInput\n         * @function\n         */\n        function clearAttachmentInput()\n        {\n            // hide UI for selected files\n            // our up-to-date jQuery can handle it :)\n            $fileWrap.find('input').val('');\n        }\n\n        /**\n         * return raw text\n         *\n         * @name   TopNav.rawText\n         * @private\n         * @function\n         */\n        function rawText()\n        {\n            TopNav.hideAllButtons();\n            Alert.showLoading('Showing raw text', 'time');\n            let paste = PasteViewer.getText();\n\n            // push a new state to allow back navigation with browser back button\n            history.pushState(\n                {type: 'raw'},\n                document.title,\n                // recreate paste URL\n                Helper.baseUri() + '?' + Model.getPasteId() + '#' +\n                CryptTool.base58encode(Model.getPasteKey())\n            );\n\n            // we use text/html instead of text/plain to avoid a bug when\n            // reloading the raw text view (it reverts to type text/html)\n            const $head  = $('head').children().not('noscript, script, link[type=\"text/css\"]'),\n                  newDoc = document.open('text/html', 'replace');\n            newDoc.write('<!DOCTYPE html><html><head>');\n            for (let i = 0; i < $head.length; ++i) {\n                newDoc.write($head[i].outerHTML);\n            }\n            newDoc.write('</head><body><pre>' + DOMPurify.sanitize(Helper.htmlEntities(paste)) + '</pre></body></html>');\n            newDoc.close();\n        }\n\n        /**\n         * download text\n         *\n         * @name   TopNav.downloadText\n         * @private\n         * @function\n         */\n        function downloadText()\n        {\n            var filename='paste-' + Model.getPasteId() + '.txt';\n            var text = PasteViewer.getText();\n\n            var element = document.createElement('a');\n            element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));\n            element.setAttribute('download', filename);\n\n            element.style.display = 'none';\n            document.body.appendChild(element);\n\n            element.click();\n\n            document.body.removeChild(element);\n        }\n\n        /**\n         * saves the language in a cookie and reloads the page\n         *\n         * @name   TopNav.setLanguage\n         * @private\n         * @function\n         * @param  {Event} event\n         */\n        function setLanguage(event)\n        {\n            document.cookie = 'lang=' + $(event.target).data('lang') + ';secure';\n            UiHelper.reloadHome();\n        }\n\n        /**\n         * hides all messages and creates a new paste\n         *\n         * @name   TopNav.clickNewPaste\n         * @private\n         * @function\n         */\n        function clickNewPaste()\n        {\n            Controller.hideStatusMessages();\n            Controller.newPaste();\n        }\n\n        /**\n         * retrys some callback registered before\n         *\n         * @name   TopNav.clickRetryButton\n         * @private\n         * @function\n         * @param  {Event} event\n         */\n        function clickRetryButton(event)\n        {\n            retryButtonCallback(event);\n        }\n\n        /**\n         * removes the existing attachment\n         *\n         * @name   TopNav.removeAttachment\n         * @private\n         * @function\n         * @param  {Event} event\n         */\n        function removeAttachment(event)\n        {\n            // if custom attachment is used, remove it first\n            if (!$customAttachment.hasClass('hidden')) {\n                AttachmentViewer.removeAttachment();\n                $customAttachment.addClass('hidden');\n                $fileWrap.removeClass('hidden');\n            }\n\n            // in any case, remove saved attachment data\n            AttachmentViewer.removeAttachmentData();\n\n            clearAttachmentInput();\n            AttachmentViewer.clearDragAndDrop();\n\n            // pevent '#' from appearing in the URL\n            event.preventDefault();\n        }\n\n        /**\n         * Shows the QR code of the current paste (URL).\n         *\n         * @name   TopNav.displayQrCode\n         * @private\n         * @function\n         */\n        function displayQrCode()\n        {\n            const qrCanvas = kjua({\n                render: 'canvas',\n                text: window.location.href\n            });\n            $('#qrcode-display').html(qrCanvas);\n        }\n\n        /**\n         * Template Email body.\n         *\n         * @name   TopNav.templateEmailBody\n         * @private\n         * @param {string} expirationDateString\n         * @param {bool} isBurnafterreading\n         */\n        function templateEmailBody(expirationDateString, isBurnafterreading)\n        {\n            const EOL = '\\n';\n            const BULLET = '  - ';\n            let emailBody = '';\n            if (expirationDateString !== null || isBurnafterreading) {\n                emailBody += I18n._('Notice:');\n                emailBody += EOL;\n\n                if (expirationDateString !== null) {\n                    emailBody += EOL;\n                    emailBody += BULLET;\n                    // avoid DOMPurify mess with forward slash in expirationDateString\n                    emailBody += Helper.sprintf(\n                        I18n._(\n                            'This link will expire after %s.',\n                            '%s'\n                        ),\n                        expirationDateString\n                    );\n                }\n                if (isBurnafterreading) {\n                    emailBody += EOL;\n                    emailBody += BULLET;\n                    emailBody += I18n._(\n                        'This link can only be accessed once, do not use back or refresh button in your browser.'\n                    );\n                }\n\n                emailBody += EOL;\n                emailBody += EOL;\n            }\n            emailBody += I18n._('Link:');\n            emailBody += EOL;\n            emailBody += `${window.location.href}`;\n            return emailBody;\n        }\n\n        /**\n         * Trigger Email send.\n         *\n         * @name   TopNav.triggerEmailSend\n         * @private\n         * @param {string} emailBody\n         */\n        function triggerEmailSend(emailBody)\n        {\n            window.open(\n                `mailto:?body=${encodeURIComponent(emailBody)}`,\n                '_self',\n                'noopener, noreferrer'\n            );\n        }\n\n        /**\n         * Send Email with current paste (URL).\n         *\n         * @name   TopNav.sendEmail\n         * @private\n         * @function\n         * @param  {Date|null} expirationDate date of expiration\n         * @param  {bool} isBurnafterreading whether it is burn after reading\n         */\n        function sendEmail(expirationDate, isBurnafterreading)\n        {\n            const expirationDateRoundedToSecond = new Date(expirationDate);\n\n            // round down at least 30 seconds to make up for the delay of request\n            expirationDateRoundedToSecond.setUTCSeconds(\n                expirationDateRoundedToSecond.getUTCSeconds() - 30\n            );\n            expirationDateRoundedToSecond.setUTCSeconds(0);\n\n            const $emailconfirmmodal = $('#emailconfirmmodal');\n            if ($emailconfirmmodal.length > 0) {\n                if (expirationDate !== null) {\n                    I18n._(\n                        $emailconfirmmodal.find('#emailconfirm-display'),\n                        'Recipient may become aware of your timezone, convert time to UTC?'\n                    );\n                    const $emailconfirmTimezoneCurrent = $emailconfirmmodal.find('#emailconfirm-timezone-current');\n                    const $emailconfirmTimezoneUtc = $emailconfirmmodal.find('#emailconfirm-timezone-utc');\n                    $emailconfirmTimezoneCurrent.off('click.sendEmailCurrentTimezone');\n                    $emailconfirmTimezoneCurrent.on('click.sendEmailCurrentTimezone', () => {\n                        const emailBody = templateEmailBody(expirationDateRoundedToSecond.toLocaleString(), isBurnafterreading);\n                        $emailconfirmmodal.modal('hide');\n                        triggerEmailSend(emailBody);\n                    });\n                    $emailconfirmTimezoneUtc.off('click.sendEmailUtcTimezone');\n                    $emailconfirmTimezoneUtc.on('click.sendEmailUtcTimezone', () => {\n                        const emailBody = templateEmailBody(expirationDateRoundedToSecond.toLocaleString(\n                            undefined,\n                            // we don't use Date.prototype.toUTCString() because we would like to avoid GMT\n                            { timeZone: 'UTC', dateStyle: 'long', timeStyle: 'long' }\n                        ), isBurnafterreading);\n                        $emailconfirmmodal.modal('hide');\n                        triggerEmailSend(emailBody);\n                    });\n                    $emailconfirmmodal.modal('show');\n                } else {\n                    triggerEmailSend(templateEmailBody(null, isBurnafterreading));\n                }\n            } else {\n                let emailBody = '';\n                if (expirationDate !== null) {\n                    const expirationDateString = window.confirm(\n                        I18n._('Recipient may become aware of your timezone, convert time to UTC?')\n                    ) ? expirationDateRoundedToSecond.toLocaleString(\n                        undefined,\n                        // we don't use Date.prototype.toUTCString() because we would like to avoid GMT\n                        { timeZone: 'UTC', dateStyle: 'long', timeStyle: 'long' }\n                    ) : expirationDateRoundedToSecond.toLocaleString();\n                    emailBody = templateEmailBody(expirationDateString, isBurnafterreading);\n                } else {\n                    emailBody = templateEmailBody(null, isBurnafterreading);\n                }\n                triggerEmailSend(emailBody);\n            }\n        }\n\n        /**\n         * Shows all navigation elements for viewing an existing paste\n         *\n         * @name   TopNav.showViewButtons\n         * @function\n         */\n        me.showViewButtons = function()\n        {\n            if (viewButtonsDisplayed) {\n                return;\n            }\n\n            $newButton.removeClass('hidden');\n            $cloneButton.removeClass('hidden');\n            $rawTextButton.removeClass('hidden');\n            $downloadTextButton.removeClass('hidden');\n            $qrCodeLink.removeClass('hidden');\n\n            viewButtonsDisplayed = true;\n        };\n\n        /**\n         * Hides all navigation elements for viewing an existing paste\n         *\n         * @name   TopNav.hideViewButtons\n         * @function\n         */\n        me.hideViewButtons = function()\n        {\n            if (!viewButtonsDisplayed) {\n                return;\n            }\n\n            $cloneButton.addClass('hidden');\n            $newButton.addClass('hidden');\n            $rawTextButton.addClass('hidden');\n            $downloadTextButton.addClass('hidden');\n            $qrCodeLink.addClass('hidden');\n            me.hideEmailButton();\n\n            viewButtonsDisplayed = false;\n        };\n\n        /**\n         * Hides all elements belonging to existing pastes\n         *\n         * @name   TopNav.hideAllButtons\n         * @function\n         */\n        me.hideAllButtons = function()\n        {\n            me.hideViewButtons();\n            me.hideCreateButtons();\n        };\n\n        /**\n         * shows all elements needed when creating a new paste\n         *\n         * @name   TopNav.showCreateButtons\n         * @function\n         */\n        me.showCreateButtons = function()\n        {\n            if (createButtonsDisplayed) {\n                return;\n            }\n\n            $attach.removeClass('hidden');\n            $burnAfterReadingOption.removeClass('hidden');\n            $expiration.removeClass('hidden');\n            $formatter.removeClass('hidden');\n            $newButton.removeClass('hidden');\n            $openDiscussionOption.removeClass('hidden');\n            $password.removeClass('hidden');\n            $sendButton.removeClass('hidden');\n\n            createButtonsDisplayed = true;\n        };\n\n        /**\n         * shows all elements needed when creating a new paste\n         *\n         * @name   TopNav.hideCreateButtons\n         * @function\n         */\n        me.hideCreateButtons = function()\n        {\n            if (!createButtonsDisplayed) {\n                return;\n            }\n\n            $newButton.addClass('hidden');\n            $sendButton.addClass('hidden');\n            $expiration.addClass('hidden');\n            $formatter.addClass('hidden');\n            $burnAfterReadingOption.addClass('hidden');\n            $openDiscussionOption.addClass('hidden');\n            $password.addClass('hidden');\n            $attach.addClass('hidden');\n\n            createButtonsDisplayed = false;\n        };\n\n        /**\n         * only shows the \"new paste\" button\n         *\n         * @name   TopNav.showNewPasteButton\n         * @function\n         */\n        me.showNewPasteButton = function()\n        {\n            $newButton.removeClass('hidden');\n        };\n\n        /**\n         * only shows the \"retry\" button\n         *\n         * @name   TopNav.showRetryButton\n         * @function\n         */\n        me.showRetryButton = function()\n        {\n            $retryButton.removeClass('hidden');\n        }\n\n        /**\n         * hides the \"retry\" button\n         *\n         * @name   TopNav.hideRetryButton\n         * @function\n         */\n        me.hideRetryButton = function()\n        {\n            $retryButton.addClass('hidden');\n        }\n\n        /**\n         * show the \"email\" button\n         *\n         * @name   TopNav.showEmailbutton\n         * @function\n         * @param {int|undefined} optionalRemainingTimeInSeconds\n         */\n        me.showEmailButton = function(optionalRemainingTimeInSeconds)\n        {\n            try {\n                // we cache expiration date in closure to avoid inaccurate expiration datetime\n                const expirationDate = Helper.calculateExpirationDate(\n                    new Date(),\n                    typeof optionalRemainingTimeInSeconds === 'number' ? optionalRemainingTimeInSeconds : TopNav.getExpiration()\n                );\n                const isBurnafterreading = TopNav.getBurnAfterReading();\n\n                $emailLink.removeClass('hidden');\n                $emailLink.off('click.sendEmail');\n                $emailLink.on('click.sendEmail', () => {\n                    sendEmail(expirationDate, isBurnafterreading);\n                });\n            } catch (error) {\n                console.error(error);\n                Alert.showError('Cannot calculate expiration date.');\n            }\n        }\n\n        /**\n         * hide the \"email\" button\n         *\n         * @name   TopNav.hideEmailButton\n         * @function\n         */\n        me.hideEmailButton = function()\n        {\n            $emailLink.addClass('hidden');\n            $emailLink.off('click.sendEmail');\n        }\n\n        /**\n         * only hides the clone button\n         *\n         * @name   TopNav.hideCloneButton\n         * @function\n         */\n        me.hideCloneButton = function()\n        {\n            $cloneButton.addClass('hidden');\n        };\n\n        /**\n         * only hides the raw text button\n         *\n         * @name   TopNav.hideRawButton\n         * @function\n         */\n        me.hideRawButton = function()\n        {\n            $rawTextButton.addClass('hidden');\n        };\n\n        /**\n         * only hides the download text button\n         *\n         * @name   TopNav.hideRawButton\n         * @function\n         */\n        me.hideDownloadButton = function()\n        {\n            $downloadTextButton.addClass('hidden');\n        };\n\n        /**\n         * only hides the qr code button\n         *\n         * @name   TopNav.hideQrCodeButton\n         * @function\n         */\n        me.hideQrCodeButton = function()\n        {\n            $qrCodeLink.addClass('hidden');\n        }\n\n        /**\n         * hide all irrelevant buttons when viewing burn after reading paste\n         *\n         * @name   TopNav.hideBurnAfterReadingButtons\n         * @function\n         */\n        me.hideBurnAfterReadingButtons = function()\n        {\n            me.hideCloneButton();\n            me.hideQrCodeButton();\n            me.hideEmailButton();\n        }\n\n        /**\n         * hides the file selector in attachment\n         *\n         * @name   TopNav.hideFileSelector\n         * @function\n         */\n        me.hideFileSelector = function()\n        {\n            $fileWrap.addClass('hidden');\n        };\n\n\n        /**\n         * shows the custom attachment\n         *\n         * @name   TopNav.showCustomAttachment\n         * @function\n         */\n        me.showCustomAttachment = function()\n        {\n            $customAttachment.removeClass('hidden');\n        };\n\n        /**\n         * hides the custom attachment\n         *\n         * @name  TopNav.hideCustomAttachment\n         * @function\n         */\n        me.hideCustomAttachment = function()\n        {\n            $customAttachment.addClass('hidden');\n            $fileWrap.removeClass('hidden');\n        };\n\n        /**\n         * collapses the navigation bar, only if expanded\n         *\n         * @name   TopNav.collapseBar\n         * @function\n         */\n        me.collapseBar = function()\n        {\n            if ($('#navbar').attr('aria-expanded') === 'true') {\n                $('.navbar-toggle').click();\n            }\n        };\n\n        /**\n         * Reset the top navigation back to it's default values.\n         *\n         * @name   TopNav.resetInput\n         * @function\n         */\n        me.resetInput = function()\n        {\n            clearAttachmentInput();\n            $burnAfterReading.prop('checked', burnAfterReadingDefault);\n            $openDiscussion.prop('checked', openDiscussionDefault);\n            if (openDiscussionDefault || !burnAfterReadingDefault) $openDiscussionOption.removeClass('buttondisabled');\n            if (burnAfterReadingDefault || !openDiscussionDefault) $burnAfterReadingOption.removeClass('buttondisabled');\n\n            pasteExpiration = Model.getExpirationDefault() || pasteExpiration;\n            $('#pasteExpiration>option').each(function() {\n                const $this = $(this);\n                if ($this.val() === pasteExpiration) {\n                    $('#pasteExpirationDisplay').text($this.text());\n                }\n            });\n        };\n\n        /**\n         * returns the currently set expiration time\n         *\n         * @name   TopNav.getExpiration\n         * @function\n         * @return {int}\n         */\n        me.getExpiration = function()\n        {\n            return pasteExpiration;\n        };\n\n        /**\n         * returns the currently selected file(s)\n         *\n         * @name   TopNav.getFileList\n         * @function\n         * @return {FileList|null}\n         */\n        me.getFileList = function()\n        {\n            const $file = $('#file');\n\n            // if no file given, return null\n            if (!$file.length || !$file[0].files.length) {\n                return null;\n            }\n\n            // ensure the selected file is still accessible\n            if (!($file[0].files && $file[0].files[0])) {\n                return null;\n            }\n\n            return $file[0].files;\n        };\n\n        /**\n         * returns the state of the burn after reading checkbox\n         *\n         * @name   TopNav.getBurnAfterReading\n         * @function\n         * @return {bool}\n         */\n        me.getBurnAfterReading = function()\n        {\n            return $burnAfterReading.is(':checked');\n        };\n\n        /**\n         * returns the state of the discussion checkbox\n         *\n         * @name   TopNav.getOpenDiscussion\n         * @function\n         * @return {bool}\n         */\n        me.getOpenDiscussion = function()\n        {\n            return $openDiscussion.is(':checked');\n        };\n\n        /**\n         * returns the entered password\n         *\n         * @name   TopNav.getPassword\n         * @function\n         * @return {string}\n         */\n        me.getPassword = function()\n        {\n            // when password is disabled $passwordInput.val() will return undefined\n            return $passwordInput.val() || '';\n        };\n\n        /**\n         * returns the element where custom attachments can be placed\n         *\n         * Used by AttachmentViewer when an attachment is cloned here.\n         *\n         * @name   TopNav.getCustomAttachment\n         * @function\n         * @return {jQuery}\n         */\n        me.getCustomAttachment = function()\n        {\n            return $customAttachment;\n        };\n\n        /**\n         * Set a function to call when the retry button is clicked.\n         *\n         * @name   TopNav.setRetryCallback\n         * @function\n         * @param {function} callback\n         */\n        me.setRetryCallback = function(callback)\n        {\n            retryButtonCallback = callback;\n        }\n\n        /**\n         * Highlight file upload\n         *\n         * @name  TopNav.highlightFileupload\n         * @function\n         */\n        me.highlightFileupload = function()\n        {\n            // visually indicate file uploaded\n            const $attachDropdownToggle = $attach.children('.dropdown-toggle');\n            if ($attachDropdownToggle.attr('aria-expanded') === 'false') {\n                $attachDropdownToggle.click();\n            }\n            $fileWrap.addClass('highlight');\n            setTimeout(function () {\n                $fileWrap.removeClass('highlight');\n            }, 300);\n        }\n\n        /**\n         * set the format on bootstrap templates in dropdown programmatically\n         *\n         * @name    TopNav.setFormat\n         * @function\n         */\n        me.setFormat = function(format)\n        {\n            $formatter.parent().find(`a[data-format=\"${format}\"]`).click();\n        }\n\n        /**\n         * returns if attachment dropdown is readonly, not editable\n         *\n         * @name   TopNav.isAttachmentReadonly\n         * @function\n         * @return {bool}\n         */\n        me.isAttachmentReadonly = function()\n        {\n            return !createButtonsDisplayed || $attach.hasClass('hidden');\n        }\n\n        /**\n         * init navigation manager\n         *\n         * preloads jQuery elements\n         *\n         * @name   TopNav.init\n         * @function\n         */\n        me.init = function()\n        {\n            $attach = $('#attach');\n            $burnAfterReading = $('#burnafterreading');\n            $burnAfterReadingOption = $('#burnafterreadingoption');\n            $cloneButton = $('#clonebutton');\n            $customAttachment = $('#customattachment');\n            $expiration = $('#expiration');\n            $fileRemoveButton = $('#fileremovebutton');\n            $fileWrap = $('#filewrap');\n            $formatter = $('#formatter');\n            $newButton = $('#newbutton');\n            $openDiscussion = $('#opendiscussion');\n            $openDiscussionOption = $('#opendiscussionoption');\n            $password = $('#password');\n            $passwordInput = $('#passwordinput');\n            $rawTextButton = $('#rawtextbutton');\n            $downloadTextButton = $('#downloadtextbutton');\n            $retryButton = $('#retrybutton');\n            $sendButton = $('#sendbutton');\n            $qrCodeLink = $('#qrcodelink');\n            $emailLink = $('#emaillink');\n\n            // bootstrap template drop down\n            $('#language ul.dropdown-menu li a').click(setLanguage);\n            // page template drop down\n            $('#language select option').click(setLanguage);\n\n            // bind events\n            $burnAfterReading.change(changeBurnAfterReading);\n            $openDiscussionOption.change(changeOpenDiscussion);\n            $newButton.click(clickNewPaste);\n            $sendButton.click(PasteEncrypter.sendPaste);\n            $cloneButton.click(Controller.clonePaste);\n            $rawTextButton.click(rawText);\n            $downloadTextButton.click(downloadText);\n            $retryButton.click(clickRetryButton);\n            $fileRemoveButton.click(removeAttachment);\n            $qrCodeLink.click(displayQrCode);\n\n            // bootstrap template drop downs\n            $('ul.dropdown-menu li a', $('#expiration').parent()).click(updateExpiration);\n            $('ul.dropdown-menu li a', $('#formatter').parent()).click(updateFormat);\n\n            // initiate default state of checkboxes\n            changeBurnAfterReading();\n            changeOpenDiscussion();\n\n            // get default values from template or fall back to set value\n            burnAfterReadingDefault = me.getBurnAfterReading();\n            openDiscussionDefault = me.getOpenDiscussion();\n            pasteExpiration = Model.getExpirationDefault() || pasteExpiration;\n\n            createButtonsDisplayed = false;\n            viewButtonsDisplayed = false;\n        };\n\n        return me;\n    })(window, document);\n\n    /**\n     * Responsible for AJAX requests, transparently handles encryption\n     *\n     * @name   ServerInteraction\n     * @class\n     */\n    const ServerInteraction = (function () {\n        const me = {};\n\n        let successFunc = null,\n            failureFunc = null,\n            symmetricKey = null,\n            url,\n            data,\n            password;\n\n        /**\n         * public variable ('constant') for errors to prevent magic numbers\n         *\n         * @name   ServerInteraction.error\n         * @readonly\n         * @enum   {Object}\n         */\n        me.error = {\n            okay: 0,\n            custom: 1,\n            unknown: 2,\n            serverError: 3\n        };\n\n        /**\n         * ajaxHeaders to send in AJAX requests\n         *\n         * @name   ServerInteraction.ajaxHeaders\n         * @private\n         * @readonly\n         * @enum   {Object}\n         */\n        const ajaxHeaders = {'X-Requested-With': 'JSONHttpRequest'};\n\n        /**\n         * called after successful upload\n         *\n         * @name   ServerInteraction.success\n         * @private\n         * @function\n         * @param {int} status\n         * @param {int} result - optional\n         */\n        function success(status, result)\n        {\n            if (successFunc !== null) {\n                // add useful data to result\n                result.encryptionKey = symmetricKey;\n                successFunc(status, result);\n            }\n        }\n\n        /**\n         * called after a upload failure\n         *\n         * @name   ServerInteraction.fail\n         * @private\n         * @function\n         * @param {int} status - internal code\n         * @param {int} result - original error code\n         */\n        function fail(status, result)\n        {\n            if (failureFunc !== null) {\n                failureFunc(status, result);\n            }\n        }\n\n        /**\n         * actually uploads the data\n         *\n         * @name   ServerInteraction.run\n         * @function\n         */\n        me.run = function()\n        {\n            let isPost = Object.keys(data).length > 0,\n                ajaxParams = {\n                    type: isPost ? 'POST' : 'GET',\n                    url: url,\n                    headers: ajaxHeaders,\n                    dataType: 'json',\n                    success: function(result) {\n                        if (result.status === 0) {\n                            success(0, result);\n                        } else if (result.status === 1) {\n                            fail(1, result);\n                        } else {\n                            fail(2, result);\n                        }\n                    }\n                };\n            if (isPost) {\n                ajaxParams.data = JSON.stringify(data);\n            }\n            $.ajax(ajaxParams).fail(function(jqXHR, textStatus, errorThrown) {\n                console.error(textStatus, errorThrown);\n                fail(3, jqXHR);\n            });\n        };\n\n        /**\n         * return currently set data, used in unit testing\n         *\n         * @name   ServerInteraction.getData\n         * @function\n         */\n        me.getData = function()\n        {\n            return data;\n        };\n\n        /**\n         * set success function\n         *\n         * @name   ServerInteraction.setUrl\n         * @function\n         * @param {function} newUrl\n         */\n        me.setUrl = function(newUrl)\n        {\n            url = newUrl;\n        };\n\n        /**\n         * sets the password to use (first value) and optionally also the\n         * encryption key (not recommended, it is automatically generated).\n         *\n         * Note: Call this after prepare() as prepare() resets these values.\n         *\n         * @name   ServerInteraction.setCryptValues\n         * @function\n         * @param {string} newPassword\n         * @param {string} newKey       - optional\n         */\n        me.setCryptParameters = function(newPassword, newKey)\n        {\n            password = newPassword;\n\n            if (typeof newKey !== 'undefined') {\n                symmetricKey = newKey;\n            }\n        };\n\n        /**\n         * set success function\n         *\n         * @name   ServerInteraction.setSuccess\n         * @function\n         * @param {function} func\n         */\n        me.setSuccess = function(func)\n        {\n            successFunc = func;\n        };\n\n        /**\n         * set failure function\n         *\n         * @name   ServerInteraction.setFailure\n         * @function\n         * @param {function} func\n         */\n        me.setFailure = function(func)\n        {\n            failureFunc = func;\n        };\n\n        /**\n         * prepares a new upload\n         *\n         * Call this when doing a new upload to reset any data from potential\n         * previous uploads. Must be called before any other method of this\n         * module.\n         *\n         * @name   ServerInteraction.prepare\n         * @function\n         * @return {object}\n         */\n        me.prepare = function()\n        {\n            // entropy should already be checked!\n\n            // reset password\n            password = '';\n\n            // reset key, so it a new one is generated when it is used\n            symmetricKey = null;\n\n            // reset data\n            successFunc = null;\n            failureFunc = null;\n            url = Helper.baseUri();\n            data = {};\n        };\n\n        /**\n         * encrypts and sets the data\n         *\n         * @name   ServerInteraction.setCipherMessage\n         * @async\n         * @function\n         * @param {object} cipherMessage\n         */\n        me.setCipherMessage = async function(cipherMessage)\n        {\n            if (\n                symmetricKey === null ||\n                (typeof symmetricKey === 'string' && symmetricKey === '')\n            ) {\n                symmetricKey = CryptTool.getSymmetricKey();\n            }\n            if (!data.hasOwnProperty('adata')) {\n                data['adata'] = [];\n            }\n            let cipherResult = await CryptTool.cipher(symmetricKey, password, JSON.stringify(cipherMessage), data['adata']);\n            data['v'] = 2;\n            data['ct'] = cipherResult[0];\n            data['adata'] = cipherResult[1];\n\n        };\n\n        /**\n         * set the additional metadata to send unencrypted\n         *\n         * @name   ServerInteraction.setUnencryptedData\n         * @function\n         * @param {string} index\n         * @param {mixed} element\n         */\n        me.setUnencryptedData = function(index, element)\n        {\n            data[index] = element;\n        };\n\n        /**\n         * Helper, which parses shows a general error message based on the result of the ServerInteraction\n         *\n         * @name    ServerInteraction.parseUploadError\n         * @function\n         * @param {int} status\n         * @param {object} data\n         * @param {string} doThisThing - a human description of the action, which was tried\n         * @return {array}\n         */\n        me.parseUploadError = function(status, data, doThisThing) {\n            let errorArray;\n\n            switch (status) {\n                case me.error.custom:\n                    errorArray = ['Could not ' + doThisThing + ': %s', data.message];\n                    break;\n                case me.error.unknown:\n                    errorArray = ['Could not ' + doThisThing + ': %s', I18n._('unknown status')];\n                    break;\n                case me.error.serverError:\n                    errorArray = ['Could not ' + doThisThing + ': %s', I18n._('server error or not responding')];\n                    break;\n                default:\n                    errorArray = ['Could not ' + doThisThing + ': %s', I18n._('unknown error')];\n                    break;\n            }\n\n            return errorArray;\n        };\n\n        return me;\n    })();\n\n    /**\n     * (controller) Responsible for encrypting paste and sending it to server.\n     *\n     * Does upload, encryption is done transparently by ServerInteraction.\n     *\n     * @name PasteEncrypter\n     * @class\n     */\n    const PasteEncrypter = (function () {\n        const me = {};\n\n        /**\n         * called after successful paste upload\n         *\n         * @name PasteEncrypter.showCreatedPaste\n         * @private\n         * @function\n         * @param {int} status\n         * @param {object} data\n         */\n        function showCreatedPaste(status, data) {\n            Alert.hideLoading();\n            Alert.hideMessages();\n\n            // show notification\n            const baseUri   = Helper.baseUri() + '?',\n                  url       = baseUri + data.id + '#' + CryptTool.base58encode(data.encryptionKey),\n                  deleteUrl = baseUri + 'pasteid=' + data.id + '&deletetoken=' + data.deletetoken;\n            PasteStatus.createPasteNotification(url, deleteUrl);\n\n            // show new URL in browser bar\n            history.pushState({type: 'newpaste'}, document.title, url);\n\n            TopNav.showViewButtons();\n\n            // this cannot be grouped with showViewButtons due to remaining time calculation\n            TopNav.showEmailButton();\n\n            TopNav.hideRawButton();\n            TopNav.hideDownloadButton();\n            Editor.hide();\n\n            // parse and show text\n            // (preparation already done in me.sendPaste())\n            PasteViewer.run();\n        }\n\n        /**\n         * called after successful comment upload\n         *\n         * @name PasteEncrypter.showUploadedComment\n         * @private\n         * @function\n         * @param {int} status\n         * @param {object} data\n         */\n        function showUploadedComment(status, data) {\n            // show success message\n            Alert.showStatus('Comment posted.');\n\n            // reload paste\n            Controller.refreshPaste(function () {\n                // highlight sent comment\n                DiscussionViewer.highlightComment(data.id, true);\n                // reset error handler\n                Alert.setCustomHandler(null);\n            });\n        }\n\n        /**\n         * send a reply in a discussion\n         *\n         * @name   PasteEncrypter.sendComment\n         * @async\n         * @function\n         */\n        me.sendComment = async function()\n        {\n            Alert.hideMessages();\n            Alert.setCustomHandler(DiscussionViewer.handleNotification);\n\n            // UI loading state\n            TopNav.hideAllButtons();\n            Alert.showLoading('Sending comment', 'cloud-upload');\n\n            // get data\n            const plainText = DiscussionViewer.getReplyMessage(),\n                  nickname  = DiscussionViewer.getReplyNickname(),\n                  parentid  = DiscussionViewer.getReplyCommentId();\n\n            // do not send if there is no data\n            if (plainText.length === 0) {\n                // revert loading status\n                Alert.hideLoading();\n                Alert.setCustomHandler(null);\n                TopNav.showViewButtons();\n                return;\n            }\n\n            // prepare server interaction\n            ServerInteraction.prepare();\n            ServerInteraction.setCryptParameters(Prompt.getPassword(), Model.getPasteKey());\n\n            // set success/fail functions\n            ServerInteraction.setSuccess(showUploadedComment);\n            ServerInteraction.setFailure(function (status, data) {\n                // revert loading status\n                Alert.hideLoading();\n                TopNav.showViewButtons();\n\n                // show error message\n                Alert.showError(\n                    ServerInteraction.parseUploadError(status, data, 'post comment')\n                );\n\n                // and reset error handler\n                Alert.setCustomHandler(null);\n            });\n\n            // fill it with unencrypted params\n            ServerInteraction.setUnencryptedData('pasteid', Model.getPasteId());\n            if (typeof parentid === 'undefined') {\n                // if parent id is not set, this is the top-most comment, so use\n                // paste id as parent, as the root element of the discussion tree\n                ServerInteraction.setUnencryptedData('parentid', Model.getPasteId());\n            } else {\n                ServerInteraction.setUnencryptedData('parentid', parentid);\n            }\n\n            // prepare cypher message\n            let cipherMessage = {\n                'comment': plainText\n            };\n            if (nickname.length > 0) {\n                cipherMessage['nickname'] = nickname;\n            }\n\n            await ServerInteraction.setCipherMessage(cipherMessage).catch(Alert.showError);\n            ServerInteraction.run();\n        };\n\n        /**\n         * sends a new paste to server\n         *\n         * @name   PasteEncrypter.sendPaste\n         * @async\n         * @function\n         */\n        me.sendPaste = async function()\n        {\n            // hide previous (error) messages\n            Controller.hideStatusMessages();\n\n            // UI loading state\n            TopNav.hideAllButtons();\n            Alert.showLoading('Sending paste', 'cloud-upload');\n            TopNav.collapseBar();\n\n            // get data\n            const plainText = Editor.getText(),\n                  format    = PasteViewer.getFormat(),\n                  // the methods may return different values if no files are attached (null, undefined or false)\n                  files     = TopNav.getFileList() || AttachmentViewer.getFile() || AttachmentViewer.hasAttachment();\n\n            // do not send if there is no data\n            if (plainText.length === 0 && !files) {\n                // revert loading status\n                Alert.hideLoading();\n                TopNav.showCreateButtons();\n                return;\n            }\n\n            // prepare server interaction\n            ServerInteraction.prepare();\n            ServerInteraction.setCryptParameters(TopNav.getPassword());\n\n            // set success/fail functions\n            ServerInteraction.setSuccess(showCreatedPaste);\n            ServerInteraction.setFailure(function (status, data) {\n                // revert loading status\n                Alert.hideLoading();\n                TopNav.showCreateButtons();\n\n                // show error message\n                Alert.showError(\n                    ServerInteraction.parseUploadError(status, data, 'create paste')\n                );\n            });\n\n            // fill it with unencrypted submitted options\n            ServerInteraction.setUnencryptedData('adata', [\n                null, format,\n                TopNav.getOpenDiscussion() ? 1 : 0,\n                TopNav.getBurnAfterReading() ? 1 : 0\n            ]);\n            ServerInteraction.setUnencryptedData('meta', {'expire': TopNav.getExpiration()});\n\n            // prepare PasteViewer for later preview\n            PasteViewer.setText(plainText);\n            PasteViewer.setFormat(format);\n\n            // prepare cypher message\n            let file = AttachmentViewer.getAttachmentData(),\n                cipherMessage = {\n                    'paste': plainText\n                };\n            if (typeof file !== 'undefined' && file !== null) {\n                cipherMessage['attachment'] = file;\n                cipherMessage['attachment_name'] = AttachmentViewer.getFile().name;\n            } else if (AttachmentViewer.hasAttachment()) {\n                // fall back to cloned part\n                let attachment = AttachmentViewer.getAttachment();\n                cipherMessage['attachment'] = attachment[0];\n                cipherMessage['attachment_name'] = attachment[1];\n\n                // we need to retrieve data from blob if browser already parsed it in memory\n                if (typeof attachment[0] === 'string' && attachment[0].startsWith('blob:')) {\n                    Alert.showStatus(\n                        [\n                            'Retrieving cloned file \\'%s\\' from memory...',\n                            attachment[1]\n                        ],\n                        'copy'\n                    );\n                    try {\n                        const blobData = await $.ajax({\n                            type: 'GET',\n                            url: `${attachment[0]}`,\n                            processData: false,\n                            timeout: 10000,\n                            xhrFields: {\n                                withCredentials: false,\n                                responseType: 'blob'\n                            }\n                        });\n                        if (blobData instanceof window.Blob) {\n                            const fileReading = new Promise(function(resolve, reject) {\n                                const fileReader = new FileReader();\n                                fileReader.onload = function (event) {\n                                    resolve(event.target.result);\n                                };\n                                fileReader.onerror = function (error) {\n                                    reject(error);\n                                }\n                                fileReader.readAsDataURL(blobData);\n                            });\n                            cipherMessage['attachment'] = await fileReading;\n                        } else {\n                            const error = 'Cannot process attachment data.';\n                            Alert.showError(error);\n                            throw new TypeError(error);\n                        }\n                    } catch (error) {\n                        console.error(error);\n                        Alert.showError('Cannot retrieve attachment.');\n                        throw error;\n                    }\n                }\n            }\n\n            // encrypt message\n            await ServerInteraction.setCipherMessage(cipherMessage).catch(Alert.showError);\n\n            // send data\n            ServerInteraction.run();\n        };\n\n        return me;\n    })();\n\n    /**\n     * (controller) Responsible for decrypting cipherdata and passing data to view.\n     *\n     * Only decryption, no download.\n     *\n     * @name PasteDecrypter\n     * @class\n     */\n    const PasteDecrypter = (function () {\n        const me = {};\n\n        /**\n         * decrypt data or prompts for password in case of failure\n         *\n         * @name   PasteDecrypter.decryptOrPromptPassword\n         * @private\n         * @async\n         * @function\n         * @param  {string} key\n         * @param  {string} password - optional, may be an empty string\n         * @param  {string} cipherdata\n         * @throws {string}\n         * @return {false|string} false, when unsuccessful or string (decrypted data)\n         */\n        async function decryptOrPromptPassword(key, password, cipherdata)\n        {\n            // try decryption without password\n            const plaindata = await CryptTool.decipher(key, password, cipherdata);\n\n            // if it fails, request password\n            if (plaindata.length === 0 && password.length === 0) {\n                // show prompt\n                Prompt.requestPassword();\n\n                // Thus, we cannot do anything yet, we need to wait for the user\n                // input.\n                return false;\n            }\n\n            // if all tries failed, we can only return an error\n            if (plaindata.length === 0) {\n                return false;\n            }\n\n            return plaindata;\n        }\n\n        /**\n         * decrypt the actual paste text\n         *\n         * @name   PasteDecrypter.decryptPaste\n         * @private\n         * @async\n         * @function\n         * @param  {Paste} paste - paste data in object form\n         * @param  {string} key\n         * @param  {string} password\n         * @throws {string}\n         * @return {Promise}\n         */\n        async function decryptPaste(paste, key, password)\n        {\n            let pastePlain = await decryptOrPromptPassword(\n                key, password,\n                paste.getCipherData()\n            );\n            if (pastePlain === false) {\n                if (password.length === 0) {\n                    throw 'waiting on user to provide a password';\n                } else {\n                    Alert.hideLoading();\n                    // reset password, so it can be re-entered\n                    Prompt.reset();\n                    TopNav.showRetryButton();\n                    throw 'Could not decrypt data. Did you enter a wrong password? Retry with the button at the top.';\n                }\n            }\n\n            if (paste.v > 1) {\n                // version 2 paste\n                const pasteMessage = JSON.parse(pastePlain);\n                if (pasteMessage.hasOwnProperty('attachment') && pasteMessage.hasOwnProperty('attachment_name')) {\n                    AttachmentViewer.setAttachment(pasteMessage.attachment, pasteMessage.attachment_name);\n                    AttachmentViewer.showAttachment();\n                }\n                pastePlain = pasteMessage.paste;\n            } else {\n                // version 1 paste\n                if (paste.hasOwnProperty('attachment') && paste.hasOwnProperty('attachmentname')) {\n                    Promise.all([\n                        CryptTool.decipher(key, password, paste.attachment),\n                        CryptTool.decipher(key, password, paste.attachmentname)\n                    ]).then((attachment) => {\n                        AttachmentViewer.setAttachment(attachment[0], attachment[1]);\n                        AttachmentViewer.showAttachment();\n                    });\n                }\n            }\n            PasteViewer.setFormat(paste.getFormat());\n            PasteViewer.setText(pastePlain);\n            PasteViewer.run();\n        }\n\n        /**\n         * decrypts all comments and shows them\n         *\n         * @name   PasteDecrypter.decryptComments\n         * @private\n         * @async\n         * @function\n         * @param  {Paste} paste - paste data in object form\n         * @param  {string} key\n         * @param  {string} password\n         * @return {Promise}\n         */\n        async function decryptComments(paste, key, password)\n        {\n            // remove potential previous discussion\n            DiscussionViewer.prepareNewDiscussion();\n\n            const commentDecryptionPromises = [];\n            // iterate over comments\n            for (let i = 0; i < paste.comments.length; ++i) {\n                const comment        = new Comment(paste.comments[i]),\n                      commentPromise = CryptTool.decipher(key, password, comment.getCipherData());\n                paste.comments[i] = comment;\n                if (comment.v > 1) {\n                    // version 2 comment\n                    commentDecryptionPromises.push(\n                        commentPromise.then(function (commentJson) {\n                            const commentMessage = JSON.parse(commentJson);\n                            return [\n                                commentMessage.comment  || '',\n                                commentMessage.nickname || ''\n                            ];\n                        })\n                    );\n                } else {\n                    // version 1 comment\n                    commentDecryptionPromises.push(\n                        Promise.all([\n                            commentPromise,\n                            paste.comments[i].meta.hasOwnProperty('nickname') ?\n                                CryptTool.decipher(key, password, paste.comments[i].meta.nickname) :\n                                Promise.resolve('')\n                        ])\n                    );\n                }\n            }\n            return Promise.all(commentDecryptionPromises).then(function (plaintexts) {\n                for (let i = 0; i < paste.comments.length; ++i) {\n                    if (plaintexts[i][0].length === 0) {\n                        continue;\n                    }\n                    DiscussionViewer.addComment(\n                        paste.comments[i],\n                        plaintexts[i][0],\n                        plaintexts[i][1]\n                    );\n                }\n            });\n        }\n\n        /**\n         * show decrypted text in the display area, including discussion (if open)\n         *\n         * @name   PasteDecrypter.run\n         * @function\n         * @param  {Paste} [paste] - (optional) object including comments to display (items = array with keys ('data','meta'))\n         */\n        me.run = function(paste)\n        {\n            Alert.hideMessages();\n            Alert.showLoading('Decrypting paste', 'cloud-download');\n\n            if (typeof paste === 'undefined') {\n                // get cipher data and wait until it is available\n                Model.getPasteData(me.run);\n                return;\n            }\n\n            let key = Model.getPasteKey(),\n                password = Prompt.getPassword(),\n                decryptionPromises = [];\n\n            TopNav.setRetryCallback(function () {\n                TopNav.hideRetryButton();\n                me.run(paste);\n            });\n\n            // decrypt paste & attachments\n            decryptionPromises.push(decryptPaste(paste, key, password));\n\n            // if the discussion is opened on this paste, display it\n            if (paste.isDiscussionEnabled()) {\n                decryptionPromises.push(decryptComments(paste, key, password));\n            }\n\n            // shows the remaining time (until) deletion\n            PasteStatus.showRemainingTime(paste);\n\n            Promise.all(decryptionPromises)\n                .then(() => {\n                    Alert.hideLoading();\n                    TopNav.showViewButtons();\n\n                    // discourage cloning (it cannot really be prevented)\n                    if (paste.isBurnAfterReadingEnabled()) {\n                        TopNav.hideBurnAfterReadingButtons();\n                    } else {\n                        // we have to pass in remaining_time here\n                        TopNav.showEmailButton(paste.getTimeToLive());\n                    }\n\n                    // only offer adding comments, after paste was successfully decrypted\n                    if (paste.isDiscussionEnabled()) {\n                        DiscussionViewer.finishDiscussion();\n                    }\n\n                })\n                .catch((err) => {\n                    // wait for the user to type in the password,\n                    // then PasteDecrypter.run will be called again\n                    Alert.showError(err);\n                });\n        };\n\n        return me;\n    })();\n\n    /**\n     * (controller) main PrivateBin logic\n     *\n     * @name   Controller\n     * @param  {object} window\n     * @param  {object} document\n     * @class\n     */\n    const Controller = (function (window, document) {\n        const me = {};\n\n        /**\n         * hides all status messages no matter which module showed them\n         *\n         * @name   Controller.hideStatusMessages\n         * @function\n         */\n        me.hideStatusMessages = function()\n        {\n            PasteStatus.hideMessages();\n            Alert.hideMessages();\n        };\n\n        /**\n         * creates a new paste\n         *\n         * @name   Controller.newPaste\n         * @function\n         */\n        me.newPaste = function()\n        {\n            // Important: This *must not* run Alert.hideMessages() as previous\n            // errors from viewing a paste should be shown.\n            TopNav.hideAllButtons();\n            Alert.showLoading('Preparing new paste', 'time');\n\n            PasteStatus.hideMessages();\n            PasteViewer.hide();\n            Editor.resetInput();\n            Editor.show();\n            Editor.focusInput();\n            AttachmentViewer.removeAttachment();\n            TopNav.resetInput();\n\n            TopNav.showCreateButtons();\n\n            // newPaste could be called when user is on paste clone editing view\n            TopNav.hideCustomAttachment();\n            AttachmentViewer.clearDragAndDrop();\n            AttachmentViewer.removeAttachmentData();\n\n            Alert.hideLoading();\n            history.pushState({type: 'create'}, document.title, Helper.baseUri());\n\n            // clear discussion\n            DiscussionViewer.prepareNewDiscussion();\n        };\n\n        /**\n         * shows the loaded paste\n         *\n         * @name   Controller.showPaste\n         * @function\n         */\n        me.showPaste = function()\n        {\n            try {\n                Model.getPasteKey();\n            } catch (err) {\n                console.error(err);\n\n                // missing decryption key (or paste ID) in URL?\n                if (window.location.hash.length === 0) {\n                    Alert.showError('Cannot decrypt paste: Decryption key missing in URL (Did you use a redirector or an URL shortener which strips part of the URL?)');\n                    return;\n                }\n            }\n\n            // show proper elements on screen\n            PasteDecrypter.run();\n        };\n\n        /**\n         * refreshes the loaded paste to show potential new data\n         *\n         * @name   Controller.refreshPaste\n         * @function\n         * @param  {function} callback\n         */\n        me.refreshPaste = function(callback)\n        {\n            // save window position to restore it later\n            const orgPosition = $(window).scrollTop();\n\n            Model.getPasteData(function (data) {\n                ServerInteraction.prepare();\n                ServerInteraction.setUrl(Helper.baseUri() + '?pasteid=' + Model.getPasteId());\n\n                ServerInteraction.setFailure(function (status, data) {\n                    // revert loading status\n                    Alert.hideLoading();\n                    TopNav.showViewButtons();\n\n                    // show error message\n                    Alert.showError(\n                        ServerInteraction.parseUploadError(status, data, 'refresh display')\n                    );\n                });\n                ServerInteraction.setSuccess(function (status, data) {\n                    PasteDecrypter.run(new Paste(data));\n\n                    // restore position\n                    window.scrollTo(0, orgPosition);\n\n                    // NOTE: could create problems as callback may be called\n                    // asyncronously if PasteDecrypter e.g. needs to wait for a\n                    // password being entered\n                    callback();\n                });\n                ServerInteraction.run();\n            }, false); // this false is important as it circumvents the cache\n        }\n\n        /**\n         * clone the current paste\n         *\n         * @name   Controller.clonePaste\n         * @function\n         */\n        me.clonePaste = function()\n        {\n            TopNav.collapseBar();\n            TopNav.hideAllButtons();\n\n            // hide messages from previous paste\n            me.hideStatusMessages();\n\n            // erase the id and the key in url\n            history.pushState({type: 'clone'}, document.title, Helper.baseUri());\n\n            if (AttachmentViewer.hasAttachment()) {\n                AttachmentViewer.moveAttachmentTo(\n                    TopNav.getCustomAttachment(),\n                    'Cloned: \\'%s\\''\n                );\n                TopNav.hideFileSelector();\n                AttachmentViewer.hideAttachment();\n                // NOTE: it also looks nice without removing the attachment\n                // but for a consistent display we remove it\n                AttachmentViewer.hideAttachmentPreview();\n                TopNav.showCustomAttachment();\n\n                // show another status message to make the user aware that the\n                // file was cloned too!\n                Alert.showStatus(\n                    [\n                        'The cloned file \\'%s\\' was attached to this paste.',\n                        AttachmentViewer.getAttachment()[1]\n                    ],\n                    'copy'\n                );\n            }\n\n            Editor.setText(PasteViewer.getText());\n            // also clone the format\n            TopNav.setFormat(PasteViewer.getFormat());\n            PasteViewer.hide();\n            Editor.show();\n\n            TopNav.showCreateButtons();\n\n            // clear discussion\n            DiscussionViewer.prepareNewDiscussion();\n        };\n\n        /**\n         * try initializing zlib or display a warning if it fails,\n         * extracted from main init to allow unit testing\n         *\n         * @name   Controller.initZ\n         * @function\n         */\n        me.initZ = function()\n        {\n            z = zlib.catch(function () {\n                if ($('body').data('compression') !== 'none') {\n                    Alert.showWarning('Your browser doesn\\'t support WebAssembly, used for zlib compression. You can create uncompressed documents, but can\\'t read compressed ones.');\n                }\n            });\n        }\n\n        /**\n         * application start\n         *\n         * @name   Controller.init\n         * @function\n         */\n        me.init = function()\n        {\n            // first load translations\n            I18n.loadTranslations();\n\n            DOMPurify.setConfig({\n                ALLOWED_URI_REGEXP: /^(?:(?:(?:f|ht)tps?|mailto|magnet):)/i,\n                SAFE_FOR_JQUERY: true\n            });\n\n            // Add a hook to make all links open a new window\n            DOMPurify.addHook('afterSanitizeAttributes', function(node) {\n                // set all elements owning target to target=_blank\n                if ('target' in node && node.id !== 'pasteurl') {\n                    node.setAttribute('target', '_blank');\n                }\n                // set non-HTML/MathML links to xlink:show=new\n                if (!node.hasAttribute('target')\n                    && (node.hasAttribute('xlink:href')\n                        || node.hasAttribute('href'))) {\n                    node.setAttribute('xlink:show', 'new');\n                }\n                if ('rel' in node) {\n                    node.setAttribute('rel', 'nofollow noopener noreferrer');\n                }\n            });\n\n            // center all modals\n            $('.modal').on('show.bs.modal', function(e) {\n                $(e.target).css({\n                    display: 'flex'\n                });\n            });\n\n            // initialize other modules/\"classes\"\n            Alert.init();\n            Model.init();\n            AttachmentViewer.init();\n            DiscussionViewer.init();\n            Editor.init();\n            PasteStatus.init();\n            PasteViewer.init();\n            Prompt.init();\n            TopNav.init();\n            UiHelper.init();\n\n            // check for legacy browsers before going any further\n            if (!Legacy.Check.getInit()) {\n                // Legacy check didn't complete, wait and try again\n                setTimeout(init, 500);\n                return;\n            }\n            if (!Legacy.Check.getStatus()) {\n                // something major is wrong, stop right away\n                return;\n            }\n            me.initZ();\n\n            // if delete token is passed (i.e. paste has been deleted by this\n            // access), there is nothing more to do\n            if (Model.hasDeleteToken()) {\n                return;\n            }\n\n            // check whether existing paste needs to be shown\n            try {\n                Model.getPasteId();\n            } catch (e) {\n                // otherwise create a new paste\n                return me.newPaste();\n            }\n\n            // always reload on back button to invalidate cache(protect burn after read paste)\n            window.addEventListener('popstate', () => {\n                window.location.reload();\n            });\n\n            // display an existing paste\n            return me.showPaste();\n        }\n\n        return me;\n    })(window, document);\n\n    return {\n        Helper: Helper,\n        I18n: I18n,\n        CryptTool: CryptTool,\n        Model: Model,\n        UiHelper: UiHelper,\n        Alert: Alert,\n        PasteStatus: PasteStatus,\n        Prompt: Prompt,\n        Editor: Editor,\n        PasteViewer: PasteViewer,\n        AttachmentViewer: AttachmentViewer,\n        DiscussionViewer: DiscussionViewer,\n        TopNav: TopNav,\n        ServerInteraction: ServerInteraction,\n        PasteEncrypter: PasteEncrypter,\n        PasteDecrypter: PasteDecrypter,\n        Controller: Controller\n    };\n})(jQuery, RawDeflate);\n", "output": {"vulnerability_count": 28, "vulnerabilities": [{"description": "JQuery's `html` function is susceptible to Cross Site Scripting (XSS) attacks. If you're just passing text, consider `text` instead. Otherwise, use a function that escapes HTML such as edX's `HtmlUtils.setHtml()`.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 407}, {"description": "JQuery's `html` function is susceptible to Cross Site Scripting (XSS) attacks. If you're just passing text, consider `text` instead. Otherwise, use a function that escapes HTML such as edX's `HtmlUtils.setHtml()`.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 756}, {"description": "JSON stringify does not produce a stable key ordering, and should not be relied on for producing object keys. Consider using json-stable-stringify instead.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1226}, {"description": "JSON stringify does not produce a stable key ordering, and should not be relied on for producing object keys. Consider using json-stable-stringify instead.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1998}, {"description": "User controlled data in a jQuery's `.html(...)` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 2067}, {"description": "JQuery's `html` function is susceptible to Cross Site Scripting (XSS) attacks. If you're just passing text, consider `text` instead. Otherwise, use a function that escapes HTML such as edX's `HtmlUtils.setHtml()`.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 2067}, {"description": "found prompt() call; should this be in production code?", "risk": "Medium", "conceptual_fix": "Not provided", "line": 2202}, {"description": "JQuery's `html` function is susceptible to Cross Site Scripting (XSS) attacks. If you're just passing text, consider `text` instead. Otherwise, use a function that escapes HTML such as edX's `HtmlUtils.setHtml()`.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 2537}, {"description": "JQuery's `html` function is susceptible to Cross Site Scripting (XSS) attacks. If you're just passing text, consider `text` instead. Otherwise, use a function that escapes HTML such as edX's `HtmlUtils.setHtml()`.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 2552}, {"description": "JQuery's `html` function is susceptible to Cross Site Scripting (XSS) attacks. If you're just passing text, consider `text` instead. Otherwise, use a function that escapes HTML such as edX's `HtmlUtils.setHtml()`.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 3020}, {"description": "JQuery's `html` function is susceptible to Cross Site Scripting (XSS) attacks. If you're just passing text, consider `text` instead. Otherwise, use a function that escapes HTML such as edX's `HtmlUtils.setHtml()`.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 3026}, {"description": "JQuery's `html` function is susceptible to Cross Site Scripting (XSS) attacks. If you're just passing text, consider `text` instead. Otherwise, use a function that escapes HTML such as edX's `HtmlUtils.setHtml()`.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 3037}, {"description": "JQuery's `html` function is susceptible to Cross Site Scripting (XSS) attacks. If you're just passing text, consider `text` instead. Otherwise, use a function that escapes HTML such as edX's `HtmlUtils.setHtml()`.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 3050}, {"description": "User controlled data in a `$(...)` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 3265}, {"description": "User controlled data in a jQuery's `.after(...)` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 3275}, {"description": "User controlled data in a `$(...)` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 3368}, {"description": "User controlled data in a `$(...)` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 3456}, {"description": "User controlled data in a `$(...)` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 3549}, {"description": "User controlled data in a `$(...)` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 3569}, {"description": "User controlled data in a `$(...)` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 3706}, {"description": "User controlled data in a jQuery's `.html(...)` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 3776}, {"description": "JQuery's `html` function is susceptible to Cross Site Scripting (XSS) attacks. If you're just passing text, consider `text` instead. Otherwise, use a function that escapes HTML such as edX's `HtmlUtils.setHtml()`.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 3776}, {"description": "JSON stringify does not produce a stable key ordering, and should not be relied on for producing object keys. Consider using json-stable-stringify instead.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 4643}, {"description": "JSON stringify does not produce a stable key ordering, and should not be relied on for producing object keys. Consider using json-stable-stringify instead.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 4643}, {"description": "JSON stringify does not produce a stable key ordering, and should not be relied on for producing object keys. Consider using json-stable-stringify instead.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 4644}, {"description": "JSON stringify does not produce a stable key ordering, and should not be relied on for producing object keys. Consider using json-stable-stringify instead.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 4644}, {"description": "User controlled data in a `$(...)` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 5287}, {"description": "User controlled data in a `$(...)` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 5421}]}}
{"CVE": "CVE-2022-31035", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "import {DropDownMenu} from 'argo-ui';\nimport * as React from 'react';\n\nclass ExternalLink {\n    public title: string;\n    public ref: string;\n\n    constructor(url: string) {\n        const parts = url.split('|');\n        if (parts.length === 2) {\n            this.title = parts[0];\n            this.ref = parts[1];\n        } else {\n            this.title = url;\n            this.ref = url;\n        }\n    }\n}\n\nexport const ApplicationURLs = ({urls}: {urls: string[]}) => {\n    const externalLinks: ExternalLink[] = [];\n    for (const url of urls || []) {\n        externalLinks.push(new ExternalLink(url));\n    }\n\n    // sorted alphabetically & links with titles first\n    externalLinks.sort((a, b) => {\n        if (a.title !== '' && b.title !== '') {\n            return a.title > b.title ? 1 : -1;\n        } else if (a.title === '') {\n            return 1;\n        } else if (b.title === '') {\n            return -1;\n        }\n        return a.ref > b.ref ? 1 : -1;\n    });\n\n    return (\n        ((externalLinks || []).length > 0 && (\n            <div className='applications-list__external-links-icon-container'>\n                <a\n                    title={externalLinks[0].title}\n                    onClick={e => {\n                        e.stopPropagation();\n                        window.open(externalLinks[0].ref);\n                    }}>\n                    <i className='fa fa-external-link-alt' />{' '}\n                    {externalLinks.length > 1 && (\n                        <DropDownMenu\n                            anchor={() => <i className='fa fa-caret-down' />}\n                            items={externalLinks.map(item => ({\n                                title: item.title,\n                                action: () => window.open(item.ref)\n                            }))}\n                        />\n                    )}\n                </a>\n            </div>\n        )) ||\n        null\n    );\n};\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2022-31051", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "const {pick} = require('lodash');\nconst marked = require('marked');\nconst envCi = require('env-ci');\nconst hookStd = require('hook-std');\nconst semver = require('semver');\nconst AggregateError = require('aggregate-error');\nconst pkg = require('./package.json');\nconst hideSensitive = require('./lib/hide-sensitive');\nconst getConfig = require('./lib/get-config');\nconst verify = require('./lib/verify');\nconst getNextVersion = require('./lib/get-next-version');\nconst getCommits = require('./lib/get-commits');\nconst getLastRelease = require('./lib/get-last-release');\nconst getReleaseToAdd = require('./lib/get-release-to-add');\nconst {extractErrors, makeTag} = require('./lib/utils');\nconst getGitAuthUrl = require('./lib/get-git-auth-url');\nconst getBranches = require('./lib/branches');\nconst getLogger = require('./lib/get-logger');\nconst {verifyAuth, isBranchUpToDate, getGitHead, tag, push, pushNotes, getTagHead, addNote} = require('./lib/git');\nconst getError = require('./lib/get-error');\nconst {COMMIT_NAME, COMMIT_EMAIL} = require('./lib/definitions/constants');\n\nlet markedOptionsSet = false;\nasync function terminalOutput(text) {\n  if (!markedOptionsSet) {\n    const {default: TerminalRenderer} = await import('marked-terminal'); // eslint-disable-line node/no-unsupported-features/es-syntax\n    marked.setOptions({renderer: new TerminalRenderer()});\n    markedOptionsSet = true;\n  }\n\n  return marked.parse(text);\n}\n\n/* eslint complexity: off */\nasync function run(context, plugins) {\n  const {cwd, env, options, logger} = context;\n  const {isCi, branch, prBranch, isPr} = context.envCi;\n  const ciBranch = isPr ? prBranch : branch;\n\n  if (!isCi && !options.dryRun && !options.noCi) {\n    logger.warn('This run was not triggered in a known CI environment, running in dry-run mode.');\n    options.dryRun = true;\n  } else {\n    // When running on CI, set the commits author and commiter info and prevent the `git` CLI to prompt for username/password. See #703.\n    Object.assign(env, {\n      GIT_AUTHOR_NAME: COMMIT_NAME,\n      GIT_AUTHOR_EMAIL: COMMIT_EMAIL,\n      GIT_COMMITTER_NAME: COMMIT_NAME,\n      GIT_COMMITTER_EMAIL: COMMIT_EMAIL,\n      ...env,\n      GIT_ASKPASS: 'echo',\n      GIT_TERMINAL_PROMPT: 0,\n    });\n  }\n\n  if (isCi && isPr && !options.noCi) {\n    logger.log(\"This run was triggered by a pull request and therefore a new version won't be published.\");\n    return false;\n  }\n\n  // Verify config\n  await verify(context);\n\n  options.repositoryUrl = await getGitAuthUrl({...context, branch: {name: ciBranch}});\n  context.branches = await getBranches(options.repositoryUrl, ciBranch, context);\n  context.branch = context.branches.find(({name}) => name === ciBranch);\n\n  if (!context.branch) {\n    logger.log(\n      `This test run was triggered on the branch ${ciBranch}, while semantic-release is configured to only publish from ${context.branches\n        .map(({name}) => name)\n        .join(', ')}, therefore a new version wont be published.`\n    );\n    return false;\n  }\n\n  logger[options.dryRun ? 'warn' : 'success'](\n    `Run automated release from branch ${ciBranch} on repository ${options.repositoryUrl}${\n      options.dryRun ? ' in dry-run mode' : ''\n    }`\n  );\n\n  try {\n    try {\n      await verifyAuth(options.repositoryUrl, context.branch.name, {cwd, env});\n    } catch (error) {\n      if (!(await isBranchUpToDate(options.repositoryUrl, context.branch.name, {cwd, env}))) {\n        logger.log(\n          `The local branch ${context.branch.name} is behind the remote one, therefore a new version won't be published.`\n        );\n        return false;\n      }\n\n      throw error;\n    }\n  } catch (error) {\n    logger.error(`The command \"${error.command}\" failed with the error message ${error.stderr}.`);\n    throw getError('EGITNOPERMISSION', context);\n  }\n\n  logger.success(`Allowed to push to the Git repository`);\n\n  await plugins.verifyConditions(context);\n\n  const errors = [];\n  context.releases = [];\n  const releaseToAdd = getReleaseToAdd(context);\n\n  if (releaseToAdd) {\n    const {lastRelease, currentRelease, nextRelease} = releaseToAdd;\n\n    nextRelease.gitHead = await getTagHead(nextRelease.gitHead, {cwd, env});\n    currentRelease.gitHead = await getTagHead(currentRelease.gitHead, {cwd, env});\n    if (context.branch.mergeRange && !semver.satisfies(nextRelease.version, context.branch.mergeRange)) {\n      errors.push(getError('EINVALIDMAINTENANCEMERGE', {...context, nextRelease}));\n    } else {\n      const commits = await getCommits({...context, lastRelease, nextRelease});\n      nextRelease.notes = await plugins.generateNotes({...context, commits, lastRelease, nextRelease});\n\n      if (options.dryRun) {\n        logger.warn(`Skip ${nextRelease.gitTag} tag creation in dry-run mode`);\n      } else {\n        await addNote({channels: [...currentRelease.channels, nextRelease.channel]}, nextRelease.gitHead, {cwd, env});\n        await push(options.repositoryUrl, {cwd, env});\n        await pushNotes(options.repositoryUrl, {cwd, env});\n        logger.success(\n          `Add ${nextRelease.channel ? `channel ${nextRelease.channel}` : 'default channel'} to tag ${\n            nextRelease.gitTag\n          }`\n        );\n      }\n\n      context.branch.tags.push({\n        version: nextRelease.version,\n        channel: nextRelease.channel,\n        gitTag: nextRelease.gitTag,\n        gitHead: nextRelease.gitHead,\n      });\n\n      const releases = await plugins.addChannel({...context, commits, lastRelease, currentRelease, nextRelease});\n      context.releases.push(...releases);\n      await plugins.success({...context, lastRelease, commits, nextRelease, releases});\n    }\n  }\n\n  if (errors.length > 0) {\n    throw new AggregateError(errors);\n  }\n\n  context.lastRelease = getLastRelease(context);\n  if (context.lastRelease.gitHead) {\n    context.lastRelease.gitHead = await getTagHead(context.lastRelease.gitHead, {cwd, env});\n  }\n\n  if (context.lastRelease.gitTag) {\n    logger.log(\n      `Found git tag ${context.lastRelease.gitTag} associated with version ${context.lastRelease.version} on branch ${context.branch.name}`\n    );\n  } else {\n    logger.log(`No git tag version found on branch ${context.branch.name}`);\n  }\n\n  context.commits = await getCommits(context);\n\n  const nextRelease = {\n    type: await plugins.analyzeCommits(context),\n    channel: context.branch.channel || null,\n    gitHead: await getGitHead({cwd, env}),\n  };\n  if (!nextRelease.type) {\n    logger.log('There are no relevant changes, so no new version is released.');\n    return context.releases.length > 0 ? {releases: context.releases} : false;\n  }\n\n  context.nextRelease = nextRelease;\n  nextRelease.version = getNextVersion(context);\n  nextRelease.gitTag = makeTag(options.tagFormat, nextRelease.version);\n  nextRelease.name = nextRelease.gitTag;\n\n  if (context.branch.type !== 'prerelease' && !semver.satisfies(nextRelease.version, context.branch.range)) {\n    throw getError('EINVALIDNEXTVERSION', {\n      ...context,\n      validBranches: context.branches.filter(\n        ({type, accept}) => type !== 'prerelease' && accept.includes(nextRelease.type)\n      ),\n    });\n  }\n\n  await plugins.verifyRelease(context);\n\n  nextRelease.notes = await plugins.generateNotes(context);\n\n  await plugins.prepare(context);\n\n  if (options.dryRun) {\n    logger.warn(`Skip ${nextRelease.gitTag} tag creation in dry-run mode`);\n  } else {\n    // Create the tag before calling the publish plugins as some require the tag to exists\n    await tag(nextRelease.gitTag, nextRelease.gitHead, {cwd, env});\n    await addNote({channels: [nextRelease.channel]}, nextRelease.gitHead, {cwd, env});\n    await push(options.repositoryUrl, {cwd, env});\n    await pushNotes(options.repositoryUrl, {cwd, env});\n    logger.success(`Created tag ${nextRelease.gitTag}`);\n  }\n\n  const releases = await plugins.publish(context);\n  context.releases.push(...releases);\n\n  await plugins.success({...context, releases});\n\n  logger.success(\n    `Published release ${nextRelease.version} on ${nextRelease.channel ? nextRelease.channel : 'default'} channel`\n  );\n\n  if (options.dryRun) {\n    logger.log(`Release note for version ${nextRelease.version}:`);\n    if (nextRelease.notes) {\n      context.stdout.write(await terminalOutput(nextRelease.notes));\n    }\n  }\n\n  return pick(context, ['lastRelease', 'commits', 'nextRelease', 'releases']);\n}\n\nasync function logErrors({logger, stderr}, err) {\n  const errors = extractErrors(err).sort((error) => (error.semanticRelease ? -1 : 0));\n  for (const error of errors) {\n    if (error.semanticRelease) {\n      logger.error(`${error.code} ${error.message}`);\n      if (error.details) {\n        stderr.write(await terminalOutput(error.details)); // eslint-disable-line no-await-in-loop\n      }\n    } else {\n      logger.error('An error occurred while running semantic-release: %O', error);\n    }\n  }\n}\n\nasync function callFail(context, plugins, err) {\n  const errors = extractErrors(err).filter((err) => err.semanticRelease);\n  if (errors.length > 0) {\n    try {\n      await plugins.fail({...context, errors});\n    } catch (error) {\n      await logErrors(context, error);\n    }\n  }\n}\n\nmodule.exports = async (cliOptions = {}, {cwd = process.cwd(), env = process.env, stdout, stderr} = {}) => {\n  const {unhook} = hookStd(\n    {silent: false, streams: [process.stdout, process.stderr, stdout, stderr].filter(Boolean)},\n    hideSensitive(env)\n  );\n  const context = {\n    cwd,\n    env,\n    stdout: stdout || process.stdout,\n    stderr: stderr || process.stderr,\n    envCi: envCi({env, cwd}),\n  };\n  context.logger = getLogger(context);\n  context.logger.log(`Running ${pkg.name} version ${pkg.version}`);\n  try {\n    const {plugins, options} = await getConfig(context, cliOptions);\n    context.options = options;\n    try {\n      const result = await run(context, plugins);\n      unhook();\n      return result;\n    } catch (error) {\n      await callFail(context, plugins, error);\n      throw error;\n    }\n  } catch (error) {\n    await logErrors(context, error);\n    unhook();\n    throw error;\n  }\n};\n", "output": {"vulnerability_count": 5, "vulnerabilities": [{"description": "This looks like a JavaScript template string. Are you missing a '$' in front of '{...}'?", "risk": "Medium", "conceptual_fix": "Not provided", "line": 70}, {"description": "This looks like a JavaScript template string. Are you missing a '$' in front of '{...}'?", "risk": "Medium", "conceptual_fix": "Not provided", "line": 70}, {"description": "This looks like a JavaScript template string. Are you missing a '$' in front of '{...}'?", "risk": "Medium", "conceptual_fix": "Not provided", "line": 70}, {"description": "This looks like a JavaScript template string. Are you missing a '$' in front of '{...}'?", "risk": "Medium", "conceptual_fix": "Not provided", "line": 70}, {"description": "This looks like a JavaScript template string. Are you missing a '$' in front of '{...}'?", "risk": "Medium", "conceptual_fix": "Not provided", "line": 71}]}}
{"CVE": "CVE-2022-31094", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "\nvar li = document.createElement('li')\nvar a = document.createElement('a')\na.textContent = 'Recently Viewed'\nli.appendChild(a)\n  li.dataset.tab = 'recent'\ndocument.querySelector('ul#tabs').lastChild.className = ''\nli.className = 'last'\ndocument.querySelector('ul#tabs').appendChild(li)\nli.onclick = function() {\n    getRecent()\n}\n\nif (window.location.href === 'https://scratch.mit.edu/mystuff/#recent') {\n    getRecent()\n}\n   \n    async function getRecent() {\n        function getCookie(name) {\n  const value = `; ${document.cookie}`;\n  const parts = value.split(`; ${name}=`);\n  if (parts.length === 2) return parts.pop().split(';').shift();\n}\n        var response2 = await fetch(\"https://scratch.mit.edu/session/\", {\n  \"headers\": {\n    \"accept\": \"*/*\",\n    \"accept-language\": \"en-US,en;q=0.9\",\n    \"sec-ch-ua\": \"\\\" Not A;Brand\\\";v=\\\"99\\\", \\\"Chromium\\\";v=\\\"101\\\", \\\"Google Chrome\\\";v=\\\"101\\\"\",\n    \"sec-ch-ua-mobile\": \"?0\",\n    \"sec-ch-ua-platform\": \"\\\"macOS\\\"\",\n    \"sec-fetch-dest\": \"empty\",\n    \"sec-fetch-mode\": \"cors\",\n    \"sec-fetch-site\": \"same-origin\",\n    \"x-requested-with\": \"XMLHttpRequest\"\n  },\n  \"referrer\": \"https://scratch.mit.edu/mystuff/\",\n  \"referrerPolicy\": \"strict-origin-when-cross-origin\",\n  \"body\": null,\n  \"method\": \"GET\",\n  \"mode\": \"cors\",\n  \"credentials\": \"include\"\n});\n        var data2 = await response2.json()\nvar response = await fetch(\"https://api.scratch.mit.edu/users/\"+document.querySelector('ul.user-nav').firstChild.firstChild.href.split('/users/')[1].split('/')[0]+\"/projects/recentlyviewed?limit=24&offset=0\", {\n  \"headers\": {\n    \"accept\": \"*/*\",\n    \"accept-language\": \"en, en;q=0.8\",\n    \"sec-ch-ua\": \"\\\" Not A;Brand\\\";v=\\\"99\\\", \\\"Chromium\\\";v=\\\"101\\\", \\\"Google Chrome\\\";v=\\\"101\\\"\",\n    \"sec-ch-ua-mobile\": \"?0\",\n    \"sec-ch-ua-platform\": \"\\\"macOS\\\"\",\n    \"sec-fetch-dest\": \"empty\",\n    \"sec-fetch-mode\": \"cors\",\n    \"sec-fetch-site\": \"same-site\",\n    \"x-token\": data2['user']['token']\n  },\n  \"referrer\": \"https://scratch.mit.edu/\",\n  \"referrerPolicy\": \"strict-origin-when-cross-origin\",\n  \"body\": null,\n  \"method\": \"GET\",\n  \"mode\": \"cors\",\n  \"credentials\": \"omit\"\n});\n    var data = await response.json()\n    console.log(data)\nfunction removeAllChildNodes(parent) {\n    while (parent.firstChild) {\n        parent.removeChild(parent.firstChild);\n    }\n}\n    if (document.querySelector('ul.media-list') === null) {\n        var ul = document.createElement('ul')\n        ul.className = 'media-list'\n        document.querySelector('div#main-content').appendChild(ul)\n    } else {\n    removeAllChildNodes(document.querySelector('ul.media-list'))\n    }\n        if (document.querySelector('div.inner') !== null) {\n    document.querySelector('div.inner').remove()\n        }\n    Object.keys(data).forEach(function(project) {\n        var pr = document.createElement('li')\n        pr.innerHTML = `<div class=\"media-item-content not-shared\"><div class=\"media-thumb\"><a href=\"/projects/${data[project]['id']}/\"><img src=\"${data[project]['image']}\"></a></div><div class=\"media-info\"><span class=\"media-info-item title\"><a href=\"/projects/${data[project]['id']}/\">${data[project]['title']}</a></span></div></div>`\n       document.querySelector('ul.media-list').prepend(pr)\n    })\n    deleteButton()\n    function deleteButton() {\n        if (document.querySelector('#main-content > div.grey.button') !== undefined) {\n            document.querySelector('#main-content > div.grey.button').remove()\n        } else {\n            setTimeout(deleteButton, 50)\n        }\n    }\n}\n", "output": {"vulnerability_count": 3, "vulnerabilities": [{"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 82}, {"description": "User controlled data in a `pr.innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 82}, {"description": "This template literal looks like HTML and has interpolated variables. These variables are not HTML-encoded by default. If the variables contain HTML tags, these may be interpreted by the browser, resulting in cross-site scripting (XSS).", "risk": "Medium", "conceptual_fix": "Not provided", "line": 82}]}}
{"CVE": "CVE-2022-31108", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "import { sanitizeUrl } from '@braintree/sanitize-url';\nimport {\n  curveBasis,\n  curveBasisClosed,\n  curveBasisOpen,\n  curveLinear,\n  curveLinearClosed,\n  curveMonotoneX,\n  curveMonotoneY,\n  curveNatural,\n  curveStep,\n  curveStepAfter,\n  curveStepBefore,\n  select,\n} from 'd3';\nimport common from './diagrams/common/common';\nimport { configKeys } from './defaultConfig';\nimport { log } from './logger';\n\n// Effectively an enum of the supported curve types, accessible by name\nconst d3CurveTypes = {\n  curveBasis: curveBasis,\n  curveBasisClosed: curveBasisClosed,\n  curveBasisOpen: curveBasisOpen,\n  curveLinear: curveLinear,\n  curveLinearClosed: curveLinearClosed,\n  curveMonotoneX: curveMonotoneX,\n  curveMonotoneY: curveMonotoneY,\n  curveNatural: curveNatural,\n  curveStep: curveStep,\n  curveStepAfter: curveStepAfter,\n  curveStepBefore: curveStepBefore,\n};\nconst directive =\n  /[%]{2}[{]\\s*(?:(?:(\\w+)\\s*:|(\\w+))\\s*(?:(?:(\\w+))|((?:(?![}][%]{2}).|\\r?\\n)*))?\\s*)(?:[}][%]{2})?/gi;\nconst directiveWithoutOpen =\n  /\\s*(?:(?:(\\w+)(?=:):|(\\w+))\\s*(?:(?:(\\w+))|((?:(?![}][%]{2}).|\\r?\\n)*))?\\s*)(?:[}][%]{2})?/gi;\nconst anyComment = /\\s*%%.*\\n/gm;\n\n/**\n * @function detectInit Detects the init config object from the text\n *\n *   ```mermaid\n *   %%{init: {\"theme\": \"debug\", \"logLevel\": 1 }}%%\n *   graph LR\n *    a-->b\n *    b-->c\n *    c-->d\n *    d-->e\n *    e-->f\n *    f-->g\n *    g-->h\n * ```\n *\n *   Or\n *\n *   ```mermaid\n *   %%{initialize: {\"theme\": \"dark\", logLevel: \"debug\" }}%%\n *   graph LR\n *    a-->b\n *    b-->c\n *    c-->d\n *    d-->e\n *    e-->f\n *    f-->g\n *    g-->h\n * ```\n * @param {string} text The text defining the graph\n * @param {any} cnf\n * @returns {object} The json object representing the init passed to mermaid.initialize()\n */\nexport const detectInit = function (text, cnf) {\n  let inits = detectDirective(text, /(?:init\\b)|(?:initialize\\b)/);\n  let results = {};\n\n  if (Array.isArray(inits)) {\n    let args = inits.map((init) => init.args);\n    directiveSanitizer(args);\n\n    results = assignWithDepth(results, [...args]);\n  } else {\n    results = inits.args;\n  }\n  if (results) {\n    let type = detectType(text, cnf);\n    ['config'].forEach((prop) => {\n      if (typeof results[prop] !== 'undefined') {\n        if (type === 'flowchart-v2') {\n          type = 'flowchart';\n        }\n        results[type] = results[prop];\n        delete results[prop];\n      }\n    });\n  }\n\n  // Todo: refactor this, these results are never used\n  return results;\n};\n\n/**\n * @function detectDirective Detects the directive from the text. Text can be single line or\n *   multiline. If type is null or omitted the first directive encountered in text will be returned\n *\n *   ```mermaid\n *   graph LR\n *    %%{somedirective}%%\n *    a-->b\n *    b-->c\n *    c-->d\n *    d-->e\n *    e-->f\n *    f-->g\n *    g-->h\n * ```\n * @param {string} text The text defining the graph\n * @param {string | RegExp} type The directive to return (default: null)\n * @returns {object | Array} An object or Array representing the directive(s): { type: string, args:\n *   object|null } matched by the input type if a single directive was found, that directive object\n *   will be returned.\n */\nexport const detectDirective = function (text, type = null) {\n  try {\n    const commentWithoutDirectives = new RegExp(\n      `[%]{2}(?![{]${directiveWithoutOpen.source})(?=[}][%]{2}).*\\n`,\n      'ig'\n    );\n    text = text.trim().replace(commentWithoutDirectives, '').replace(/'/gm, '\"');\n    log.debug(\n      `Detecting diagram directive${type !== null ? ' type:' + type : ''} based on the text:${text}`\n    );\n    let match,\n      result = [];\n    while ((match = directive.exec(text)) !== null) {\n      // This is necessary to avoid infinite loops with zero-width matches\n      if (match.index === directive.lastIndex) {\n        directive.lastIndex++;\n      }\n      if (\n        (match && !type) ||\n        (type && match[1] && match[1].match(type)) ||\n        (type && match[2] && match[2].match(type))\n      ) {\n        let type = match[1] ? match[1] : match[2];\n        let args = match[3] ? match[3].trim() : match[4] ? JSON.parse(match[4].trim()) : null;\n        result.push({ type, args });\n      }\n    }\n    if (result.length === 0) {\n      result.push({ type: text, args: null });\n    }\n\n    return result.length === 1 ? result[0] : result;\n  } catch (error) {\n    log.error(\n      `ERROR: ${error.message} - Unable to parse directive\n      ${type !== null ? ' type:' + type : ''} based on the text:${text}`\n    );\n    return { type: null, args: null };\n  }\n};\n\n/**\n * @function detectType Detects the type of the graph text. Takes into consideration the possible\n *   existence of an %%init directive\n *\n *   ```mermaid\n *   %%{initialize: {\"startOnLoad\": true, logLevel: \"fatal\" }}%%\n *   graph LR\n *    a-->b\n *    b-->c\n *    c-->d\n *    d-->e\n *    e-->f\n *    f-->g\n *    g-->h\n * ```\n * @param {string} text The text defining the graph\n * @param {{\n *   class: { defaultRenderer: string } | undefined;\n *   state: { defaultRenderer: string } | undefined;\n *   flowchart: { defaultRenderer: string } | undefined;\n * }} [cnf]\n * @returns {string} A graph definition key\n */\nexport const detectType = function (text, cnf) {\n  text = text.replace(directive, '').replace(anyComment, '\\n');\n  if (text.match(/^\\s*C4Context|C4Container|C4Component|C4Dynamic|C4Deployment/)) {\n    return 'c4';\n  }\n\n  if (text.match(/^\\s*sequenceDiagram/)) {\n    return 'sequence';\n  }\n\n  if (text.match(/^\\s*gantt/)) {\n    return 'gantt';\n  }\n  if (text.match(/^\\s*classDiagram-v2/)) {\n    return 'classDiagram';\n  }\n  if (text.match(/^\\s*classDiagram/)) {\n    if (cnf && cnf.class && cnf.class.defaultRenderer === 'dagre-wrapper') return 'classDiagram';\n    return 'class';\n  }\n\n  if (text.match(/^\\s*stateDiagram-v2/)) {\n    return 'stateDiagram';\n  }\n\n  if (text.match(/^\\s*stateDiagram/)) {\n    if (cnf && cnf.class && cnf.state.defaultRenderer === 'dagre-wrapper') return 'stateDiagram';\n    return 'state';\n  }\n\n  if (text.match(/^\\s*gitGraph/)) {\n    return 'gitGraph';\n  }\n  if (text.match(/^\\s*flowchart/)) {\n    return 'flowchart-v2';\n  }\n\n  if (text.match(/^\\s*info/)) {\n    return 'info';\n  }\n  if (text.match(/^\\s*pie/)) {\n    return 'pie';\n  }\n\n  if (text.match(/^\\s*erDiagram/)) {\n    return 'er';\n  }\n\n  if (text.match(/^\\s*journey/)) {\n    return 'journey';\n  }\n\n  if (text.match(/^\\s*requirement/) || text.match(/^\\s*requirementDiagram/)) {\n    return 'requirement';\n  }\n  if (cnf && cnf.flowchart && cnf.flowchart.defaultRenderer === 'dagre-wrapper')\n    return 'flowchart-v2';\n\n  return 'flowchart';\n};\n\n/**\n * Caches results of functions based on input\n *\n * @param {Function} fn Function to run\n * @param {Function} resolver Function that resolves to an ID given arguments the `fn` takes\n * @returns {Function} An optimized caching function\n */\nconst memoize = (fn, resolver) => {\n  let cache = {};\n  return (...args) => {\n    let n = resolver ? resolver.apply(this, args) : args[0];\n    if (n in cache) {\n      return cache[n];\n    } else {\n      let result = fn(...args);\n      cache[n] = result;\n      return result;\n    }\n  };\n};\n\n/**\n * @function isSubstringInArray Detects whether a substring in present in a given array\n * @param {string} str The substring to detect\n * @param {Array} arr The array to search\n * @returns {number} The array index containing the substring or -1 if not present\n */\nexport const isSubstringInArray = function (str, arr) {\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i].match(str)) return i;\n  }\n  return -1;\n};\n\n/**\n * Returns a d3 curve given a curve name\n *\n * @param {string | undefined} interpolate The interpolation name\n * @param {any} defaultCurve The default curve to return\n * @returns {import('d3-shape').CurveFactory} The curve factory to use\n */\nexport const interpolateToCurve = (interpolate, defaultCurve) => {\n  if (!interpolate) {\n    return defaultCurve;\n  }\n  const curveName = `curve${interpolate.charAt(0).toUpperCase() + interpolate.slice(1)}`;\n  return d3CurveTypes[curveName] || defaultCurve;\n};\n\n/**\n * Formats a URL string\n *\n * @param {string} linkStr String of the URL\n * @param {{ securityLevel: string }} config Configuration passed to MermaidJS\n * @returns {string | undefined} The formatted URL\n */\nexport const formatUrl = (linkStr, config) => {\n  let url = linkStr.trim();\n\n  if (url) {\n    if (config.securityLevel !== 'loose') {\n      return sanitizeUrl(url);\n    }\n\n    return url;\n  }\n};\n\n/**\n * Runs a function\n *\n * @param {string} functionName A dot seperated path to the function relative to the `window`\n * @param {...any} params Parameters to pass to the function\n */\nexport const runFunc = (functionName, ...params) => {\n  const arrPaths = functionName.split('.');\n\n  const len = arrPaths.length - 1;\n  const fnName = arrPaths[len];\n\n  let obj = window;\n  for (let i = 0; i < len; i++) {\n    obj = obj[arrPaths[i]];\n    if (!obj) return;\n  }\n\n  obj[fnName](...params);\n};\n\n/**\n * @typedef {object} Point A (x, y) point\n * @property {number} x The x value\n * @property {number} y The y value\n */\n\n/**\n * Finds the distance between two points using the Distance Formula\n *\n * @param {Point} p1 The first point\n * @param {Point} p2 The second point\n * @returns {number} The distance\n */\nconst distance = (p1, p2) =>\n  p1 && p2 ? Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2)) : 0;\n\n/**\n * @param {Point[]} points List of points\n * @returns {Point}\n * @todo Give this a description\n */\nconst traverseEdge = (points) => {\n  let prevPoint;\n  let totalDistance = 0;\n\n  points.forEach((point) => {\n    totalDistance += distance(point, prevPoint);\n    prevPoint = point;\n  });\n\n  // Traverse half of total distance along points\n  let remainingDistance = totalDistance / 2;\n  let center = undefined;\n  prevPoint = undefined;\n  points.forEach((point) => {\n    if (prevPoint && !center) {\n      const vectorDistance = distance(point, prevPoint);\n      if (vectorDistance < remainingDistance) {\n        remainingDistance -= vectorDistance;\n      } else {\n        // The point is remainingDistance from prevPoint in the vector between prevPoint and point\n        // Calculate the coordinates\n        const distanceRatio = remainingDistance / vectorDistance;\n        if (distanceRatio <= 0) center = prevPoint;\n        if (distanceRatio >= 1) center = { x: point.x, y: point.y };\n        if (distanceRatio > 0 && distanceRatio < 1) {\n          center = {\n            x: (1 - distanceRatio) * prevPoint.x + distanceRatio * point.x,\n            y: (1 - distanceRatio) * prevPoint.y + distanceRatio * point.y,\n          };\n        }\n      }\n    }\n    prevPoint = point;\n  });\n  return center;\n};\n\n/**\n * Alias for `traverseEdge`\n *\n * @param {Point[]} points List of points\n * @returns {Point} Return result of `transverseEdge`\n */\nconst calcLabelPosition = (points) => {\n  if (points.length === 1) {\n    return points[0];\n  }\n  return traverseEdge(points);\n};\n\nconst calcCardinalityPosition = (isRelationTypePresent, points, initialPosition) => {\n  let prevPoint;\n  let totalDistance = 0; // eslint-disable-line\n  log.info('our points', points);\n  if (points[0] !== initialPosition) {\n    points = points.reverse();\n  }\n  points.forEach((point) => {\n    totalDistance += distance(point, prevPoint);\n    prevPoint = point;\n  });\n\n  // Traverse only 25 total distance along points to find cardinality point\n  const distanceToCardinalityPoint = 25;\n\n  let remainingDistance = distanceToCardinalityPoint;\n  let center;\n  prevPoint = undefined;\n  points.forEach((point) => {\n    if (prevPoint && !center) {\n      const vectorDistance = distance(point, prevPoint);\n      if (vectorDistance < remainingDistance) {\n        remainingDistance -= vectorDistance;\n      } else {\n        // The point is remainingDistance from prevPoint in the vector between prevPoint and point\n        // Calculate the coordinates\n        const distanceRatio = remainingDistance / vectorDistance;\n        if (distanceRatio <= 0) center = prevPoint;\n        if (distanceRatio >= 1) center = { x: point.x, y: point.y };\n        if (distanceRatio > 0 && distanceRatio < 1) {\n          center = {\n            x: (1 - distanceRatio) * prevPoint.x + distanceRatio * point.x,\n            y: (1 - distanceRatio) * prevPoint.y + distanceRatio * point.y,\n          };\n        }\n      }\n    }\n    prevPoint = point;\n  });\n  // if relation is present (Arrows will be added), change cardinality point off-set distance (d)\n  let d = isRelationTypePresent ? 10 : 5;\n  //Calculate Angle for x and y axis\n  let angle = Math.atan2(points[0].y - center.y, points[0].x - center.x);\n  let cardinalityPosition = { x: 0, y: 0 };\n  //Calculation cardinality position using angle, center point on the line/curve but pendicular and with offset-distance\n  cardinalityPosition.x = Math.sin(angle) * d + (points[0].x + center.x) / 2;\n  cardinalityPosition.y = -Math.cos(angle) * d + (points[0].y + center.y) / 2;\n  return cardinalityPosition;\n};\n\n/**\n * Position ['start_left', 'start_right', 'end_left', 'end_right']\n *\n * @param {any} terminalMarkerSize\n * @param {any} position\n * @param {any} _points\n * @returns {any}\n */\nconst calcTerminalLabelPosition = (terminalMarkerSize, position, _points) => {\n  // Todo looking to faster cloning method\n  let points = JSON.parse(JSON.stringify(_points));\n  let prevPoint;\n  let totalDistance = 0; // eslint-disable-line\n  log.info('our points', points);\n  if (position !== 'start_left' && position !== 'start_right') {\n    points = points.reverse();\n  }\n\n  points.forEach((point) => {\n    totalDistance += distance(point, prevPoint);\n    prevPoint = point;\n  });\n\n  // Traverse only 25 total distance along points to find cardinality point\n  const distanceToCardinalityPoint = 25 + terminalMarkerSize;\n\n  let remainingDistance = distanceToCardinalityPoint;\n  let center;\n  prevPoint = undefined;\n  points.forEach((point) => {\n    if (prevPoint && !center) {\n      const vectorDistance = distance(point, prevPoint);\n      if (vectorDistance < remainingDistance) {\n        remainingDistance -= vectorDistance;\n      } else {\n        // The point is remainingDistance from prevPoint in the vector between prevPoint and point\n        // Calculate the coordinates\n        const distanceRatio = remainingDistance / vectorDistance;\n        if (distanceRatio <= 0) center = prevPoint;\n        if (distanceRatio >= 1) center = { x: point.x, y: point.y };\n        if (distanceRatio > 0 && distanceRatio < 1) {\n          center = {\n            x: (1 - distanceRatio) * prevPoint.x + distanceRatio * point.x,\n            y: (1 - distanceRatio) * prevPoint.y + distanceRatio * point.y,\n          };\n        }\n      }\n    }\n    prevPoint = point;\n  });\n  // if relation is present (Arrows will be added), change cardinality point off-set distance (d)\n  let d = 10 + terminalMarkerSize * 0.5;\n  //Calculate Angle for x and y axis\n  let angle = Math.atan2(points[0].y - center.y, points[0].x - center.x);\n\n  let cardinalityPosition = { x: 0, y: 0 };\n\n  //Calculation cardinality position using angle, center point on the line/curve but pendicular and with offset-distance\n\n  cardinalityPosition.x = Math.sin(angle) * d + (points[0].x + center.x) / 2;\n  cardinalityPosition.y = -Math.cos(angle) * d + (points[0].y + center.y) / 2;\n  if (position === 'start_left') {\n    cardinalityPosition.x = Math.sin(angle + Math.PI) * d + (points[0].x + center.x) / 2;\n    cardinalityPosition.y = -Math.cos(angle + Math.PI) * d + (points[0].y + center.y) / 2;\n  }\n  if (position === 'end_right') {\n    cardinalityPosition.x = Math.sin(angle - Math.PI) * d + (points[0].x + center.x) / 2 - 5;\n    cardinalityPosition.y = -Math.cos(angle - Math.PI) * d + (points[0].y + center.y) / 2 - 5;\n  }\n  if (position === 'end_left') {\n    cardinalityPosition.x = Math.sin(angle) * d + (points[0].x + center.x) / 2 - 5;\n    cardinalityPosition.y = -Math.cos(angle) * d + (points[0].y + center.y) / 2 - 5;\n  }\n  return cardinalityPosition;\n};\n\n/**\n * Gets styles from an array of declarations\n *\n * @param {string[]} arr Declarations\n * @returns {{ style: string; labelStyle: string }} The styles grouped as strings\n */\nexport const getStylesFromArray = (arr) => {\n  let style = '';\n  let labelStyle = '';\n\n  for (let i = 0; i < arr.length; i++) {\n    if (typeof arr[i] !== 'undefined') {\n      // add text properties to label style definition\n      if (arr[i].startsWith('color:') || arr[i].startsWith('text-align:')) {\n        labelStyle = labelStyle + arr[i] + ';';\n      } else {\n        style = style + arr[i] + ';';\n      }\n    }\n  }\n\n  return { style: style, labelStyle: labelStyle };\n};\n\nlet cnt = 0;\nexport const generateId = () => {\n  cnt++;\n  return 'id-' + Math.random().toString(36).substr(2, 12) + '-' + cnt;\n};\n\n/**\n * @param {any} length\n * @returns {any}\n */\nfunction makeid(length) {\n  var result = '';\n  var characters = '0123456789abcdef';\n  var charactersLength = characters.length;\n  for (var i = 0; i < length; i++) {\n    result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  }\n  return result;\n}\n\nexport const random = (options) => {\n  return makeid(options.length);\n};\n\n/**\n * @function assignWithDepth Extends the functionality of {@link ObjectConstructor.assign} with the\n *   ability to merge arbitrary-depth objects For each key in src with path `k` (recursively)\n *   performs an Object.assign(dst[`k`], src[`k`]) with a slight change from the typical handling of\n *   undefined for dst[`k`]: instead of raising an error, dst[`k`] is auto-initialized to {} and\n *   effectively merged with src[`k`]<p> Additionally, dissimilar types will not clobber unless the\n *   config.clobber parameter === true. Example:\n *\n *   ```js\n *   let config_0 = { foo: { bar: 'bar' }, bar: 'foo' };\n *   let config_1 = { foo: 'foo', bar: 'bar' };\n *   let result = assignWithDepth(config_0, config_1);\n *   console.log(result);\n *   //-> result: { foo: { bar: 'bar' }, bar: 'bar' }\n *   ```\n *\n *   Traditional Object.assign would have clobbered foo in config_0 with foo in config_1. If src is a\n *   destructured array of objects and dst is not an array, assignWithDepth will apply each element\n *   of src to dst in order.\n * @param dst\n * @param src\n * @param config\n * @param dst\n * @param src\n * @param config\n * @param dst\n * @param src\n * @param config\n * @param {any} dst - The destination of the merge\n * @param {any} src - The source object(s) to merge into destination\n * @param {{ depth: number; clobber: boolean }} [config={ depth: 2, clobber: false }] - Depth: depth\n *   to traverse within src and dst for merging - clobber: should dissimilar types clobber (default:\n *   { depth: 2, clobber: false }). Default is `{ depth: 2, clobber: false }`\n * @returns {any}\n */\nexport const assignWithDepth = function (dst, src, config) {\n  const { depth, clobber } = Object.assign({ depth: 2, clobber: false }, config);\n  if (Array.isArray(src) && !Array.isArray(dst)) {\n    src.forEach((s) => assignWithDepth(dst, s, config));\n    return dst;\n  } else if (Array.isArray(src) && Array.isArray(dst)) {\n    src.forEach((s) => {\n      if (dst.indexOf(s) === -1) {\n        dst.push(s);\n      }\n    });\n    return dst;\n  }\n  if (typeof dst === 'undefined' || depth <= 0) {\n    if (dst !== undefined && dst !== null && typeof dst === 'object' && typeof src === 'object') {\n      return Object.assign(dst, src);\n    } else {\n      return src;\n    }\n  }\n  if (typeof src !== 'undefined' && typeof dst === 'object' && typeof src === 'object') {\n    Object.keys(src).forEach((key) => {\n      if (\n        typeof src[key] === 'object' &&\n        (dst[key] === undefined || typeof dst[key] === 'object')\n      ) {\n        if (dst[key] === undefined) {\n          dst[key] = Array.isArray(src[key]) ? [] : {};\n        }\n        dst[key] = assignWithDepth(dst[key], src[key], { depth: depth - 1, clobber });\n      } else if (clobber || (typeof dst[key] !== 'object' && typeof src[key] !== 'object')) {\n        dst[key] = src[key];\n      }\n    });\n  }\n  return dst;\n};\n\nexport const getTextObj = function () {\n  return {\n    x: 0,\n    y: 0,\n    fill: undefined,\n    anchor: 'start',\n    style: '#666',\n    width: 100,\n    height: 100,\n    textMargin: 0,\n    rx: 0,\n    ry: 0,\n    valign: undefined,\n  };\n};\n\n/**\n * Adds text to an element\n *\n * @param {SVGElement} elem Element to add text to\n * @param {{\n *   text: string;\n *   x: number;\n *   y: number;\n *   anchor: 'start' | 'middle' | 'end';\n *   fontFamily: string;\n *   fontSize: string | number;\n *   fontWeight: string | number;\n *   fill: string;\n *   class: string | undefined;\n *   textMargin: number;\n * }} textData\n * @returns {SVGTextElement} Text element with given styling and content\n */\nexport const drawSimpleText = function (elem, textData) {\n  // Remove and ignore br:s\n  const nText = textData.text.replace(common.lineBreakRegex, ' ');\n\n  const textElem = elem.append('text');\n  textElem.attr('x', textData.x);\n  textElem.attr('y', textData.y);\n  textElem.style('text-anchor', textData.anchor);\n  textElem.style('font-family', textData.fontFamily);\n  textElem.style('font-size', textData.fontSize);\n  textElem.style('font-weight', textData.fontWeight);\n  textElem.attr('fill', textData.fill);\n  if (typeof textData.class !== 'undefined') {\n    textElem.attr('class', textData.class);\n  }\n\n  const span = textElem.append('tspan');\n  span.attr('x', textData.x + textData.textMargin * 2);\n  span.attr('fill', textData.fill);\n  span.text(nText);\n\n  return textElem;\n};\n\nexport const wrapLabel = memoize(\n  (label, maxWidth, config) => {\n    if (!label) {\n      return label;\n    }\n    config = Object.assign(\n      { fontSize: 12, fontWeight: 400, fontFamily: 'Arial', joinWith: '<br/>' },\n      config\n    );\n    if (common.lineBreakRegex.test(label)) {\n      return label;\n    }\n    const words = label.split(' ');\n    const completedLines = [];\n    let nextLine = '';\n    words.forEach((word, index) => {\n      const wordLength = calculateTextWidth(`${word} `, config);\n      const nextLineLength = calculateTextWidth(nextLine, config);\n      if (wordLength > maxWidth) {\n        const { hyphenatedStrings, remainingWord } = breakString(word, maxWidth, '-', config);\n        completedLines.push(nextLine, ...hyphenatedStrings);\n        nextLine = remainingWord;\n      } else if (nextLineLength + wordLength >= maxWidth) {\n        completedLines.push(nextLine);\n        nextLine = word;\n      } else {\n        nextLine = [nextLine, word].filter(Boolean).join(' ');\n      }\n      const currentWord = index + 1;\n      const isLastWord = currentWord === words.length;\n      if (isLastWord) {\n        completedLines.push(nextLine);\n      }\n    });\n    return completedLines.filter((line) => line !== '').join(config.joinWith);\n  },\n  (label, maxWidth, config) =>\n    `${label}-${maxWidth}-${config.fontSize}-${config.fontWeight}-${config.fontFamily}-${config.joinWith}`\n);\n\nconst breakString = memoize(\n  (word, maxWidth, hyphenCharacter = '-', config) => {\n    config = Object.assign(\n      { fontSize: 12, fontWeight: 400, fontFamily: 'Arial', margin: 0 },\n      config\n    );\n    const characters = word.split('');\n    const lines = [];\n    let currentLine = '';\n    characters.forEach((character, index) => {\n      const nextLine = `${currentLine}${character}`;\n      const lineWidth = calculateTextWidth(nextLine, config);\n      if (lineWidth >= maxWidth) {\n        const currentCharacter = index + 1;\n        const isLastLine = characters.length === currentCharacter;\n        const hyphenatedNextLine = `${nextLine}${hyphenCharacter}`;\n        lines.push(isLastLine ? nextLine : hyphenatedNextLine);\n        currentLine = '';\n      } else {\n        currentLine = nextLine;\n      }\n    });\n    return { hyphenatedStrings: lines, remainingWord: currentLine };\n  },\n  (word, maxWidth, hyphenCharacter = '-', config) =>\n    `${word}-${maxWidth}-${hyphenCharacter}-${config.fontSize}-${config.fontWeight}-${config.fontFamily}`\n);\n\n/**\n * This calculates the text's height, taking into account the wrap breaks and both the statically\n * configured height, width, and the length of the text (in pixels).\n *\n * If the wrapped text text has greater height, we extend the height, so it's value won't overflow.\n *\n * @param {any} text The text to measure\n * @param {any} config - The config for fontSize, fontFamily, and fontWeight all impacting the resulting size\n * @returns {any} - The height for the given text\n */\nexport const calculateTextHeight = function (text, config) {\n  config = Object.assign(\n    { fontSize: 12, fontWeight: 400, fontFamily: 'Arial', margin: 15 },\n    config\n  );\n  return calculateTextDimensions(text, config).height;\n};\n\n/**\n * This calculates the width of the given text, font size and family.\n *\n * @param {any} text - The text to calculate the width of\n * @param {any} config - The config for fontSize, fontFamily, and fontWeight all impacting the resulting size\n * @returns {any} - The width for the given text\n */\nexport const calculateTextWidth = function (text, config) {\n  config = Object.assign({ fontSize: 12, fontWeight: 400, fontFamily: 'Arial' }, config);\n  return calculateTextDimensions(text, config).width;\n};\n\n/**\n * This calculates the dimensions of the given text, font size, font family, font weight, and margins.\n *\n * @param {any} text - The text to calculate the width of\n * @param {any} config - The config for fontSize, fontFamily, fontWeight, and margin all impacting\n *   the resulting size\n * @returns - The width for the given text\n */\nexport const calculateTextDimensions = memoize(\n  function (text, config) {\n    config = Object.assign({ fontSize: 12, fontWeight: 400, fontFamily: 'Arial' }, config);\n    const { fontSize, fontFamily, fontWeight } = config;\n    if (!text) {\n      return { width: 0, height: 0 };\n    }\n\n    // We can't really know if the user supplied font family will render on the user agent;\n    // thus, we'll take the max width between the user supplied font family, and a default\n    // of sans-serif.\n    const fontFamilies = ['sans-serif', fontFamily];\n    const lines = text.split(common.lineBreakRegex);\n    let dims = [];\n\n    const body = select('body');\n    // We don't want to leak DOM elements - if a removal operation isn't available\n    // for any reason, do not continue.\n    if (!body.remove) {\n      return { width: 0, height: 0, lineHeight: 0 };\n    }\n\n    const g = body.append('svg');\n\n    for (let fontFamily of fontFamilies) {\n      let cheight = 0;\n      let dim = { width: 0, height: 0, lineHeight: 0 };\n      for (let line of lines) {\n        const textObj = getTextObj();\n        textObj.text = line;\n        const textElem = drawSimpleText(g, textObj)\n          .style('font-size', fontSize)\n          .style('font-weight', fontWeight)\n          .style('font-family', fontFamily);\n\n        let bBox = (textElem._groups || textElem)[0][0].getBBox();\n        dim.width = Math.round(Math.max(dim.width, bBox.width));\n        cheight = Math.round(bBox.height);\n        dim.height += cheight;\n        dim.lineHeight = Math.round(Math.max(dim.lineHeight, cheight));\n      }\n      dims.push(dim);\n    }\n\n    g.remove();\n\n    let index =\n      isNaN(dims[1].height) ||\n      isNaN(dims[1].width) ||\n      isNaN(dims[1].lineHeight) ||\n      (dims[0].height > dims[1].height &&\n        dims[0].width > dims[1].width &&\n        dims[0].lineHeight > dims[1].lineHeight)\n        ? 0\n        : 1;\n    return dims[index];\n  },\n  (text, config) => `${text}-${config.fontSize}-${config.fontWeight}-${config.fontFamily}`\n);\n\n/**\n * Applys d3 attributes\n *\n * @param {any} d3Elem D3 Element to apply the attributes onto\n * @param {[string, string][]} attrs Object.keys equivalent format of key to value mapping of attributes\n */\nconst d3Attrs = function (d3Elem, attrs) {\n  for (let attr of attrs) {\n    d3Elem.attr(attr[0], attr[1]);\n  }\n};\n\n/**\n * Gives attributes for an SVG's size given arguments\n *\n * @param {number} height The height of the SVG\n * @param {number} width The width of the SVG\n * @param {boolean} useMaxWidth Whether or not to use max-width and set width to 100%\n * @returns {Map<'height' | 'width' | 'style', string>} Attributes for the SVG\n */\nexport const calculateSvgSizeAttrs = function (height, width, useMaxWidth) {\n  let attrs = new Map();\n  attrs.set('height', height);\n  if (useMaxWidth) {\n    attrs.set('width', '100%');\n    attrs.set('style', `max-width: ${width}px;`);\n  } else {\n    attrs.set('width', width);\n  }\n  return attrs;\n};\n\n/**\n * Applies attributes from `calculateSvgSizeAttrs`\n *\n * @param {SVGSVGElement} svgElem The SVG Element to configure\n * @param {number} height The height of the SVG\n * @param {number} width The width of the SVG\n * @param {boolean} useMaxWidth Whether or not to use max-width and set width to 100%\n */\nexport const configureSvgSize = function (svgElem, height, width, useMaxWidth) {\n  const attrs = calculateSvgSizeAttrs(height, width, useMaxWidth);\n  d3Attrs(svgElem, attrs);\n};\nexport const setupGraphViewbox = function (graph, svgElem, padding, useMaxWidth) {\n  const svgBounds = svgElem.node().getBBox();\n  const sWidth = svgBounds.width;\n  const sHeight = svgBounds.height;\n\n  let width = graph._label.width;\n  let height = graph._label.height;\n  let tx = 0;\n  let ty = 0;\n  if (sWidth > width) {\n    tx = (sWidth - width) / 2 + padding;\n    width = sWidth + padding * 2;\n  } else {\n    if (Math.abs(sWidth - width) >= 2 * padding + 1) {\n      width = width - padding;\n    }\n  }\n  if (sHeight > height) {\n    ty = (sHeight - height) / 2 + padding;\n    height = sHeight + padding * 2;\n  }\n  configureSvgSize(svgElem, height, width, useMaxWidth);\n\n  // Ensure the viewBox includes the whole svgBounds area with extra space for padding\n  const vBox = `0 0 ${width} ${height}`;\n  log.debug(\n    'Grpah.label',\n    graph._label,\n    'swidth',\n    sWidth,\n    'sheight',\n    sHeight,\n    'width',\n    width,\n    'height',\n    height,\n    'tx',\n    tx,\n    'ty',\n    ty,\n    'vBox',\n    vBox\n  );\n  svgElem.attr('viewBox', vBox);\n  svgElem.select('g').attr('transform', `translate(${tx}, ${ty})`);\n};\n\nexport const initIdGeneratior = class iterator {\n  constructor(deterministic, seed) {\n    this.deterministic = deterministic;\n    this.seed = seed;\n\n    this.count = seed ? seed.length : 0;\n  }\n\n  next() {\n    if (!this.deterministic) return Date.now();\n\n    return this.count++;\n  }\n};\n\nlet decoder;\n\n/**\n * Decodes HTML, source: {@link https://github.com/shrpne/entity-decode/blob/v2.0.1/browser.js}\n *\n * @param {string} html HTML as a string\n * @returns Unescaped HTML\n */\nexport const entityDecode = function (html) {\n  decoder = decoder || document.createElement('div');\n  // Escape HTML before decoding for HTML Entities\n  html = escape(html).replace(/%26/g, '&').replace(/%23/g, '#').replace(/%3B/g, ';');\n  // decoding\n  decoder.innerHTML = html;\n  return unescape(decoder.textContent);\n};\n\n/**\n * Sanitizes directive objects\n *\n * @param {object} args Directive's JSON\n */\nexport const directiveSanitizer = (args) => {\n  log.debug('directiveSanitizer called with', args);\n  if (typeof args === 'object') {\n    // check for array\n    if (args.length) {\n      args.forEach((arg) => directiveSanitizer(arg));\n    } else {\n      // This is an object\n      Object.keys(args).forEach((key) => {\n        log.debug('Checking key', key);\n        if (key.indexOf('__') === 0) {\n          log.debug('sanitize deleting __ option', key);\n          delete args[key];\n        }\n\n        if (key.indexOf('proto') >= 0) {\n          log.debug('sanitize deleting proto option', key);\n          delete args[key];\n        }\n\n        if (key.indexOf('constr') >= 0) {\n          log.debug('sanitize deleting constr option', key);\n          delete args[key];\n        }\n\n        if (key.indexOf('themeCSS') >= 0) {\n          log.debug('sanitizing themeCss option');\n          args[key] = sanitizeCss(args[key]);\n        }\n        if (configKeys.indexOf(key) < 0) {\n          log.debug('sanitize deleting option', key);\n          delete args[key];\n        } else {\n          if (typeof args[key] === 'object') {\n            log.debug('sanitize deleting object', key);\n            directiveSanitizer(args[key]);\n          }\n        }\n      });\n    }\n  }\n};\nexport const sanitizeCss = (str) => {\n  const stringsearch = 'o';\n  const startCnt = (str.match(/\\{/g) || []).length;\n  const endCnt = (str.match(/\\}/g) || []).length;\n  if (startCnt !== endCnt) {\n    return '{ /* ERROR: Unbalanced CSS */ }';\n  }\n  // Todo add more checks here\n  return str;\n};\n\nexport default {\n  assignWithDepth,\n  wrapLabel,\n  calculateTextHeight,\n  calculateTextWidth,\n  calculateTextDimensions,\n  calculateSvgSizeAttrs,\n  configureSvgSize,\n  setupGraphViewbox,\n  detectInit,\n  detectDirective,\n  detectType,\n  isSubstringInArray,\n  interpolateToCurve,\n  calcLabelPosition,\n  calcCardinalityPosition,\n  calcTerminalLabelPosition,\n  formatUrl,\n  getStylesFromArray,\n  generateId,\n  random,\n  memoize,\n  runFunc,\n  entityDecode,\n  initIdGeneratior,\n  directiveSanitizer,\n  sanitizeCss,\n};\n", "output": {"vulnerability_count": 17, "vulnerabilities": [{"description": "This looks like a JavaScript template string. Are you missing a '$' in front of '{...}'?", "risk": "Medium", "conceptual_fix": "Not provided", "line": 125}, {"description": "This looks like a JavaScript template string. Are you missing a '$' in front of '{...}'?", "risk": "Medium", "conceptual_fix": "Not provided", "line": 125}, {"description": "This looks like a JavaScript template string. Are you missing a '$' in front of '{...}'?", "risk": "Medium", "conceptual_fix": "Not provided", "line": 125}, {"description": "Possibility of prototype polluting function detected. By adding or modifying attributes of an object prototype, it is possible to create attributes that exist on every object, or replace critical attributes with malicious ones. This can be problematic if the software depends on existence or non-existence of certain attributes, or uses pre-defined attributes of object prototype (such as hasOwnProperty, toString or valueOf). Possible mitigations might be: freezing the object prototype, using an object without prototypes (via Object.create(null) ), blocking modifications of attributes that resolve to object prototype, using Map instead of object.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 329}, {"description": "Using non-static data to retrieve and run functions from the object is dangerous. If the data is user-controlled, it may allow executing arbitrary code.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 333}, {"description": "JSON stringify does not produce a stable key ordering, and should not be relied on for producing object keys. Consider using json-stable-stringify instead.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 510}, {"description": "JSON stringify does not produce a stable key ordering, and should not be relied on for producing object keys. Consider using json-stable-stringify instead.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 510}, {"description": "JSON stringify does not produce a stable key ordering, and should not be relied on for producing object keys. Consider using json-stable-stringify instead.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 516}, {"description": "JSON stringify does not produce a stable key ordering, and should not be relied on for producing object keys. Consider using json-stable-stringify instead.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 517}, {"description": "JSON stringify does not produce a stable key ordering, and should not be relied on for producing object keys. Consider using json-stable-stringify instead.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 519}, {"description": "JSON stringify does not produce a stable key ordering, and should not be relied on for producing object keys. Consider using json-stable-stringify instead.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 520}, {"description": "JSON stringify does not produce a stable key ordering, and should not be relied on for producing object keys. Consider using json-stable-stringify instead.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 523}, {"description": "JSON stringify does not produce a stable key ordering, and should not be relied on for producing object keys. Consider using json-stable-stringify instead.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 524}, {"description": "JSON stringify does not produce a stable key ordering, and should not be relied on for producing object keys. Consider using json-stable-stringify instead.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 527}, {"description": "JSON stringify does not produce a stable key ordering, and should not be relied on for producing object keys. Consider using json-stable-stringify instead.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 528}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 997}, {"description": "User controlled data in a `decoder.innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 997}]}}
{"CVE": "CVE-2022-31129", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "import { configFromStringAndFormat } from './from-string-and-format';\nimport { createUTCDate } from './date-from-array';\nimport { hooks } from '../utils/hooks';\nimport { deprecate } from '../utils/deprecate';\nimport getParsingFlags from './parsing-flags';\nimport { defaultLocaleMonthsShort } from '../units/month';\nimport { defaultLocaleWeekdaysShort } from '../units/day-of-week';\n\n// iso 8601 regex\n// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)\nvar extendedIsoRegex =\n        /^\\s*((?:[+-]\\d{6}|\\d{4})-(?:\\d\\d-\\d\\d|W\\d\\d-\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?::\\d\\d(?::\\d\\d(?:[.,]\\d+)?)?)?)([+-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/,\n    basicIsoRegex =\n        /^\\s*((?:[+-]\\d{6}|\\d{4})(?:\\d\\d\\d\\d|W\\d\\d\\d|W\\d\\d|\\d\\d\\d|\\d\\d|))(?:(T| )(\\d\\d(?:\\d\\d(?:\\d\\d(?:[.,]\\d+)?)?)?)([+-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/,\n    tzRegex = /Z|[+-]\\d\\d(?::?\\d\\d)?/,\n    isoDates = [\n        ['YYYYYY-MM-DD', /[+-]\\d{6}-\\d\\d-\\d\\d/],\n        ['YYYY-MM-DD', /\\d{4}-\\d\\d-\\d\\d/],\n        ['GGGG-[W]WW-E', /\\d{4}-W\\d\\d-\\d/],\n        ['GGGG-[W]WW', /\\d{4}-W\\d\\d/, false],\n        ['YYYY-DDD', /\\d{4}-\\d{3}/],\n        ['YYYY-MM', /\\d{4}-\\d\\d/, false],\n        ['YYYYYYMMDD', /[+-]\\d{10}/],\n        ['YYYYMMDD', /\\d{8}/],\n        ['GGGG[W]WWE', /\\d{4}W\\d{3}/],\n        ['GGGG[W]WW', /\\d{4}W\\d{2}/, false],\n        ['YYYYDDD', /\\d{7}/],\n        ['YYYYMM', /\\d{6}/, false],\n        ['YYYY', /\\d{4}/, false],\n    ],\n    // iso time formats and regexes\n    isoTimes = [\n        ['HH:mm:ss.SSSS', /\\d\\d:\\d\\d:\\d\\d\\.\\d+/],\n        ['HH:mm:ss,SSSS', /\\d\\d:\\d\\d:\\d\\d,\\d+/],\n        ['HH:mm:ss', /\\d\\d:\\d\\d:\\d\\d/],\n        ['HH:mm', /\\d\\d:\\d\\d/],\n        ['HHmmss.SSSS', /\\d\\d\\d\\d\\d\\d\\.\\d+/],\n        ['HHmmss,SSSS', /\\d\\d\\d\\d\\d\\d,\\d+/],\n        ['HHmmss', /\\d\\d\\d\\d\\d\\d/],\n        ['HHmm', /\\d\\d\\d\\d/],\n        ['HH', /\\d\\d/],\n    ],\n    aspNetJsonRegex = /^\\/?Date\\((-?\\d+)/i,\n    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3\n    rfc2822 =\n        /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\\d{4}))$/,\n    obsOffsets = {\n        UT: 0,\n        GMT: 0,\n        EDT: -4 * 60,\n        EST: -5 * 60,\n        CDT: -5 * 60,\n        CST: -6 * 60,\n        MDT: -6 * 60,\n        MST: -7 * 60,\n        PDT: -7 * 60,\n        PST: -8 * 60,\n    };\n\n// date from iso format\nexport function configFromISO(config) {\n    var i,\n        l,\n        string = config._i,\n        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),\n        allowTime,\n        dateFormat,\n        timeFormat,\n        tzFormat,\n        isoDatesLen = isoDates.length,\n        isoTimesLen = isoTimes.length;\n\n    if (match) {\n        getParsingFlags(config).iso = true;\n        for (i = 0, l = isoDatesLen; i < l; i++) {\n            if (isoDates[i][1].exec(match[1])) {\n                dateFormat = isoDates[i][0];\n                allowTime = isoDates[i][2] !== false;\n                break;\n            }\n        }\n        if (dateFormat == null) {\n            config._isValid = false;\n            return;\n        }\n        if (match[3]) {\n            for (i = 0, l = isoTimesLen; i < l; i++) {\n                if (isoTimes[i][1].exec(match[3])) {\n                    // match[2] should be 'T' or space\n                    timeFormat = (match[2] || ' ') + isoTimes[i][0];\n                    break;\n                }\n            }\n            if (timeFormat == null) {\n                config._isValid = false;\n                return;\n            }\n        }\n        if (!allowTime && timeFormat != null) {\n            config._isValid = false;\n            return;\n        }\n        if (match[4]) {\n            if (tzRegex.exec(match[4])) {\n                tzFormat = 'Z';\n            } else {\n                config._isValid = false;\n                return;\n            }\n        }\n        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');\n        configFromStringAndFormat(config);\n    } else {\n        config._isValid = false;\n    }\n}\n\nfunction extractFromRFC2822Strings(\n    yearStr,\n    monthStr,\n    dayStr,\n    hourStr,\n    minuteStr,\n    secondStr\n) {\n    var result = [\n        untruncateYear(yearStr),\n        defaultLocaleMonthsShort.indexOf(monthStr),\n        parseInt(dayStr, 10),\n        parseInt(hourStr, 10),\n        parseInt(minuteStr, 10),\n    ];\n\n    if (secondStr) {\n        result.push(parseInt(secondStr, 10));\n    }\n\n    return result;\n}\n\nfunction untruncateYear(yearStr) {\n    var year = parseInt(yearStr, 10);\n    if (year <= 49) {\n        return 2000 + year;\n    } else if (year <= 999) {\n        return 1900 + year;\n    }\n    return year;\n}\n\nfunction preprocessRFC2822(s) {\n    // Remove comments and folding whitespace and replace multiple-spaces with a single space\n    return s\n        .replace(/\\([^)]*\\)|[\\n\\t]/g, ' ')\n        .replace(/(\\s\\s+)/g, ' ')\n        .replace(/^\\s\\s*/, '')\n        .replace(/\\s\\s*$/, '');\n}\n\nfunction checkWeekday(weekdayStr, parsedInput, config) {\n    if (weekdayStr) {\n        // TODO: Replace the vanilla JS Date object with an independent day-of-week check.\n        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),\n            weekdayActual = new Date(\n                parsedInput[0],\n                parsedInput[1],\n                parsedInput[2]\n            ).getDay();\n        if (weekdayProvided !== weekdayActual) {\n            getParsingFlags(config).weekdayMismatch = true;\n            config._isValid = false;\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction calculateOffset(obsOffset, militaryOffset, numOffset) {\n    if (obsOffset) {\n        return obsOffsets[obsOffset];\n    } else if (militaryOffset) {\n        // the only allowed military tz is Z\n        return 0;\n    } else {\n        var hm = parseInt(numOffset, 10),\n            m = hm % 100,\n            h = (hm - m) / 100;\n        return h * 60 + m;\n    }\n}\n\n// date and time from ref 2822 format\nexport function configFromRFC2822(config) {\n    var match = rfc2822.exec(preprocessRFC2822(config._i)),\n        parsedArray;\n    if (match) {\n        parsedArray = extractFromRFC2822Strings(\n            match[4],\n            match[3],\n            match[2],\n            match[5],\n            match[6],\n            match[7]\n        );\n        if (!checkWeekday(match[1], parsedArray, config)) {\n            return;\n        }\n\n        config._a = parsedArray;\n        config._tzm = calculateOffset(match[8], match[9], match[10]);\n\n        config._d = createUTCDate.apply(null, config._a);\n        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n\n        getParsingFlags(config).rfc2822 = true;\n    } else {\n        config._isValid = false;\n    }\n}\n\n// date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict\nexport function configFromString(config) {\n    var matched = aspNetJsonRegex.exec(config._i);\n    if (matched !== null) {\n        config._d = new Date(+matched[1]);\n        return;\n    }\n\n    configFromISO(config);\n    if (config._isValid === false) {\n        delete config._isValid;\n    } else {\n        return;\n    }\n\n    configFromRFC2822(config);\n    if (config._isValid === false) {\n        delete config._isValid;\n    } else {\n        return;\n    }\n\n    if (config._strict) {\n        config._isValid = false;\n    } else {\n        // Final attempt, use Input Fallback\n        hooks.createFromInputFallback(config);\n    }\n}\n\nhooks.createFromInputFallback = deprecate(\n    'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +\n        'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +\n        'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',\n    function (config) {\n        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));\n    }\n);\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2022-31160", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "/*!\n * jQuery UI Checkboxradio @VERSION\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n */\n\n//>>label: Checkboxradio\n//>>group: Widgets\n//>>description: Enhances a form with multiple themeable checkboxes or radio buttons.\n//>>docs: http://api.jqueryui.com/checkboxradio/\n//>>demos: http://jqueryui.com/checkboxradio/\n//>>css.structure: ../../themes/base/core.css\n//>>css.structure: ../../themes/base/button.css\n//>>css.structure: ../../themes/base/checkboxradio.css\n//>>css.theme: ../../themes/base/theme.css\n\n( function( factory ) {\n\t\"use strict\";\n\n\tif ( typeof define === \"function\" && define.amd ) {\n\n\t\t// AMD. Register as an anonymous module.\n\t\tdefine( [\n\t\t\t\"jquery\",\n\t\t\t\"../form-reset-mixin\",\n\t\t\t\"../labels\",\n\t\t\t\"../widget\"\n\t\t], factory );\n\t} else {\n\n\t\t// Browser globals\n\t\tfactory( jQuery );\n\t}\n} )( function( $ ) {\n\"use strict\";\n\n$.widget( \"ui.checkboxradio\", [ $.ui.formResetMixin, {\n\tversion: \"@VERSION\",\n\toptions: {\n\t\tdisabled: null,\n\t\tlabel: null,\n\t\ticon: true,\n\t\tclasses: {\n\t\t\t\"ui-checkboxradio-label\": \"ui-corner-all\",\n\t\t\t\"ui-checkboxradio-icon\": \"ui-corner-all\"\n\t\t}\n\t},\n\n\t_getCreateOptions: function() {\n\t\tvar disabled, labels;\n\t\tvar that = this;\n\t\tvar options = this._super() || {};\n\n\t\t// We read the type here, because it makes more sense to throw a element type error first,\n\t\t// rather then the error for lack of a label. Often if its the wrong type, it\n\t\t// won't have a label (e.g. calling on a div, btn, etc)\n\t\tthis._readType();\n\n\t\tlabels = this.element.labels();\n\n\t\t// If there are multiple labels, use the last one\n\t\tthis.label = $( labels[ labels.length - 1 ] );\n\t\tif ( !this.label.length ) {\n\t\t\t$.error( \"No label found for checkboxradio widget\" );\n\t\t}\n\n\t\tthis.originalLabel = \"\";\n\n\t\t// We need to get the label text but this may also need to make sure it does not contain the\n\t\t// input itself.\n\t\tthis.label.contents().not( this.element[ 0 ] ).each( function() {\n\n\t\t\t// The label contents could be text, html, or a mix. We concat each element to get a\n\t\t\t// string representation of the label, without the input as part of it.\n\t\t\tthat.originalLabel += this.nodeType === 3 ? $( this ).text() : this.outerHTML;\n\t\t} );\n\n\t\t// Set the label option if we found label text\n\t\tif ( this.originalLabel ) {\n\t\t\toptions.label = this.originalLabel;\n\t\t}\n\n\t\tdisabled = this.element[ 0 ].disabled;\n\t\tif ( disabled != null ) {\n\t\t\toptions.disabled = disabled;\n\t\t}\n\t\treturn options;\n\t},\n\n\t_create: function() {\n\t\tvar checked = this.element[ 0 ].checked;\n\n\t\tthis._bindFormResetHandler();\n\n\t\tif ( this.options.disabled == null ) {\n\t\t\tthis.options.disabled = this.element[ 0 ].disabled;\n\t\t}\n\n\t\tthis._setOption( \"disabled\", this.options.disabled );\n\t\tthis._addClass( \"ui-checkboxradio\", \"ui-helper-hidden-accessible\" );\n\t\tthis._addClass( this.label, \"ui-checkboxradio-label\", \"ui-button ui-widget\" );\n\n\t\tif ( this.type === \"radio\" ) {\n\t\t\tthis._addClass( this.label, \"ui-checkboxradio-radio-label\" );\n\t\t}\n\n\t\tif ( this.options.label && this.options.label !== this.originalLabel ) {\n\t\t\tthis._updateLabel();\n\t\t} else if ( this.originalLabel ) {\n\t\t\tthis.options.label = this.originalLabel;\n\t\t}\n\n\t\tthis._enhance();\n\n\t\tif ( checked ) {\n\t\t\tthis._addClass( this.label, \"ui-checkboxradio-checked\", \"ui-state-active\" );\n\t\t}\n\n\t\tthis._on( {\n\t\t\tchange: \"_toggleClasses\",\n\t\t\tfocus: function() {\n\t\t\t\tthis._addClass( this.label, null, \"ui-state-focus ui-visual-focus\" );\n\t\t\t},\n\t\t\tblur: function() {\n\t\t\t\tthis._removeClass( this.label, null, \"ui-state-focus ui-visual-focus\" );\n\t\t\t}\n\t\t} );\n\t},\n\n\t_readType: function() {\n\t\tvar nodeName = this.element[ 0 ].nodeName.toLowerCase();\n\t\tthis.type = this.element[ 0 ].type;\n\t\tif ( nodeName !== \"input\" || !/radio|checkbox/.test( this.type ) ) {\n\t\t\t$.error( \"Can't create checkboxradio on element.nodeName=\" + nodeName +\n\t\t\t\t\" and element.type=\" + this.type );\n\t\t}\n\t},\n\n\t// Support jQuery Mobile enhanced option\n\t_enhance: function() {\n\t\tthis._updateIcon( this.element[ 0 ].checked );\n\t},\n\n\twidget: function() {\n\t\treturn this.label;\n\t},\n\n\t_getRadioGroup: function() {\n\t\tvar group;\n\t\tvar name = this.element[ 0 ].name;\n\t\tvar nameSelector = \"input[name='\" + $.escapeSelector( name ) + \"']\";\n\n\t\tif ( !name ) {\n\t\t\treturn $( [] );\n\t\t}\n\n\t\tif ( this.form.length ) {\n\t\t\tgroup = $( this.form[ 0 ].elements ).filter( nameSelector );\n\t\t} else {\n\n\t\t\t// Not inside a form, check all inputs that also are not inside a form\n\t\t\tgroup = $( nameSelector ).filter( function() {\n\t\t\t\treturn $( this )._form().length === 0;\n\t\t\t} );\n\t\t}\n\n\t\treturn group.not( this.element );\n\t},\n\n\t_toggleClasses: function() {\n\t\tvar checked = this.element[ 0 ].checked;\n\t\tthis._toggleClass( this.label, \"ui-checkboxradio-checked\", \"ui-state-active\", checked );\n\n\t\tif ( this.options.icon && this.type === \"checkbox\" ) {\n\t\t\tthis._toggleClass( this.icon, null, \"ui-icon-check ui-state-checked\", checked )\n\t\t\t\t._toggleClass( this.icon, null, \"ui-icon-blank\", !checked );\n\t\t}\n\n\t\tif ( this.type === \"radio\" ) {\n\t\t\tthis._getRadioGroup()\n\t\t\t\t.each( function() {\n\t\t\t\t\tvar instance = $( this ).checkboxradio( \"instance\" );\n\n\t\t\t\t\tif ( instance ) {\n\t\t\t\t\t\tinstance._removeClass( instance.label,\n\t\t\t\t\t\t\t\"ui-checkboxradio-checked\", \"ui-state-active\" );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t}\n\t},\n\n\t_destroy: function() {\n\t\tthis._unbindFormResetHandler();\n\n\t\tif ( this.icon ) {\n\t\t\tthis.icon.remove();\n\t\t\tthis.iconSpace.remove();\n\t\t}\n\t},\n\n\t_setOption: function( key, value ) {\n\n\t\t// We don't allow the value to be set to nothing\n\t\tif ( key === \"label\" && !value ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._super( key, value );\n\n\t\tif ( key === \"disabled\" ) {\n\t\t\tthis._toggleClass( this.label, null, \"ui-state-disabled\", value );\n\t\t\tthis.element[ 0 ].disabled = value;\n\n\t\t\t// Don't refresh when setting disabled\n\t\t\treturn;\n\t\t}\n\t\tthis.refresh();\n\t},\n\n\t_updateIcon: function( checked ) {\n\t\tvar toAdd = \"ui-icon ui-icon-background \";\n\n\t\tif ( this.options.icon ) {\n\t\t\tif ( !this.icon ) {\n\t\t\t\tthis.icon = $( \"<span>\" );\n\t\t\t\tthis.iconSpace = $( \"<span> </span>\" );\n\t\t\t\tthis._addClass( this.iconSpace, \"ui-checkboxradio-icon-space\" );\n\t\t\t}\n\n\t\t\tif ( this.type === \"checkbox\" ) {\n\t\t\t\ttoAdd += checked ? \"ui-icon-check ui-state-checked\" : \"ui-icon-blank\";\n\t\t\t\tthis._removeClass( this.icon, null, checked ? \"ui-icon-blank\" : \"ui-icon-check\" );\n\t\t\t} else {\n\t\t\t\ttoAdd += \"ui-icon-blank\";\n\t\t\t}\n\t\t\tthis._addClass( this.icon, \"ui-checkboxradio-icon\", toAdd );\n\t\t\tif ( !checked ) {\n\t\t\t\tthis._removeClass( this.icon, null, \"ui-icon-check ui-state-checked\" );\n\t\t\t}\n\t\t\tthis.icon.prependTo( this.label ).after( this.iconSpace );\n\t\t} else if ( this.icon !== undefined ) {\n\t\t\tthis.icon.remove();\n\t\t\tthis.iconSpace.remove();\n\t\t\tdelete this.icon;\n\t\t}\n\t},\n\n\t_updateLabel: function() {\n\n\t\t// Remove the contents of the label ( minus the icon, icon space, and input )\n\t\tvar contents = this.label.contents().not( this.element[ 0 ] );\n\t\tif ( this.icon ) {\n\t\t\tcontents = contents.not( this.icon[ 0 ] );\n\t\t}\n\t\tif ( this.iconSpace ) {\n\t\t\tcontents = contents.not( this.iconSpace[ 0 ] );\n\t\t}\n\t\tcontents.remove();\n\n\t\tthis.label.append( this.options.label );\n\t},\n\n\trefresh: function() {\n\t\tvar checked = this.element[ 0 ].checked,\n\t\t\tisDisabled = this.element[ 0 ].disabled;\n\n\t\tthis._updateIcon( checked );\n\t\tthis._toggleClass( this.label, \"ui-checkboxradio-checked\", \"ui-state-active\", checked );\n\t\tif ( this.options.label !== null ) {\n\t\t\tthis._updateLabel();\n\t\t}\n\n\t\tif ( isDisabled !== this.options.disabled ) {\n\t\t\tthis._setOptions( { \"disabled\": isDisabled } );\n\t\t}\n\t}\n\n} ] );\n\nreturn $.ui.checkboxradio;\n\n} );\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2022-31179", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "/**\n * @overview Provides functionality specifically for Unix systems.\n * @license MPL-2.0\n */\n\nimport * as fs from \"fs\";\nimport * as path from \"path\";\n\nimport which from \"which\";\n\n/**\n * The name of the Bourne-again shell (Bash) binary.\n *\n * @constant\n * @type {string}\n */\nconst binBash = \"bash\";\n\n/**\n * The name of the Debian Almquist shell (Dash) binary.\n *\n * @constant\n * @type {string}\n */\nconst binDash = \"dash\";\n\n/**\n * The name of the Z shell (Zsh) binary.\n *\n * @constant\n * @type {string}\n */\nconst binZsh = \"zsh\";\n\n/**\n * Escapes a shell argument for use in Bash(-like shells).\n *\n * @param {string} arg The argument to escape.\n * @param {boolean} interpolation Is interpolation enabled.\n * @param {boolean} quoted Is `arg` being quoted.\n * @returns {string} The escaped argument.\n */\nfunction escapeArgBash(arg, interpolation, quoted) {\n  let result = arg.replace(/\\u0000/g, \"\");\n\n  if (interpolation) {\n    result = result\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\\n/g, \" \")\n      .replace(/(^|\\s)(~|#)/g, \"$1\\\\$2\")\n      .replace(/(\\*|\\?)/g, \"\\\\$1\")\n      .replace(/(\\$|\\;|\\&|\\|)/g, \"\\\\$1\")\n      .replace(/(\\(|\\)|\\<|\\>)/g, \"\\\\$1\")\n      .replace(/(\"|'|`)/g, \"\\\\$1\")\n      .replace(/\\{(?=(.*?(?:\\,|\\.).*?)\\})/g, \"\\\\{\")\n      .replace(/(?<=\\=(?:.*?:)?)(~)(?=\\:|\\=|\\-|\\+|\\/|0|\\s|$)/g, \"\\\\$1\");\n  } else if (quoted) {\n    result = result.replace(/'/g, `'\\\\''`);\n  }\n\n  return result;\n}\n\n/**\n * Escapes a shell argument for use in Dash\n *\n * @param {string} arg The argument to escape.\n * @param {boolean} interpolation Is interpolation enabled.\n * @param {boolean} quoted Is `arg` being quoted.\n * @returns {string} The escaped argument.\n */\nfunction escapeArgDash(arg, interpolation, quoted) {\n  let result = arg.replace(/\\u0000/g, \"\");\n\n  if (interpolation) {\n    result = result\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\\n/g, \" \")\n      .replace(/(^|\\s)(~|#)/g, \"$1\\\\$2\")\n      .replace(/(\\*|\\?)/g, \"\\\\$1\")\n      .replace(/(\\$|\\;|\\&|\\|)/g, \"\\\\$1\")\n      .replace(/(\\(|\\)|\\<|\\>)/g, \"\\\\$1\")\n      .replace(/(\"|'|`)/g, \"\\\\$1\")\n      .replace(/\\{(?=(.*?(?:\\,|\\.).*?)\\})/g, \"\\\\{\");\n  } else if (quoted) {\n    result = result.replace(/'/g, `'\\\\''`);\n  }\n\n  return result;\n}\n\n/**\n * Escapes a shell argument for use in Zsh.\n *\n * @param {string} arg The argument to escape.\n * @param {boolean} interpolation Is interpolation enabled.\n * @param {boolean} quoted Is `arg` being quoted.\n * @returns {string} The escaped argument.\n */\nfunction escapeArgZsh(arg, interpolation, quoted) {\n  let result = arg.replace(/\\u0000/g, \"\");\n\n  if (interpolation) {\n    result = result\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\\n/g, \" \")\n      .replace(/(^|\\s)(~|#|=)/g, \"$1\\\\$2\")\n      .replace(/(\\*|\\?)/g, \"\\\\$1\")\n      .replace(/(\\$|\\;|\\&|\\|)/g, \"\\\\$1\")\n      .replace(/(\\(|\\)|\\<|\\>)/g, \"\\\\$1\")\n      .replace(/(\"|'|`)/g, \"\\\\$1\")\n      .replace(/(\\[|\\]|\\{|\\})/g, \"\\\\$1\");\n  } else if (quoted) {\n    result = result.replace(/'/g, `'\\\\''`);\n  }\n\n  return result;\n}\n\n/**\n * Quotes an argument for use in a Unix shell.\n *\n * @param {string} arg The argument to quote.\n * @returns {string} The quoted argument.\n */\nfunction quoteArg(arg) {\n  return `'${arg}'`;\n}\n\n/**\n * The mapping from shell names to functions that escape arguments for that\n * shell.\n *\n * @constant\n * @type {Map<string, Function>}\n */\nconst escapeFunctionsByShell = new Map([\n  [binBash, escapeArgBash],\n  [binDash, escapeArgDash],\n  [binZsh, escapeArgZsh],\n]);\n\n/**\n * The mapping from shell names to functions that quote arguments for that\n * shell.\n *\n * @constant\n * @type {Map<string, Function>}\n */\nconst quoteFunctionsByShell = new Map([\n  [binBash, quoteArg],\n  [binDash, quoteArg],\n  [binZsh, quoteArg],\n]);\n\n/**\n * Returns the basename of a directory or file path on a Unix system.\n *\n * @param {string} fullPath A Unix-style directory or file path.\n * @returns {string} The basename of `fullPath`.\n */\nfunction getBasename(fullPath) {\n  return path.basename(fullPath);\n}\n\n/**\n * Returns the default shell for Unix systems.\n *\n * For more information, see `options.shell` in:\n * https://nodejs.org/api/child_process.html#child_processexeccommand-options-callback\n *\n * @returns {string} The default shell.\n */\nexport function getDefaultShell() {\n  return \"/bin/sh\";\n}\n\n/**\n * Returns a function to escape arguments for use in a particular shell.\n *\n * @param {string} shellName The name of a Unix shell.\n * @returns {Function?} A function to escape arguments for use in the shell.\n */\nexport function getEscapeFunction(shellName) {\n  return escapeFunctionsByShell.get(shellName) || null;\n}\n\n/**\n * Returns a function to quote arguments for use in a particular shell.\n *\n * @param {string} shellName The name of a Unix shell.\n * @returns {Function?} A function to quote arguments for use in the shell.\n */\nexport function getQuoteFunction(shellName) {\n  return quoteFunctionsByShell.get(shellName) || null;\n}\n\n/**\n * Determines the name of the shell identified by a file path or file name.\n *\n * @param {Object} args The arguments for this function.\n * @param {string} args.shell The name or path of the shell.\n * @param {Object} deps The dependencies for this function.\n * @param {Function} deps.resolveExecutable Resolve the path to an executable.\n * @returns {string} The shell name.\n */\nexport function getShellName({ shell }, { resolveExecutable }) {\n  shell = resolveExecutable(\n    { executable: shell },\n    { exists: fs.existsSync, readlink: fs.readlinkSync, which: which.sync }\n  );\n\n  const shellName = getBasename(shell);\n  if (getEscapeFunction(shellName) === null) {\n    return binBash;\n  }\n\n  return shellName;\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2022-31180", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "/**\n * @overview Provides functionality specifically for Windows systems.\n * @license MPL-2.0\n */\n\nimport * as fs from \"fs\";\nimport * as path from \"path\";\n\nimport which from \"which\";\n\n/**\n * The name of the Windows Command Prompt binary.\n *\n * @constant\n * @type {string}\n */\nconst binCmd = \"cmd.exe\";\n\n/**\n * The name of the Windows PowerShell binary.\n *\n * @constant\n * @type {string}\n */\nconst binPowerShell = \"powershell.exe\";\n\n/**\n * Escapes a shell argument for use in Windows Command Prompt.\n *\n * @param {string} arg The argument to escape.\n * @param {boolean} interpolation Is interpolation enabled.\n * @param {boolean} quoted Is `arg` being quoted.\n * @returns {string} The escaped argument.\n */\nfunction escapeArgCmd(arg, interpolation, quoted) {\n  let result = arg.replace(/\\u0000/g, \"\");\n\n  if (interpolation) {\n    result = result\n      .replace(/\\^/g, \"^^\")\n      .replace(/(<|>)/g, \"^$1\")\n      .replace(/(\")/g, \"^$1\")\n      .replace(/(\\&|\\|)/g, \"^$1\");\n  } else if (quoted) {\n    result = result.replace(/\"/g, `\"\"`);\n  }\n\n  return result;\n}\n\n/**\n * Escapes a shell argument for use in Windows PowerShell.\n *\n * @param {string} arg The argument to escape.\n * @param {boolean} interpolation Is interpolation enabled.\n * @param {boolean} quoted Is `arg` being quoted.\n * @returns {string} The escaped argument.\n */\nfunction escapeArgPowerShell(arg, interpolation, quoted) {\n  let result = arg\n    .replace(/\\u0000/g, \"\")\n    .replace(/`/g, \"``\")\n    .replace(/\\$/g, \"`$\");\n\n  if (interpolation) {\n    result = result\n      .replace(/^((?:\\*|[1-6])?)(>)/g, \"$1`$2\")\n      .replace(/^(<|@|#|-|\\:|\\])/g, \"`$1\")\n      .replace(/(,|\\;|\\&|\\|)/g, \"`$1\")\n      .replace(/(\\(|\\)|\\{|\\})/g, \"`$1\")\n      .replace(/('||||)/g, \"`$1\")\n      .replace(/(\"|||)/g, \"`$1\");\n  } else if (quoted) {\n    result = result.replace(/(\"|||)/g, \"$1$1\");\n  }\n\n  return result;\n}\n\n/**\n * Quotes an argument for use in a Windows shell.\n *\n * @param {string} arg The argument to quote.\n * @returns {string} The quoted argument.\n */\nfunction quoteArg(arg) {\n  return `\"${arg}\"`;\n}\n\n/**\n * The mapping from shell names to functions that escape arguments for that\n * shell.\n *\n * @constant\n * @type {Map<string, Function>}\n */\nconst escapeFunctionsByShell = new Map([\n  [binCmd, escapeArgCmd],\n  [binPowerShell, escapeArgPowerShell],\n]);\n\n/**\n * The mapping from shell names to functions that quote arguments for that\n * shell.\n *\n * @constant\n * @type {Map<string, Function>}\n */\nconst quoteFunctionsByShell = new Map([\n  [binCmd, quoteArg],\n  [binPowerShell, quoteArg],\n]);\n\n/**\n * Returns the basename of a directory or file path on a Windows system.\n *\n * @param {string} fullPath A Windows-style directory or file path.\n * @returns {string} The basename of `fullPath`.\n */\nfunction getBasename(fullPath) {\n  return path.win32.basename(fullPath);\n}\n\n/**\n * Returns the default shell for Windows systems.\n *\n * For more information, see:\n * https://nodejs.org/api/child_process.html#default-windows-shell\n *\n * @param {Object} args The arguments for this function.\n * @param {Object} args.env The environment variables.\n * @param {string} [args.env.ComSpec] The %COMSPEC% value.\n * @returns {string} The default shell.\n */\nexport function getDefaultShell({ env }) {\n  if (Object.prototype.hasOwnProperty.call(env, \"ComSpec\")) {\n    return env.ComSpec;\n  }\n\n  return binCmd;\n}\n\n/**\n * Returns a function to escape arguments for use in a particular shell.\n *\n * @param {string} shellName The name of a Windows shell.\n * @returns {Function?} A function to escape arguments for use in the shell.\n */\nexport function getEscapeFunction(shellName) {\n  return escapeFunctionsByShell.get(shellName) || null;\n}\n\n/**\n * Returns a function to quote arguments for use in a particular shell.\n *\n * @param {string} shellName The name of a Windows shell.\n * @returns {Function?} A function to quote arguments for use in the shell.\n */\nexport function getQuoteFunction(shellName) {\n  return quoteFunctionsByShell.get(shellName) || null;\n}\n\n/**\n * Determines the name of the shell identified by a file path or file name.\n *\n * @param {Object} args The arguments for this function.\n * @param {string} args.shell The name or path of the shell.\n * @param {Object} deps The dependencies for this function.\n * @param {Function} deps.resolveExecutable Resolve the path to an executable.\n * @returns {string} The shell name.\n */\nexport function getShellName({ shell }, { resolveExecutable }) {\n  shell = resolveExecutable(\n    { executable: shell },\n    { exists: fs.existsSync, readlink: fs.readlinkSync, which: which.sync }\n  );\n\n  const shellName = getBasename(shell);\n  if (getEscapeFunction(shellName) === null) {\n    return binCmd;\n  }\n\n  return shellName;\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2022-32172", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "<template>\n  <q-page class=\"q-pa-md\">\n    <q-table\n      :title=\"t('template.header')\"\n      :rows=\"templates\"\n      row-key=\"id\"\n      :pagination=\"pagination\"\n      :filter=\"filterQuery\"\n      :filter-method=\"filterData\"\n    >\n      <template #top-right>\n        <q-input\n          v-model=\"filterQuery\"\n          filled\n          borderless\n          dense\n          :placeholder=\"t('template.search')\"\n        >\n          <template #append>\n            <q-icon name=\"search\" class=\"cursor-pointer\" />\n          </template>\n        </q-input>\n        <q-btn\n          class=\"q-ml-sm\"\n          color=\"primary\"\n          icon=\"add\"\n          :label=\"t('template.add')\"\n          @click=\"addTemplate\"\n        />\n      </template>\n\n      <!-- eslint-disable-next-line vue/no-lone-template -->\n      <template v-slot:body-cell-#=\"props\">\n        <q-td :props=\"props\" width=\"80\">\n          {{ props.value }}\n        </q-td>\n      </template>\n      <template #body-cell-name=\"props\">\n        <q-td :props=\"props\" auto-width>\n          <a\n            class=\"text-primary text-decoration-none\"\n            @click=\"previewTemplate(props)\"\n          >\n            {{ props.value }}\n          </a>\n        </q-td>\n      </template>\n      <template #body-cell-template=\"props\">\n        <q-td :props=\"props\" auto-width>\n          <q-badge v-if=\"props.value.mappings\">\n            M <q-tooltip class=\"bg-black\">Mappings</q-tooltip>\n          </q-badge>\n          <q-badge v-if=\"props.value.settings\" class=\"q-ml-xs\">\n            S <q-tooltip class=\"bg-black\">Settings</q-tooltip>\n          </q-badge>\n          <q-badge\n            v-if=\"props.value.settings == null && props.value.mappings == null\"\n            color=\"transparent\"\n            text-color=\"black\"\n            class=\"q-pl-none\"\n          >\n            None\n          </q-badge>\n        </q-td>\n      </template>\n      <template #body-cell-actions=\"props\">\n        <q-td :props=\"props\" auto-width>\n          <q-btn\n            dense\n            unelevated\n            size=\"sm\"\n            color=\"teal-5\"\n            class=\"action-button\"\n            icon=\"edit\"\n            @click=\"editTemplate(props)\"\n          />\n          <q-btn\n            dense\n            unelevated\n            size=\"sm\"\n            color=\"red-5\"\n            class=\"action-button q-ml-sm\"\n            icon=\"delete\"\n            @click=\"deleteTemplate(props)\"\n          />\n        </q-td>\n      </template>\n    </q-table>\n\n    <q-dialog\n      v-model=\"showAddTemplateDialog\"\n      position=\"right\"\n      full-height\n      seamless\n      maximized\n    >\n      <add-update-template @updated=\"templateAdded\" />\n    </q-dialog>\n\n    <q-dialog\n      v-model=\"showUpdateTemplateDialog\"\n      position=\"right\"\n      full-height\n      seamless\n      maximized\n    >\n      <add-update-template v-model=\"template\" @updated=\"templateUpdated\" />\n    </q-dialog>\n\n    <q-dialog\n      v-model=\"showPreviewTemplateDialog\"\n      position=\"right\"\n      full-height\n      maximized\n    >\n      <preview-template v-model=\"template\" />\n    </q-dialog>\n  </q-page>\n</template>\n\n<script>\nimport { defineComponent, ref } from \"vue\";\nimport { useStore } from \"vuex\";\nimport { useQuasar, date } from \"quasar\";\nimport { useI18n } from \"vue-i18n\";\n\nimport templateService from \"../services/template\";\nimport AddUpdateTemplate from \"../components/template/AddUpdateTemplate.vue\";\nimport PreviewTemplate from \"../components/template/PreviewTemplate.vue\";\n\nexport default defineComponent({\n  name: \"PageTemplate\",\n  components: {\n    AddUpdateTemplate,\n    PreviewTemplate,\n  },\n  setup() {\n    const store = useStore();\n    const $q = useQuasar();\n    const { t } = useI18n();\n\n    const templates = ref([]);\n    const getTemplates = () => {\n      templateService.list().then((res) => {\n        var counter = 1;\n        templates.value = res.data.map((data) => {\n          return {\n            \"#\": counter++,\n            name: data.name,\n            patterns: data.index_template.index_patterns.join(\", \"),\n            priority: data.index_template.priority || \"\",\n            template: data.index_template.template,\n            actions: \"\",\n          };\n        });\n      });\n    };\n\n    getTemplates();\n\n    const template = ref({});\n    const showAddTemplateDialog = ref(false);\n    const showUpdateTemplateDialog = ref(false);\n    const showPreviewTemplateDialog = ref(false);\n\n    const addTemplate = () => {\n      showAddTemplateDialog.value = true;\n    };\n    const editTemplate = (props) => {\n      template.value = props.row;\n      showUpdateTemplateDialog.value = true;\n    };\n    const deleteTemplate = (props) => {\n      $q.dialog({\n        title: \"Delete template\",\n        message:\n          \"You are about to delete this template: <ul><li>\" +\n          props.row.name +\n          \"</li></ul>\",\n        cancel: true,\n        persistent: true,\n        html: true,\n      }).onOk(() => {\n        templateService.delete(props.row.name).then(() => {\n          getTemplates();\n        });\n      });\n    };\n\n    const previewTemplate = (props) => {\n      template.value = props.row;\n      showPreviewTemplateDialog.value = true;\n    };\n\n    return {\n      t,\n      showAddTemplateDialog,\n      showUpdateTemplateDialog,\n      showPreviewTemplateDialog,\n      template,\n      templates,\n      pagination: {\n        rowsPerPage: 20,\n      },\n      filterQuery: ref(\"\"),\n      filterData(rows, terms) {\n        var filtered = [];\n        terms = terms.toLowerCase();\n        for (var i = 0; i < rows.length; i++) {\n          if (rows[i][\"name\"].toLowerCase().includes(terms)) {\n            filtered.push(rows[i]);\n          }\n        }\n        return filtered;\n      },\n      addTemplate,\n      editTemplate,\n      deleteTemplate,\n      previewTemplate,\n      templateAdded() {\n        showAddTemplateDialog.value = false;\n        getTemplates();\n      },\n      templateUpdated() {\n        showUpdateTemplateDialog.value = false;\n        getTemplates();\n      },\n    };\n  },\n});\n</script>\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2022-35923", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "import Context from './Context';\nimport optional from './rules/optional';\n\nfunction v8n() {\n  return typeof Proxy !== 'undefined'\n    ? proxyContext(new Context())\n    : proxylessContext(new Context());\n}\n\n// Custom rules\nlet customRules = {};\n\nv8n.extend = function(newRules) {\n  Object.assign(customRules, newRules);\n};\n\nv8n.clearCustomRules = function() {\n  customRules = {};\n};\n\nfunction proxyContext(context) {\n  return new Proxy(context, {\n    get(obj, prop) {\n      if (prop in obj) {\n        return obj[prop];\n      }\n\n      const newContext = proxyContext(context._clone());\n\n      if (prop in availableModifiers) {\n        return newContext._applyModifier(availableModifiers[prop], prop);\n      }\n      if (prop in customRules) {\n        return newContext._applyRule(customRules[prop], prop);\n      }\n      if (prop in availableRules) {\n        return newContext._applyRule(availableRules[prop], prop);\n      }\n    },\n  });\n}\n\nfunction proxylessContext(context) {\n  const addRuleSet = (ruleSet, targetContext) => {\n    Object.keys(ruleSet).forEach(prop => {\n      targetContext[prop] = (...args) => {\n        const newContext = proxylessContext(targetContext._clone());\n        const contextWithRuleApplied = newContext._applyRule(\n          ruleSet[prop],\n          prop,\n        )(...args);\n        return contextWithRuleApplied;\n      };\n    });\n    return targetContext;\n  };\n\n  const contextWithAvailableRules = addRuleSet(availableRules, context);\n  const contextWithAllRules = addRuleSet(\n    customRules,\n    contextWithAvailableRules,\n  );\n\n  Object.keys(availableModifiers).forEach(prop => {\n    Object.defineProperty(contextWithAllRules, prop, {\n      get: () => {\n        const newContext = proxylessContext(contextWithAllRules._clone());\n        return newContext._applyModifier(availableModifiers[prop], prop);\n      },\n    });\n  });\n\n  return contextWithAllRules;\n}\n\nconst availableModifiers = {\n  not: {\n    simple: fn => value => !fn(value),\n    async: fn => value =>\n      Promise.resolve(fn(value))\n        .then(result => !result)\n        .catch(() => true),\n  },\n\n  some: {\n    simple: fn => value => {\n      return split(value).some(item => {\n        try {\n          return fn(item);\n        } catch (ex) {\n          return false;\n        }\n      });\n    },\n    async: fn => value => {\n      return Promise.all(\n        split(value).map(item => {\n          try {\n            return fn(item).catch(() => false);\n          } catch (ex) {\n            return false;\n          }\n        }),\n      ).then(result => result.some(Boolean));\n    },\n  },\n\n  every: {\n    simple: fn => value => value !== false && split(value).every(fn),\n    async: fn => value =>\n      Promise.all(split(value).map(fn)).then(result => result.every(Boolean)),\n  },\n\n  strict: {\n    simple: (fn, rule) => value => {\n      if (isSchemaRule(rule) && value && typeof value === 'object') {\n        return (\n          Object.keys(rule.args[0]).length === Object.keys(value).length &&\n          fn(value)\n        );\n      }\n      return fn(value);\n    },\n    async: (fn, rule) => value =>\n      Promise.resolve(fn(value))\n        .then(result => {\n          if (isSchemaRule(rule) && value && typeof value === 'object') {\n            return (\n              Object.keys(rule.args[0]).length === Object.keys(value).length &&\n              result\n            );\n          }\n          return result;\n        })\n        .catch(() => false),\n  },\n};\n\nfunction isSchemaRule(rule) {\n  return (\n    rule &&\n    rule.name === 'schema' &&\n    rule.args.length > 0 &&\n    typeof rule.args[0] === 'object'\n  );\n}\n\nfunction split(value) {\n  if (typeof value === 'string') {\n    return value.split('');\n  }\n  return value;\n}\n\nconst availableRules = {\n  // Value\n\n  equal: expected => value => value == expected,\n\n  exact: expected => value => value === expected,\n\n  // Types\n\n  number: (allowInfinite = true) => value =>\n    typeof value === 'number' && (allowInfinite || isFinite(value)),\n\n  integer: () => value => {\n    const isInteger = Number.isInteger || isIntegerPolyfill;\n    return isInteger(value);\n  },\n\n  numeric: () => value => !isNaN(parseFloat(value)) && isFinite(value),\n\n  string: () => testType('string'),\n\n  boolean: () => testType('boolean'),\n\n  undefined: () => testType('undefined'),\n\n  null: () => testType('null'),\n\n  array: () => testType('array'),\n\n  object: () => testType('object'),\n\n  instanceOf: instance => value => value instanceof instance,\n\n  // Pattern\n\n  pattern: expected => value => expected.test(value),\n\n  lowercase: () => value => /^([a-z]+\\s*)+$/.test(value),\n\n  uppercase: () => value => /^([A-Z]+\\s*)+$/.test(value),\n\n  vowel: () => value => /^[aeiou]+$/i.test(value),\n\n  consonant: () => value => /^(?=[^aeiou])([a-z]+)$/i.test(value),\n\n  // Value at\n\n  first: expected => value => value[0] == expected,\n\n  last: expected => value => value[value.length - 1] == expected,\n\n  // Length\n\n  empty: () => value => value.length === 0,\n\n  length: (min, max) => value =>\n    value.length >= min && value.length <= (max || min),\n\n  minLength: min => value => value.length >= min,\n\n  maxLength: max => value => value.length <= max,\n\n  // Range\n\n  negative: () => value => value < 0,\n\n  positive: () => value => value >= 0,\n\n  between: (a, b) => value => value >= a && value <= b,\n\n  range: (a, b) => value => value >= a && value <= b,\n\n  lessThan: n => value => value < n,\n\n  lessThanOrEqual: n => value => value <= n,\n\n  greaterThan: n => value => value > n,\n\n  greaterThanOrEqual: n => value => value >= n,\n\n  // Divisible\n\n  even: () => value => value % 2 === 0,\n\n  odd: () => value => value % 2 !== 0,\n\n  includes: expected => value => ~value.indexOf(expected),\n\n  schema: schema => testSchema(schema),\n\n  // branching\n\n  passesAnyOf: (...validations) => value =>\n    validations.some(validation => validation.test(value)),\n\n  optional,\n};\n\nfunction testType(expected) {\n  return value => {\n    return (\n      (Array.isArray(value) && expected === 'array') ||\n      (value === null && expected === 'null') ||\n      typeof value === expected\n    );\n  };\n}\n\nfunction isIntegerPolyfill(value) {\n  return (\n    typeof value === 'number' && isFinite(value) && Math.floor(value) === value\n  );\n}\n\nfunction testSchema(schema) {\n  return {\n    simple: value => {\n      const causes = [];\n      Object.keys(schema).forEach(key => {\n        const nestedValidation = schema[key];\n        try {\n          nestedValidation.check((value || {})[key]);\n        } catch (ex) {\n          ex.target = key;\n          causes.push(ex);\n        }\n      });\n      if (causes.length > 0) {\n        throw causes;\n      }\n      return true;\n    },\n    async: value => {\n      const causes = [];\n      const nested = Object.keys(schema).map(key => {\n        const nestedValidation = schema[key];\n        return nestedValidation.testAsync((value || {})[key]).catch(ex => {\n          ex.target = key;\n          causes.push(ex);\n        });\n      });\n      return Promise.all(nested).then(() => {\n        if (causes.length > 0) {\n          throw causes;\n        }\n\n        return true;\n      });\n    },\n  };\n}\n\nexport default v8n;\n", "output": {"vulnerability_count": 2, "vulnerabilities": [{"description": "Detected the use of a regular expression `^([a-z]+\\s*)+$` which appears to be vulnerable to a Regular expression Denial-of-Service (ReDoS). For this reason, it is recommended to review the regex and ensure it is not vulnerable to catastrophic backtracking, and if possible use a library which offers default safety against ReDoS vulnerabilities.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 192}, {"description": "Detected the use of a regular expression `^([A-Z]+\\s*)+$` which appears to be vulnerable to a Regular expression Denial-of-Service (ReDoS). For this reason, it is recommended to review the regex and ensure it is not vulnerable to catastrophic backtracking, and if possible use a library which offers default safety against ReDoS vulnerabilities.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 194}]}}
{"CVE": "CVE-2022-36036", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "/**\n * Copyright (c) Samuel Wall.\n *\n * This source code is licensed under the MIT license found in the\n * license file in the root directory of this source tree.\n */\n\nimport React, { useEffect, useState, ReactElement } from 'react'\nimport mermaid from 'mermaid'\nimport mermaidAPI from 'mermaid/mermaidAPI'\n\nimport { Config } from './config.model'\nimport { getTheme } from './theme.helper'\n\n/**\n * Assign a unique ID to each mermaid svg as per requirements\n * of `mermaid.render`.\n */\nlet id = 0\n\n/**\n * Properties for Mermaid component.\n */\nexport type MermaidProps = {\n  /**\n   * Mermaid diagram.\n   */\n  chart: string\n\n  /**\n   * Config to initialize mermaid with.\n   */\n  config?: Config\n}\n\n/**\n * Component to display Mermaid diagrams.\n *\n * @param param0 Diagram to display.\n * @param param1 Config.\n * @returns The component.\n */\nexport const Mermaid = ({ chart, config }: MermaidProps): ReactElement<MermaidProps> => {\n  // Due to Docusaurus not correctly parsing client-side from server-side modules, use the provided workaround\n  // found in the accompanying issue: https://github.com/facebook/docusaurus/issues/4268#issuecomment-783553084\n  /* istanbul ignore next */\n  if (typeof window === 'undefined') {\n    return <div></div>\n  }\n\n  const html: HTMLHtmlElement = document.querySelector('html')!\n\n  // Watch for changes in theme in the HTML attribute `data-theme`.\n  const [theme, setTheme] = useState<mermaidAPI.Theme>(getTheme(html, config))\n\n  useEffect(() => {\n    const observer = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        if (mutation.type !== 'attributes' || mutation.attributeName !== 'data-theme') {\n          continue\n        }\n        setTheme(getTheme(mutation.target as HTMLHtmlElement, config))\n        break\n      }\n    })\n\n    observer.observe(html, { attributes: true })\n    return () => {\n      try {\n        observer.disconnect()\n      } catch {\n        // Do nothing\n      }\n    }\n  }, [chart, config, theme])\n\n  // When theme updates, rerender the SVG.\n  const [svg, setSvg] = useState<string>('')\n  useEffect(() => {\n    const render = () => {\n      mermaid.render(`mermaid-svg-${id.toString()}`, chart, (renderedSvg) => setSvg(renderedSvg))\n      id++\n    }\n\n    if (config) {\n      if (config.mermaid) {\n        mermaid.initialize({ startOnLoad: true, ...config.mermaid, theme })\n      } else {\n        mermaid.initialize({ startOnLoad: true, theme })\n      }\n      render()\n    } else {\n      // Is there a better way?\n      setTimeout(render, 0)\n    }\n  }, [theme, chart])\n\n  return <div dangerouslySetInnerHTML={{ __html: svg }}></div>\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2022-36037", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "<template>\n  <k-draggable\n    :list=\"state\"\n    :options=\"dragOptions\"\n    :data-layout=\"layout\"\n    element=\"k-dropdown\"\n    class=\"k-multiselect-input\"\n    @click.native=\"$refs.dropdown.toggle\"\n    @end=\"onInput\"\n  >\n    <k-tag\n      v-for=\"tag in sorted\"\n      :ref=\"tag.value\"\n      :key=\"tag.value\"\n      :removable=\"true\"\n      @click.native.stop\n      @remove=\"remove(tag)\"\n      @keydown.native.left=\"navigate('prev')\"\n      @keydown.native.right=\"navigate('next')\"\n      @keydown.native.down=\"$refs.dropdown.open\"\n    >\n      {{ tag.text }}\n    </k-tag>\n\n    <k-dropdown-content\n      slot=\"footer\"\n      ref=\"dropdown\"\n      @open=\"onOpen\"\n      @close=\"onClose\"\n      @keydown.native.esc.stop=\"close\"\n    >\n      <k-dropdown-item\n        v-if=\"search\"\n        icon=\"search\"\n        class=\"k-multiselect-search\"\n      >\n        <input\n          ref=\"search\"\n          v-model=\"q\"\n          :placeholder=\"search.min ? $t('search.min', { min: search.min }) : $t('search') + ' '\"\n          @keydown.esc.stop=\"escape\"\n        >\n      </k-dropdown-item>\n\n      <div class=\"k-multiselect-options\">\n        <k-dropdown-item\n          v-for=\"option in visible\"\n          :key=\"option.value\"\n          :icon=\"isSelected(option) ? 'check' : 'circle-outline'\"\n          :class=\"{\n            'k-multiselect-option': true,\n            'selected': isSelected(option),\n            'disabled': !more\n          }\"\n          @click.prevent=\"select(option)\"\n          @keydown.native.enter.prevent.stop=\"select(option)\"\n          @keydown.native.space.prevent.stop=\"select(option)\"\n        >\n          <!-- eslint-disable-next-line vue/no-v-html -->\n          <span v-html=\"option.display\" />\n          <!-- eslint-disable-next-line vue/no-v-html -->\n          <span class=\"k-multiselect-value\" v-html=\"option.info\" />\n        </k-dropdown-item>\n\n        <k-dropdown-item\n          v-if=\"filtered.length === 0\"\n          :disabled=\"true\"\n          class=\"k-multiselect-option\"\n        >\n          {{ emptyLabel }}\n        </k-dropdown-item>\n      </div>\n\n      <k-button\n        v-if=\"visible.length < filtered.length\"\n        class=\"k-multiselect-more\"\n        @click.stop=\"limit = false\"\n      >\n        {{ $t(\"search.all\") }} ({{ filtered.length }})\n      </k-button>\n    </k-dropdown-content>\n  </k-draggable>\n</template>\n\n<script>\nimport { required, minLength, maxLength } from \"vuelidate/lib/validators\";\n\nexport default {\n  inheritAttrs: false,\n  props: {\n    id: [Number, String],\n    disabled: Boolean,\n    max: Number,\n    min: Number,\n    layout: String,\n    options: {\n      type: Array,\n      default() {\n        return [];\n      }\n    },\n    required: Boolean,\n    search: [Object, Boolean],\n    separator: {\n      type: String,\n      default: \",\"\n    },\n    sort: Boolean,\n    value: {\n      type: Array,\n      required: true,\n      default() {\n        return [];\n      }\n    }\n  },\n  data() {\n    return {\n      state: this.value,\n      q: null,\n      limit: true,\n      scrollTop: 0\n    };\n  },\n  computed: {\n    draggable() {\n      return this.state.length > 1 && !this.sort;\n    },\n    dragOptions() {\n      return {\n        disabled: !this.draggable,\n        draggable: \".k-tag\",\n        delay: 1\n      };\n    },\n    emptyLabel() {\n      if (this.q) {\n        return this.$t(\"search.results.none\");\n      }\n\n      return this.$t(\"options.none\");\n    },\n    filtered() {\n      if (this.q && this.q.length >= (this.search.min || 0)) {\n        return this.options\n          .filter(option => this.isFiltered(option))\n          .map(option => ({\n            ...option,\n            display: this.toHighlightedString(option.text),\n            info: this.toHighlightedString(option.value)\n          }));\n      }\n\n      return this.options.map(option => ({\n        ...option,\n        display: option.text,\n        info: option.value\n      }));\n    },\n    more() {\n      return !this.max || this.state.length < this.max;\n    },\n    regex() {\n      return new RegExp(`(${RegExp.escape(this.q)})`, \"ig\");\n    },\n    sorted() {\n      if (this.sort === false) {\n        return this.state;\n      }\n\n      let items = this.state;\n\n      const index = x => this.options.findIndex(y => y.value === x.value);\n      return items.sort((a, b) => index(a) - index(b));\n    },\n    visible() {\n      if (this.limit) {\n        return this.filtered.slice(0, this.search.display || this.filtered.length);\n      }\n\n      return this.filtered;\n    },\n  },\n  watch: {\n    value(value) {\n      this.state = value;\n      this.onInvalid();\n    }\n  },\n  mounted() {\n    this.onInvalid();\n    this.$events.$on(\"click\", this.close);\n    this.$events.$on(\"keydown.cmd.s\", this.close);\n  },\n  destroyed() {\n    this.$events.$off(\"click\", this.close);\n    this.$events.$off(\"keydown.cmd.s\", this.close);\n  },\n  methods: {\n    add(option) {\n      if (this.more === true) {\n        this.state.push(option);\n        this.onInput();\n      }\n    },\n    blur() {\n      this.close();\n    },\n    close() {\n      if (this.$refs.dropdown.isOpen === true) {\n        this.$refs.dropdown.close();\n        this.limit = true;\n      }\n    },\n    escape() {\n      if (this.q) {\n        this.q = null;\n        return;\n      }\n\n      this.close();\n    },\n    focus() {\n      this.$refs.dropdown.open();\n    },\n    index(option) {\n      return this.state.findIndex(item => item.value === option.value);\n    },\n    isFiltered(option) {\n      return String(option.text).match(this.regex) ||\n             String(option.value).match(this.regex);\n    },\n    isSelected(option) {\n      return this.index(option) !== -1;\n    },\n    navigate(direction) {\n      let current = document.activeElement;\n\n      switch (direction) {\n        case \"prev\":\n          if (\n            current &&\n            current.previousSibling &&\n            current.previousSibling.focus\n          ) {\n            current.previousSibling.focus();\n          }\n          break;\n        case \"next\":\n          if (\n            current &&\n            current.nextSibling &&\n            current.nextSibling.focus\n          ) {\n            current.nextSibling.focus();\n          }\n          break;\n      }\n    },\n    onClose() {\n      if (this.$refs.dropdown.isOpen === false) {\n        if (document.activeElement === this.$parent.$el) {\n          this.q = null;\n        }\n\n        this.$parent.$el.focus();\n      }\n    },\n    onInput() {\n      this.$emit(\"input\", this.sorted);\n    },\n    onInvalid() {\n      this.$emit(\"invalid\", this.$v.$invalid, this.$v);\n    },\n    onOpen() {\n      this.$nextTick(() => {\n        if (this.$refs.search && this.$refs.search.focus) {\n          this.$refs.search.focus();\n        }\n\n        this.$refs.dropdown.$el.querySelector('.k-multiselect-options').scrollTop = this.scrollTop;\n      });\n    },\n    remove(option) {\n      this.state.splice(this.index(option), 1);\n      this.onInput();\n    },\n    select(option) {\n      this.scrollTop = this.$refs.dropdown.$el.querySelector('.k-multiselect-options').scrollTop;\n\n      option = { text: option.text, value: option.value };\n\n      if (this.isSelected(option)) {\n        this.remove(option);\n      } else {\n        this.add(option);\n      }\n    },\n    toHighlightedString(string) {\n      // make sure that no HTML exists before in the string\n      // to avoid XSS when displaying via `v-html`\n      string = this.$helper.string.stripHTML(string);\n      return string.replace(this.regex, \"<b>$1</b>\")\n    },\n  },\n  validations() {\n    return {\n      state: {\n        required: this.required ? required : true,\n        minLength: this.min ? minLength(this.min) : true,\n        maxLength: this.max ? maxLength(this.max) : true\n      }\n    };\n  }\n};\n</script>\n\n<style lang=\"scss\">\n.k-multiselect-input {\n  display: flex;\n  flex-wrap: wrap;\n  position: relative;\n  font-size: $text-sm;\n  min-height: 2.25rem;\n  line-height: 1;\n}\n.k-multiselect-input .k-sortable-ghost {\n  background: $color-focus;\n}\n\n.k-multiselect-input .k-dropdown-content {\n  width: 100%;\n}\n\n.k-multiselect-search {\n  margin-top: 0 !important;\n  color: $color-white;\n  background: $color-gray-900;\n  border-bottom: 1px dashed rgba($color-white, 0.2);\n\n  > .k-button-text {\n    flex: 1;\n    opacity: 1 !important;\n  }\n\n  input {\n    width: 100%;\n    color: $color-white;\n    background: none;\n    border: none;\n    outline: none;\n    padding: 0.25rem 0;\n    font: inherit;\n  }\n}\n\n.k-multiselect-options {\n  position: relative;\n  max-height: 275px;\n  overflow-y: auto;\n  padding: 0.5rem 0;\n}\n\n.k-multiselect-option {\n  position: relative;\n\n  &.selected {\n    color: $color-positive-on-dark;\n  }\n\n  &.disabled:not(.selected) .k-icon {\n    opacity: 0;\n  }\n\n  b {\n    color: $color-focus-on-dark;\n    font-weight: 700;\n  }\n}\n\n.k-multiselect-value {\n  color: $color-light-grey;\n  margin-left: 0.25rem;\n\n  &::before {\n    content: \" (\";\n  }\n  &::after {\n    content: \")\";\n  }\n}\n\n.k-multiselect-input[data-layout=\"list\"] .k-tag {\n  width: 100%;\n  margin-right: 0 !important;\n}\n\n.k-multiselect-more {\n  width: 100%;\n  padding: .75rem;\n  color: rgba($color-white, .8);\n  text-align: center;\n  border-top: 1px dashed rgba($color-white, 0.2);\n\n  &:hover {\n    color: $color-white;\n  }\n}\n</style>\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2022-39232", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "\"use strict\";\n\nconst EmberApp = require(\"ember-cli/lib/broccoli/ember-app\");\nconst resolve = require(\"path\").resolve;\nconst mergeTrees = require(\"broccoli-merge-trees\");\nconst concat = require(\"broccoli-concat\");\nconst prettyTextEngine = require(\"./lib/pretty-text-engine\");\nconst { createI18nTree } = require(\"./lib/translation-plugin\");\nconst discourseScss = require(\"./lib/discourse-scss\");\nconst generateScriptsTree = require(\"./lib/scripts\");\nconst funnel = require(\"broccoli-funnel\");\n\nconst SILENCED_WARN_PREFIXES = [\n  \"Setting the `jquery-integration` optional feature flag\",\n  \"The Ember Classic edition has been deprecated\",\n  \"Setting the `template-only-glimmer-components` optional feature flag to `false`\",\n  \"DEPRECATION: Invoking the `<LinkTo>` component with positional arguments is deprecated\",\n];\n\nmodule.exports = function (defaults) {\n  let discourseRoot = resolve(\"../../../..\");\n  let vendorJs = discourseRoot + \"/vendor/assets/javascripts/\";\n\n  // Silence the warnings listed in SILENCED_WARN_PREFIXES\n  const ui = defaults.project.ui;\n  const oldWriteWarning = ui.writeWarnLine.bind(ui);\n  ui.writeWarnLine = (message, ...args) => {\n    if (!SILENCED_WARN_PREFIXES.some((prefix) => message.startsWith(prefix))) {\n      return oldWriteWarning(message, ...args);\n    }\n  };\n\n  // Silence warnings which go straight to console.warn (e.g. template compiler deprecations)\n  /* eslint-disable no-console */\n  const oldConsoleWarn = console.warn.bind(console);\n  console.warn = (message, ...args) => {\n    if (!SILENCED_WARN_PREFIXES.some((prefix) => message.startsWith(prefix))) {\n      return oldConsoleWarn(message, ...args);\n    }\n  };\n  /* eslint-enable no-console */\n\n  const isProduction = EmberApp.env().includes(\"production\");\n  const isTest = EmberApp.env().includes(\"test\");\n\n  let app = new EmberApp(defaults, {\n    autoRun: false,\n    \"ember-qunit\": {\n      insertContentForTestBody: false,\n    },\n    sourcemaps: {\n      // There seems to be a bug with broccoli-concat when sourcemaps are disabled\n      // that causes the `app.import` statements below to fail in production mode.\n      // This forces the use of `fast-sourcemap-concat` which works in production.\n      enabled: true,\n    },\n    autoImport: {\n      forbidEval: true,\n      insertScriptsAt: \"ember-auto-import-scripts\",\n    },\n    fingerprint: {\n      // Handled by Rails asset pipeline\n      enabled: false,\n    },\n    SRI: {\n      // We don't use SRI in Rails. Disable here to match:\n      enabled: false,\n    },\n\n    \"ember-cli-terser\": {\n      enabled: isProduction,\n      exclude: [\n        \"**/test-*.js\",\n        \"**/core-tests*.js\",\n        \"**/highlightjs/*\",\n        \"**/javascripts/*\",\n      ],\n    },\n\n    // We need to build tests in prod for theme tests\n    tests: true,\n  });\n\n  // Patching a private method is not great, but there's no other way for us to tell\n  // Ember CLI that we want the tests alone in a package without helpers/fixtures, since\n  // we re-use those in the theme tests.\n  app._defaultPackager.packageApplicationTests = function (tree) {\n    let appTestTrees = []\n      .concat(\n        this.packageEmberCliInternalFiles(),\n        this.packageTestApplicationConfig(),\n        tree\n      )\n      .filter(Boolean);\n\n    appTestTrees = mergeTrees(appTestTrees, {\n      overwrite: true,\n      annotation: \"TreeMerger (appTestTrees)\",\n    });\n\n    let tests = concat(appTestTrees, {\n      inputFiles: [\"**/tests/**/*-test.js\"],\n      headerFiles: [\"vendor/ember-cli/tests-prefix.js\"],\n      footerFiles: [\"vendor/ember-cli/app-config.js\"],\n      outputFile: \"/assets/core-tests.js\",\n      annotation: \"Concat: Core Tests\",\n      sourceMapConfig: false,\n    });\n\n    let testHelpers = concat(appTestTrees, {\n      inputFiles: [\n        \"**/tests/test-boot-ember-cli.js\",\n        \"**/tests/helpers/**/*.js\",\n        \"**/tests/fixtures/**/*.js\",\n        \"**/tests/setup-tests.js\",\n      ],\n      outputFile: \"/assets/test-helpers.js\",\n      annotation: \"Concat: Test Helpers\",\n      sourceMapConfig: false,\n    });\n\n    if (isTest) {\n      return mergeTrees([\n        tests,\n        testHelpers,\n        discourseScss(`${discourseRoot}/app/assets/stylesheets`, \"testem.scss\"),\n      ]);\n    } else {\n      return mergeTrees([tests, testHelpers]);\n    }\n  };\n\n  // WARNING: We should only import scripts here if they are not in NPM.\n  // For example: our very specific version of bootstrap-modal.\n  app.import(vendorJs + \"bootbox.js\");\n  app.import(\"node_modules/bootstrap/js/modal.js\");\n  app.import(vendorJs + \"caret_position.js\");\n  app.import(\"node_modules/ember-source/dist/ember-template-compiler.js\", {\n    type: \"test\",\n  });\n  app.import(discourseRoot + \"/app/assets/javascripts/polyfills.js\");\n\n  app.import(\n    discourseRoot +\n      \"/app/assets/javascripts/discourse/public/assets/scripts/module-shims.js\"\n  );\n\n  const discoursePluginsTree = app.project\n    .findAddonByName(\"discourse-plugins\")\n    .generatePluginsTree();\n\n  const terserPlugin = app.project.findAddonByName(\"ember-cli-terser\");\n  const applyTerser = (tree) => terserPlugin.postprocessTree(\"all\", tree);\n\n  return mergeTrees([\n    createI18nTree(discourseRoot, vendorJs),\n    app.toTree(),\n    funnel(`${discourseRoot}/public/javascripts`, { destDir: \"javascripts\" }),\n    funnel(`${vendorJs}/highlightjs`, {\n      files: [\"highlight-test-bundle.min.js\"],\n      destDir: \"assets/highlightjs\",\n    }),\n    applyTerser(\n      concat(mergeTrees([app.options.adminTree]), {\n        inputFiles: [\"**/*.js\"],\n        outputFile: `assets/admin.js`,\n      })\n    ),\n    applyTerser(\n      concat(mergeTrees([app.options.wizardTree]), {\n        inputFiles: [\"**/*.js\"],\n        outputFile: `assets/wizard.js`,\n      })\n    ),\n    applyTerser(prettyTextEngine(app)),\n    generateScriptsTree(app),\n    applyTerser(discoursePluginsTree),\n  ]);\n};\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2022-39236", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { MBeaconEventContent } from \"../@types/beacon\";\nimport { M_TIMESTAMP } from \"../@types/location\";\nimport { BeaconInfoState, BeaconLocationState, parseBeaconContent, parseBeaconInfoContent } from \"../content-helpers\";\nimport { MatrixEvent } from \"../matrix\";\nimport { sortEventsByLatestContentTimestamp } from \"../utils\";\nimport { TypedEventEmitter } from \"./typed-event-emitter\";\n\nexport enum BeaconEvent {\n    New = \"Beacon.new\",\n    Update = \"Beacon.update\",\n    LivenessChange = \"Beacon.LivenessChange\",\n    Destroy = \"Beacon.Destroy\",\n    LocationUpdate = \"Beacon.LocationUpdate\",\n}\n\nexport type BeaconEventHandlerMap = {\n    [BeaconEvent.Update]: (event: MatrixEvent, beacon: Beacon) => void;\n    [BeaconEvent.LivenessChange]: (isLive: boolean, beacon: Beacon) => void;\n    [BeaconEvent.Destroy]: (beaconIdentifier: string) => void;\n    [BeaconEvent.LocationUpdate]: (locationState: BeaconLocationState) => void;\n    [BeaconEvent.Destroy]: (beaconIdentifier: string) => void;\n};\n\nexport const isTimestampInDuration = (\n    startTimestamp: number,\n    durationMs: number,\n    timestamp: number,\n): boolean => timestamp >= startTimestamp && startTimestamp + durationMs >= timestamp;\n\n// beacon info events are uniquely identified by\n// `<roomId>_<state_key>`\nexport type BeaconIdentifier = string;\nexport const getBeaconInfoIdentifier = (event: MatrixEvent): BeaconIdentifier =>\n    `${event.getRoomId()}_${event.getStateKey()}`;\n\n// https://github.com/matrix-org/matrix-spec-proposals/pull/3672\nexport class Beacon extends TypedEventEmitter<Exclude<BeaconEvent, BeaconEvent.New>, BeaconEventHandlerMap> {\n    public readonly roomId: string;\n    private _beaconInfo: BeaconInfoState;\n    private _isLive: boolean;\n    private livenessWatchTimeout: ReturnType<typeof setTimeout>;\n    private _latestLocationEvent: MatrixEvent | undefined;\n\n    constructor(\n        private rootEvent: MatrixEvent,\n    ) {\n        super();\n        this.setBeaconInfo(this.rootEvent);\n        this.roomId = this.rootEvent.getRoomId();\n    }\n\n    public get isLive(): boolean {\n        return this._isLive;\n    }\n\n    public get identifier(): BeaconIdentifier {\n        return getBeaconInfoIdentifier(this.rootEvent);\n    }\n\n    public get beaconInfoId(): string {\n        return this.rootEvent.getId();\n    }\n\n    public get beaconInfoOwner(): string {\n        return this.rootEvent.getStateKey();\n    }\n\n    public get beaconInfoEventType(): string {\n        return this.rootEvent.getType();\n    }\n\n    public get beaconInfo(): BeaconInfoState {\n        return this._beaconInfo;\n    }\n\n    public get latestLocationState(): BeaconLocationState | undefined {\n        return this._latestLocationEvent && parseBeaconContent(this._latestLocationEvent.getContent());\n    }\n\n    public get latestLocationEvent(): MatrixEvent | undefined {\n        return this._latestLocationEvent;\n    }\n\n    public update(beaconInfoEvent: MatrixEvent): void {\n        if (getBeaconInfoIdentifier(beaconInfoEvent) !== this.identifier) {\n            throw new Error('Invalid updating event');\n        }\n        // don't update beacon with an older event\n        if (beaconInfoEvent.event.origin_server_ts < this.rootEvent.event.origin_server_ts) {\n            return;\n        }\n        this.rootEvent = beaconInfoEvent;\n        this.setBeaconInfo(this.rootEvent);\n\n        this.emit(BeaconEvent.Update, beaconInfoEvent, this);\n        this.clearLatestLocation();\n    }\n\n    public destroy(): void {\n        if (this.livenessWatchTimeout) {\n            clearTimeout(this.livenessWatchTimeout);\n        }\n\n        this._isLive = false;\n        this.emit(BeaconEvent.Destroy, this.identifier);\n    }\n\n    /**\n     * Monitor liveness of a beacon\n     * Emits BeaconEvent.LivenessChange when beacon expires\n     */\n    public monitorLiveness(): void {\n        if (this.livenessWatchTimeout) {\n            clearTimeout(this.livenessWatchTimeout);\n        }\n\n        this.checkLiveness();\n        if (this.isLive) {\n            const expiryInMs = (this._beaconInfo?.timestamp + this._beaconInfo?.timeout) - Date.now();\n            if (expiryInMs > 1) {\n                this.livenessWatchTimeout = setTimeout(\n                    () => { this.monitorLiveness(); },\n                    expiryInMs,\n                );\n            }\n        } else if (this._beaconInfo?.timestamp > Date.now()) {\n            // beacon start timestamp is in the future\n            // check liveness again then\n            this.livenessWatchTimeout = setTimeout(\n                () => { this.monitorLiveness(); },\n                this.beaconInfo?.timestamp - Date.now(),\n            );\n        }\n    }\n\n    /**\n     * Process Beacon locations\n     * Emits BeaconEvent.LocationUpdate\n     */\n    public addLocations(beaconLocationEvents: MatrixEvent[]): void {\n        // discard locations for beacons that are not live\n        if (!this.isLive) {\n            return;\n        }\n\n        const validLocationEvents = beaconLocationEvents.filter(event => {\n            const content = event.getContent<MBeaconEventContent>();\n            const timestamp = M_TIMESTAMP.findIn<number>(content);\n            return (\n                // only include positions that were taken inside the beacon's live period\n                isTimestampInDuration(this._beaconInfo.timestamp, this._beaconInfo.timeout, timestamp) &&\n                // ignore positions older than our current latest location\n                (!this.latestLocationState || timestamp > this.latestLocationState.timestamp)\n            );\n        });\n        const latestLocationEvent = validLocationEvents.sort(sortEventsByLatestContentTimestamp)?.[0];\n\n        if (latestLocationEvent) {\n            this._latestLocationEvent = latestLocationEvent;\n            this.emit(BeaconEvent.LocationUpdate, this.latestLocationState);\n        }\n    }\n\n    private clearLatestLocation = () => {\n        this._latestLocationEvent = undefined;\n        this.emit(BeaconEvent.LocationUpdate, this.latestLocationState);\n    };\n\n    private setBeaconInfo(event: MatrixEvent): void {\n        this._beaconInfo = parseBeaconInfoContent(event.getContent());\n        this.checkLiveness();\n    }\n\n    private checkLiveness(): void {\n        const prevLiveness = this.isLive;\n\n        // element web sets a beacon's start timestamp to the senders local current time\n        // when Alice's system clock deviates slightly from Bob's a beacon Alice intended to be live\n        // may have a start timestamp in the future from Bob's POV\n        // handle this by adding 6min of leniency to the start timestamp when it is in the future\n        const startTimestamp = this._beaconInfo?.timestamp > Date.now() ?\n            this._beaconInfo?.timestamp - 360000 /* 6min */ :\n            this._beaconInfo?.timestamp;\n        this._isLive = !!this._beaconInfo?.live &&\n            isTimestampInDuration(startTimestamp, this._beaconInfo?.timeout, Date.now());\n\n        if (prevLiveness !== this.isLive) {\n            this.emit(BeaconEvent.LivenessChange, this.isLive, this);\n        }\n    }\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2022-39249", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "/*\nCopyright 2016 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { Account, InboundGroupSession, OutboundGroupSession, Session, Utility } from \"@matrix-org/olm\";\nimport { Logger } from \"loglevel\";\n\nimport { logger } from '../logger';\nimport { IndexedDBCryptoStore } from './store/indexeddb-crypto-store';\nimport * as algorithms from './algorithms';\nimport { CryptoStore, IProblem, ISessionInfo, IWithheld } from \"./store/base\";\nimport { IOlmDevice, IOutboundGroupSessionKey } from \"./algorithms/megolm\";\nimport { IMegolmSessionData } from \"./index\";\n\n// The maximum size of an event is 65K, and we base64 the content, so this is a\n// reasonable approximation to the biggest plaintext we can encrypt.\nconst MAX_PLAINTEXT_LENGTH = 65536 * 3 / 4;\n\nfunction checkPayloadLength(payloadString: string): void {\n    if (payloadString === undefined) {\n        throw new Error(\"payloadString undefined\");\n    }\n\n    if (payloadString.length > MAX_PLAINTEXT_LENGTH) {\n        // might as well fail early here rather than letting the olm library throw\n        // a cryptic memory allocation error.\n        //\n        // Note that even if we manage to do the encryption, the message send may fail,\n        // because by the time we've wrapped the ciphertext in the event object, it may\n        // exceed 65K. But at least we won't just fail with \"abort()\" in that case.\n        const err = new Error(\"Message too long (\" + payloadString.length + \" bytes). \" +\n                        \"The maximum for an encrypted message is \" +\n                        MAX_PLAINTEXT_LENGTH + \" bytes.\");\n        // TODO: [TypeScript] We should have our own error types\n        err[\"data\"] = {\n            errcode: \"M_TOO_LARGE\",\n            error: \"Payload too large for encrypted message\",\n        };\n        throw err;\n    }\n}\n\n/**\n * The type of object we use for importing and exporting megolm session data.\n *\n * @typedef {Object} module:crypto/OlmDevice.MegolmSessionData\n * @property {String} sender_key  Sender's Curve25519 device key\n * @property {String[]} forwarding_curve25519_key_chain Devices which forwarded\n *     this session to us (normally empty).\n * @property {Object<string, string>} sender_claimed_keys Other keys the sender claims.\n * @property {String} room_id     Room this session is used in\n * @property {String} session_id  Unique id for the session\n * @property {String} session_key Base64'ed key data\n */\n\ninterface IInitOpts {\n    fromExportedDevice?: IExportedDevice;\n    pickleKey?: string;\n}\n\n/**\n * data stored in the session store about an inbound group session\n *\n * @typedef {Object} InboundGroupSessionData\n * @property {string} room_id\n * @property {string} session   pickled Olm.InboundGroupSession\n * @property {Object<string, string>} keysClaimed\n * @property {Array<string>} forwardingCurve25519KeyChain  Devices involved in forwarding\n *     this session to us (normally empty).\n * @property {boolean=} untrusted whether this session is untrusted.\n * @property {boolean=} sharedHistory whether this session exists during the room being set to shared history.\n */\n\nexport interface InboundGroupSessionData {\n    room_id: string; // eslint-disable-line camelcase\n    session: string;\n    keysClaimed: Record<string, string>;\n    forwardingCurve25519KeyChain: string[];\n    untrusted?: boolean;\n    sharedHistory?: boolean;\n}\n\nexport interface IDecryptedGroupMessage {\n    result: string;\n    keysClaimed: Record<string, string>;\n    senderKey: string;\n    forwardingCurve25519KeyChain: string[];\n    untrusted: boolean;\n}\n\nexport interface IInboundSession {\n    payload: string;\n    session_id: string;\n}\n\nexport interface IExportedDevice {\n    pickleKey: string;\n    pickledAccount: string;\n    sessions: ISessionInfo[];\n}\n\ninterface IUnpickledSessionInfo extends Omit<ISessionInfo, \"session\"> {\n    session: Session;\n}\n\n/* eslint-disable camelcase */\ninterface IInboundGroupSessionKey {\n    chain_index: number;\n    key: string;\n    forwarding_curve25519_key_chain: string[];\n    sender_claimed_ed25519_key: string;\n    shared_history: boolean;\n}\n/* eslint-enable camelcase */\n\n/**\n * Manages the olm cryptography functions. Each OlmDevice has a single\n * OlmAccount and a number of OlmSessions.\n *\n * Accounts and sessions are kept pickled in the cryptoStore.\n *\n * @constructor\n * @alias module:crypto/OlmDevice\n *\n * @param {Object} cryptoStore A store for crypto data\n *\n * @property {string} deviceCurve25519Key   Curve25519 key for the account\n * @property {string} deviceEd25519Key      Ed25519 key for the account\n */\nexport class OlmDevice {\n    public pickleKey = \"DEFAULT_KEY\"; // set by consumers\n\n    // don't know these until we load the account from storage in init()\n    public deviceCurve25519Key: string = null;\n    public deviceEd25519Key: string = null;\n    private maxOneTimeKeys: number = null;\n\n    // we don't bother stashing outboundgroupsessions in the cryptoStore -\n    // instead we keep them here.\n    private outboundGroupSessionStore: Record<string, string> = {};\n\n    // Store a set of decrypted message indexes for each group session.\n    // This partially mitigates a replay attack where a MITM resends a group\n    // message into the room.\n    //\n    // When we decrypt a message and the message index matches a previously\n    // decrypted message, one possible cause of that is that we are decrypting\n    // the same event, and may not indicate an actual replay attack.  For\n    // example, this could happen if we receive events, forget about them, and\n    // then re-fetch them when we backfill.  So we store the event ID and\n    // timestamp corresponding to each message index when we first decrypt it,\n    // and compare these against the event ID and timestamp every time we use\n    // that same index.  If they match, then we're probably decrypting the same\n    // event and we don't consider it a replay attack.\n    //\n    // Keys are strings of form \"<senderKey>|<session_id>|<message_index>\"\n    // Values are objects of the form \"{id: <event id>, timestamp: <ts>}\"\n    private inboundGroupSessionMessageIndexes: Record<string, { id: string, timestamp: number }> = {};\n\n    // Keep track of sessions that we're starting, so that we don't start\n    // multiple sessions for the same device at the same time.\n    public sessionsInProgress: Record<string, Promise<void>> = {}; // set by consumers\n\n    // Used by olm to serialise prekey message decryptions\n    public olmPrekeyPromise: Promise<any> = Promise.resolve(); // set by consumers\n\n    constructor(private readonly cryptoStore: CryptoStore) {\n    }\n\n    /**\n     * @return {array} The version of Olm.\n     */\n    static getOlmVersion(): [number, number, number] {\n        return global.Olm.get_library_version();\n    }\n\n    /**\n     * Initialise the OlmAccount. This must be called before any other operations\n     * on the OlmDevice.\n     *\n     * Data from an exported Olm device can be provided\n     * in order to re-create this device.\n     *\n     * Attempts to load the OlmAccount from the crypto store, or creates one if none is\n     * found.\n     *\n     * Reads the device keys from the OlmAccount object.\n     *\n     * @param {object} opts\n     * @param {object} opts.fromExportedDevice (Optional) data from exported device\n     *     that must be re-created.\n     *     If present, opts.pickleKey is ignored\n     *     (exported data already provides a pickle key)\n     * @param {object} opts.pickleKey (Optional) pickle key to set instead of default one\n     */\n    public async init({ pickleKey, fromExportedDevice }: IInitOpts = {}): Promise<void> {\n        let e2eKeys;\n        const account = new global.Olm.Account();\n\n        try {\n            if (fromExportedDevice) {\n                if (pickleKey) {\n                    logger.warn(\n                        'ignoring opts.pickleKey'\n                        + ' because opts.fromExportedDevice is present.',\n                    );\n                }\n                this.pickleKey = fromExportedDevice.pickleKey;\n                await this.initialiseFromExportedDevice(fromExportedDevice, account);\n            } else {\n                if (pickleKey) {\n                    this.pickleKey = pickleKey;\n                }\n                await this.initialiseAccount(account);\n            }\n            e2eKeys = JSON.parse(account.identity_keys());\n\n            this.maxOneTimeKeys = account.max_number_of_one_time_keys();\n        } finally {\n            account.free();\n        }\n\n        this.deviceCurve25519Key = e2eKeys.curve25519;\n        this.deviceEd25519Key = e2eKeys.ed25519;\n    }\n\n    /**\n     * Populates the crypto store using data that was exported from an existing device.\n     * Note that for now only the account and sessions stores are populated;\n     * Other stores will be as with a new device.\n     *\n     * @param {IExportedDevice} exportedData Data exported from another device\n     *     through the export method.\n     * @param {Olm.Account} account an olm account to initialize\n     */\n    private async initialiseFromExportedDevice(exportedData: IExportedDevice, account: Account): Promise<void> {\n        await this.cryptoStore.doTxn(\n            'readwrite',\n            [\n                IndexedDBCryptoStore.STORE_ACCOUNT,\n                IndexedDBCryptoStore.STORE_SESSIONS,\n            ],\n            (txn) => {\n                this.cryptoStore.storeAccount(txn, exportedData.pickledAccount);\n                exportedData.sessions.forEach((session) => {\n                    const {\n                        deviceKey,\n                        sessionId,\n                    } = session;\n                    const sessionInfo = {\n                        session: session.session,\n                        lastReceivedMessageTs: session.lastReceivedMessageTs,\n                    };\n                    this.cryptoStore.storeEndToEndSession(\n                        deviceKey,\n                        sessionId,\n                        sessionInfo,\n                        txn,\n                    );\n                });\n            });\n        account.unpickle(this.pickleKey, exportedData.pickledAccount);\n    }\n\n    private async initialiseAccount(account: Account): Promise<void> {\n        await this.cryptoStore.doTxn(\n            'readwrite',\n            [IndexedDBCryptoStore.STORE_ACCOUNT],\n            (txn) => {\n                this.cryptoStore.getAccount(txn, (pickledAccount) => {\n                    if (pickledAccount !== null) {\n                        account.unpickle(this.pickleKey, pickledAccount);\n                    } else {\n                        account.create();\n                        pickledAccount = account.pickle(this.pickleKey);\n                        this.cryptoStore.storeAccount(txn, pickledAccount);\n                    }\n                });\n            },\n        );\n    }\n\n    /**\n     * extract our OlmAccount from the crypto store and call the given function\n     * with the account object\n     * The `account` object is usable only within the callback passed to this\n     * function and will be freed as soon the callback returns. It is *not*\n     * usable for the rest of the lifetime of the transaction.\n     * This function requires a live transaction object from cryptoStore.doTxn()\n     * and therefore may only be called in a doTxn() callback.\n     *\n     * @param {*} txn Opaque transaction object from cryptoStore.doTxn()\n     * @param {function} func\n     * @private\n     */\n    private getAccount(txn: unknown, func: (account: Account) => void): void {\n        this.cryptoStore.getAccount(txn, (pickledAccount: string) => {\n            const account = new global.Olm.Account();\n            try {\n                account.unpickle(this.pickleKey, pickledAccount);\n                func(account);\n            } finally {\n                account.free();\n            }\n        });\n    }\n\n    /*\n     * Saves an account to the crypto store.\n     * This function requires a live transaction object from cryptoStore.doTxn()\n     * and therefore may only be called in a doTxn() callback.\n     *\n     * @param {*} txn Opaque transaction object from cryptoStore.doTxn()\n     * @param {object} Olm.Account object\n     * @private\n     */\n    private storeAccount(txn: unknown, account: Account): void {\n        this.cryptoStore.storeAccount(txn, account.pickle(this.pickleKey));\n    }\n\n    /**\n     * Export data for re-creating the Olm device later.\n     * TODO export data other than just account and (P2P) sessions.\n     *\n     * @return {Promise<object>} The exported data\n     */\n    public async export(): Promise<IExportedDevice> {\n        const result: Partial<IExportedDevice> = {\n            pickleKey: this.pickleKey,\n        };\n\n        await this.cryptoStore.doTxn(\n            'readonly',\n            [\n                IndexedDBCryptoStore.STORE_ACCOUNT,\n                IndexedDBCryptoStore.STORE_SESSIONS,\n            ],\n            (txn) => {\n                this.cryptoStore.getAccount(txn, (pickledAccount: string) => {\n                    result.pickledAccount = pickledAccount;\n                });\n                result.sessions = [];\n                // Note that the pickledSession object we get in the callback\n                // is not exactly the same thing you get in method _getSession\n                // see documentation of IndexedDBCryptoStore.getAllEndToEndSessions\n                this.cryptoStore.getAllEndToEndSessions(txn, (pickledSession) => {\n                    result.sessions.push(pickledSession);\n                });\n            },\n        );\n        return result as IExportedDevice;\n    }\n\n    /**\n     * extract an OlmSession from the session store and call the given function\n     * The session is usable only within the callback passed to this\n     * function and will be freed as soon the callback returns. It is *not*\n     * usable for the rest of the lifetime of the transaction.\n     *\n     * @param {string} deviceKey\n     * @param {string} sessionId\n     * @param {*} txn Opaque transaction object from cryptoStore.doTxn()\n     * @param {function} func\n     * @private\n     */\n    private getSession(\n        deviceKey: string,\n        sessionId: string,\n        txn: unknown,\n        func: (unpickledSessionInfo: IUnpickledSessionInfo) => void,\n    ): void {\n        this.cryptoStore.getEndToEndSession(\n            deviceKey, sessionId, txn, (sessionInfo: ISessionInfo) => {\n                this.unpickleSession(sessionInfo, func);\n            },\n        );\n    }\n\n    /**\n     * Creates a session object from a session pickle and executes the given\n     * function with it. The session object is destroyed once the function\n     * returns.\n     *\n     * @param {object} sessionInfo\n     * @param {function} func\n     * @private\n     */\n    private unpickleSession(\n        sessionInfo: ISessionInfo,\n        func: (unpickledSessionInfo: IUnpickledSessionInfo) => void,\n    ): void {\n        const session = new global.Olm.Session();\n        try {\n            session.unpickle(this.pickleKey, sessionInfo.session);\n            const unpickledSessInfo: IUnpickledSessionInfo = Object.assign({}, sessionInfo, { session });\n\n            func(unpickledSessInfo);\n        } finally {\n            session.free();\n        }\n    }\n\n    /**\n     * store our OlmSession in the session store\n     *\n     * @param {string} deviceKey\n     * @param {object} sessionInfo {session: OlmSession, lastReceivedMessageTs: int}\n     * @param {*} txn Opaque transaction object from cryptoStore.doTxn()\n     * @private\n     */\n    private saveSession(deviceKey: string, sessionInfo: IUnpickledSessionInfo, txn: unknown): void {\n        const sessionId = sessionInfo.session.session_id();\n        const pickledSessionInfo = Object.assign(sessionInfo, {\n            session: sessionInfo.session.pickle(this.pickleKey),\n        });\n        this.cryptoStore.storeEndToEndSession(deviceKey, sessionId, pickledSessionInfo, txn);\n    }\n\n    /**\n     * get an OlmUtility and call the given function\n     *\n     * @param {function} func\n     * @return {object} result of func\n     * @private\n     */\n    private getUtility<T>(func: (utility: Utility) => T): T {\n        const utility = new global.Olm.Utility();\n        try {\n            return func(utility);\n        } finally {\n            utility.free();\n        }\n    }\n\n    /**\n     * Signs a message with the ed25519 key for this account.\n     *\n     * @param {string} message  message to be signed\n     * @return {Promise<string>} base64-encoded signature\n     */\n    public async sign(message: string): Promise<string> {\n        let result;\n        await this.cryptoStore.doTxn(\n            'readonly', [IndexedDBCryptoStore.STORE_ACCOUNT],\n            (txn) => {\n                this.getAccount(txn, (account: Account) => {\n                    result = account.sign(message);\n                });\n            });\n        return result;\n    }\n\n    /**\n     * Get the current (unused, unpublished) one-time keys for this account.\n     *\n     * @return {object} one time keys; an object with the single property\n     * <tt>curve25519</tt>, which is itself an object mapping key id to Curve25519\n     * key.\n     */\n    public async getOneTimeKeys(): Promise<{ curve25519: { [keyId: string]: string } }> {\n        let result;\n        await this.cryptoStore.doTxn(\n            'readonly', [IndexedDBCryptoStore.STORE_ACCOUNT],\n            (txn) => {\n                this.getAccount(txn, (account) => {\n                    result = JSON.parse(account.one_time_keys());\n                });\n            },\n        );\n\n        return result;\n    }\n\n    /**\n     * Get the maximum number of one-time keys we can store.\n     *\n     * @return {number} number of keys\n     */\n    public maxNumberOfOneTimeKeys(): number {\n        return this.maxOneTimeKeys;\n    }\n\n    /**\n     * Marks all of the one-time keys as published.\n     */\n    public async markKeysAsPublished(): Promise<void> {\n        await this.cryptoStore.doTxn(\n            'readwrite', [IndexedDBCryptoStore.STORE_ACCOUNT],\n            (txn) => {\n                this.getAccount(txn, (account: Account) => {\n                    account.mark_keys_as_published();\n                    this.storeAccount(txn, account);\n                });\n            },\n        );\n    }\n\n    /**\n     * Generate some new one-time keys\n     *\n     * @param {number} numKeys number of keys to generate\n     * @return {Promise} Resolved once the account is saved back having generated the keys\n     */\n    public generateOneTimeKeys(numKeys: number): Promise<void> {\n        return this.cryptoStore.doTxn(\n            'readwrite', [IndexedDBCryptoStore.STORE_ACCOUNT],\n            (txn) => {\n                this.getAccount(txn, (account) => {\n                    account.generate_one_time_keys(numKeys);\n                    this.storeAccount(txn, account);\n                });\n            },\n        );\n    }\n\n    /**\n     * Generate a new fallback keys\n     *\n     * @return {Promise} Resolved once the account is saved back having generated the key\n     */\n    public async generateFallbackKey(): Promise<void> {\n        await this.cryptoStore.doTxn(\n            'readwrite', [IndexedDBCryptoStore.STORE_ACCOUNT],\n            (txn) => {\n                this.getAccount(txn, (account) => {\n                    account.generate_fallback_key();\n                    this.storeAccount(txn, account);\n                });\n            },\n        );\n    }\n\n    public async getFallbackKey(): Promise<Record<string, Record<string, string>>> {\n        let result: Record<string, Record<string, string>>;\n        await this.cryptoStore.doTxn(\n            'readonly', [IndexedDBCryptoStore.STORE_ACCOUNT],\n            (txn) => {\n                this.getAccount(txn, (account: Account) => {\n                    result = JSON.parse(account.unpublished_fallback_key());\n                });\n            },\n        );\n        return result;\n    }\n\n    public async forgetOldFallbackKey(): Promise<void> {\n        await this.cryptoStore.doTxn(\n            'readwrite', [IndexedDBCryptoStore.STORE_ACCOUNT],\n            (txn) => {\n                this.getAccount(txn, (account: Account) => {\n                    account.forget_old_fallback_key();\n                    this.storeAccount(txn, account);\n                });\n            },\n        );\n    }\n\n    /**\n     * Generate a new outbound session\n     *\n     * The new session will be stored in the cryptoStore.\n     *\n     * @param {string} theirIdentityKey remote user's Curve25519 identity key\n     * @param {string} theirOneTimeKey  remote user's one-time Curve25519 key\n     * @return {string} sessionId for the outbound session.\n     */\n    public async createOutboundSession(theirIdentityKey: string, theirOneTimeKey: string): Promise<string> {\n        let newSessionId: string;\n        await this.cryptoStore.doTxn(\n            'readwrite', [\n                IndexedDBCryptoStore.STORE_ACCOUNT,\n                IndexedDBCryptoStore.STORE_SESSIONS,\n            ],\n            (txn) => {\n                this.getAccount(txn, (account: Account) => {\n                    const session = new global.Olm.Session();\n                    try {\n                        session.create_outbound(account, theirIdentityKey, theirOneTimeKey);\n                        newSessionId = session.session_id();\n                        this.storeAccount(txn, account);\n                        const sessionInfo: IUnpickledSessionInfo = {\n                            session,\n                            // Pretend we've received a message at this point, otherwise\n                            // if we try to send a message to the device, it won't use\n                            // this session\n                            lastReceivedMessageTs: Date.now(),\n                        };\n                        this.saveSession(theirIdentityKey, sessionInfo, txn);\n                    } finally {\n                        session.free();\n                    }\n                });\n            },\n            logger.withPrefix(\"[createOutboundSession]\"),\n        );\n        return newSessionId;\n    }\n\n    /**\n     * Generate a new inbound session, given an incoming message\n     *\n     * @param {string} theirDeviceIdentityKey remote user's Curve25519 identity key\n     * @param {number} messageType  messageType field from the received message (must be 0)\n     * @param {string} ciphertext base64-encoded body from the received message\n     *\n     * @return {{payload: string, session_id: string}} decrypted payload, and\n     *     session id of new session\n     *\n     * @raises {Error} if the received message was not valid (for instance, it\n     *     didn't use a valid one-time key).\n     */\n    public async createInboundSession(\n        theirDeviceIdentityKey: string,\n        messageType: number,\n        ciphertext: string,\n    ): Promise<IInboundSession> {\n        if (messageType !== 0) {\n            throw new Error(\"Need messageType == 0 to create inbound session\");\n        }\n\n        let result: { payload: string, session_id: string }; // eslint-disable-line camelcase\n        await this.cryptoStore.doTxn(\n            'readwrite', [\n                IndexedDBCryptoStore.STORE_ACCOUNT,\n                IndexedDBCryptoStore.STORE_SESSIONS,\n            ],\n            (txn) => {\n                this.getAccount(txn, (account: Account) => {\n                    const session = new global.Olm.Session();\n                    try {\n                        session.create_inbound_from(account, theirDeviceIdentityKey, ciphertext);\n                        account.remove_one_time_keys(session);\n                        this.storeAccount(txn, account);\n\n                        const payloadString = session.decrypt(messageType, ciphertext);\n\n                        const sessionInfo: IUnpickledSessionInfo = {\n                            session,\n                            // this counts as a received message: set last received message time\n                            // to now\n                            lastReceivedMessageTs: Date.now(),\n                        };\n                        this.saveSession(theirDeviceIdentityKey, sessionInfo, txn);\n\n                        result = {\n                            payload: payloadString,\n                            session_id: session.session_id(),\n                        };\n                    } finally {\n                        session.free();\n                    }\n                });\n            },\n            logger.withPrefix(\"[createInboundSession]\"),\n        );\n\n        return result;\n    }\n\n    /**\n     * Get a list of known session IDs for the given device\n     *\n     * @param {string} theirDeviceIdentityKey Curve25519 identity key for the\n     *     remote device\n     * @return {Promise<string[]>}  a list of known session ids for the device\n     */\n    public async getSessionIdsForDevice(theirDeviceIdentityKey: string): Promise<string[]> {\n        const log = logger.withPrefix(\"[getSessionIdsForDevice]\");\n\n        if (this.sessionsInProgress[theirDeviceIdentityKey]) {\n            log.debug(`Waiting for Olm session for ${theirDeviceIdentityKey} to be created`);\n            try {\n                await this.sessionsInProgress[theirDeviceIdentityKey];\n            } catch (e) {\n                // if the session failed to be created, just fall through and\n                // return an empty result\n            }\n        }\n        let sessionIds: string[];\n        await this.cryptoStore.doTxn(\n            'readonly', [IndexedDBCryptoStore.STORE_SESSIONS],\n            (txn) => {\n                this.cryptoStore.getEndToEndSessions(\n                    theirDeviceIdentityKey, txn, (sessions) => {\n                        sessionIds = Object.keys(sessions);\n                    },\n                );\n            },\n            log,\n        );\n\n        return sessionIds;\n    }\n\n    /**\n     * Get the right olm session id for encrypting messages to the given identity key\n     *\n     * @param {string} theirDeviceIdentityKey Curve25519 identity key for the\n     *     remote device\n     * @param {boolean} nowait Don't wait for an in-progress session to complete.\n     *     This should only be set to true of the calling function is the function\n     *     that marked the session as being in-progress.\n     * @param {Logger} [log] A possibly customised log\n     * @return {Promise<?string>}  session id, or null if no established session\n     */\n    public async getSessionIdForDevice(\n        theirDeviceIdentityKey: string,\n        nowait = false,\n        log?: Logger,\n    ): Promise<string | null> {\n        const sessionInfos = await this.getSessionInfoForDevice(theirDeviceIdentityKey, nowait, log);\n\n        if (sessionInfos.length === 0) {\n            return null;\n        }\n        // Use the session that has most recently received a message\n        let idxOfBest = 0;\n        for (let i = 1; i < sessionInfos.length; i++) {\n            const thisSessInfo = sessionInfos[i];\n            const thisLastReceived = thisSessInfo.lastReceivedMessageTs === undefined ?\n                0 : thisSessInfo.lastReceivedMessageTs;\n\n            const bestSessInfo = sessionInfos[idxOfBest];\n            const bestLastReceived = bestSessInfo.lastReceivedMessageTs === undefined ?\n                0 : bestSessInfo.lastReceivedMessageTs;\n            if (\n                thisLastReceived > bestLastReceived || (\n                    thisLastReceived === bestLastReceived &&\n                    thisSessInfo.sessionId < bestSessInfo.sessionId\n                )\n            ) {\n                idxOfBest = i;\n            }\n        }\n        return sessionInfos[idxOfBest].sessionId;\n    }\n\n    /**\n     * Get information on the active Olm sessions for a device.\n     * <p>\n     * Returns an array, with an entry for each active session. The first entry in\n     * the result will be the one used for outgoing messages. Each entry contains\n     * the keys 'hasReceivedMessage' (true if the session has received an incoming\n     * message and is therefore past the pre-key stage), and 'sessionId'.\n     *\n     * @param {string} deviceIdentityKey Curve25519 identity key for the device\n     * @param {boolean} nowait Don't wait for an in-progress session to complete.\n     *     This should only be set to true of the calling function is the function\n     *     that marked the session as being in-progress.\n     * @param {Logger} [log] A possibly customised log\n     * @return {Array.<{sessionId: string, hasReceivedMessage: boolean}>}\n     */\n    public async getSessionInfoForDevice(\n        deviceIdentityKey: string,\n        nowait = false,\n        log = logger,\n    ): Promise<{ sessionId: string, lastReceivedMessageTs: number, hasReceivedMessage: boolean }[]> {\n        log = log.withPrefix(\"[getSessionInfoForDevice]\");\n\n        if (this.sessionsInProgress[deviceIdentityKey] && !nowait) {\n            log.debug(`Waiting for Olm session for ${deviceIdentityKey} to be created`);\n            try {\n                await this.sessionsInProgress[deviceIdentityKey];\n            } catch (e) {\n                // if the session failed to be created, then just fall through and\n                // return an empty result\n            }\n        }\n        const info = [];\n\n        await this.cryptoStore.doTxn(\n            'readonly', [IndexedDBCryptoStore.STORE_SESSIONS],\n            (txn) => {\n                this.cryptoStore.getEndToEndSessions(deviceIdentityKey, txn, (sessions) => {\n                    const sessionIds = Object.keys(sessions).sort();\n                    for (const sessionId of sessionIds) {\n                        this.unpickleSession(sessions[sessionId], (sessInfo: IUnpickledSessionInfo) => {\n                            info.push({\n                                lastReceivedMessageTs: sessInfo.lastReceivedMessageTs,\n                                hasReceivedMessage: sessInfo.session.has_received_message(),\n                                sessionId: sessionId,\n                            });\n                        });\n                    }\n                });\n            },\n            log,\n        );\n\n        return info;\n    }\n\n    /**\n     * Encrypt an outgoing message using an existing session\n     *\n     * @param {string} theirDeviceIdentityKey Curve25519 identity key for the\n     *     remote device\n     * @param {string} sessionId  the id of the active session\n     * @param {string} payloadString  payload to be encrypted and sent\n     *\n     * @return {Promise<string>} ciphertext\n     */\n    public async encryptMessage(\n        theirDeviceIdentityKey: string,\n        sessionId: string,\n        payloadString: string,\n    ): Promise<string> {\n        checkPayloadLength(payloadString);\n\n        let res;\n        await this.cryptoStore.doTxn(\n            'readwrite', [IndexedDBCryptoStore.STORE_SESSIONS],\n            (txn) => {\n                this.getSession(theirDeviceIdentityKey, sessionId, txn, (sessionInfo) => {\n                    const sessionDesc = sessionInfo.session.describe();\n                    logger.log(\n                        \"encryptMessage: Olm Session ID \" + sessionId + \" to \" +\n                        theirDeviceIdentityKey + \": \" + sessionDesc,\n                    );\n                    res = sessionInfo.session.encrypt(payloadString);\n                    this.saveSession(theirDeviceIdentityKey, sessionInfo, txn);\n                });\n            },\n            logger.withPrefix(\"[encryptMessage]\"),\n        );\n        return res;\n    }\n\n    /**\n     * Decrypt an incoming message using an existing session\n     *\n     * @param {string} theirDeviceIdentityKey Curve25519 identity key for the\n     *     remote device\n     * @param {string} sessionId  the id of the active session\n     * @param {number} messageType  messageType field from the received message\n     * @param {string} ciphertext base64-encoded body from the received message\n     *\n     * @return {Promise<string>} decrypted payload.\n     */\n    public async decryptMessage(\n        theirDeviceIdentityKey: string,\n        sessionId: string,\n        messageType: number,\n        ciphertext: string,\n    ): Promise<string> {\n        let payloadString;\n        await this.cryptoStore.doTxn(\n            'readwrite', [IndexedDBCryptoStore.STORE_SESSIONS],\n            (txn) => {\n                this.getSession(theirDeviceIdentityKey, sessionId, txn, (sessionInfo: IUnpickledSessionInfo) => {\n                    const sessionDesc = sessionInfo.session.describe();\n                    logger.log(\n                        \"decryptMessage: Olm Session ID \" + sessionId + \" from \" +\n                        theirDeviceIdentityKey + \": \" + sessionDesc,\n                    );\n                    payloadString = sessionInfo.session.decrypt(messageType, ciphertext);\n                    sessionInfo.lastReceivedMessageTs = Date.now();\n                    this.saveSession(theirDeviceIdentityKey, sessionInfo, txn);\n                });\n            },\n            logger.withPrefix(\"[decryptMessage]\"),\n        );\n        return payloadString;\n    }\n\n    /**\n     * Determine if an incoming messages is a prekey message matching an existing session\n     *\n     * @param {string} theirDeviceIdentityKey Curve25519 identity key for the\n     *     remote device\n     * @param {string} sessionId  the id of the active session\n     * @param {number} messageType  messageType field from the received message\n     * @param {string} ciphertext base64-encoded body from the received message\n     *\n     * @return {Promise<boolean>} true if the received message is a prekey message which matches\n     *    the given session.\n     */\n    public async matchesSession(\n        theirDeviceIdentityKey: string,\n        sessionId: string,\n        messageType: number,\n        ciphertext: string,\n    ): Promise<boolean> {\n        if (messageType !== 0) {\n            return false;\n        }\n\n        let matches;\n        await this.cryptoStore.doTxn(\n            'readonly', [IndexedDBCryptoStore.STORE_SESSIONS],\n            (txn) => {\n                this.getSession(theirDeviceIdentityKey, sessionId, txn, (sessionInfo) => {\n                    matches = sessionInfo.session.matches_inbound(ciphertext);\n                });\n            },\n            logger.withPrefix(\"[matchesSession]\"),\n        );\n        return matches;\n    }\n\n    public async recordSessionProblem(deviceKey: string, type: string, fixed: boolean): Promise<void> {\n        await this.cryptoStore.storeEndToEndSessionProblem(deviceKey, type, fixed);\n    }\n\n    public sessionMayHaveProblems(deviceKey: string, timestamp: number): Promise<IProblem> {\n        return this.cryptoStore.getEndToEndSessionProblem(deviceKey, timestamp);\n    }\n\n    public filterOutNotifiedErrorDevices(devices: IOlmDevice[]): Promise<IOlmDevice[]> {\n        return this.cryptoStore.filterOutNotifiedErrorDevices(devices);\n    }\n\n    // Outbound group session\n    // ======================\n\n    /**\n     * store an OutboundGroupSession in outboundGroupSessionStore\n     *\n     * @param {Olm.OutboundGroupSession} session\n     * @private\n     */\n    private saveOutboundGroupSession(session: OutboundGroupSession): void {\n        this.outboundGroupSessionStore[session.session_id()] = session.pickle(this.pickleKey);\n    }\n\n    /**\n     * extract an OutboundGroupSession from outboundGroupSessionStore and call the\n     * given function\n     *\n     * @param {string} sessionId\n     * @param {function} func\n     * @return {object} result of func\n     * @private\n     */\n    private getOutboundGroupSession<T>(sessionId: string, func: (session: OutboundGroupSession) => T): T {\n        const pickled = this.outboundGroupSessionStore[sessionId];\n        if (pickled === undefined) {\n            throw new Error(\"Unknown outbound group session \" + sessionId);\n        }\n\n        const session = new global.Olm.OutboundGroupSession();\n        try {\n            session.unpickle(this.pickleKey, pickled);\n            return func(session);\n        } finally {\n            session.free();\n        }\n    }\n\n    /**\n     * Generate a new outbound group session\n     *\n     * @return {string} sessionId for the outbound session.\n     */\n    public createOutboundGroupSession(): string {\n        const session = new global.Olm.OutboundGroupSession();\n        try {\n            session.create();\n            this.saveOutboundGroupSession(session);\n            return session.session_id();\n        } finally {\n            session.free();\n        }\n    }\n\n    /**\n     * Encrypt an outgoing message with an outbound group session\n     *\n     * @param {string} sessionId  the id of the outboundgroupsession\n     * @param {string} payloadString  payload to be encrypted and sent\n     *\n     * @return {string} ciphertext\n     */\n    public encryptGroupMessage(sessionId: string, payloadString: string): string {\n        logger.log(`encrypting msg with megolm session ${sessionId}`);\n\n        checkPayloadLength(payloadString);\n\n        return this.getOutboundGroupSession(sessionId, (session: OutboundGroupSession) => {\n            const res = session.encrypt(payloadString);\n            this.saveOutboundGroupSession(session);\n            return res;\n        });\n    }\n\n    /**\n     * Get the session keys for an outbound group session\n     *\n     * @param {string} sessionId  the id of the outbound group session\n     *\n     * @return {{chain_index: number, key: string}} current chain index, and\n     *     base64-encoded secret key.\n     */\n    public getOutboundGroupSessionKey(sessionId: string): IOutboundGroupSessionKey {\n        return this.getOutboundGroupSession(sessionId, function(session: OutboundGroupSession) {\n            return {\n                chain_index: session.message_index(),\n                key: session.session_key(),\n            };\n        });\n    }\n\n    // Inbound group session\n    // =====================\n\n    /**\n     * Unpickle a session from a sessionData object and invoke the given function.\n     * The session is valid only until func returns.\n     *\n     * @param {Object} sessionData Object describing the session.\n     * @param {function(Olm.InboundGroupSession)} func Invoked with the unpickled session\n     * @return {*} result of func\n     */\n    private unpickleInboundGroupSession<T>(\n        sessionData: InboundGroupSessionData,\n        func: (session: InboundGroupSession) => T,\n    ): T {\n        const session = new global.Olm.InboundGroupSession();\n        try {\n            session.unpickle(this.pickleKey, sessionData.session);\n            return func(session);\n        } finally {\n            session.free();\n        }\n    }\n\n    /**\n     * extract an InboundGroupSession from the crypto store and call the given function\n     *\n     * @param {string} roomId The room ID to extract the session for, or null to fetch\n     *     sessions for any room.\n     * @param {string} senderKey\n     * @param {string} sessionId\n     * @param {*} txn Opaque transaction object from cryptoStore.doTxn()\n     * @param {function(Olm.InboundGroupSession, InboundGroupSessionData)} func\n     *   function to call.\n     *\n     * @private\n     */\n    private getInboundGroupSession(\n        roomId: string,\n        senderKey: string,\n        sessionId: string,\n        txn: unknown,\n        func: (session: InboundGroupSession, data: InboundGroupSessionData, withheld?: IWithheld) => void,\n    ): void {\n        this.cryptoStore.getEndToEndInboundGroupSession(\n            senderKey, sessionId, txn, (sessionData: InboundGroupSessionData, withheld: IWithheld | null) => {\n                if (sessionData === null) {\n                    func(null, null, withheld);\n                    return;\n                }\n\n                // if we were given a room ID, check that the it matches the original one for the session. This stops\n                // the HS pretending a message was targeting a different room.\n                if (roomId !== null && roomId !== sessionData.room_id) {\n                    throw new Error(\n                        \"Mismatched room_id for inbound group session (expected \" +\n                        sessionData.room_id + \", was \" + roomId + \")\",\n                    );\n                }\n\n                this.unpickleInboundGroupSession(sessionData, (session: InboundGroupSession) => {\n                    func(session, sessionData, withheld);\n                });\n            },\n        );\n    }\n\n    /**\n     * Add an inbound group session to the session store\n     *\n     * @param {string} roomId     room in which this session will be used\n     * @param {string} senderKey  base64-encoded curve25519 key of the sender\n     * @param {Array<string>} forwardingCurve25519KeyChain  Devices involved in forwarding\n     *     this session to us.\n     * @param {string} sessionId  session identifier\n     * @param {string} sessionKey base64-encoded secret key\n     * @param {Object<string, string>} keysClaimed Other keys the sender claims.\n     * @param {boolean} exportFormat true if the megolm keys are in export format\n     *    (ie, they lack an ed25519 signature)\n     * @param {Object} [extraSessionData={}] any other data to be include with the session\n     */\n    public async addInboundGroupSession(\n        roomId: string,\n        senderKey: string,\n        forwardingCurve25519KeyChain: string[],\n        sessionId: string,\n        sessionKey: string,\n        keysClaimed: Record<string, string>,\n        exportFormat: boolean,\n        extraSessionData: Record<string, any> = {},\n    ): Promise<void> {\n        await this.cryptoStore.doTxn(\n            'readwrite', [\n                IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS,\n                IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS_WITHHELD,\n                IndexedDBCryptoStore.STORE_SHARED_HISTORY_INBOUND_GROUP_SESSIONS,\n            ], (txn) => {\n                /* if we already have this session, consider updating it */\n                this.getInboundGroupSession(\n                    roomId, senderKey, sessionId, txn,\n                    (existingSession: InboundGroupSession, existingSessionData: InboundGroupSessionData) => {\n                        // new session.\n                        const session = new global.Olm.InboundGroupSession();\n                        try {\n                            if (exportFormat) {\n                                session.import_session(sessionKey);\n                            } else {\n                                session.create(sessionKey);\n                            }\n                            if (sessionId != session.session_id()) {\n                                throw new Error(\n                                    \"Mismatched group session ID from senderKey: \" +\n                                    senderKey,\n                                );\n                            }\n\n                            if (existingSession) {\n                                logger.log(\n                                    \"Update for megolm session \"\n                                    + senderKey + \"/\" + sessionId,\n                                );\n                                if (existingSession.first_known_index()\n                                    <= session.first_known_index()\n                                    && !(existingSession.first_known_index() == session.first_known_index()\n                                        && !extraSessionData.untrusted\n                                        && existingSessionData.untrusted)) {\n                                    // existing session has lower index (i.e. can\n                                    // decrypt more), or they have the same index and\n                                    // the new sessions trust does not win over the old\n                                    // sessions trust, so keep it\n                                    logger.log(`Keeping existing megolm session ${sessionId}`);\n                                    return;\n                                }\n                            }\n\n                            logger.info(\n                                \"Storing megolm session \" + senderKey + \"/\" + sessionId +\n                                \" with first index \" + session.first_known_index(),\n                            );\n\n                            const sessionData = Object.assign({}, extraSessionData, {\n                                room_id: roomId,\n                                session: session.pickle(this.pickleKey),\n                                keysClaimed: keysClaimed,\n                                forwardingCurve25519KeyChain: forwardingCurve25519KeyChain,\n                            });\n\n                            this.cryptoStore.storeEndToEndInboundGroupSession(\n                                senderKey, sessionId, sessionData, txn,\n                            );\n\n                            if (!existingSession && extraSessionData.sharedHistory) {\n                                this.cryptoStore.addSharedHistoryInboundGroupSession(\n                                    roomId, senderKey, sessionId, txn,\n                                );\n                            }\n                        } finally {\n                            session.free();\n                        }\n                    },\n                );\n            },\n            logger.withPrefix(\"[addInboundGroupSession]\"),\n        );\n    }\n\n    /**\n     * Record in the data store why an inbound group session was withheld.\n     *\n     * @param {string} roomId     room that the session belongs to\n     * @param {string} senderKey  base64-encoded curve25519 key of the sender\n     * @param {string} sessionId  session identifier\n     * @param {string} code       reason code\n     * @param {string} reason     human-readable version of `code`\n     */\n    public async addInboundGroupSessionWithheld(\n        roomId: string,\n        senderKey: string,\n        sessionId: string,\n        code: string,\n        reason: string,\n    ): Promise<void> {\n        await this.cryptoStore.doTxn(\n            'readwrite', [IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS_WITHHELD],\n            (txn) => {\n                this.cryptoStore.storeEndToEndInboundGroupSessionWithheld(\n                    senderKey, sessionId,\n                    {\n                        room_id: roomId,\n                        code: code,\n                        reason: reason,\n                    },\n                    txn,\n                );\n            },\n        );\n    }\n\n    /**\n     * Decrypt a received message with an inbound group session\n     *\n     * @param {string} roomId    room in which the message was received\n     * @param {string} senderKey base64-encoded curve25519 key of the sender\n     * @param {string} sessionId session identifier\n     * @param {string} body      base64-encoded body of the encrypted message\n     * @param {string} eventId   ID of the event being decrypted\n     * @param {Number} timestamp timestamp of the event being decrypted\n     *\n     * @return {null} the sessionId is unknown\n     *\n     * @return {Promise<{result: string, senderKey: string,\n     *    forwardingCurve25519KeyChain: Array<string>,\n     *    keysClaimed: Object<string, string>}>}\n     */\n    public async decryptGroupMessage(\n        roomId: string,\n        senderKey: string,\n        sessionId: string,\n        body: string,\n        eventId: string,\n        timestamp: number,\n    ): Promise<IDecryptedGroupMessage | null> {\n        let result: IDecryptedGroupMessage;\n        // when the localstorage crypto store is used as an indexeddb backend,\n        // exceptions thrown from within the inner function are not passed through\n        // to the top level, so we store exceptions in a variable and raise them at\n        // the end\n        let error: Error;\n\n        await this.cryptoStore.doTxn(\n            'readwrite', [\n                IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS,\n                IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS_WITHHELD,\n            ], (txn) => {\n                this.getInboundGroupSession(\n                    roomId, senderKey, sessionId, txn, (session, sessionData, withheld) => {\n                        if (session === null) {\n                            if (withheld) {\n                                error = new algorithms.DecryptionError(\n                                    \"MEGOLM_UNKNOWN_INBOUND_SESSION_ID\",\n                                    calculateWithheldMessage(withheld),\n                                    {\n                                        session: senderKey + '|' + sessionId,\n                                    },\n                                );\n                            }\n                            result = null;\n                            return;\n                        }\n                        let res;\n                        try {\n                            res = session.decrypt(body);\n                        } catch (e) {\n                            if (e && e.message === 'OLM.UNKNOWN_MESSAGE_INDEX' && withheld) {\n                                error = new algorithms.DecryptionError(\n                                    \"MEGOLM_UNKNOWN_INBOUND_SESSION_ID\",\n                                    calculateWithheldMessage(withheld),\n                                    {\n                                        session: senderKey + '|' + sessionId,\n                                    },\n                                );\n                            } else {\n                                error = e;\n                            }\n                            return;\n                        }\n\n                        let plaintext: string = res.plaintext;\n                        if (plaintext === undefined) {\n                            // Compatibility for older olm versions.\n                            plaintext = res;\n                        } else {\n                            // Check if we have seen this message index before to detect replay attacks.\n                            // If the event ID and timestamp are specified, and the match the event ID\n                            // and timestamp from the last time we used this message index, then we\n                            // don't consider it a replay attack.\n                            const messageIndexKey = (\n                                senderKey + \"|\" + sessionId + \"|\" + res.message_index\n                            );\n                            if (messageIndexKey in this.inboundGroupSessionMessageIndexes) {\n                                const msgInfo = (\n                                    this.inboundGroupSessionMessageIndexes[messageIndexKey]\n                                );\n                                if (\n                                    msgInfo.id !== eventId ||\n                                    msgInfo.timestamp !== timestamp\n                                ) {\n                                    error = new Error(\n                                        \"Duplicate message index, possible replay attack: \" +\n                                        messageIndexKey,\n                                    );\n                                    return;\n                                }\n                            }\n                            this.inboundGroupSessionMessageIndexes[messageIndexKey] = {\n                                id: eventId,\n                                timestamp: timestamp,\n                            };\n                        }\n\n                        sessionData.session = session.pickle(this.pickleKey);\n                        this.cryptoStore.storeEndToEndInboundGroupSession(\n                            senderKey, sessionId, sessionData, txn,\n                        );\n                        result = {\n                            result: plaintext,\n                            keysClaimed: sessionData.keysClaimed || {},\n                            senderKey: senderKey,\n                            forwardingCurve25519KeyChain: (\n                                sessionData.forwardingCurve25519KeyChain || []\n                            ),\n                            untrusted: sessionData.untrusted,\n                        };\n                    },\n                );\n            },\n            logger.withPrefix(\"[decryptGroupMessage]\"),\n        );\n\n        if (error) {\n            throw error;\n        }\n        return result;\n    }\n\n    /**\n     * Determine if we have the keys for a given megolm session\n     *\n     * @param {string} roomId    room in which the message was received\n     * @param {string} senderKey base64-encoded curve25519 key of the sender\n     * @param {string} sessionId session identifier\n     *\n     * @returns {Promise<boolean>} true if we have the keys to this session\n     */\n    public async hasInboundSessionKeys(roomId: string, senderKey: string, sessionId: string): Promise<boolean> {\n        let result: boolean;\n        await this.cryptoStore.doTxn(\n            'readonly', [\n                IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS,\n                IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS_WITHHELD,\n            ], (txn) => {\n                this.cryptoStore.getEndToEndInboundGroupSession(\n                    senderKey, sessionId, txn, (sessionData) => {\n                        if (sessionData === null) {\n                            result = false;\n                            return;\n                        }\n\n                        if (roomId !== sessionData.room_id) {\n                            logger.warn(\n                                `requested keys for inbound group session ${senderKey}|` +\n                                `${sessionId}, with incorrect room_id ` +\n                                `(expected ${sessionData.room_id}, ` +\n                                `was ${roomId})`,\n                            );\n                            result = false;\n                        } else {\n                            result = true;\n                        }\n                    },\n                );\n            },\n            logger.withPrefix(\"[hasInboundSessionKeys]\"),\n        );\n\n        return result;\n    }\n\n    /**\n     * Extract the keys to a given megolm session, for sharing\n     *\n     * @param {string} roomId    room in which the message was received\n     * @param {string} senderKey base64-encoded curve25519 key of the sender\n     * @param {string} sessionId session identifier\n     * @param {number} chainIndex The chain index at which to export the session.\n     *     If omitted, export at the first index we know about.\n     *\n     * @returns {Promise<{chain_index: number, key: string,\n     *        forwarding_curve25519_key_chain: Array<string>,\n     *        sender_claimed_ed25519_key: string\n     *    }>}\n     *    details of the session key. The key is a base64-encoded megolm key in\n     *    export format.\n     *\n     * @throws Error If the given chain index could not be obtained from the known\n     *     index (ie. the given chain index is before the first we have).\n     */\n    public async getInboundGroupSessionKey(\n        roomId: string,\n        senderKey: string,\n        sessionId: string,\n        chainIndex?: number,\n    ): Promise<IInboundGroupSessionKey> {\n        let result: IInboundGroupSessionKey;\n        await this.cryptoStore.doTxn(\n            'readonly', [\n                IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS,\n                IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS_WITHHELD,\n            ], (txn) => {\n                this.getInboundGroupSession(\n                    roomId, senderKey, sessionId, txn, (session, sessionData) => {\n                        if (session === null) {\n                            result = null;\n                            return;\n                        }\n\n                        if (chainIndex === undefined) {\n                            chainIndex = session.first_known_index();\n                        }\n\n                        const exportedSession = session.export_session(chainIndex);\n\n                        const claimedKeys = sessionData.keysClaimed || {};\n                        const senderEd25519Key = claimedKeys.ed25519 || null;\n\n                        result = {\n                            \"chain_index\": chainIndex,\n                            \"key\": exportedSession,\n                            \"forwarding_curve25519_key_chain\":\n                                sessionData.forwardingCurve25519KeyChain || [],\n                            \"sender_claimed_ed25519_key\": senderEd25519Key,\n                            \"shared_history\": sessionData.sharedHistory || false,\n                        };\n                    },\n                );\n            },\n            logger.withPrefix(\"[getInboundGroupSessionKey]\"),\n        );\n\n        return result;\n    }\n\n    /**\n     * Export an inbound group session\n     *\n     * @param {string} senderKey base64-encoded curve25519 key of the sender\n     * @param {string} sessionId session identifier\n     * @param {ISessionInfo} sessionData The session object from the store\n     * @return {module:crypto/OlmDevice.MegolmSessionData} exported session data\n     */\n    public exportInboundGroupSession(\n        senderKey: string,\n        sessionId: string,\n        sessionData: InboundGroupSessionData,\n    ): IMegolmSessionData {\n        return this.unpickleInboundGroupSession(sessionData, (session) => {\n            const messageIndex = session.first_known_index();\n\n            return {\n                \"sender_key\": senderKey,\n                \"sender_claimed_keys\": sessionData.keysClaimed,\n                \"room_id\": sessionData.room_id,\n                \"session_id\": sessionId,\n                \"session_key\": session.export_session(messageIndex),\n                \"forwarding_curve25519_key_chain\": sessionData.forwardingCurve25519KeyChain || [],\n                \"first_known_index\": session.first_known_index(),\n                \"org.matrix.msc3061.shared_history\": sessionData.sharedHistory || false,\n            } as IMegolmSessionData;\n        });\n    }\n\n    async getSharedHistoryInboundGroupSessions(roomId: string): Promise<[senderKey: string, sessionId: string][]> {\n        let result: Promise<[senderKey: string, sessionId: string][]>;\n        await this.cryptoStore.doTxn(\n            'readonly', [\n                IndexedDBCryptoStore.STORE_SHARED_HISTORY_INBOUND_GROUP_SESSIONS,\n            ], (txn) => {\n                result = this.cryptoStore.getSharedHistoryInboundGroupSessions(roomId, txn);\n            },\n            logger.withPrefix(\"[getSharedHistoryInboundGroupSessionsForRoom]\"),\n        );\n        return result;\n    }\n\n    // Utilities\n    // =========\n\n    /**\n     * Verify an ed25519 signature.\n     *\n     * @param {string} key ed25519 key\n     * @param {string} message message which was signed\n     * @param {string} signature base64-encoded signature to be checked\n     *\n     * @raises {Error} if there is a problem with the verification. If the key was\n     * too small then the message will be \"OLM.INVALID_BASE64\". If the signature\n     * was invalid then the message will be \"OLM.BAD_MESSAGE_MAC\".\n     */\n    public verifySignature(\n        key: string,\n        message: string,\n        signature: string,\n    ): void {\n        this.getUtility(function(util: Utility) {\n            util.ed25519_verify(key, message, signature);\n        });\n    }\n}\n\nexport const WITHHELD_MESSAGES = {\n    \"m.unverified\": \"The sender has disabled encrypting to unverified devices.\",\n    \"m.blacklisted\": \"The sender has blocked you.\",\n    \"m.unauthorised\": \"You are not authorised to read the message.\",\n    \"m.no_olm\": \"Unable to establish a secure channel.\",\n};\n\n/**\n * Calculate the message to use for the exception when a session key is withheld.\n *\n * @param {object} withheld  An object that describes why the key was withheld.\n *\n * @return {string} the message\n *\n * @private\n */\nfunction calculateWithheldMessage(withheld: IWithheld): string {\n    if (withheld.code && withheld.code in WITHHELD_MESSAGES) {\n        return WITHHELD_MESSAGES[withheld.code];\n    } else if (withheld.reason) {\n        return withheld.reason;\n    } else {\n        return \"decryption key withheld\";\n    }\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2022-39250", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "/*\nCopyright 2015 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Defines m.olm encryption/decryption\n *\n * @module crypto/algorithms/megolm\n */\n\nimport { logger } from '../../logger';\nimport * as olmlib from \"../olmlib\";\nimport {\n    DecryptionAlgorithm,\n    DecryptionError,\n    EncryptionAlgorithm,\n    IParams,\n    registerAlgorithm,\n    UnknownDeviceError,\n} from \"./base\";\nimport { IDecryptedGroupMessage, WITHHELD_MESSAGES } from '../OlmDevice';\nimport { Room } from '../../models/room';\nimport { DeviceInfo } from \"../deviceinfo\";\nimport { IOlmSessionResult } from \"../olmlib\";\nimport { DeviceInfoMap } from \"../DeviceList\";\nimport { MatrixEvent } from \"../..\";\nimport { IEventDecryptionResult, IMegolmSessionData, IncomingRoomKeyRequest } from \"../index\";\n\n// determine whether the key can be shared with invitees\nexport function isRoomSharedHistory(room: Room): boolean {\n    const visibilityEvent = room?.currentState?.getStateEvents(\"m.room.history_visibility\", \"\");\n    // NOTE: if the room visibility is unset, it would normally default to\n    // \"world_readable\".\n    // (https://spec.matrix.org/unstable/client-server-api/#server-behaviour-5)\n    // But we will be paranoid here, and treat it as a situation where the room\n    // is not shared-history\n    const visibility = visibilityEvent?.getContent()?.history_visibility;\n    return [\"world_readable\", \"shared\"].includes(visibility);\n}\n\ninterface IBlockedDevice {\n    code: string;\n    reason: string;\n    deviceInfo: DeviceInfo;\n}\n\ninterface IBlockedMap {\n    [userId: string]: {\n        [deviceId: string]: IBlockedDevice;\n    };\n}\n\nexport interface IOlmDevice<T = DeviceInfo> {\n    userId: string;\n    deviceInfo: T;\n}\n\n/* eslint-disable camelcase */\nexport interface IOutboundGroupSessionKey {\n    chain_index: number;\n    key: string;\n}\n\ninterface IMessage {\n    type: string;\n    content: {\n        algorithm: string;\n        room_id: string;\n        sender_key?: string;\n        sender_claimed_ed25519_key?: string;\n        session_id: string;\n        session_key: string;\n        chain_index: number;\n        forwarding_curve25519_key_chain?: string[];\n        \"org.matrix.msc3061.shared_history\": boolean;\n    };\n}\n\ninterface IKeyForwardingMessage extends IMessage {\n    type: \"m.forwarded_room_key\";\n}\n\ninterface IPayload extends Partial<IMessage> {\n    code?: string;\n    reason?: string;\n    room_id?: string;\n    session_id?: string;\n    algorithm?: string;\n    sender_key?: string;\n}\n\ninterface IEncryptedContent {\n    algorithm: string;\n    sender_key: string;\n    ciphertext: Record<string, string>;\n}\n/* eslint-enable camelcase */\n\ninterface SharedWithData {\n    // The identity key of the device we shared with\n    deviceKey: string;\n    // The message index of the ratchet we shared with that device\n    messageIndex: number;\n}\n\n/**\n * @private\n * @constructor\n *\n * @param {string} sessionId\n * @param {boolean} sharedHistory whether the session can be freely shared with\n *    other group members, according to the room history visibility settings\n *\n * @property {string} sessionId\n * @property {Number} useCount     number of times this session has been used\n * @property {Number} creationTime when the session was created (ms since the epoch)\n *\n * @property {object} sharedWithDevices\n *    devices with which we have shared the session key\n *        userId -> {deviceId -> SharedWithData}\n */\nclass OutboundSessionInfo {\n    public useCount = 0;\n    public creationTime: number;\n    public sharedWithDevices: Record<string, Record<string, SharedWithData>> = {};\n    public blockedDevicesNotified: Record<string, Record<string, boolean>> = {};\n\n    constructor(public readonly sessionId: string, public readonly sharedHistory = false) {\n        this.creationTime = new Date().getTime();\n    }\n\n    /**\n     * Check if it's time to rotate the session\n     *\n     * @param {Number} rotationPeriodMsgs\n     * @param {Number} rotationPeriodMs\n     * @return {Boolean}\n     */\n    public needsRotation(rotationPeriodMsgs: number, rotationPeriodMs: number): boolean {\n        const sessionLifetime = new Date().getTime() - this.creationTime;\n\n        if (this.useCount >= rotationPeriodMsgs ||\n            sessionLifetime >= rotationPeriodMs\n        ) {\n            logger.log(\n                \"Rotating megolm session after \" + this.useCount +\n                \" messages, \" + sessionLifetime + \"ms\",\n            );\n            return true;\n        }\n\n        return false;\n    }\n\n    public markSharedWithDevice(userId: string, deviceId: string, deviceKey: string, chainIndex: number): void {\n        if (!this.sharedWithDevices[userId]) {\n            this.sharedWithDevices[userId] = {};\n        }\n        this.sharedWithDevices[userId][deviceId] = { deviceKey, messageIndex: chainIndex };\n    }\n\n    public markNotifiedBlockedDevice(userId: string, deviceId: string): void {\n        if (!this.blockedDevicesNotified[userId]) {\n            this.blockedDevicesNotified[userId] = {};\n        }\n        this.blockedDevicesNotified[userId][deviceId] = true;\n    }\n\n    /**\n     * Determine if this session has been shared with devices which it shouldn't\n     * have been.\n     *\n     * @param {Object} devicesInRoom userId -> {deviceId -> object}\n     *   devices we should shared the session with.\n     *\n     * @return {Boolean} true if we have shared the session with devices which aren't\n     * in devicesInRoom.\n     */\n    public sharedWithTooManyDevices(devicesInRoom: Record<string, Record<string, object>>): boolean {\n        for (const userId in this.sharedWithDevices) {\n            if (!this.sharedWithDevices.hasOwnProperty(userId)) {\n                continue;\n            }\n\n            if (!devicesInRoom.hasOwnProperty(userId)) {\n                logger.log(\"Starting new megolm session because we shared with \" + userId);\n                return true;\n            }\n\n            for (const deviceId in this.sharedWithDevices[userId]) {\n                if (!this.sharedWithDevices[userId].hasOwnProperty(deviceId)) {\n                    continue;\n                }\n\n                if (!devicesInRoom[userId].hasOwnProperty(deviceId)) {\n                    logger.log(\n                        \"Starting new megolm session because we shared with \" +\n                        userId + \":\" + deviceId,\n                    );\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n}\n\n/**\n * Megolm encryption implementation\n *\n * @constructor\n * @extends {module:crypto/algorithms/EncryptionAlgorithm}\n *\n * @param {object} params parameters, as per\n *     {@link module:crypto/algorithms/EncryptionAlgorithm}\n */\nclass MegolmEncryption extends EncryptionAlgorithm {\n    // the most recent attempt to set up a session. This is used to serialise\n    // the session setups, so that we have a race-free view of which session we\n    // are using, and which devices we have shared the keys with. It resolves\n    // with an OutboundSessionInfo (or undefined, for the first message in the\n    // room).\n    private setupPromise = Promise.resolve<OutboundSessionInfo | null>(null);\n\n    // Map of outbound sessions by sessions ID. Used if we need a particular\n    // session (the session we're currently using to send is always obtained\n    // using setupPromise).\n    private outboundSessions: Record<string, OutboundSessionInfo> = {};\n\n    private readonly sessionRotationPeriodMsgs: number;\n    private readonly sessionRotationPeriodMs: number;\n    private encryptionPreparation?: {\n        promise: Promise<void>;\n        startTime: number;\n    };\n\n    constructor(params: IParams) {\n        super(params);\n\n        this.sessionRotationPeriodMsgs = params.config?.rotation_period_msgs ?? 100;\n        this.sessionRotationPeriodMs = params.config?.rotation_period_ms ?? 7 * 24 * 3600 * 1000;\n    }\n\n    /**\n     * @private\n     *\n     * @param {module:models/room} room\n     * @param {Object} devicesInRoom The devices in this room, indexed by user ID\n     * @param {Object} blocked The devices that are blocked, indexed by user ID\n     * @param {boolean} [singleOlmCreationPhase] Only perform one round of olm\n     *     session creation\n     *\n     * @return {Promise} Promise which resolves to the\n     *    OutboundSessionInfo when setup is complete.\n     */\n    private async ensureOutboundSession(\n        room: Room,\n        devicesInRoom: DeviceInfoMap,\n        blocked: IBlockedMap,\n        singleOlmCreationPhase = false,\n    ): Promise<OutboundSessionInfo> {\n        // takes the previous OutboundSessionInfo, and considers whether to create\n        // a new one. Also shares the key with any (new) devices in the room.\n        //\n        // Returns the successful session whether keyshare succeeds or not.\n        //\n        // returns a promise which resolves once the keyshare is successful.\n        const setup = async (oldSession: OutboundSessionInfo | null): Promise<OutboundSessionInfo> => {\n            const sharedHistory = isRoomSharedHistory(room);\n\n            const session = await this.prepareSession(devicesInRoom, sharedHistory, oldSession);\n\n            try {\n                await this.shareSession(devicesInRoom, sharedHistory, singleOlmCreationPhase, blocked, session);\n            } catch (e) {\n                logger.error(`Failed to ensure outbound session in ${this.roomId}`, e);\n            }\n\n            return session;\n        };\n\n        // first wait for the previous share to complete\n        const prom = this.setupPromise.then(setup);\n\n        // Ensure any failures are logged for debugging\n        prom.catch(e => {\n            logger.error(`Failed to setup outbound session in ${this.roomId}`, e);\n        });\n\n        // setupPromise resolves to `session` whether or not the share succeeds\n        this.setupPromise = prom;\n\n        // but we return a promise which only resolves if the share was successful.\n        return prom;\n    }\n\n    private async prepareSession(\n        devicesInRoom: DeviceInfoMap,\n        sharedHistory: boolean,\n        session: OutboundSessionInfo | null,\n    ): Promise<OutboundSessionInfo> {\n        // history visibility changed\n        if (session && sharedHistory !== session.sharedHistory) {\n            session = null;\n        }\n\n        // need to make a brand new session?\n        if (session?.needsRotation(this.sessionRotationPeriodMsgs, this.sessionRotationPeriodMs)) {\n            logger.log(\"Starting new megolm session because we need to rotate.\");\n            session = null;\n        }\n\n        // determine if we have shared with anyone we shouldn't have\n        if (session?.sharedWithTooManyDevices(devicesInRoom)) {\n            session = null;\n        }\n\n        if (!session) {\n            logger.log(`Starting new megolm session for room ${this.roomId}`);\n            session = await this.prepareNewSession(sharedHistory);\n            logger.log(`Started new megolm session ${session.sessionId} ` +\n                `for room ${this.roomId}`);\n            this.outboundSessions[session.sessionId] = session;\n        }\n\n        return session;\n    }\n\n    private async shareSession(\n        devicesInRoom: DeviceInfoMap,\n        sharedHistory: boolean,\n        singleOlmCreationPhase: boolean,\n        blocked: IBlockedMap,\n        session: OutboundSessionInfo,\n    ) {\n        // now check if we need to share with any devices\n        const shareMap: Record<string, DeviceInfo[]> = {};\n\n        for (const [userId, userDevices] of Object.entries(devicesInRoom)) {\n            for (const [deviceId, deviceInfo] of Object.entries(userDevices)) {\n                const key = deviceInfo.getIdentityKey();\n                if (key == this.olmDevice.deviceCurve25519Key) {\n                    // don't bother sending to ourself\n                    continue;\n                }\n\n                if (\n                    !session.sharedWithDevices[userId] ||\n                    session.sharedWithDevices[userId][deviceId] === undefined\n                ) {\n                    shareMap[userId] = shareMap[userId] || [];\n                    shareMap[userId].push(deviceInfo);\n                }\n            }\n        }\n\n        const key = this.olmDevice.getOutboundGroupSessionKey(session.sessionId);\n        const payload: IPayload = {\n            type: \"m.room_key\",\n            content: {\n                \"algorithm\": olmlib.MEGOLM_ALGORITHM,\n                \"room_id\": this.roomId,\n                \"session_id\": session.sessionId,\n                \"session_key\": key.key,\n                \"chain_index\": key.chain_index,\n                \"org.matrix.msc3061.shared_history\": sharedHistory,\n            },\n        };\n        const [devicesWithoutSession, olmSessions] = await olmlib.getExistingOlmSessions(\n            this.olmDevice, this.baseApis, shareMap,\n        );\n\n        await Promise.all([\n            (async () => {\n                // share keys with devices that we already have a session for\n                logger.debug(`Sharing keys with existing Olm sessions in ${this.roomId}`, olmSessions);\n                await this.shareKeyWithOlmSessions(session, key, payload, olmSessions);\n                logger.debug(`Shared keys with existing Olm sessions in ${this.roomId}`);\n            })(),\n            (async () => {\n                logger.debug(\n                    `Sharing keys (start phase 1) with new Olm sessions in ${this.roomId}`,\n                    devicesWithoutSession,\n                );\n                const errorDevices: IOlmDevice[] = [];\n\n                // meanwhile, establish olm sessions for devices that we don't\n                // already have a session for, and share keys with them.  If\n                // we're doing two phases of olm session creation, use a\n                // shorter timeout when fetching one-time keys for the first\n                // phase.\n                const start = Date.now();\n                const failedServers: string[] = [];\n                await this.shareKeyWithDevices(\n                    session, key, payload, devicesWithoutSession, errorDevices,\n                    singleOlmCreationPhase ? 10000 : 2000, failedServers,\n                );\n                logger.debug(`Shared keys (end phase 1) with new Olm sessions in ${this.roomId}`);\n\n                if (!singleOlmCreationPhase && (Date.now() - start < 10000)) {\n                    // perform the second phase of olm session creation if requested,\n                    // and if the first phase didn't take too long\n                    (async () => {\n                        // Retry sending keys to devices that we were unable to establish\n                        // an olm session for.  This time, we use a longer timeout, but we\n                        // do this in the background and don't block anything else while we\n                        // do this.  We only need to retry users from servers that didn't\n                        // respond the first time.\n                        const retryDevices: Record<string, DeviceInfo[]> = {};\n                        const failedServerMap = new Set;\n                        for (const server of failedServers) {\n                            failedServerMap.add(server);\n                        }\n                        const failedDevices: IOlmDevice[] = [];\n                        for (const { userId, deviceInfo } of errorDevices) {\n                            const userHS = userId.slice(userId.indexOf(\":\") + 1);\n                            if (failedServerMap.has(userHS)) {\n                                retryDevices[userId] = retryDevices[userId] || [];\n                                retryDevices[userId].push(deviceInfo);\n                            } else {\n                                // if we aren't going to retry, then handle it\n                                // as a failed device\n                                failedDevices.push({ userId, deviceInfo });\n                            }\n                        }\n\n                        logger.debug(`Sharing keys (start phase 2) with new Olm sessions in ${this.roomId}`);\n                        await this.shareKeyWithDevices(\n                            session, key, payload, retryDevices, failedDevices, 30000,\n                        );\n                        logger.debug(`Shared keys (end phase 2) with new Olm sessions in ${this.roomId}`);\n\n                        await this.notifyFailedOlmDevices(session, key, failedDevices);\n                    })();\n                } else {\n                    await this.notifyFailedOlmDevices(session, key, errorDevices);\n                }\n                logger.debug(`Shared keys (all phases done) with new Olm sessions in ${this.roomId}`);\n            })(),\n            (async () => {\n                logger.debug(`There are ${Object.entries(blocked).length} blocked devices in ${this.roomId}`,\n                    Object.entries(blocked));\n\n                // also, notify newly blocked devices that they're blocked\n                logger.debug(`Notifying newly blocked devices in ${this.roomId}`);\n                const blockedMap: Record<string, Record<string, { device: IBlockedDevice }>> = {};\n                let blockedCount = 0;\n                for (const [userId, userBlockedDevices] of Object.entries(blocked)) {\n                    for (const [deviceId, device] of Object.entries(userBlockedDevices)) {\n                        if (\n                            !session.blockedDevicesNotified[userId] ||\n                            session.blockedDevicesNotified[userId][deviceId] === undefined\n                        ) {\n                            blockedMap[userId] = blockedMap[userId] || {};\n                            blockedMap[userId][deviceId] = { device };\n                            blockedCount++;\n                        }\n                    }\n                }\n\n                await this.notifyBlockedDevices(session, blockedMap);\n                logger.debug(`Notified ${blockedCount} newly blocked devices in ${this.roomId}`, blockedMap);\n            })(),\n        ]);\n    }\n\n    /**\n     * @private\n     *\n     * @param {boolean} sharedHistory\n     *\n     * @return {module:crypto/algorithms/megolm.OutboundSessionInfo} session\n     */\n    private async prepareNewSession(sharedHistory: boolean): Promise<OutboundSessionInfo> {\n        const sessionId = this.olmDevice.createOutboundGroupSession();\n        const key = this.olmDevice.getOutboundGroupSessionKey(sessionId);\n\n        await this.olmDevice.addInboundGroupSession(\n            this.roomId, this.olmDevice.deviceCurve25519Key, [], sessionId,\n            key.key, { ed25519: this.olmDevice.deviceEd25519Key }, false,\n            { sharedHistory },\n        );\n\n        // don't wait for it to complete\n        this.crypto.backupManager.backupGroupSession(this.olmDevice.deviceCurve25519Key, sessionId);\n\n        return new OutboundSessionInfo(sessionId, sharedHistory);\n    }\n\n    /**\n     * Determines what devices in devicesByUser don't have an olm session as given\n     * in devicemap.\n     *\n     * @private\n     *\n     * @param {object} devicemap the devices that have olm sessions, as returned by\n     *     olmlib.ensureOlmSessionsForDevices.\n     * @param {object} devicesByUser a map of user IDs to array of deviceInfo\n     * @param {array} [noOlmDevices] an array to fill with devices that don't have\n     *     olm sessions\n     *\n     * @return {array} an array of devices that don't have olm sessions.  If\n     *     noOlmDevices is specified, then noOlmDevices will be returned.\n     */\n    private getDevicesWithoutSessions(\n        devicemap: Record<string, Record<string, IOlmSessionResult>>,\n        devicesByUser: Record<string, DeviceInfo[]>,\n        noOlmDevices: IOlmDevice[] = [],\n    ): IOlmDevice[] {\n        for (const [userId, devicesToShareWith] of Object.entries(devicesByUser)) {\n            const sessionResults = devicemap[userId];\n\n            for (const deviceInfo of devicesToShareWith) {\n                const deviceId = deviceInfo.deviceId;\n\n                const sessionResult = sessionResults[deviceId];\n                if (!sessionResult.sessionId) {\n                    // no session with this device, probably because there\n                    // were no one-time keys.\n\n                    noOlmDevices.push({ userId, deviceInfo });\n                    delete sessionResults[deviceId];\n\n                    // ensureOlmSessionsForUsers has already done the logging,\n                    // so just skip it.\n                    continue;\n                }\n            }\n        }\n\n        return noOlmDevices;\n    }\n\n    /**\n     * Splits the user device map into multiple chunks to reduce the number of\n     * devices we encrypt to per API call.\n     *\n     * @private\n     *\n     * @param {object} devicesByUser map from userid to list of devices\n     *\n     * @return {array<array<object>>} the blocked devices, split into chunks\n     */\n    private splitDevices<T extends DeviceInfo | IBlockedDevice>(\n        devicesByUser: Record<string, Record<string, { device: T }>>,\n    ): IOlmDevice<T>[][] {\n        const maxDevicesPerRequest = 20;\n\n        // use an array where the slices of a content map gets stored\n        let currentSlice: IOlmDevice<T>[] = [];\n        const mapSlices = [currentSlice];\n\n        for (const [userId, userDevices] of Object.entries(devicesByUser)) {\n            for (const deviceInfo of Object.values(userDevices)) {\n                currentSlice.push({\n                    userId: userId,\n                    deviceInfo: deviceInfo.device,\n                });\n            }\n\n            // We do this in the per-user loop as we prefer that all messages to the\n            // same user end up in the same API call to make it easier for the\n            // server (e.g. only have to send one EDU if a remote user, etc). This\n            // does mean that if a user has many devices we may go over the desired\n            // limit, but its not a hard limit so that is fine.\n            if (currentSlice.length > maxDevicesPerRequest) {\n                // the current slice is filled up. Start inserting into the next slice\n                currentSlice = [];\n                mapSlices.push(currentSlice);\n            }\n        }\n        if (currentSlice.length === 0) {\n            mapSlices.pop();\n        }\n        return mapSlices;\n    }\n\n    /**\n     * @private\n     *\n     * @param {module:crypto/algorithms/megolm.OutboundSessionInfo} session\n     *\n     * @param {number} chainIndex current chain index\n     *\n     * @param {object<userId, deviceInfo>} userDeviceMap\n     *   mapping from userId to deviceInfo\n     *\n     * @param {object} payload fields to include in the encrypted payload\n     *\n     * @return {Promise} Promise which resolves once the key sharing\n     *     for the given userDeviceMap is generated and has been sent.\n     */\n    private encryptAndSendKeysToDevices(\n        session: OutboundSessionInfo,\n        chainIndex: number,\n        devices: IOlmDevice[],\n        payload: IPayload,\n    ): Promise<void> {\n        return this.crypto.encryptAndSendToDevices(\n            devices,\n            payload,\n        ).then(() => {\n            // store that we successfully uploaded the keys of the current slice\n            for (const device of devices) {\n                session.markSharedWithDevice(\n                    device.userId,\n                    device.deviceInfo.deviceId,\n                    device.deviceInfo.getIdentityKey(),\n                    chainIndex,\n                );\n            }\n        }).catch((error) => {\n            logger.error(\"failed to encryptAndSendToDevices\", error);\n            throw error;\n        });\n    }\n\n    /**\n     * @private\n     *\n     * @param {module:crypto/algorithms/megolm.OutboundSessionInfo} session\n     *\n     * @param {array<object>} userDeviceMap list of blocked devices to notify\n     *\n     * @param {object} payload fields to include in the notification payload\n     *\n     * @return {Promise} Promise which resolves once the notifications\n     *     for the given userDeviceMap is generated and has been sent.\n     */\n    private async sendBlockedNotificationsToDevices(\n        session: OutboundSessionInfo,\n        userDeviceMap: IOlmDevice<IBlockedDevice>[],\n        payload: IPayload,\n    ): Promise<void> {\n        const contentMap: Record<string, Record<string, IPayload>> = {};\n\n        for (const val of userDeviceMap) {\n            const userId = val.userId;\n            const blockedInfo = val.deviceInfo;\n            const deviceInfo = blockedInfo.deviceInfo;\n            const deviceId = deviceInfo.deviceId;\n\n            const message = Object.assign({}, payload);\n            message.code = blockedInfo.code;\n            message.reason = blockedInfo.reason;\n            if (message.code === \"m.no_olm\") {\n                delete message.room_id;\n                delete message.session_id;\n            }\n\n            if (!contentMap[userId]) {\n                contentMap[userId] = {};\n            }\n            contentMap[userId][deviceId] = message;\n        }\n\n        await this.baseApis.sendToDevice(\"m.room_key.withheld\", contentMap);\n\n        // record the fact that we notified these blocked devices\n        for (const userId of Object.keys(contentMap)) {\n            for (const deviceId of Object.keys(contentMap[userId])) {\n                session.markNotifiedBlockedDevice(userId, deviceId);\n            }\n        }\n    }\n\n    /**\n     * Re-shares a megolm session key with devices if the key has already been\n     * sent to them.\n     *\n     * @param {string} senderKey The key of the originating device for the session\n     * @param {string} sessionId ID of the outbound session to share\n     * @param {string} userId ID of the user who owns the target device\n     * @param {module:crypto/deviceinfo} device The target device\n     */\n    public async reshareKeyWithDevice(\n        senderKey: string,\n        sessionId: string,\n        userId: string,\n        device: DeviceInfo,\n    ): Promise<void> {\n        const obSessionInfo = this.outboundSessions[sessionId];\n        if (!obSessionInfo) {\n            logger.debug(`megolm session ${sessionId} not found: not re-sharing keys`);\n            return;\n        }\n\n        // The chain index of the key we previously sent this device\n        if (obSessionInfo.sharedWithDevices[userId] === undefined) {\n            logger.debug(`megolm session ${sessionId} never shared with user ${userId}`);\n            return;\n        }\n        const sessionSharedData = obSessionInfo.sharedWithDevices[userId][device.deviceId];\n        if (sessionSharedData === undefined) {\n            logger.debug(\n                \"megolm session ID \" + sessionId + \" never shared with device \" +\n                userId + \":\" + device.deviceId,\n            );\n            return;\n        }\n\n        if (sessionSharedData.deviceKey !== device.getIdentityKey()) {\n            logger.warn(\n                `Session has been shared with device ${device.deviceId} but with identity ` +\n                `key ${sessionSharedData.deviceKey}. Key is now ${device.getIdentityKey()}!`,\n            );\n            return;\n        }\n\n        // get the key from the inbound session: the outbound one will already\n        // have been ratcheted to the next chain index.\n        const key = await this.olmDevice.getInboundGroupSessionKey(\n            this.roomId, senderKey, sessionId, sessionSharedData.messageIndex,\n        );\n\n        if (!key) {\n            logger.warn(\n                `No inbound session key found for megolm ${sessionId}: not re-sharing keys`,\n            );\n            return;\n        }\n\n        await olmlib.ensureOlmSessionsForDevices(\n            this.olmDevice, this.baseApis, {\n                [userId]: [device],\n            },\n        );\n\n        const payload = {\n            type: \"m.forwarded_room_key\",\n            content: {\n                \"algorithm\": olmlib.MEGOLM_ALGORITHM,\n                \"room_id\": this.roomId,\n                \"session_id\": sessionId,\n                \"session_key\": key.key,\n                \"chain_index\": key.chain_index,\n                \"sender_key\": senderKey,\n                \"sender_claimed_ed25519_key\": key.sender_claimed_ed25519_key,\n                \"forwarding_curve25519_key_chain\": key.forwarding_curve25519_key_chain,\n                \"org.matrix.msc3061.shared_history\": key.shared_history || false,\n            },\n        };\n\n        const encryptedContent = {\n            algorithm: olmlib.OLM_ALGORITHM,\n            sender_key: this.olmDevice.deviceCurve25519Key,\n            ciphertext: {},\n        };\n        await olmlib.encryptMessageForDevice(\n            encryptedContent.ciphertext,\n            this.userId,\n            this.deviceId,\n            this.olmDevice,\n            userId,\n            device,\n            payload,\n        );\n\n        await this.baseApis.sendToDevice(\"m.room.encrypted\", {\n            [userId]: {\n                [device.deviceId]: encryptedContent,\n            },\n        });\n        logger.debug(`Re-shared key for megolm session ${sessionId} with ${userId}:${device.deviceId}`);\n    }\n\n    /**\n     * @private\n     *\n     * @param {module:crypto/algorithms/megolm.OutboundSessionInfo} session\n     *\n     * @param {object} key the session key as returned by\n     *    OlmDevice.getOutboundGroupSessionKey\n     *\n     * @param {object} payload the base to-device message payload for sharing keys\n     *\n     * @param {object<string, module:crypto/deviceinfo[]>} devicesByUser\n     *    map from userid to list of devices\n     *\n     * @param {array<object>} errorDevices\n     *    array that will be populated with the devices that we can't get an\n     *    olm session for\n     *\n     * @param {Number} [otkTimeout] The timeout in milliseconds when requesting\n     *     one-time keys for establishing new olm sessions.\n     *\n     * @param {Array} [failedServers] An array to fill with remote servers that\n     *     failed to respond to one-time-key requests.\n     */\n    private async shareKeyWithDevices(\n        session: OutboundSessionInfo,\n        key: IOutboundGroupSessionKey,\n        payload: IPayload,\n        devicesByUser: Record<string, DeviceInfo[]>,\n        errorDevices: IOlmDevice[],\n        otkTimeout: number,\n        failedServers?: string[],\n    ) {\n        logger.debug(`Ensuring Olm sessions for devices in ${this.roomId}`);\n        const devicemap = await olmlib.ensureOlmSessionsForDevices(\n            this.olmDevice, this.baseApis, devicesByUser, false, otkTimeout, failedServers,\n            logger.withPrefix?.(`[${this.roomId}]`),\n        );\n        logger.debug(`Ensured Olm sessions for devices in ${this.roomId}`);\n\n        this.getDevicesWithoutSessions(devicemap, devicesByUser, errorDevices);\n\n        logger.debug(`Sharing keys with newly created Olm sessions in ${this.roomId}`);\n        await this.shareKeyWithOlmSessions(session, key, payload, devicemap);\n        logger.debug(`Shared keys with newly created Olm sessions in ${this.roomId}`);\n    }\n\n    private async shareKeyWithOlmSessions(\n        session: OutboundSessionInfo,\n        key: IOutboundGroupSessionKey,\n        payload: IPayload,\n        devicemap: Record<string, Record<string, IOlmSessionResult>>,\n    ): Promise<void> {\n        const userDeviceMaps = this.splitDevices(devicemap);\n\n        for (let i = 0; i < userDeviceMaps.length; i++) {\n            const taskDetail =\n                `megolm keys for ${session.sessionId} ` +\n                `in ${this.roomId} (slice ${i + 1}/${userDeviceMaps.length})`;\n            try {\n                logger.debug(`Sharing ${taskDetail}`,\n                    userDeviceMaps[i].map((d) => `${d.userId}/${d.deviceInfo.deviceId}`));\n                await this.encryptAndSendKeysToDevices(\n                    session, key.chain_index, userDeviceMaps[i], payload,\n                );\n                logger.debug(`Shared ${taskDetail}`);\n            } catch (e) {\n                logger.error(`Failed to share ${taskDetail}`);\n                throw e;\n            }\n        }\n    }\n\n    /**\n     * Notify devices that we weren't able to create olm sessions.\n     *\n     * @param {module:crypto/algorithms/megolm.OutboundSessionInfo} session\n     *\n     * @param {object} key\n     *\n     * @param {Array<object>} failedDevices the devices that we were unable to\n     *     create olm sessions for, as returned by shareKeyWithDevices\n     */\n    private async notifyFailedOlmDevices(\n        session: OutboundSessionInfo,\n        key: IOutboundGroupSessionKey,\n        failedDevices: IOlmDevice[],\n    ): Promise<void> {\n        logger.debug(\n            `Notifying ${failedDevices.length} devices we failed to ` +\n            `create Olm sessions in ${this.roomId}`,\n        );\n\n        // mark the devices that failed as \"handled\" because we don't want to try\n        // to claim a one-time-key for dead devices on every message.\n        for (const { userId, deviceInfo } of failedDevices) {\n            const deviceId = deviceInfo.deviceId;\n\n            session.markSharedWithDevice(\n                userId, deviceId, deviceInfo.getIdentityKey(), key.chain_index,\n            );\n        }\n\n        const unnotifiedFailedDevices =\n            await this.olmDevice.filterOutNotifiedErrorDevices(\n                failedDevices,\n            );\n        logger.debug(\n            `Need to notify ${unnotifiedFailedDevices.length} failed devices ` +\n            `which haven't been notified before in ${this.roomId}`,\n        );\n        const blockedMap: Record<string, Record<string, { device: IBlockedDevice }>> = {};\n        for (const { userId, deviceInfo } of unnotifiedFailedDevices) {\n            blockedMap[userId] = blockedMap[userId] || {};\n            // we use a similar format to what\n            // olmlib.ensureOlmSessionsForDevices returns, so that\n            // we can use the same function to split\n            blockedMap[userId][deviceInfo.deviceId] = {\n                device: {\n                    code: \"m.no_olm\",\n                    reason: WITHHELD_MESSAGES[\"m.no_olm\"],\n                    deviceInfo,\n                },\n            };\n        }\n\n        // send the notifications\n        await this.notifyBlockedDevices(session, blockedMap);\n        logger.debug(\n            `Notified ${unnotifiedFailedDevices.length} devices we failed to ` +\n            `create Olm sessions in ${this.roomId}`,\n        );\n    }\n\n    /**\n     * Notify blocked devices that they have been blocked.\n     *\n     * @param {module:crypto/algorithms/megolm.OutboundSessionInfo} session\n     *\n     * @param {object<string, object>} devicesByUser\n     *    map from userid to device ID to blocked data\n     */\n    private async notifyBlockedDevices(\n        session: OutboundSessionInfo,\n        devicesByUser: Record<string, Record<string, { device: IBlockedDevice }>>,\n    ): Promise<void> {\n        const payload: IPayload = {\n            room_id: this.roomId,\n            session_id: session.sessionId,\n            algorithm: olmlib.MEGOLM_ALGORITHM,\n            sender_key: this.olmDevice.deviceCurve25519Key,\n        };\n\n        const userDeviceMaps = this.splitDevices(devicesByUser);\n\n        for (let i = 0; i < userDeviceMaps.length; i++) {\n            try {\n                await this.sendBlockedNotificationsToDevices(session, userDeviceMaps[i], payload);\n                logger.log(`Completed blacklist notification for ${session.sessionId} `\n                    + `in ${this.roomId} (slice ${i + 1}/${userDeviceMaps.length})`);\n            } catch (e) {\n                logger.log(`blacklist notification for ${session.sessionId} in `\n                    + `${this.roomId} (slice ${i + 1}/${userDeviceMaps.length}) failed`);\n\n                throw e;\n            }\n        }\n    }\n\n    /**\n     * Perform any background tasks that can be done before a message is ready to\n     * send, in order to speed up sending of the message.\n     *\n     * @param {module:models/room} room the room the event is in\n     */\n    public prepareToEncrypt(room: Room): void {\n        if (this.encryptionPreparation != null) {\n            // We're already preparing something, so don't do anything else.\n            // FIXME: check if we need to restart\n            // (https://github.com/matrix-org/matrix-js-sdk/issues/1255)\n            const elapsedTime = Date.now() - this.encryptionPreparation.startTime;\n            logger.debug(\n                `Already started preparing to encrypt for ${this.roomId} ` +\n                `${elapsedTime} ms ago, skipping`,\n            );\n            return;\n        }\n\n        logger.debug(`Preparing to encrypt events for ${this.roomId}`);\n\n        this.encryptionPreparation = {\n            startTime: Date.now(),\n            promise: (async () => {\n                try {\n                    logger.debug(`Getting devices in ${this.roomId}`);\n                    const [devicesInRoom, blocked] = await this.getDevicesInRoom(room);\n\n                    if (this.crypto.getGlobalErrorOnUnknownDevices()) {\n                        // Drop unknown devices for now.  When the message gets sent, we'll\n                        // throw an error, but we'll still be prepared to send to the known\n                        // devices.\n                        this.removeUnknownDevices(devicesInRoom);\n                    }\n\n                    logger.debug(`Ensuring outbound session in ${this.roomId}`);\n                    await this.ensureOutboundSession(room, devicesInRoom, blocked, true);\n\n                    logger.debug(`Ready to encrypt events for ${this.roomId}`);\n                } catch (e) {\n                    logger.error(`Failed to prepare to encrypt events for ${this.roomId}`, e);\n                } finally {\n                    delete this.encryptionPreparation;\n                }\n            })(),\n        };\n    }\n\n    /**\n     * @inheritdoc\n     *\n     * @param {module:models/room} room\n     * @param {string} eventType\n     * @param {object} content plaintext event content\n     *\n     * @return {Promise} Promise which resolves to the new event body\n     */\n    public async encryptMessage(room: Room, eventType: string, content: object): Promise<object> {\n        logger.log(`Starting to encrypt event for ${this.roomId}`);\n\n        if (this.encryptionPreparation != null) {\n            // If we started sending keys, wait for it to be done.\n            // FIXME: check if we need to cancel\n            // (https://github.com/matrix-org/matrix-js-sdk/issues/1255)\n            try {\n                await this.encryptionPreparation.promise;\n            } catch (e) {\n                // ignore any errors -- if the preparation failed, we'll just\n                // restart everything here\n            }\n        }\n\n        const [devicesInRoom, blocked] = await this.getDevicesInRoom(room);\n\n        // check if any of these devices are not yet known to the user.\n        // if so, warn the user so they can verify or ignore.\n        if (this.crypto.getGlobalErrorOnUnknownDevices()) {\n            this.checkForUnknownDevices(devicesInRoom);\n        }\n\n        const session = await this.ensureOutboundSession(room, devicesInRoom, blocked);\n        const payloadJson = {\n            room_id: this.roomId,\n            type: eventType,\n            content: content,\n        };\n\n        const ciphertext = this.olmDevice.encryptGroupMessage(\n            session.sessionId, JSON.stringify(payloadJson),\n        );\n        const encryptedContent = {\n            algorithm: olmlib.MEGOLM_ALGORITHM,\n            sender_key: this.olmDevice.deviceCurve25519Key,\n            ciphertext: ciphertext,\n            session_id: session.sessionId,\n            // Include our device ID so that recipients can send us a\n            // m.new_device message if they don't have our session key.\n            // XXX: Do we still need this now that m.new_device messages\n            // no longer exist since #483?\n            device_id: this.deviceId,\n        };\n\n        session.useCount++;\n        return encryptedContent;\n    }\n\n    /**\n     * Forces the current outbound group session to be discarded such\n     * that another one will be created next time an event is sent.\n     *\n     * This should not normally be necessary.\n     */\n    public forceDiscardSession(): void {\n        this.setupPromise = this.setupPromise.then(() => null);\n    }\n\n    /**\n     * Checks the devices we're about to send to and see if any are entirely\n     * unknown to the user.  If so, warn the user, and mark them as known to\n     * give the user a chance to go verify them before re-sending this message.\n     *\n     * @param {Object} devicesInRoom userId -> {deviceId -> object}\n     *   devices we should shared the session with.\n     */\n    private checkForUnknownDevices(devicesInRoom: DeviceInfoMap): void {\n        const unknownDevices: Record<string, Record<string, DeviceInfo>> = {};\n\n        Object.keys(devicesInRoom).forEach((userId) => {\n            Object.keys(devicesInRoom[userId]).forEach((deviceId) => {\n                const device = devicesInRoom[userId][deviceId];\n                if (device.isUnverified() && !device.isKnown()) {\n                    if (!unknownDevices[userId]) {\n                        unknownDevices[userId] = {};\n                    }\n                    unknownDevices[userId][deviceId] = device;\n                }\n            });\n        });\n\n        if (Object.keys(unknownDevices).length) {\n            // it'd be kind to pass unknownDevices up to the user in this error\n            throw new UnknownDeviceError(\n                \"This room contains unknown devices which have not been verified. \" +\n                \"We strongly recommend you verify them before continuing.\", unknownDevices);\n        }\n    }\n\n    /**\n     * Remove unknown devices from a set of devices.  The devicesInRoom parameter\n     * will be modified.\n     *\n     * @param {Object} devicesInRoom userId -> {deviceId -> object}\n     *   devices we should shared the session with.\n     */\n    private removeUnknownDevices(devicesInRoom: DeviceInfoMap): void {\n        for (const [userId, userDevices] of Object.entries(devicesInRoom)) {\n            for (const [deviceId, device] of Object.entries(userDevices)) {\n                if (device.isUnverified() && !device.isKnown()) {\n                    delete userDevices[deviceId];\n                }\n            }\n\n            if (Object.keys(userDevices).length === 0) {\n                delete devicesInRoom[userId];\n            }\n        }\n    }\n\n    /**\n     * Get the list of unblocked devices for all users in the room\n     *\n     * @param {module:models/room} room\n     *\n     * @return {Promise} Promise which resolves to an array whose\n     *     first element is a map from userId to deviceId to deviceInfo indicating\n     *     the devices that messages should be encrypted to, and whose second\n     *     element is a map from userId to deviceId to data indicating the devices\n     *     that are in the room but that have been blocked\n     */\n    private async getDevicesInRoom(room: Room): Promise<[DeviceInfoMap, IBlockedMap]> {\n        const members = await room.getEncryptionTargetMembers();\n        const roomMembers = members.map(function(u) {\n            return u.userId;\n        });\n\n        // The global value is treated as a default for when rooms don't specify a value.\n        let isBlacklisting = this.crypto.getGlobalBlacklistUnverifiedDevices();\n        if (typeof room.getBlacklistUnverifiedDevices() === 'boolean') {\n            isBlacklisting = room.getBlacklistUnverifiedDevices();\n        }\n\n        // We are happy to use a cached version here: we assume that if we already\n        // have a list of the user's devices, then we already share an e2e room\n        // with them, which means that they will have announced any new devices via\n        // device_lists in their /sync response.  This cache should then be maintained\n        // using all the device_lists changes and left fields.\n        // See https://github.com/vector-im/element-web/issues/2305 for details.\n        const devices = await this.crypto.downloadKeys(roomMembers, false);\n        const blocked: IBlockedMap = {};\n        // remove any blocked devices\n        for (const userId in devices) {\n            if (!devices.hasOwnProperty(userId)) {\n                continue;\n            }\n\n            const userDevices = devices[userId];\n            for (const deviceId in userDevices) {\n                if (!userDevices.hasOwnProperty(deviceId)) {\n                    continue;\n                }\n\n                const deviceTrust = this.crypto.checkDeviceTrust(userId, deviceId);\n\n                if (userDevices[deviceId].isBlocked() ||\n                    (!deviceTrust.isVerified() && isBlacklisting)\n                ) {\n                    if (!blocked[userId]) {\n                        blocked[userId] = {};\n                    }\n                    const isBlocked = userDevices[deviceId].isBlocked();\n                    blocked[userId][deviceId] = {\n                        code: isBlocked ? \"m.blacklisted\" : \"m.unverified\",\n                        reason: WITHHELD_MESSAGES[isBlocked ? \"m.blacklisted\" : \"m.unverified\"],\n                        deviceInfo: userDevices[deviceId],\n                    };\n                    delete userDevices[deviceId];\n                }\n            }\n        }\n\n        return [devices, blocked];\n    }\n}\n\n/**\n * Megolm decryption implementation\n *\n * @constructor\n * @extends {module:crypto/algorithms/DecryptionAlgorithm}\n *\n * @param {object} params parameters, as per\n *     {@link module:crypto/algorithms/DecryptionAlgorithm}\n */\nclass MegolmDecryption extends DecryptionAlgorithm {\n    // events which we couldn't decrypt due to unknown sessions / indexes: map from\n    // senderKey|sessionId to Set of MatrixEvents\n    private pendingEvents = new Map<string, Map<string, Set<MatrixEvent>>>();\n\n    // this gets stubbed out by the unit tests.\n    private olmlib = olmlib;\n\n    /**\n     * @inheritdoc\n     *\n     * @param {MatrixEvent} event\n     *\n     * returns a promise which resolves to a\n     * {@link module:crypto~EventDecryptionResult} once we have finished\n     * decrypting, or rejects with an `algorithms.DecryptionError` if there is a\n     * problem decrypting the event.\n     */\n    public async decryptEvent(event: MatrixEvent): Promise<IEventDecryptionResult> {\n        const content = event.getWireContent();\n\n        if (!content.sender_key || !content.session_id ||\n            !content.ciphertext\n        ) {\n            throw new DecryptionError(\n                \"MEGOLM_MISSING_FIELDS\",\n                \"Missing fields in input\",\n            );\n        }\n\n        // we add the event to the pending list *before* we start decryption.\n        //\n        // then, if the key turns up while decryption is in progress (and\n        // decryption fails), we will schedule a retry.\n        // (fixes https://github.com/vector-im/element-web/issues/5001)\n        this.addEventToPendingList(event);\n\n        let res: IDecryptedGroupMessage;\n        try {\n            res = await this.olmDevice.decryptGroupMessage(\n                event.getRoomId(), content.sender_key, content.session_id, content.ciphertext,\n                event.getId(), event.getTs(),\n            );\n        } catch (e) {\n            if (e.name === \"DecryptionError\") {\n                // re-throw decryption errors as-is\n                throw e;\n            }\n\n            let errorCode = \"OLM_DECRYPT_GROUP_MESSAGE_ERROR\";\n\n            if (e && e.message === 'OLM.UNKNOWN_MESSAGE_INDEX') {\n                this.requestKeysForEvent(event);\n\n                errorCode = 'OLM_UNKNOWN_MESSAGE_INDEX';\n            }\n\n            throw new DecryptionError(\n                errorCode,\n                e ? e.toString() : \"Unknown Error: Error is undefined\", {\n                    session: content.sender_key + '|' + content.session_id,\n                },\n            );\n        }\n\n        if (res === null) {\n            // We've got a message for a session we don't have.\n            // try and get the missing key from the backup first\n            this.crypto.backupManager.queryKeyBackupRateLimited(event.getRoomId(), content.session_id).catch(() => {});\n\n            // (XXX: We might actually have received this key since we started\n            // decrypting, in which case we'll have scheduled a retry, and this\n            // request will be redundant. We could probably check to see if the\n            // event is still in the pending list; if not, a retry will have been\n            // scheduled, so we needn't send out the request here.)\n            this.requestKeysForEvent(event);\n\n            // See if there was a problem with the olm session at the time the\n            // event was sent.  Use a fuzz factor of 2 minutes.\n            const problem = await this.olmDevice.sessionMayHaveProblems(\n                content.sender_key, event.getTs() - 120000,\n            );\n            if (problem) {\n                let problemDescription = PROBLEM_DESCRIPTIONS[problem.type as \"no_olm\"] || PROBLEM_DESCRIPTIONS.unknown;\n                if (problem.fixed) {\n                    problemDescription +=\n                        \" Trying to create a new secure channel and re-requesting the keys.\";\n                }\n                throw new DecryptionError(\n                    \"MEGOLM_UNKNOWN_INBOUND_SESSION_ID\",\n                    problemDescription,\n                    {\n                        session: content.sender_key + '|' + content.session_id,\n                    },\n                );\n            }\n\n            throw new DecryptionError(\n                \"MEGOLM_UNKNOWN_INBOUND_SESSION_ID\",\n                \"The sender's device has not sent us the keys for this message.\",\n                {\n                    session: content.sender_key + '|' + content.session_id,\n                },\n            );\n        }\n\n        // success. We can remove the event from the pending list, if that hasn't\n        // already happened.\n        this.removeEventFromPendingList(event);\n\n        const payload = JSON.parse(res.result);\n\n        // belt-and-braces check that the room id matches that indicated by the HS\n        // (this is somewhat redundant, since the megolm session is scoped to the\n        // room, so neither the sender nor a MITM can lie about the room_id).\n        if (payload.room_id !== event.getRoomId()) {\n            throw new DecryptionError(\n                \"MEGOLM_BAD_ROOM\",\n                \"Message intended for room \" + payload.room_id,\n            );\n        }\n\n        return {\n            clearEvent: payload,\n            senderCurve25519Key: res.senderKey,\n            claimedEd25519Key: res.keysClaimed.ed25519,\n            forwardingCurve25519KeyChain: res.forwardingCurve25519KeyChain,\n            untrusted: res.untrusted,\n        };\n    }\n\n    private requestKeysForEvent(event: MatrixEvent): void {\n        const wireContent = event.getWireContent();\n\n        const recipients = event.getKeyRequestRecipients(this.userId);\n\n        this.crypto.requestRoomKey({\n            room_id: event.getRoomId(),\n            algorithm: wireContent.algorithm,\n            sender_key: wireContent.sender_key,\n            session_id: wireContent.session_id,\n        }, recipients);\n    }\n\n    /**\n     * Add an event to the list of those awaiting their session keys.\n     *\n     * @private\n     *\n     * @param {module:models/event.MatrixEvent} event\n     */\n    private addEventToPendingList(event: MatrixEvent): void {\n        const content = event.getWireContent();\n        const senderKey = content.sender_key;\n        const sessionId = content.session_id;\n        if (!this.pendingEvents.has(senderKey)) {\n            this.pendingEvents.set(senderKey, new Map<string, Set<MatrixEvent>>());\n        }\n        const senderPendingEvents = this.pendingEvents.get(senderKey);\n        if (!senderPendingEvents.has(sessionId)) {\n            senderPendingEvents.set(sessionId, new Set());\n        }\n        senderPendingEvents.get(sessionId)?.add(event);\n    }\n\n    /**\n     * Remove an event from the list of those awaiting their session keys.\n     *\n     * @private\n     *\n     * @param {module:models/event.MatrixEvent} event\n     */\n    private removeEventFromPendingList(event: MatrixEvent): void {\n        const content = event.getWireContent();\n        const senderKey = content.sender_key;\n        const sessionId = content.session_id;\n        const senderPendingEvents = this.pendingEvents.get(senderKey);\n        const pendingEvents = senderPendingEvents?.get(sessionId);\n        if (!pendingEvents) {\n            return;\n        }\n\n        pendingEvents.delete(event);\n        if (pendingEvents.size === 0) {\n            senderPendingEvents.delete(sessionId);\n        }\n        if (senderPendingEvents.size === 0) {\n            this.pendingEvents.delete(senderKey);\n        }\n    }\n\n    /**\n     * @inheritdoc\n     *\n     * @param {module:models/event.MatrixEvent} event key event\n     */\n    public async onRoomKeyEvent(event: MatrixEvent): Promise<void> {\n        const content = event.getContent<Partial<IMessage[\"content\"]>>();\n        let senderKey = event.getSenderKey();\n        let forwardingKeyChain: string[] = [];\n        let exportFormat = false;\n        let keysClaimed: ReturnType<MatrixEvent[\"getKeysClaimed\"]>;\n\n        if (!content.room_id ||\n            !content.session_key ||\n            !content.session_id ||\n            !content.algorithm\n        ) {\n            logger.error(\"key event is missing fields\");\n            return;\n        }\n\n        if (!senderKey) {\n            logger.error(\"key event has no sender key (not encrypted?)\");\n            return;\n        }\n\n        if (event.getType() == \"m.forwarded_room_key\") {\n            exportFormat = true;\n            forwardingKeyChain = Array.isArray(content.forwarding_curve25519_key_chain) ?\n                content.forwarding_curve25519_key_chain : [];\n\n            // copy content before we modify it\n            forwardingKeyChain = forwardingKeyChain.slice();\n            forwardingKeyChain.push(senderKey);\n\n            if (!content.sender_key) {\n                logger.error(\"forwarded_room_key event is missing sender_key field\");\n                return;\n            }\n            senderKey = content.sender_key;\n\n            const ed25519Key = content.sender_claimed_ed25519_key;\n            if (!ed25519Key) {\n                logger.error(\n                    `forwarded_room_key_event is missing sender_claimed_ed25519_key field`,\n                );\n                return;\n            }\n\n            keysClaimed = {\n                ed25519: ed25519Key,\n            };\n        } else {\n            keysClaimed = event.getKeysClaimed();\n        }\n\n        const extraSessionData: any = {};\n        if (content[\"org.matrix.msc3061.shared_history\"]) {\n            extraSessionData.sharedHistory = true;\n        }\n\n        try {\n            await this.olmDevice.addInboundGroupSession(\n                content.room_id,\n                senderKey,\n                forwardingKeyChain,\n                content.session_id,\n                content.session_key,\n                keysClaimed,\n                exportFormat,\n                extraSessionData,\n            );\n\n            // have another go at decrypting events sent with this session.\n            if (await this.retryDecryption(senderKey, content.session_id)) {\n                // cancel any outstanding room key requests for this session.\n                // Only do this if we managed to decrypt every message in the\n                // session, because if we didn't, we leave the other key\n                // requests in the hopes that someone sends us a key that\n                // includes an earlier index.\n                this.crypto.cancelRoomKeyRequest({\n                    algorithm: content.algorithm,\n                    room_id: content.room_id,\n                    session_id: content.session_id,\n                    sender_key: senderKey,\n                });\n            }\n\n            // don't wait for the keys to be backed up for the server\n            await this.crypto.backupManager.backupGroupSession(senderKey, content.session_id);\n        } catch (e) {\n            logger.error(`Error handling m.room_key_event: ${e}`);\n        }\n    }\n\n    /**\n     * @inheritdoc\n     *\n     * @param {module:models/event.MatrixEvent} event key event\n     */\n    public async onRoomKeyWithheldEvent(event: MatrixEvent): Promise<void> {\n        const content = event.getContent();\n        const senderKey = content.sender_key;\n\n        if (content.code === \"m.no_olm\") {\n            const sender = event.getSender();\n            logger.warn(\n                `${sender}:${senderKey} was unable to establish an olm session with us`,\n            );\n            // if the sender says that they haven't been able to establish an olm\n            // session, let's proactively establish one\n\n            // Note: after we record that the olm session has had a problem, we\n            // trigger retrying decryption for all the messages from the sender's\n            // key, so that we can update the error message to indicate the olm\n            // session problem.\n\n            if (await this.olmDevice.getSessionIdForDevice(senderKey)) {\n                // a session has already been established, so we don't need to\n                // create a new one.\n                logger.debug(\"New session already created.  Not creating a new one.\");\n                await this.olmDevice.recordSessionProblem(senderKey, \"no_olm\", true);\n                this.retryDecryptionFromSender(senderKey);\n                return;\n            }\n            let device = this.crypto.deviceList.getDeviceByIdentityKey(\n                content.algorithm, senderKey,\n            );\n            if (!device) {\n                // if we don't know about the device, fetch the user's devices again\n                // and retry before giving up\n                await this.crypto.downloadKeys([sender], false);\n                device = this.crypto.deviceList.getDeviceByIdentityKey(\n                    content.algorithm, senderKey,\n                );\n                if (!device) {\n                    logger.info(\n                        \"Couldn't find device for identity key \" + senderKey +\n                        \": not establishing session\",\n                    );\n                    await this.olmDevice.recordSessionProblem(senderKey, \"no_olm\", false);\n                    this.retryDecryptionFromSender(senderKey);\n                    return;\n                }\n            }\n            await olmlib.ensureOlmSessionsForDevices(\n                this.olmDevice, this.baseApis, { [sender]: [device] }, false,\n            );\n            const encryptedContent = {\n                algorithm: olmlib.OLM_ALGORITHM,\n                sender_key: this.olmDevice.deviceCurve25519Key,\n                ciphertext: {},\n            };\n            await olmlib.encryptMessageForDevice(\n                encryptedContent.ciphertext,\n                this.userId,\n                undefined,\n                this.olmDevice,\n                sender,\n                device,\n                { type: \"m.dummy\" },\n            );\n\n            await this.olmDevice.recordSessionProblem(senderKey, \"no_olm\", true);\n            this.retryDecryptionFromSender(senderKey);\n\n            await this.baseApis.sendToDevice(\"m.room.encrypted\", {\n                [sender]: {\n                    [device.deviceId]: encryptedContent,\n                },\n            });\n        } else {\n            await this.olmDevice.addInboundGroupSessionWithheld(\n                content.room_id, senderKey, content.session_id, content.code,\n                content.reason,\n            );\n        }\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public hasKeysForKeyRequest(keyRequest: IncomingRoomKeyRequest): Promise<boolean> {\n        const body = keyRequest.requestBody;\n\n        return this.olmDevice.hasInboundSessionKeys(\n            body.room_id,\n            body.sender_key,\n            body.session_id,\n            // TODO: ratchet index\n        );\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public shareKeysWithDevice(keyRequest: IncomingRoomKeyRequest): void {\n        const userId = keyRequest.userId;\n        const deviceId = keyRequest.deviceId;\n        const deviceInfo = this.crypto.getStoredDevice(userId, deviceId);\n        const body = keyRequest.requestBody;\n\n        this.olmlib.ensureOlmSessionsForDevices(\n            this.olmDevice, this.baseApis, {\n                [userId]: [deviceInfo],\n            },\n        ).then((devicemap) => {\n            const olmSessionResult = devicemap[userId][deviceId];\n            if (!olmSessionResult.sessionId) {\n                // no session with this device, probably because there\n                // were no one-time keys.\n                //\n                // ensureOlmSessionsForUsers has already done the logging,\n                // so just skip it.\n                return null;\n            }\n\n            logger.log(\n                \"sharing keys for session \" + body.sender_key + \"|\"\n                + body.session_id + \" with device \"\n                + userId + \":\" + deviceId,\n            );\n\n            return this.buildKeyForwardingMessage(\n                body.room_id, body.sender_key, body.session_id,\n            );\n        }).then((payload) => {\n            const encryptedContent = {\n                algorithm: olmlib.OLM_ALGORITHM,\n                sender_key: this.olmDevice.deviceCurve25519Key,\n                ciphertext: {},\n            };\n\n            return this.olmlib.encryptMessageForDevice(\n                encryptedContent.ciphertext,\n                this.userId,\n                undefined,\n                this.olmDevice,\n                userId,\n                deviceInfo,\n                payload,\n            ).then(() => {\n                const contentMap = {\n                    [userId]: {\n                        [deviceId]: encryptedContent,\n                    },\n                };\n\n                // TODO: retries\n                return this.baseApis.sendToDevice(\"m.room.encrypted\", contentMap);\n            });\n        });\n    }\n\n    private async buildKeyForwardingMessage(\n        roomId: string,\n        senderKey: string,\n        sessionId: string,\n    ): Promise<IKeyForwardingMessage> {\n        const key = await this.olmDevice.getInboundGroupSessionKey(roomId, senderKey, sessionId);\n\n        return {\n            type: \"m.forwarded_room_key\",\n            content: {\n                \"algorithm\": olmlib.MEGOLM_ALGORITHM,\n                \"room_id\": roomId,\n                \"sender_key\": senderKey,\n                \"sender_claimed_ed25519_key\": key.sender_claimed_ed25519_key,\n                \"session_id\": sessionId,\n                \"session_key\": key.key,\n                \"chain_index\": key.chain_index,\n                \"forwarding_curve25519_key_chain\": key.forwarding_curve25519_key_chain,\n                \"org.matrix.msc3061.shared_history\": key.shared_history || false,\n            },\n        };\n    }\n\n    /**\n     * @inheritdoc\n     *\n     * @param {module:crypto/OlmDevice.MegolmSessionData} session\n     * @param {object} [opts={}] options for the import\n     * @param {boolean} [opts.untrusted] whether the key should be considered as untrusted\n     * @param {string} [opts.source] where the key came from\n     */\n    public importRoomKey(\n        session: IMegolmSessionData,\n        opts: { untrusted?: boolean, source?: string } = {},\n    ): Promise<void> {\n        const extraSessionData: any = {};\n        if (opts.untrusted || session.untrusted) {\n            extraSessionData.untrusted = true;\n        }\n        if (session[\"org.matrix.msc3061.shared_history\"]) {\n            extraSessionData.sharedHistory = true;\n        }\n        return this.olmDevice.addInboundGroupSession(\n            session.room_id,\n            session.sender_key,\n            session.forwarding_curve25519_key_chain,\n            session.session_id,\n            session.session_key,\n            session.sender_claimed_keys,\n            true,\n            extraSessionData,\n        ).then(() => {\n            if (opts.source !== \"backup\") {\n                // don't wait for it to complete\n                this.crypto.backupManager.backupGroupSession(\n                    session.sender_key, session.session_id,\n                ).catch((e) => {\n                    // This throws if the upload failed, but this is fine\n                    // since it will have written it to the db and will retry.\n                    logger.log(\"Failed to back up megolm session\", e);\n                });\n            }\n            // have another go at decrypting events sent with this session.\n            this.retryDecryption(session.sender_key, session.session_id);\n        });\n    }\n\n    /**\n     * Have another go at decrypting events after we receive a key. Resolves once\n     * decryption has been re-attempted on all events.\n     *\n     * @private\n     * @param {String} senderKey\n     * @param {String} sessionId\n     *\n     * @return {Boolean} whether all messages were successfully decrypted\n     */\n    private async retryDecryption(senderKey: string, sessionId: string): Promise<boolean> {\n        const senderPendingEvents = this.pendingEvents.get(senderKey);\n        if (!senderPendingEvents) {\n            return true;\n        }\n\n        const pending = senderPendingEvents.get(sessionId);\n        if (!pending) {\n            return true;\n        }\n\n        logger.debug(\"Retrying decryption on events\", [...pending]);\n\n        await Promise.all([...pending].map(async (ev) => {\n            try {\n                await ev.attemptDecryption(this.crypto, { isRetry: true });\n            } catch (e) {\n                // don't die if something goes wrong\n            }\n        }));\n\n        // If decrypted successfully, they'll have been removed from pendingEvents\n        return !this.pendingEvents.get(senderKey)?.has(sessionId);\n    }\n\n    public async retryDecryptionFromSender(senderKey: string): Promise<boolean> {\n        const senderPendingEvents = this.pendingEvents.get(senderKey);\n        if (!senderPendingEvents) {\n            return true;\n        }\n\n        this.pendingEvents.delete(senderKey);\n\n        await Promise.all([...senderPendingEvents].map(async ([_sessionId, pending]) => {\n            await Promise.all([...pending].map(async (ev) => {\n                try {\n                    await ev.attemptDecryption(this.crypto);\n                } catch (e) {\n                    // don't die if something goes wrong\n                }\n            }));\n        }));\n\n        return !this.pendingEvents.has(senderKey);\n    }\n\n    public async sendSharedHistoryInboundSessions(devicesByUser: Record<string, DeviceInfo[]>): Promise<void> {\n        await olmlib.ensureOlmSessionsForDevices(this.olmDevice, this.baseApis, devicesByUser);\n\n        logger.log(\"sendSharedHistoryInboundSessions to users\", Object.keys(devicesByUser));\n\n        const sharedHistorySessions = await this.olmDevice.getSharedHistoryInboundGroupSessions(this.roomId);\n        logger.log(\"shared-history sessions\", sharedHistorySessions);\n        for (const [senderKey, sessionId] of sharedHistorySessions) {\n            const payload = await this.buildKeyForwardingMessage(this.roomId, senderKey, sessionId);\n\n            const promises: Promise<unknown>[] = [];\n            const contentMap: Record<string, Record<string, IEncryptedContent>> = {};\n            for (const [userId, devices] of Object.entries(devicesByUser)) {\n                contentMap[userId] = {};\n                for (const deviceInfo of devices) {\n                    const encryptedContent: IEncryptedContent = {\n                        algorithm: olmlib.OLM_ALGORITHM,\n                        sender_key: this.olmDevice.deviceCurve25519Key,\n                        ciphertext: {},\n                    };\n                    contentMap[userId][deviceInfo.deviceId] = encryptedContent;\n                    promises.push(\n                        olmlib.encryptMessageForDevice(\n                            encryptedContent.ciphertext,\n                            this.userId,\n                            undefined,\n                            this.olmDevice,\n                            userId,\n                            deviceInfo,\n                            payload,\n                        ),\n                    );\n                }\n            }\n            await Promise.all(promises);\n\n            // prune out any devices that encryptMessageForDevice could not encrypt for,\n            // in which case it will have just not added anything to the ciphertext object.\n            // There's no point sending messages to devices if we couldn't encrypt to them,\n            // since that's effectively a blank message.\n            for (const userId of Object.keys(contentMap)) {\n                for (const deviceId of Object.keys(contentMap[userId])) {\n                    if (Object.keys(contentMap[userId][deviceId].ciphertext).length === 0) {\n                        logger.log(\n                            \"No ciphertext for device \" +\n                            userId + \":\" + deviceId + \": pruning\",\n                        );\n                        delete contentMap[userId][deviceId];\n                    }\n                }\n                // No devices left for that user? Strip that too.\n                if (Object.keys(contentMap[userId]).length === 0) {\n                    logger.log(\"Pruned all devices for user \" + userId);\n                    delete contentMap[userId];\n                }\n            }\n\n            // Is there anything left?\n            if (Object.keys(contentMap).length === 0) {\n                logger.log(\"No users left to send to: aborting\");\n                return;\n            }\n\n            await this.baseApis.sendToDevice(\"m.room.encrypted\", contentMap);\n        }\n    }\n}\n\nconst PROBLEM_DESCRIPTIONS = {\n    no_olm: \"The sender was unable to establish a secure channel.\",\n    unknown: \"The secure channel with the sender was corrupted.\",\n};\n\nregisterAlgorithm(olmlib.MEGOLM_ALGORITHM, MegolmEncryption, MegolmDecryption);\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2022-39357", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "/*\n * MediaFinder plugin\n *\n * Data attributes:\n * - data-control=\"mediafinder\" - enables the plugin on an element\n * - data-option=\"value\" - an option with a value\n *\n * JavaScript API:\n * $('a#someElement').mediaFinder({ option: 'value' })\n *\n * Dependences:\n * - Some other plugin (filename.js)\n */\n\n+function ($) { \"use strict\";\n    var Base = $.wn.foundation.base,\n        BaseProto = Base.prototype\n\n    var MediaFinder = function (element, options) {\n        this.$el = $(element)\n        this.options = options || {}\n\n        $.wn.foundation.controlUtils.markDisposable(element)\n        Base.call(this)\n        this.init()\n    }\n\n    MediaFinder.prototype = Object.create(BaseProto)\n    MediaFinder.prototype.constructor = MediaFinder\n\n    MediaFinder.prototype.init = function() {\n        if (this.options.isMulti === null) {\n            this.options.isMulti = this.$el.hasClass('is-multi')\n        }\n\n        if (this.options.isPreview === null) {\n            this.options.isPreview = this.$el.hasClass('is-preview')\n        }\n\n        if (this.options.isImage === null) {\n            this.options.isImage = this.$el.hasClass('is-image')\n        }\n\n        this.$el.one('dispose-control', this.proxy(this.dispose))\n\n        if (this.options.thumbnailWidth > 0) {\n            this.$el.find('[data-find-image]').css('maxWidth', this.options.thumbnailWidth + 'px')\n        }\n\n        else if (this.options.thumbnailHeight > 0) {\n            this.$el.find('[data-find-image]').css('maxHeight', this.options.thumbnailHeight + 'px')\n        }\n\n        // Stop here for preview mode\n        if (this.options.isPreview) {\n            return\n        }\n\n        this.$el.on('click', '.find-button', this.proxy(this.onClickFindButton))\n        this.$el.on('click', '.find-remove-button', this.proxy(this.onClickRemoveButton))\n\n        this.$findValue = $('[data-find-value]', this.$el)\n    }\n\n    MediaFinder.prototype.dispose = function() {\n        this.$el.off('click', '.find-button', this.proxy(this.onClickFindButton))\n        this.$el.off('click', '.find-remove-button', this.proxy(this.onClickRemoveButton))\n        this.$el.off('dispose-control', this.proxy(this.dispose))\n        this.$el.removeData('oc.mediaFinder')\n\n        this.$findValue = null\n        this.$el = null\n\n        // In some cases options could contain callbacks,\n        // so it's better to clean them up too.\n        this.options = null\n\n        BaseProto.dispose.call(this)\n    }\n\n    MediaFinder.prototype.setValue = function(value) {\n        // set value and trigger change event, so that wrapping implementations\n        // like mlmediafinder can listen for changes.\n        this.$findValue.val(value).trigger('change')\n    }\n\n    MediaFinder.prototype.onClickRemoveButton = function() {\n        this.setValue('')\n\n        this.evalIsPopulated()\n    }\n\n    MediaFinder.prototype.onClickFindButton = function() {\n        var self = this\n\n        new $.wn.mediaManager.popup({\n            alias: 'ocmediamanager',\n            cropAndInsertButton: true,\n            onInsert: function(items) {\n                if (!items.length) {\n                    alert('Please select image(s) to insert.')\n                    return\n                }\n\n                if (items.length > 1) {\n                    alert('Please select a single item.')\n                    return\n                }\n\n                var path, publicUrl\n                for (var i=0, len=items.length; i<len; i++) {\n                    path = items[i].path\n                    publicUrl = items[i].publicUrl\n                }\n\n                self.setValue(path)\n\n                if (self.options.isImage) {\n                    $('[data-find-image]', self.$el).attr('src', publicUrl)\n                    $('[data-find-error]', self.$el).hide()\n                }\n\n                self.evalIsPopulated()\n\n                this.hide()\n            }\n        })\n    }\n\n    MediaFinder.prototype.evalIsPopulated = function() {\n        var isPopulated = !!this.$findValue.val()\n        this.$el.toggleClass('is-populated', isPopulated)\n        $('[data-find-file-name]', this.$el).text(this.$findValue.val().substring(1))\n    }\n\n    MediaFinder.DEFAULTS = {\n        isMulti: null,\n        isPreview: null,\n        isImage: null\n    }\n\n    // PLUGIN DEFINITION\n    // ============================\n\n    var old = $.fn.mediaFinder\n\n    $.fn.mediaFinder = function(option) {\n        var args = arguments;\n\n        return this.each(function() {\n            var $this   = $(this)\n            var data    = $this.data('oc.mediaFinder')\n            var options = $.extend({}, MediaFinder.DEFAULTS, $this.data(), typeof option == 'object' && option)\n            if (!data) $this.data('oc.mediaFinder', (data = new MediaFinder(this, options)))\n            if (typeof option == 'string') data[option].apply(data, args)\n        })\n      }\n\n    $.fn.mediaFinder.Constructor = MediaFinder\n\n    $.fn.mediaFinder.noConflict = function() {\n        $.fn.mediaFinder = old\n        return this\n    }\n\n    $(document).render(function() {\n        $('[data-control=\"mediafinder\"]').mediaFinder()\n    })\n\n}(window.jQuery);\n", "output": {"vulnerability_count": 3, "vulnerabilities": [{"description": "User controlled data in a `$(...)` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 20}, {"description": "found alert() call; should this be in production code?", "risk": "Medium", "conceptual_fix": "Not provided", "line": 101}, {"description": "found alert() call; should this be in production code?", "risk": "Medium", "conceptual_fix": "Not provided", "line": 106}]}}
{"CVE": "CVE-2022-42225", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "<template>\n  <IBox v-loading=\"loading\" class=\"box\">\n    <div slot=\"header\" class=\"clearfix ibox-title\">\n      <i class=\"fa fa-comments\" /> {{ $t('common.Message') }}\n    </div>\n    <template v-if=\"comments\">\n      <div v-for=\"item in comments\" :key=\"item.id\" class=\"feed-activity-list\">\n        <div class=\"feed-element\">\n          <a href=\"#\" class=\"pull-left\">\n            <el-avatar :src=\"imageUrl\" size=\"30\" class=\"header-avatar\" />\n          </a>\n          <div class=\"media-body \">\n            <strong>{{ item.user_display }}</strong> <small class=\"text-muted\">{{ formatTime(item.date_created) }}</small>\n            <br>\n            <small class=\"text-muted\">{{ toSafeLocalDateStr(item.date_created) }}</small>\n            <div style=\"padding-top: 10px;\" v-html=\"item.body\" />\n          </div>\n        </div>\n      </div>\n    </template>\n    <slot />\n    <el-form ref=\"comments\" :model=\"form\" label-width=\"45px\" style=\"padding-top: 20px\">\n      <el-form-item :label=\"$t('tickets.reply')\">\n        <el-input v-model=\"form.comments\" :autosize=\"{ minRows: 4 }\" type=\"textarea\" />\n      </el-form-item>\n      <el-form-item style=\"float: right\">\n        <template v-if=\"hasActionPerm\">\n          <el-button\n            :disabled=\"object.status === 'closed'\"\n            type=\"primary\"\n            size=\"small\"\n            @click=\"handleApprove\"\n          >\n            <i class=\"fa fa-check\" /> {{ $t('tickets.Accept') }}\n          </el-button>\n          <el-button\n            :disabled=\"object.status === 'closed'\"\n            type=\"warning\"\n            size=\"small\"\n            @click=\"handleReject\"\n          >\n            <i class=\"fa fa-ban\" /> {{ $t('tickets.Reject') }}\n          </el-button>\n        </template>\n        <el-button\n          v-if=\"isSelfTicket\"\n          :disabled=\"object.status === 'closed'\"\n          type=\"danger\"\n          size=\"small\"\n          @click=\"handleClose\"\n        >\n          <i class=\"fa fa-times\" /> {{ $t('tickets.Close') }}\n        </el-button>\n        <el-button\n          :disabled=\"object.status === 'closed'\"\n          type=\"info\"\n          size=\"small\"\n          @click=\"handleComment\"\n        >\n          <i class=\"fa fa-pencil\" /> {{ $t('tickets.reply') }}\n        </el-button>\n      </el-form-item>\n    </el-form>\n  </IBox>\n</template>\n\n<script>\nimport IBox from '@/components/IBox'\nimport { formatTime, getDateTimeStamp } from '@/utils'\nimport { toSafeLocalDateStr } from '@/utils/common'\nexport default {\n  name: 'Comments',\n  components: { IBox },\n  props: {\n    object: {\n      type: Object,\n      default: () => ({})\n    },\n    approve: {\n      type: Function,\n      default: null\n    },\n    reject: {\n      type: Function,\n      default: null\n    },\n    close: {\n      type: Function,\n      default: null\n    }\n  },\n  data() {\n    return {\n      comments: '',\n      type_api: '',\n      imageUrl: require('@/assets/img/admin.png'),\n      form: {\n        comments: ''\n      },\n      loading: false\n    }\n  },\n  computed: {\n    hasActionPerm() {\n      return this.object.process_map[this.object.approval_step - 1].assignees.indexOf(this.$store.state.users.profile.id) !== -1\n    },\n    isSelfTicket() {\n      return this.object.applicant === this.$store.state.users.profile.id\n    }\n  },\n  mounted() {\n    switch (this.object.type) {\n      case 'login_confirm':\n        this.type_api = 'apply-login-tickets'\n        break\n      case 'apply_asset':\n        this.type_api = 'apply-asset-tickets'\n        break\n      case 'apply_application':\n        this.type_api = 'apply-app-tickets'\n        break\n      case 'login_asset_confirm':\n        this.type_api = 'apply-login-asset-tickets'\n        break\n      case 'command_confirm':\n        this.type_api = 'apply-command-tickets'\n        break\n      default:\n        this.type_api = 'tickets'\n    }\n    this.getComment()\n  },\n  methods: {\n    formatTime(dateStr) {\n      return formatTime(getDateTimeStamp(dateStr))\n    },\n    toSafeLocalDateStr(dataStr) {\n      return toSafeLocalDateStr(dataStr)\n    },\n    getComment() {\n      this.loading = true\n      const url = `/api/v1/tickets/comments/?ticket_id=${this.object.id}`\n      this.$axios.get(url).then(res => {\n        this.comments = res\n      }).catch(err => {\n        this.$message.error(err)\n      }).finally(() => {\n        this.loading = false\n        this.form.comments = ''\n      })\n    },\n    defaultApprove() {\n      this.createComment(function() {\n      })\n      const url = `/api/v1/tickets/${this.type_api}/${this.object.id}/approve/`\n      this.$axios.put(url).then(res => this.reloadPage()).catch(err => this.$message.error(err))\n    },\n    defaultReject() {\n      this.createComment(function() {})\n      const url = `/api/v1/tickets/${this.type_api}/${this.object.id}/reject/`\n      this.$axios.put(url).then(res => this.reloadPage()).catch(err => this.$message.error(err))\n    },\n    defaultClose() {\n      const url = `/api/v1/tickets/${this.type_api}/${this.object.id}/close/`\n      this.$axios.put(url).then(res => this.reloadPage()).catch(err => this.$message.error(err))\n    },\n    createComment(successCallback) {\n      const commentText = this.form.comments\n      const ticketId = this.object.id\n      const commentUrl = `/api/v1/tickets/comments/?ticket_id=${this.object.id}`\n      if (!commentText) { return }\n      const body = {\n        body: commentText,\n        ticket: ticketId\n      }\n      this.$axios.post(commentUrl, body).then(res => {\n        if (successCallback) {\n          successCallback()\n        } else {\n          this.reloadPage()\n        }\n      })\n    },\n    handleApprove() {\n      const handler = this.approve || this.defaultApprove\n      handler()\n    },\n    handleReject() {\n      const handler = this.reject || this.defaultReject\n      handler()\n    },\n    handleClose() {\n      const handler = this.close || this.defaultClose\n      handler()\n    },\n    handleComment() {\n      this.createComment(\n        this.getComment\n      )\n    },\n    reloadPage() {\n      window.location.reload()\n    }\n  }\n\n}\n</script>\n\n<style lang='less' scoped>\n.box {\n  margin-bottom: 15px;\n}\n.feed-activity-list {\n  //padding-top: 20px;\n  line-height: 1.5;\n}\n.feed-activity-list .feed-element {\n  border-bottom: 1px solid #e7eaec;\n}\n.feed-element:first-child {\n  margin-top: 0;\n}\n.feed-element {\n  padding-top: 15px;\n  padding-bottom: 15px;\n}\n\n.feed-element,\n.media-body {\n  overflow: hidden;\n}\n.feed-element > .pull-left {\n  margin-right: 10px;\n}\n.feed-element .header-avatar {\n  width: 38px;\n  height: 38px;\n}\n.text-muted {\n  color: #888888;\n}\n</style>\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2022-46155", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "require=(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n\"use strict\";\n// istanbul ignore file\nvar AbortController;\nif (typeof window === 'undefined') {\n    AbortController = require('abort-controller');\n}\nelse if ('signal' in new Request('')) {\n    AbortController = window.AbortController;\n}\nelse {\n    /* eslint-disable @typescript-eslint/no-var-requires */\n    var polyfill = require('abortcontroller-polyfill/dist/cjs-ponyfill');\n    /* eslint-enable @typescript-eslint/no-var-requires */\n    AbortController = polyfill.AbortController;\n}\nmodule.exports = AbortController;\n\n},{\"abort-controller\":20,\"abortcontroller-polyfill/dist/cjs-ponyfill\":19}],2:[function(require,module,exports){\n\"use strict\";\nvar AirtableError = /** @class */ (function () {\n    function AirtableError(error, message, statusCode) {\n        this.error = error;\n        this.message = message;\n        this.statusCode = statusCode;\n    }\n    AirtableError.prototype.toString = function () {\n        return [\n            this.message,\n            '(',\n            this.error,\n            ')',\n            this.statusCode ? \"[Http code \" + this.statusCode + \"]\" : '',\n        ].join('');\n    };\n    return AirtableError;\n}());\nmodule.exports = AirtableError;\n\n},{}],3:[function(require,module,exports){\n\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar get_1 = __importDefault(require(\"lodash/get\"));\nvar isPlainObject_1 = __importDefault(require(\"lodash/isPlainObject\"));\nvar keys_1 = __importDefault(require(\"lodash/keys\"));\nvar fetch_1 = __importDefault(require(\"./fetch\"));\nvar abort_controller_1 = __importDefault(require(\"./abort-controller\"));\nvar object_to_query_param_string_1 = __importDefault(require(\"./object_to_query_param_string\"));\nvar airtable_error_1 = __importDefault(require(\"./airtable_error\"));\nvar table_1 = __importDefault(require(\"./table\"));\nvar http_headers_1 = __importDefault(require(\"./http_headers\"));\nvar run_action_1 = __importDefault(require(\"./run_action\"));\nvar package_version_1 = __importDefault(require(\"./package_version\"));\nvar exponential_backoff_with_jitter_1 = __importDefault(require(\"./exponential_backoff_with_jitter\"));\nvar userAgent = \"Airtable.js/\" + package_version_1.default;\nvar Base = /** @class */ (function () {\n    function Base(airtable, baseId) {\n        this._airtable = airtable;\n        this._id = baseId;\n    }\n    Base.prototype.table = function (tableName) {\n        return new table_1.default(this, null, tableName);\n    };\n    Base.prototype.makeRequest = function (options) {\n        var _this = this;\n        var _a;\n        if (options === void 0) { options = {}; }\n        var method = get_1.default(options, 'method', 'GET').toUpperCase();\n        var url = this._airtable._endpointUrl + \"/v\" + this._airtable._apiVersionMajor + \"/\" + this._id + get_1.default(options, 'path', '/') + \"?\" + object_to_query_param_string_1.default(get_1.default(options, 'qs', {}));\n        var controller = new abort_controller_1.default();\n        var headers = this._getRequestHeaders(Object.assign({}, this._airtable._customHeaders, (_a = options.headers) !== null && _a !== void 0 ? _a : {}));\n        var requestOptions = {\n            method: method,\n            headers: headers,\n            signal: controller.signal,\n        };\n        if ('body' in options && _canRequestMethodIncludeBody(method)) {\n            requestOptions.body = JSON.stringify(options.body);\n        }\n        var timeout = setTimeout(function () {\n            controller.abort();\n        }, this._airtable._requestTimeout);\n        return new Promise(function (resolve, reject) {\n            fetch_1.default(url, requestOptions)\n                .then(function (resp) {\n                clearTimeout(timeout);\n                if (resp.status === 429 && !_this._airtable._noRetryIfRateLimited) {\n                    var numAttempts_1 = get_1.default(options, '_numAttempts', 0);\n                    var backoffDelayMs = exponential_backoff_with_jitter_1.default(numAttempts_1);\n                    setTimeout(function () {\n                        var newOptions = __assign(__assign({}, options), { _numAttempts: numAttempts_1 + 1 });\n                        _this.makeRequest(newOptions)\n                            .then(resolve)\n                            .catch(reject);\n                    }, backoffDelayMs);\n                }\n                else {\n                    resp.json()\n                        .then(function (body) {\n                        var err = _this._checkStatusForError(resp.status, body) ||\n                            _getErrorForNonObjectBody(resp.status, body);\n                        if (err) {\n                            reject(err);\n                        }\n                        else {\n                            resolve({\n                                statusCode: resp.status,\n                                headers: resp.headers,\n                                body: body,\n                            });\n                        }\n                    })\n                        .catch(function () {\n                        var err = _getErrorForNonObjectBody(resp.status);\n                        reject(err);\n                    });\n                }\n            })\n                .catch(function (err) {\n                clearTimeout(timeout);\n                err = new airtable_error_1.default('CONNECTION_ERROR', err.message, null);\n                reject(err);\n            });\n        });\n    };\n    /**\n     * @deprecated This method is deprecated.\n     */\n    Base.prototype.runAction = function (method, path, queryParams, bodyData, callback) {\n        run_action_1.default(this, method, path, queryParams, bodyData, callback, 0);\n    };\n    Base.prototype._getRequestHeaders = function (headers) {\n        var result = new http_headers_1.default();\n        result.set('Authorization', \"Bearer \" + this._airtable._apiKey);\n        result.set('User-Agent', userAgent);\n        result.set('Content-Type', 'application/json');\n        for (var _i = 0, _a = keys_1.default(headers); _i < _a.length; _i++) {\n            var headerKey = _a[_i];\n            result.set(headerKey, headers[headerKey]);\n        }\n        return result.toJSON();\n    };\n    Base.prototype._checkStatusForError = function (statusCode, body) {\n        var _a = (body !== null && body !== void 0 ? body : { error: {} }).error, error = _a === void 0 ? {} : _a;\n        var type = error.type, message = error.message;\n        if (statusCode === 401) {\n            return new airtable_error_1.default('AUTHENTICATION_REQUIRED', 'You should provide valid api key to perform this operation', statusCode);\n        }\n        else if (statusCode === 403) {\n            return new airtable_error_1.default('NOT_AUTHORIZED', 'You are not authorized to perform this operation', statusCode);\n        }\n        else if (statusCode === 404) {\n            return new airtable_error_1.default('NOT_FOUND', message !== null && message !== void 0 ? message : 'Could not find what you are looking for', statusCode);\n        }\n        else if (statusCode === 413) {\n            return new airtable_error_1.default('REQUEST_TOO_LARGE', 'Request body is too large', statusCode);\n        }\n        else if (statusCode === 422) {\n            return new airtable_error_1.default(type !== null && type !== void 0 ? type : 'UNPROCESSABLE_ENTITY', message !== null && message !== void 0 ? message : 'The operation cannot be processed', statusCode);\n        }\n        else if (statusCode === 429) {\n            return new airtable_error_1.default('TOO_MANY_REQUESTS', 'You have made too many requests in a short period of time. Please retry your request later', statusCode);\n        }\n        else if (statusCode === 500) {\n            return new airtable_error_1.default('SERVER_ERROR', 'Try again. If the problem persists, contact support.', statusCode);\n        }\n        else if (statusCode === 503) {\n            return new airtable_error_1.default('SERVICE_UNAVAILABLE', 'The service is temporarily unavailable. Please retry shortly.', statusCode);\n        }\n        else if (statusCode >= 400) {\n            return new airtable_error_1.default(type !== null && type !== void 0 ? type : 'UNEXPECTED_ERROR', message !== null && message !== void 0 ? message : 'An unexpected error occurred', statusCode);\n        }\n        else {\n            return null;\n        }\n    };\n    Base.prototype.doCall = function (tableName) {\n        return this.table(tableName);\n    };\n    Base.prototype.getId = function () {\n        return this._id;\n    };\n    Base.createFunctor = function (airtable, baseId) {\n        var base = new Base(airtable, baseId);\n        var baseFn = function (tableName) {\n            return base.doCall(tableName);\n        };\n        baseFn._base = base;\n        baseFn.table = base.table.bind(base);\n        baseFn.makeRequest = base.makeRequest.bind(base);\n        baseFn.runAction = base.runAction.bind(base);\n        baseFn.getId = base.getId.bind(base);\n        return baseFn;\n    };\n    return Base;\n}());\nfunction _canRequestMethodIncludeBody(method) {\n    return method !== 'GET' && method !== 'DELETE';\n}\nfunction _getErrorForNonObjectBody(statusCode, body) {\n    if (isPlainObject_1.default(body)) {\n        return null;\n    }\n    else {\n        return new airtable_error_1.default('UNEXPECTED_ERROR', 'The response from Airtable was invalid JSON. Please try again soon.', statusCode);\n    }\n}\nmodule.exports = Base;\n\n},{\"./abort-controller\":1,\"./airtable_error\":2,\"./exponential_backoff_with_jitter\":6,\"./fetch\":7,\"./http_headers\":9,\"./object_to_query_param_string\":11,\"./package_version\":12,\"./run_action\":16,\"./table\":17,\"lodash/get\":77,\"lodash/isPlainObject\":89,\"lodash/keys\":93}],4:[function(require,module,exports){\n\"use strict\";\n/**\n * Given a function fn that takes a callback as its last argument, returns\n * a new version of the function that takes the callback optionally. If\n * the function is not called with a callback for the last argument, the\n * function will return a promise instead.\n */\n/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types */\nfunction callbackToPromise(fn, context, callbackArgIndex) {\n    if (callbackArgIndex === void 0) { callbackArgIndex = void 0; }\n    /* eslint-enable @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types */\n    return function () {\n        var callArgs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            callArgs[_i] = arguments[_i];\n        }\n        var thisCallbackArgIndex;\n        if (callbackArgIndex === void 0) {\n            // istanbul ignore next\n            thisCallbackArgIndex = callArgs.length > 0 ? callArgs.length - 1 : 0;\n        }\n        else {\n            thisCallbackArgIndex = callbackArgIndex;\n        }\n        var callbackArg = callArgs[thisCallbackArgIndex];\n        if (typeof callbackArg === 'function') {\n            fn.apply(context, callArgs);\n            return void 0;\n        }\n        else {\n            var args_1 = [];\n            // If an explicit callbackArgIndex is set, but the function is called\n            // with too few arguments, we want to push undefined onto args so that\n            // our constructed callback ends up at the right index.\n            var argLen = Math.max(callArgs.length, thisCallbackArgIndex);\n            for (var i = 0; i < argLen; i++) {\n                args_1.push(callArgs[i]);\n            }\n            return new Promise(function (resolve, reject) {\n                args_1.push(function (err, result) {\n                    if (err) {\n                        reject(err);\n                    }\n                    else {\n                        resolve(result);\n                    }\n                });\n                fn.apply(context, args_1);\n            });\n        }\n    };\n}\nmodule.exports = callbackToPromise;\n\n},{}],5:[function(require,module,exports){\n\"use strict\";\nvar didWarnForDeprecation = {};\n/**\n * Convenience function for marking a function as deprecated.\n *\n * Will emit a warning the first time that function is called.\n *\n * @param fn the function to mark as deprecated.\n * @param key a unique key identifying the function.\n * @param message the warning message.\n *\n * @return a wrapped function\n */\nfunction deprecate(fn, key, message) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (!didWarnForDeprecation[key]) {\n            didWarnForDeprecation[key] = true;\n            console.warn(message);\n        }\n        fn.apply(this, args);\n    };\n}\nmodule.exports = deprecate;\n\n},{}],6:[function(require,module,exports){\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar internal_config_json_1 = __importDefault(require(\"./internal_config.json\"));\n// \"Full Jitter\" algorithm taken from https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/\nfunction exponentialBackoffWithJitter(numberOfRetries) {\n    var rawBackoffTimeMs = internal_config_json_1.default.INITIAL_RETRY_DELAY_IF_RATE_LIMITED * Math.pow(2, numberOfRetries);\n    var clippedBackoffTimeMs = Math.min(internal_config_json_1.default.MAX_RETRY_DELAY_IF_RATE_LIMITED, rawBackoffTimeMs);\n    var jitteredBackoffTimeMs = Math.random() * clippedBackoffTimeMs;\n    return jitteredBackoffTimeMs;\n}\nmodule.exports = exponentialBackoffWithJitter;\n\n},{\"./internal_config.json\":10}],7:[function(require,module,exports){\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\n// istanbul ignore file\nvar node_fetch_1 = __importDefault(require(\"node-fetch\"));\nmodule.exports = typeof window === 'undefined' ? node_fetch_1.default : window.fetch.bind(window);\n\n},{\"node-fetch\":20}],8:[function(require,module,exports){\n\"use strict\";\n/* eslint-enable @typescript-eslint/no-explicit-any */\nfunction has(object, property) {\n    return Object.prototype.hasOwnProperty.call(object, property);\n}\nmodule.exports = has;\n\n},{}],9:[function(require,module,exports){\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar keys_1 = __importDefault(require(\"lodash/keys\"));\nvar isBrowser = typeof window !== 'undefined';\nvar HttpHeaders = /** @class */ (function () {\n    function HttpHeaders() {\n        this._headersByLowercasedKey = {};\n    }\n    HttpHeaders.prototype.set = function (headerKey, headerValue) {\n        var lowercasedKey = headerKey.toLowerCase();\n        if (lowercasedKey === 'x-airtable-user-agent') {\n            lowercasedKey = 'user-agent';\n            headerKey = 'User-Agent';\n        }\n        this._headersByLowercasedKey[lowercasedKey] = {\n            headerKey: headerKey,\n            headerValue: headerValue,\n        };\n    };\n    HttpHeaders.prototype.toJSON = function () {\n        var result = {};\n        for (var _i = 0, _a = keys_1.default(this._headersByLowercasedKey); _i < _a.length; _i++) {\n            var lowercasedKey = _a[_i];\n            var headerDefinition = this._headersByLowercasedKey[lowercasedKey];\n            var headerKey = void 0;\n            /* istanbul ignore next */\n            if (isBrowser && lowercasedKey === 'user-agent') {\n                // Some browsers do not allow overriding the user agent.\n                // https://github.com/Airtable/airtable.js/issues/52\n                headerKey = 'X-Airtable-User-Agent';\n            }\n            else {\n                headerKey = headerDefinition.headerKey;\n            }\n            result[headerKey] = headerDefinition.headerValue;\n        }\n        return result;\n    };\n    return HttpHeaders;\n}());\nmodule.exports = HttpHeaders;\n\n},{\"lodash/keys\":93}],10:[function(require,module,exports){\nmodule.exports={\n    \"INITIAL_RETRY_DELAY_IF_RATE_LIMITED\": 5000,\n    \"MAX_RETRY_DELAY_IF_RATE_LIMITED\": 600000\n}\n\n},{}],11:[function(require,module,exports){\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar isArray_1 = __importDefault(require(\"lodash/isArray\"));\nvar isNil_1 = __importDefault(require(\"lodash/isNil\"));\nvar keys_1 = __importDefault(require(\"lodash/keys\"));\n/* eslint-enable @typescript-eslint/no-explicit-any */\n// Adapted from jQuery.param:\n// https://github.com/jquery/jquery/blob/2.2-stable/src/serialize.js\nfunction buildParams(prefix, obj, addFn) {\n    if (isArray_1.default(obj)) {\n        // Serialize array item.\n        for (var index = 0; index < obj.length; index++) {\n            var value = obj[index];\n            if (/\\[\\]$/.test(prefix)) {\n                // Treat each array item as a scalar.\n                addFn(prefix, value);\n            }\n            else {\n                // Item is non-scalar (array or object), encode its numeric index.\n                buildParams(prefix + \"[\" + (typeof value === 'object' && value !== null ? index : '') + \"]\", value, addFn);\n            }\n        }\n    }\n    else if (typeof obj === 'object') {\n        // Serialize object item.\n        for (var _i = 0, _a = keys_1.default(obj); _i < _a.length; _i++) {\n            var key = _a[_i];\n            var value = obj[key];\n            buildParams(prefix + \"[\" + key + \"]\", value, addFn);\n        }\n    }\n    else {\n        // Serialize scalar item.\n        addFn(prefix, obj);\n    }\n}\nfunction objectToQueryParamString(obj) {\n    var parts = [];\n    var addFn = function (key, value) {\n        value = isNil_1.default(value) ? '' : value;\n        parts.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(value));\n    };\n    for (var _i = 0, _a = keys_1.default(obj); _i < _a.length; _i++) {\n        var key = _a[_i];\n        var value = obj[key];\n        buildParams(key, value, addFn);\n    }\n    return parts.join('&').replace(/%20/g, '+');\n}\nmodule.exports = objectToQueryParamString;\n\n},{\"lodash/isArray\":79,\"lodash/isNil\":85,\"lodash/keys\":93}],12:[function(require,module,exports){\n\"use strict\";\nmodule.exports = \"0.11.5\";\n\n},{}],13:[function(require,module,exports){\n\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar isFunction_1 = __importDefault(require(\"lodash/isFunction\"));\nvar keys_1 = __importDefault(require(\"lodash/keys\"));\nvar record_1 = __importDefault(require(\"./record\"));\nvar callback_to_promise_1 = __importDefault(require(\"./callback_to_promise\"));\nvar has_1 = __importDefault(require(\"./has\"));\nvar query_params_1 = require(\"./query_params\");\nvar object_to_query_param_string_1 = __importDefault(require(\"./object_to_query_param_string\"));\n/**\n * Builds a query object. Won't fetch until `firstPage` or\n * or `eachPage` is called.\n *\n * Params should be validated prior to being passed to Query\n * with `Query.validateParams`.\n */\nvar Query = /** @class */ (function () {\n    function Query(table, params) {\n        this._table = table;\n        this._params = params;\n        this.firstPage = callback_to_promise_1.default(firstPage, this);\n        this.eachPage = callback_to_promise_1.default(eachPage, this, 1);\n        this.all = callback_to_promise_1.default(all, this);\n    }\n    /**\n     * Validates the parameters for passing to the Query constructor.\n     *\n     * @params {object} params parameters to validate\n     *\n     * @return an object with two keys:\n     *  validParams: the object that should be passed to the constructor.\n     *  ignoredKeys: a list of keys that will be ignored.\n     *  errors: a list of error messages.\n     */\n    Query.validateParams = function (params) {\n        var validParams = {};\n        var ignoredKeys = [];\n        var errors = [];\n        for (var _i = 0, _a = keys_1.default(params); _i < _a.length; _i++) {\n            var key = _a[_i];\n            var value = params[key];\n            if (has_1.default(Query.paramValidators, key)) {\n                var validator = Query.paramValidators[key];\n                var validationResult = validator(value);\n                if (validationResult.pass) {\n                    validParams[key] = value;\n                }\n                else {\n                    errors.push(validationResult.error);\n                }\n            }\n            else {\n                ignoredKeys.push(key);\n            }\n        }\n        return {\n            validParams: validParams,\n            ignoredKeys: ignoredKeys,\n            errors: errors,\n        };\n    };\n    Query.paramValidators = query_params_1.paramValidators;\n    return Query;\n}());\n/**\n * Fetches the first page of results for the query asynchronously,\n * then calls `done(error, records)`.\n */\nfunction firstPage(done) {\n    if (!isFunction_1.default(done)) {\n        throw new Error('The first parameter to `firstPage` must be a function');\n    }\n    this.eachPage(function (records) {\n        done(null, records);\n    }, function (error) {\n        done(error, null);\n    });\n}\n/**\n * Fetches each page of results for the query asynchronously.\n *\n * Calls `pageCallback(records, fetchNextPage)` for each\n * page. You must call `fetchNextPage()` to fetch the next page of\n * results.\n *\n * After fetching all pages, or if there's an error, calls\n * `done(error)`.\n */\nfunction eachPage(pageCallback, done) {\n    var _this = this;\n    if (!isFunction_1.default(pageCallback)) {\n        throw new Error('The first parameter to `eachPage` must be a function');\n    }\n    if (!isFunction_1.default(done) && done !== void 0) {\n        throw new Error('The second parameter to `eachPage` must be a function or undefined');\n    }\n    var params = __assign({}, this._params);\n    var pathAndParamsAsString = \"/\" + this._table._urlEncodedNameOrId() + \"?\" + object_to_query_param_string_1.default(params);\n    var queryParams = {};\n    var requestData = null;\n    var method;\n    var path;\n    if (params.method === 'post' || pathAndParamsAsString.length > query_params_1.URL_CHARACTER_LENGTH_LIMIT) {\n        // There is a 16kb limit on GET requests. Since the URL makes up nearly all of the request size, we check for any requests that\n        // that come close to this limit and send it as a POST instead. Additionally, we'll send the request as a post if it is specified\n        // with the request params\n        requestData = params;\n        method = 'post';\n        path = \"/\" + this._table._urlEncodedNameOrId() + \"/listRecords\";\n        var paramNames = Object.keys(params);\n        for (var _i = 0, paramNames_1 = paramNames; _i < paramNames_1.length; _i++) {\n            var paramName = paramNames_1[_i];\n            if (query_params_1.shouldListRecordsParamBePassedAsParameter(paramName)) {\n                // timeZone and userLocale is parsed from the GET request separately from the other params. This parsing\n                // does not occurring within the body parser we use for POST requests, so this will still need to be passed\n                // via query params\n                queryParams[paramName] = params[paramName];\n            }\n            else {\n                requestData[paramName] = params[paramName];\n            }\n        }\n    }\n    else {\n        method = 'get';\n        queryParams = params;\n        path = \"/\" + this._table._urlEncodedNameOrId();\n    }\n    var inner = function () {\n        _this._table._base.runAction(method, path, queryParams, requestData, function (err, response, result) {\n            if (err) {\n                done(err, null);\n            }\n            else {\n                var next = void 0;\n                if (result.offset) {\n                    params.offset = result.offset;\n                    next = inner;\n                }\n                else {\n                    next = function () {\n                        done(null);\n                    };\n                }\n                var records = result.records.map(function (recordJson) {\n                    return new record_1.default(_this._table, null, recordJson);\n                });\n                pageCallback(records, next);\n            }\n        });\n    };\n    inner();\n}\n/**\n * Fetches all pages of results asynchronously. May take a long time.\n */\nfunction all(done) {\n    if (!isFunction_1.default(done)) {\n        throw new Error('The first parameter to `all` must be a function');\n    }\n    var allRecords = [];\n    this.eachPage(function (pageRecords, fetchNextPage) {\n        allRecords.push.apply(allRecords, pageRecords);\n        fetchNextPage();\n    }, function (err) {\n        if (err) {\n            done(err, null);\n        }\n        else {\n            done(null, allRecords);\n        }\n    });\n}\nmodule.exports = Query;\n\n},{\"./callback_to_promise\":4,\"./has\":8,\"./object_to_query_param_string\":11,\"./query_params\":14,\"./record\":15,\"lodash/isFunction\":83,\"lodash/keys\":93}],14:[function(require,module,exports){\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.shouldListRecordsParamBePassedAsParameter = exports.URL_CHARACTER_LENGTH_LIMIT = exports.paramValidators = void 0;\nvar typecheck_1 = __importDefault(require(\"./typecheck\"));\nvar isString_1 = __importDefault(require(\"lodash/isString\"));\nvar isNumber_1 = __importDefault(require(\"lodash/isNumber\"));\nvar isPlainObject_1 = __importDefault(require(\"lodash/isPlainObject\"));\nvar isBoolean_1 = __importDefault(require(\"lodash/isBoolean\"));\nexports.paramValidators = {\n    fields: typecheck_1.default(typecheck_1.default.isArrayOf(isString_1.default), 'the value for `fields` should be an array of strings'),\n    filterByFormula: typecheck_1.default(isString_1.default, 'the value for `filterByFormula` should be a string'),\n    maxRecords: typecheck_1.default(isNumber_1.default, 'the value for `maxRecords` should be a number'),\n    pageSize: typecheck_1.default(isNumber_1.default, 'the value for `pageSize` should be a number'),\n    offset: typecheck_1.default(isNumber_1.default, 'the value for `offset` should be a number'),\n    sort: typecheck_1.default(typecheck_1.default.isArrayOf(function (obj) {\n        return (isPlainObject_1.default(obj) &&\n            isString_1.default(obj.field) &&\n            (obj.direction === void 0 || ['asc', 'desc'].includes(obj.direction)));\n    }), 'the value for `sort` should be an array of sort objects. ' +\n        'Each sort object must have a string `field` value, and an optional ' +\n        '`direction` value that is \"asc\" or \"desc\".'),\n    view: typecheck_1.default(isString_1.default, 'the value for `view` should be a string'),\n    cellFormat: typecheck_1.default(function (cellFormat) {\n        return isString_1.default(cellFormat) && ['json', 'string'].includes(cellFormat);\n    }, 'the value for `cellFormat` should be \"json\" or \"string\"'),\n    timeZone: typecheck_1.default(isString_1.default, 'the value for `timeZone` should be a string'),\n    userLocale: typecheck_1.default(isString_1.default, 'the value for `userLocale` should be a string'),\n    method: typecheck_1.default(function (method) {\n        return isString_1.default(method) && ['get', 'post'].includes(method);\n    }, 'the value for `method` should be \"get\" or \"post\"'),\n    returnFieldsByFieldId: typecheck_1.default(isBoolean_1.default, 'the value for `returnFieldsByFieldId` should be a boolean'),\n};\nexports.URL_CHARACTER_LENGTH_LIMIT = 15000;\nexports.shouldListRecordsParamBePassedAsParameter = function (paramName) {\n    return paramName === 'timeZone' || paramName === 'userLocale';\n};\n\n},{\"./typecheck\":18,\"lodash/isBoolean\":81,\"lodash/isNumber\":86,\"lodash/isPlainObject\":89,\"lodash/isString\":90}],15:[function(require,module,exports){\n\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar callback_to_promise_1 = __importDefault(require(\"./callback_to_promise\"));\nvar Record = /** @class */ (function () {\n    function Record(table, recordId, recordJson) {\n        this._table = table;\n        this.id = recordId || recordJson.id;\n        this.setRawJson(recordJson);\n        this.save = callback_to_promise_1.default(save, this);\n        this.patchUpdate = callback_to_promise_1.default(patchUpdate, this);\n        this.putUpdate = callback_to_promise_1.default(putUpdate, this);\n        this.destroy = callback_to_promise_1.default(destroy, this);\n        this.fetch = callback_to_promise_1.default(fetch, this);\n        this.updateFields = this.patchUpdate;\n        this.replaceFields = this.putUpdate;\n    }\n    Record.prototype.getId = function () {\n        return this.id;\n    };\n    Record.prototype.get = function (columnName) {\n        return this.fields[columnName];\n    };\n    Record.prototype.set = function (columnName, columnValue) {\n        this.fields[columnName] = columnValue;\n    };\n    Record.prototype.setRawJson = function (rawJson) {\n        this._rawJson = rawJson;\n        this.fields = (this._rawJson && this._rawJson.fields) || {};\n    };\n    return Record;\n}());\nfunction save(done) {\n    this.putUpdate(this.fields, done);\n}\nfunction patchUpdate(cellValuesByName, opts, done) {\n    var _this = this;\n    if (!done) {\n        done = opts;\n        opts = {};\n    }\n    var updateBody = __assign({ fields: cellValuesByName }, opts);\n    this._table._base.runAction('patch', \"/\" + this._table._urlEncodedNameOrId() + \"/\" + this.id, {}, updateBody, function (err, response, results) {\n        if (err) {\n            done(err);\n            return;\n        }\n        _this.setRawJson(results);\n        done(null, _this);\n    });\n}\nfunction putUpdate(cellValuesByName, opts, done) {\n    var _this = this;\n    if (!done) {\n        done = opts;\n        opts = {};\n    }\n    var updateBody = __assign({ fields: cellValuesByName }, opts);\n    this._table._base.runAction('put', \"/\" + this._table._urlEncodedNameOrId() + \"/\" + this.id, {}, updateBody, function (err, response, results) {\n        if (err) {\n            done(err);\n            return;\n        }\n        _this.setRawJson(results);\n        done(null, _this);\n    });\n}\nfunction destroy(done) {\n    var _this = this;\n    this._table._base.runAction('delete', \"/\" + this._table._urlEncodedNameOrId() + \"/\" + this.id, {}, null, function (err) {\n        if (err) {\n            done(err);\n            return;\n        }\n        done(null, _this);\n    });\n}\nfunction fetch(done) {\n    var _this = this;\n    this._table._base.runAction('get', \"/\" + this._table._urlEncodedNameOrId() + \"/\" + this.id, {}, null, function (err, response, results) {\n        if (err) {\n            done(err);\n            return;\n        }\n        _this.setRawJson(results);\n        done(null, _this);\n    });\n}\nmodule.exports = Record;\n\n},{\"./callback_to_promise\":4}],16:[function(require,module,exports){\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar exponential_backoff_with_jitter_1 = __importDefault(require(\"./exponential_backoff_with_jitter\"));\nvar object_to_query_param_string_1 = __importDefault(require(\"./object_to_query_param_string\"));\nvar package_version_1 = __importDefault(require(\"./package_version\"));\nvar fetch_1 = __importDefault(require(\"./fetch\"));\nvar abort_controller_1 = __importDefault(require(\"./abort-controller\"));\nvar userAgent = \"Airtable.js/\" + package_version_1.default;\nfunction runAction(base, method, path, queryParams, bodyData, callback, numAttempts) {\n    var url = base._airtable._endpointUrl + \"/v\" + base._airtable._apiVersionMajor + \"/\" + base._id + path + \"?\" + object_to_query_param_string_1.default(queryParams);\n    var headers = {\n        authorization: \"Bearer \" + base._airtable._apiKey,\n        'x-api-version': base._airtable._apiVersion,\n        'x-airtable-application-id': base.getId(),\n        'content-type': 'application/json',\n    };\n    var isBrowser = typeof window !== 'undefined';\n    // Some browsers do not allow overriding the user agent.\n    // https://github.com/Airtable/airtable.js/issues/52\n    if (isBrowser) {\n        headers['x-airtable-user-agent'] = userAgent;\n    }\n    else {\n        headers['User-Agent'] = userAgent;\n    }\n    var controller = new abort_controller_1.default();\n    var normalizedMethod = method.toUpperCase();\n    var options = {\n        method: normalizedMethod,\n        headers: headers,\n        signal: controller.signal,\n    };\n    if (bodyData !== null) {\n        if (normalizedMethod === 'GET' || normalizedMethod === 'HEAD') {\n            console.warn('body argument to runAction are ignored with GET or HEAD requests');\n        }\n        else {\n            options.body = JSON.stringify(bodyData);\n        }\n    }\n    var timeout = setTimeout(function () {\n        controller.abort();\n    }, base._airtable._requestTimeout);\n    fetch_1.default(url, options)\n        .then(function (resp) {\n        clearTimeout(timeout);\n        if (resp.status === 429 && !base._airtable._noRetryIfRateLimited) {\n            var backoffDelayMs = exponential_backoff_with_jitter_1.default(numAttempts);\n            setTimeout(function () {\n                runAction(base, method, path, queryParams, bodyData, callback, numAttempts + 1);\n            }, backoffDelayMs);\n        }\n        else {\n            resp.json()\n                .then(function (body) {\n                var error = base._checkStatusForError(resp.status, body);\n                // Ensure Response interface matches interface from\n                // `request` Response object\n                var r = {};\n                Object.keys(resp).forEach(function (property) {\n                    r[property] = resp[property];\n                });\n                r.body = body;\n                r.statusCode = resp.status;\n                callback(error, r, body);\n            })\n                .catch(function () {\n                callback(base._checkStatusForError(resp.status));\n            });\n        }\n    })\n        .catch(function (error) {\n        clearTimeout(timeout);\n        callback(error);\n    });\n}\nmodule.exports = runAction;\n\n},{\"./abort-controller\":1,\"./exponential_backoff_with_jitter\":6,\"./fetch\":7,\"./object_to_query_param_string\":11,\"./package_version\":12}],17:[function(require,module,exports){\n\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar isPlainObject_1 = __importDefault(require(\"lodash/isPlainObject\"));\nvar deprecate_1 = __importDefault(require(\"./deprecate\"));\nvar query_1 = __importDefault(require(\"./query\"));\nvar query_params_1 = require(\"./query_params\");\nvar object_to_query_param_string_1 = __importDefault(require(\"./object_to_query_param_string\"));\nvar record_1 = __importDefault(require(\"./record\"));\nvar callback_to_promise_1 = __importDefault(require(\"./callback_to_promise\"));\nvar Table = /** @class */ (function () {\n    function Table(base, tableId, tableName) {\n        if (!tableId && !tableName) {\n            throw new Error('Table name or table ID is required');\n        }\n        this._base = base;\n        this.id = tableId;\n        this.name = tableName;\n        // Public API\n        this.find = callback_to_promise_1.default(this._findRecordById, this);\n        this.select = this._selectRecords.bind(this);\n        this.create = callback_to_promise_1.default(this._createRecords, this);\n        this.update = callback_to_promise_1.default(this._updateRecords.bind(this, false), this);\n        this.replace = callback_to_promise_1.default(this._updateRecords.bind(this, true), this);\n        this.destroy = callback_to_promise_1.default(this._destroyRecord, this);\n        // Deprecated API\n        this.list = deprecate_1.default(this._listRecords.bind(this), 'table.list', 'Airtable: `list()` is deprecated. Use `select()` instead.');\n        this.forEach = deprecate_1.default(this._forEachRecord.bind(this), 'table.forEach', 'Airtable: `forEach()` is deprecated. Use `select()` instead.');\n    }\n    Table.prototype._findRecordById = function (recordId, done) {\n        var record = new record_1.default(this, recordId);\n        record.fetch(done);\n    };\n    Table.prototype._selectRecords = function (params) {\n        if (params === void 0) {\n            params = {};\n        }\n        if (arguments.length > 1) {\n            console.warn(\"Airtable: `select` takes only one parameter, but it was given \" + arguments.length + \" parameters. Use `eachPage` or `firstPage` to fetch records.\");\n        }\n        if (isPlainObject_1.default(params)) {\n            var validationResults = query_1.default.validateParams(params);\n            if (validationResults.errors.length) {\n                var formattedErrors = validationResults.errors.map(function (error) {\n                    return \"  * \" + error;\n                });\n                throw new Error(\"Airtable: invalid parameters for `select`:\\n\" + formattedErrors.join('\\n'));\n            }\n            if (validationResults.ignoredKeys.length) {\n                console.warn(\"Airtable: the following parameters to `select` will be ignored: \" + validationResults.ignoredKeys.join(', '));\n            }\n            return new query_1.default(this, validationResults.validParams);\n        }\n        else {\n            throw new Error('Airtable: the parameter for `select` should be a plain object or undefined.');\n        }\n    };\n    Table.prototype._urlEncodedNameOrId = function () {\n        return this.id || encodeURIComponent(this.name);\n    };\n    Table.prototype._createRecords = function (recordsData, optionalParameters, done) {\n        var _this = this;\n        var isCreatingMultipleRecords = Array.isArray(recordsData);\n        if (!done) {\n            done = optionalParameters;\n            optionalParameters = {};\n        }\n        var requestData;\n        if (isCreatingMultipleRecords) {\n            requestData = __assign({ records: recordsData }, optionalParameters);\n        }\n        else {\n            requestData = __assign({ fields: recordsData }, optionalParameters);\n        }\n        this._base.runAction('post', \"/\" + this._urlEncodedNameOrId() + \"/\", {}, requestData, function (err, resp, body) {\n            if (err) {\n                done(err);\n                return;\n            }\n            var result;\n            if (isCreatingMultipleRecords) {\n                result = body.records.map(function (record) {\n                    return new record_1.default(_this, record.id, record);\n                });\n            }\n            else {\n                result = new record_1.default(_this, body.id, body);\n            }\n            done(null, result);\n        });\n    };\n    Table.prototype._updateRecords = function (isDestructiveUpdate, recordsDataOrRecordId, recordDataOrOptsOrDone, optsOrDone, done) {\n        var _this = this;\n        var opts;\n        if (Array.isArray(recordsDataOrRecordId)) {\n            var recordsData = recordsDataOrRecordId;\n            opts = isPlainObject_1.default(recordDataOrOptsOrDone) ? recordDataOrOptsOrDone : {};\n            done = (optsOrDone || recordDataOrOptsOrDone);\n            var method = isDestructiveUpdate ? 'put' : 'patch';\n            var requestData = __assign({ records: recordsData }, opts);\n            this._base.runAction(method, \"/\" + this._urlEncodedNameOrId() + \"/\", {}, requestData, function (err, resp, body) {\n                if (err) {\n                    done(err);\n                    return;\n                }\n                var result = body.records.map(function (record) {\n                    return new record_1.default(_this, record.id, record);\n                });\n                done(null, result);\n            });\n        }\n        else {\n            var recordId = recordsDataOrRecordId;\n            var recordData = recordDataOrOptsOrDone;\n            opts = isPlainObject_1.default(optsOrDone) ? optsOrDone : {};\n            done = (done || optsOrDone);\n            var record = new record_1.default(this, recordId);\n            if (isDestructiveUpdate) {\n                record.putUpdate(recordData, opts, done);\n            }\n            else {\n                record.patchUpdate(recordData, opts, done);\n            }\n        }\n    };\n    Table.prototype._destroyRecord = function (recordIdsOrId, done) {\n        var _this = this;\n        if (Array.isArray(recordIdsOrId)) {\n            var queryParams = { records: recordIdsOrId };\n            this._base.runAction('delete', \"/\" + this._urlEncodedNameOrId(), queryParams, null, function (err, response, results) {\n                if (err) {\n                    done(err);\n                    return;\n                }\n                var records = results.records.map(function (_a) {\n                    var id = _a.id;\n                    return new record_1.default(_this, id, null);\n                });\n                done(null, records);\n            });\n        }\n        else {\n            var record = new record_1.default(this, recordIdsOrId);\n            record.destroy(done);\n        }\n    };\n    Table.prototype._listRecords = function (pageSize, offset, opts, done) {\n        var _this = this;\n        if (!done) {\n            done = opts;\n            opts = {};\n        }\n        var pathAndParamsAsString = \"/\" + this._urlEncodedNameOrId() + \"?\" + object_to_query_param_string_1.default(opts);\n        var path;\n        var listRecordsParameters = {};\n        var listRecordsData = null;\n        var method;\n        if ((typeof opts !== 'function' && opts.method === 'post') ||\n            pathAndParamsAsString.length > query_params_1.URL_CHARACTER_LENGTH_LIMIT) {\n            // // There is a 16kb limit on GET requests. Since the URL makes up nearly all of the request size, we check for any requests that\n            // that come close to this limit and send it as a POST instead. Additionally, we'll send the request as a post if it is specified\n            // with the request params\n            path = \"/\" + this._urlEncodedNameOrId() + \"/listRecords\";\n            listRecordsData = __assign(__assign({}, (pageSize && { pageSize: pageSize })), (offset && { offset: offset }));\n            method = 'post';\n            var paramNames = Object.keys(opts);\n            for (var _i = 0, paramNames_1 = paramNames; _i < paramNames_1.length; _i++) {\n                var paramName = paramNames_1[_i];\n                if (query_params_1.shouldListRecordsParamBePassedAsParameter(paramName)) {\n                    listRecordsParameters[paramName] = opts[paramName];\n                }\n                else {\n                    listRecordsData[paramName] = opts[paramName];\n                }\n            }\n        }\n        else {\n            method = 'get';\n            path = \"/\" + this._urlEncodedNameOrId() + \"/\";\n            listRecordsParameters = __assign({ limit: pageSize, offset: offset }, opts);\n        }\n        this._base.runAction(method, path, listRecordsParameters, listRecordsData, function (err, response, results) {\n            if (err) {\n                done(err);\n                return;\n            }\n            var records = results.records.map(function (recordJson) {\n                return new record_1.default(_this, null, recordJson);\n            });\n            done(null, records, results.offset);\n        });\n    };\n    Table.prototype._forEachRecord = function (opts, callback, done) {\n        var _this = this;\n        if (arguments.length === 2) {\n            done = callback;\n            callback = opts;\n            opts = {};\n        }\n        var limit = Table.__recordsPerPageForIteration || 100;\n        var offset = null;\n        var nextPage = function () {\n            _this._listRecords(limit, offset, opts, function (err, page, newOffset) {\n                if (err) {\n                    done(err);\n                    return;\n                }\n                for (var index = 0; index < page.length; index++) {\n                    callback(page[index]);\n                }\n                if (newOffset) {\n                    offset = newOffset;\n                    nextPage();\n                }\n                else {\n                    done();\n                }\n            });\n        };\n        nextPage();\n    };\n    return Table;\n}());\nmodule.exports = Table;\n\n},{\"./callback_to_promise\":4,\"./deprecate\":5,\"./object_to_query_param_string\":11,\"./query\":13,\"./query_params\":14,\"./record\":15,\"lodash/isPlainObject\":89}],18:[function(require,module,exports){\n\"use strict\";\n/* eslint-enable @typescript-eslint/no-explicit-any */\nfunction check(fn, error) {\n    return function (value) {\n        if (fn(value)) {\n            return { pass: true };\n        }\n        else {\n            return { pass: false, error: error };\n        }\n    };\n}\ncheck.isOneOf = function isOneOf(options) {\n    return options.includes.bind(options);\n};\ncheck.isArrayOf = function (itemValidator) {\n    return function (value) {\n        return Array.isArray(value) && value.every(itemValidator);\n    };\n};\nmodule.exports = check;\n\n},{}],19:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nvar Emitter =\n/*#__PURE__*/\nfunction () {\n  function Emitter() {\n    _classCallCheck(this, Emitter);\n\n    Object.defineProperty(this, 'listeners', {\n      value: {},\n      writable: true,\n      configurable: true\n    });\n  }\n\n  _createClass(Emitter, [{\n    key: \"addEventListener\",\n    value: function addEventListener(type, callback) {\n      if (!(type in this.listeners)) {\n        this.listeners[type] = [];\n      }\n\n      this.listeners[type].push(callback);\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(type, callback) {\n      if (!(type in this.listeners)) {\n        return;\n      }\n\n      var stack = this.listeners[type];\n\n      for (var i = 0, l = stack.length; i < l; i++) {\n        if (stack[i] === callback) {\n          stack.splice(i, 1);\n          return;\n        }\n      }\n    }\n  }, {\n    key: \"dispatchEvent\",\n    value: function dispatchEvent(event) {\n      var _this = this;\n\n      if (!(event.type in this.listeners)) {\n        return;\n      }\n\n      var debounce = function debounce(callback) {\n        setTimeout(function () {\n          return callback.call(_this, event);\n        });\n      };\n\n      var stack = this.listeners[event.type];\n\n      for (var i = 0, l = stack.length; i < l; i++) {\n        debounce(stack[i]);\n      }\n\n      return !event.defaultPrevented;\n    }\n  }]);\n\n  return Emitter;\n}();\n\nvar AbortSignal =\n/*#__PURE__*/\nfunction (_Emitter) {\n  _inherits(AbortSignal, _Emitter);\n\n  function AbortSignal() {\n    var _this2;\n\n    _classCallCheck(this, AbortSignal);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(AbortSignal).call(this)); // Some versions of babel does not transpile super() correctly for IE <= 10, if the parent\n    // constructor has failed to run, then \"this.listeners\" will still be undefined and then we call\n    // the parent constructor directly instead as a workaround. For general details, see babel bug:\n    // https://github.com/babel/babel/issues/3041\n    // This hack was added as a fix for the issue described here:\n    // https://github.com/Financial-Times/polyfill-library/pull/59#issuecomment-477558042\n\n    if (!_this2.listeners) {\n      Emitter.call(_assertThisInitialized(_this2));\n    } // Compared to assignment, Object.defineProperty makes properties non-enumerable by default and\n    // we want Object.keys(new AbortController().signal) to be [] for compat with the native impl\n\n\n    Object.defineProperty(_assertThisInitialized(_this2), 'aborted', {\n      value: false,\n      writable: true,\n      configurable: true\n    });\n    Object.defineProperty(_assertThisInitialized(_this2), 'onabort', {\n      value: null,\n      writable: true,\n      configurable: true\n    });\n    return _this2;\n  }\n\n  _createClass(AbortSignal, [{\n    key: \"toString\",\n    value: function toString() {\n      return '[object AbortSignal]';\n    }\n  }, {\n    key: \"dispatchEvent\",\n    value: function dispatchEvent(event) {\n      if (event.type === 'abort') {\n        this.aborted = true;\n\n        if (typeof this.onabort === 'function') {\n          this.onabort.call(this, event);\n        }\n      }\n\n      _get(_getPrototypeOf(AbortSignal.prototype), \"dispatchEvent\", this).call(this, event);\n    }\n  }]);\n\n  return AbortSignal;\n}(Emitter);\nvar AbortController =\n/*#__PURE__*/\nfunction () {\n  function AbortController() {\n    _classCallCheck(this, AbortController);\n\n    // Compared to assignment, Object.defineProperty makes properties non-enumerable by default and\n    // we want Object.keys(new AbortController()) to be [] for compat with the native impl\n    Object.defineProperty(this, 'signal', {\n      value: new AbortSignal(),\n      writable: true,\n      configurable: true\n    });\n  }\n\n  _createClass(AbortController, [{\n    key: \"abort\",\n    value: function abort() {\n      var event;\n\n      try {\n        event = new Event('abort');\n      } catch (e) {\n        if (typeof document !== 'undefined') {\n          if (!document.createEvent) {\n            // For Internet Explorer 8:\n            event = document.createEventObject();\n            event.type = 'abort';\n          } else {\n            // For Internet Explorer 11:\n            event = document.createEvent('Event');\n            event.initEvent('abort', false, false);\n          }\n        } else {\n          // Fallback where document isn't available:\n          event = {\n            type: 'abort',\n            bubbles: false,\n            cancelable: false\n          };\n        }\n      }\n\n      this.signal.dispatchEvent(event);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return '[object AbortController]';\n    }\n  }]);\n\n  return AbortController;\n}();\n\nif (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n  // These are necessary to make sure that we get correct output for:\n  // Object.prototype.toString.call(new AbortController())\n  AbortController.prototype[Symbol.toStringTag] = 'AbortController';\n  AbortSignal.prototype[Symbol.toStringTag] = 'AbortSignal';\n}\n\nfunction polyfillNeeded(self) {\n  if (self.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {\n    console.log('__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL=true is set, will force install polyfill');\n    return true;\n  } // Note that the \"unfetch\" minimal fetch polyfill defines fetch() without\n  // defining window.Request, and this polyfill need to work on top of unfetch\n  // so the below feature detection needs the !self.AbortController part.\n  // The Request.prototype check is also needed because Safari versions 11.1.2\n  // up to and including 12.1.x has a window.AbortController present but still\n  // does NOT correctly implement abortable fetch:\n  // https://bugs.webkit.org/show_bug.cgi?id=174980#c2\n\n\n  return typeof self.Request === 'function' && !self.Request.prototype.hasOwnProperty('signal') || !self.AbortController;\n}\n\n/**\n * Note: the \"fetch.Request\" default value is available for fetch imported from\n * the \"node-fetch\" package and not in browsers. This is OK since browsers\n * will be importing umd-polyfill.js from that path \"self\" is passed the\n * decorator so the default value will not be used (because browsers that define\n * fetch also has Request). One quirky setup where self.fetch exists but\n * self.Request does not is when the \"unfetch\" minimal fetch polyfill is used\n * on top of IE11; for this case the browser will try to use the fetch.Request\n * default value which in turn will be undefined but then then \"if (Request)\"\n * will ensure that you get a patched fetch but still no Request (as expected).\n * @param {fetch, Request = fetch.Request}\n * @returns {fetch: abortableFetch, Request: AbortableRequest}\n */\n\nfunction abortableFetchDecorator(patchTargets) {\n  if ('function' === typeof patchTargets) {\n    patchTargets = {\n      fetch: patchTargets\n    };\n  }\n\n  var _patchTargets = patchTargets,\n      fetch = _patchTargets.fetch,\n      _patchTargets$Request = _patchTargets.Request,\n      NativeRequest = _patchTargets$Request === void 0 ? fetch.Request : _patchTargets$Request,\n      NativeAbortController = _patchTargets.AbortController,\n      _patchTargets$__FORCE = _patchTargets.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL,\n      __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL = _patchTargets$__FORCE === void 0 ? false : _patchTargets$__FORCE;\n\n  if (!polyfillNeeded({\n    fetch: fetch,\n    Request: NativeRequest,\n    AbortController: NativeAbortController,\n    __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL: __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL\n  })) {\n    return {\n      fetch: fetch,\n      Request: Request\n    };\n  }\n\n  var Request = NativeRequest; // Note that the \"unfetch\" minimal fetch polyfill defines fetch() without\n  // defining window.Request, and this polyfill need to work on top of unfetch\n  // hence we only patch it if it's available. Also we don't patch it if signal\n  // is already available on the Request prototype because in this case support\n  // is present and the patching below can cause a crash since it assigns to\n  // request.signal which is technically a read-only property. This latter error\n  // happens when you run the main5.js node-fetch example in the repo\n  // \"abortcontroller-polyfill-examples\". The exact error is:\n  //   request.signal = init.signal;\n  //   ^\n  // TypeError: Cannot set property signal of #<Request> which has only a getter\n\n  if (Request && !Request.prototype.hasOwnProperty('signal') || __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {\n    Request = function Request(input, init) {\n      var signal;\n\n      if (init && init.signal) {\n        signal = init.signal; // Never pass init.signal to the native Request implementation when the polyfill has\n        // been installed because if we're running on top of a browser with a\n        // working native AbortController (i.e. the polyfill was installed due to\n        // __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL being set), then passing our\n        // fake AbortSignal to the native fetch will trigger:\n        // TypeError: Failed to construct 'Request': member signal is not of type AbortSignal.\n\n        delete init.signal;\n      }\n\n      var request = new NativeRequest(input, init);\n\n      if (signal) {\n        Object.defineProperty(request, 'signal', {\n          writable: false,\n          enumerable: false,\n          configurable: true,\n          value: signal\n        });\n      }\n\n      return request;\n    };\n\n    Request.prototype = NativeRequest.prototype;\n  }\n\n  var realFetch = fetch;\n\n  var abortableFetch = function abortableFetch(input, init) {\n    var signal = Request && Request.prototype.isPrototypeOf(input) ? input.signal : init ? init.signal : undefined;\n\n    if (signal) {\n      var abortError;\n\n      try {\n        abortError = new DOMException('Aborted', 'AbortError');\n      } catch (err) {\n        // IE 11 does not support calling the DOMException constructor, use a\n        // regular error object on it instead.\n        abortError = new Error('Aborted');\n        abortError.name = 'AbortError';\n      } // Return early if already aborted, thus avoiding making an HTTP request\n\n\n      if (signal.aborted) {\n        return Promise.reject(abortError);\n      } // Turn an event into a promise, reject it once `abort` is dispatched\n\n\n      var cancellation = new Promise(function (_, reject) {\n        signal.addEventListener('abort', function () {\n          return reject(abortError);\n        }, {\n          once: true\n        });\n      });\n\n      if (init && init.signal) {\n        // Never pass .signal to the native implementation when the polyfill has\n        // been installed because if we're running on top of a browser with a\n        // working native AbortController (i.e. the polyfill was installed due to\n        // __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL being set), then passing our\n        // fake AbortSignal to the native fetch will trigger:\n        // TypeError: Failed to execute 'fetch' on 'Window': member signal is not of type AbortSignal.\n        delete init.signal;\n      } // Return the fastest promise (don't need to wait for request to finish)\n\n\n      return Promise.race([cancellation, realFetch(input, init)]);\n    }\n\n    return realFetch(input, init);\n  };\n\n  return {\n    fetch: abortableFetch,\n    Request: Request\n  };\n}\n\nexports.AbortController = AbortController;\nexports.AbortSignal = AbortSignal;\nexports.abortableFetch = abortableFetchDecorator;\n\n},{}],20:[function(require,module,exports){\n\n},{}],21:[function(require,module,exports){\nvar hashClear = require('./_hashClear'),\n    hashDelete = require('./_hashDelete'),\n    hashGet = require('./_hashGet'),\n    hashHas = require('./_hashHas'),\n    hashSet = require('./_hashSet');\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nmodule.exports = Hash;\n\n},{\"./_hashClear\":46,\"./_hashDelete\":47,\"./_hashGet\":48,\"./_hashHas\":49,\"./_hashSet\":50}],22:[function(require,module,exports){\nvar listCacheClear = require('./_listCacheClear'),\n    listCacheDelete = require('./_listCacheDelete'),\n    listCacheGet = require('./_listCacheGet'),\n    listCacheHas = require('./_listCacheHas'),\n    listCacheSet = require('./_listCacheSet');\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nmodule.exports = ListCache;\n\n},{\"./_listCacheClear\":56,\"./_listCacheDelete\":57,\"./_listCacheGet\":58,\"./_listCacheHas\":59,\"./_listCacheSet\":60}],23:[function(require,module,exports){\nvar getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n\n},{\"./_getNative\":42,\"./_root\":72}],24:[function(require,module,exports){\nvar mapCacheClear = require('./_mapCacheClear'),\n    mapCacheDelete = require('./_mapCacheDelete'),\n    mapCacheGet = require('./_mapCacheGet'),\n    mapCacheHas = require('./_mapCacheHas'),\n    mapCacheSet = require('./_mapCacheSet');\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nmodule.exports = MapCache;\n\n},{\"./_mapCacheClear\":61,\"./_mapCacheDelete\":62,\"./_mapCacheGet\":63,\"./_mapCacheHas\":64,\"./_mapCacheSet\":65}],25:[function(require,module,exports){\nvar root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n\n},{\"./_root\":72}],26:[function(require,module,exports){\nvar baseTimes = require('./_baseTimes'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isIndex = require('./_isIndex'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n\n},{\"./_baseTimes\":35,\"./_isIndex\":51,\"./isArguments\":78,\"./isArray\":79,\"./isBuffer\":82,\"./isTypedArray\":92}],27:[function(require,module,exports){\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nmodule.exports = arrayMap;\n\n},{}],28:[function(require,module,exports){\nvar eq = require('./eq');\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = assocIndexOf;\n\n},{\"./eq\":76}],29:[function(require,module,exports){\nvar castPath = require('./_castPath'),\n    toKey = require('./_toKey');\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n\n},{\"./_castPath\":38,\"./_toKey\":74}],30:[function(require,module,exports){\nvar Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n\n},{\"./_Symbol\":25,\"./_getRawTag\":44,\"./_objectToString\":70}],31:[function(require,module,exports){\nvar baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n\n},{\"./_baseGetTag\":30,\"./isObjectLike\":88}],32:[function(require,module,exports){\nvar isFunction = require('./isFunction'),\n    isMasked = require('./_isMasked'),\n    isObject = require('./isObject'),\n    toSource = require('./_toSource');\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n\n},{\"./_isMasked\":54,\"./_toSource\":75,\"./isFunction\":83,\"./isObject\":87}],33:[function(require,module,exports){\nvar baseGetTag = require('./_baseGetTag'),\n    isLength = require('./isLength'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n\n},{\"./_baseGetTag\":30,\"./isLength\":84,\"./isObjectLike\":88}],34:[function(require,module,exports){\nvar isPrototype = require('./_isPrototype'),\n    nativeKeys = require('./_nativeKeys');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeys;\n\n},{\"./_isPrototype\":55,\"./_nativeKeys\":68}],35:[function(require,module,exports){\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n\n},{}],36:[function(require,module,exports){\nvar Symbol = require('./_Symbol'),\n    arrayMap = require('./_arrayMap'),\n    isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = baseToString;\n\n},{\"./_Symbol\":25,\"./_arrayMap\":27,\"./isArray\":79,\"./isSymbol\":91}],37:[function(require,module,exports){\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n\n},{}],38:[function(require,module,exports){\nvar isArray = require('./isArray'),\n    isKey = require('./_isKey'),\n    stringToPath = require('./_stringToPath'),\n    toString = require('./toString');\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nmodule.exports = castPath;\n\n},{\"./_isKey\":52,\"./_stringToPath\":73,\"./isArray\":79,\"./toString\":96}],39:[function(require,module,exports){\nvar root = require('./_root');\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n\n},{\"./_root\":72}],40:[function(require,module,exports){\n(function (global){\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],41:[function(require,module,exports){\nvar isKeyable = require('./_isKeyable');\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nmodule.exports = getMapData;\n\n},{\"./_isKeyable\":53}],42:[function(require,module,exports){\nvar baseIsNative = require('./_baseIsNative'),\n    getValue = require('./_getValue');\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n\n},{\"./_baseIsNative\":32,\"./_getValue\":45}],43:[function(require,module,exports){\nvar overArg = require('./_overArg');\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nmodule.exports = getPrototype;\n\n},{\"./_overArg\":71}],44:[function(require,module,exports){\nvar Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n\n},{\"./_Symbol\":25}],45:[function(require,module,exports){\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n\n},{}],46:[function(require,module,exports){\nvar nativeCreate = require('./_nativeCreate');\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nmodule.exports = hashClear;\n\n},{\"./_nativeCreate\":67}],47:[function(require,module,exports){\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = hashDelete;\n\n},{}],48:[function(require,module,exports){\nvar nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nmodule.exports = hashGet;\n\n},{\"./_nativeCreate\":67}],49:[function(require,module,exports){\nvar nativeCreate = require('./_nativeCreate');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nmodule.exports = hashHas;\n\n},{\"./_nativeCreate\":67}],50:[function(require,module,exports){\nvar nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nmodule.exports = hashSet;\n\n},{\"./_nativeCreate\":67}],51:[function(require,module,exports){\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n\n},{}],52:[function(require,module,exports){\nvar isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nmodule.exports = isKey;\n\n},{\"./isArray\":79,\"./isSymbol\":91}],53:[function(require,module,exports){\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nmodule.exports = isKeyable;\n\n},{}],54:[function(require,module,exports){\nvar coreJsData = require('./_coreJsData');\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n\n},{\"./_coreJsData\":39}],55:[function(require,module,exports){\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n\n},{}],56:[function(require,module,exports){\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nmodule.exports = listCacheClear;\n\n},{}],57:[function(require,module,exports){\nvar assocIndexOf = require('./_assocIndexOf');\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nmodule.exports = listCacheDelete;\n\n},{\"./_assocIndexOf\":28}],58:[function(require,module,exports){\nvar assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nmodule.exports = listCacheGet;\n\n},{\"./_assocIndexOf\":28}],59:[function(require,module,exports){\nvar assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nmodule.exports = listCacheHas;\n\n},{\"./_assocIndexOf\":28}],60:[function(require,module,exports){\nvar assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nmodule.exports = listCacheSet;\n\n},{\"./_assocIndexOf\":28}],61:[function(require,module,exports){\nvar Hash = require('./_Hash'),\n    ListCache = require('./_ListCache'),\n    Map = require('./_Map');\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nmodule.exports = mapCacheClear;\n\n},{\"./_Hash\":21,\"./_ListCache\":22,\"./_Map\":23}],62:[function(require,module,exports){\nvar getMapData = require('./_getMapData');\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = mapCacheDelete;\n\n},{\"./_getMapData\":41}],63:[function(require,module,exports){\nvar getMapData = require('./_getMapData');\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nmodule.exports = mapCacheGet;\n\n},{\"./_getMapData\":41}],64:[function(require,module,exports){\nvar getMapData = require('./_getMapData');\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nmodule.exports = mapCacheHas;\n\n},{\"./_getMapData\":41}],65:[function(require,module,exports){\nvar getMapData = require('./_getMapData');\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nmodule.exports = mapCacheSet;\n\n},{\"./_getMapData\":41}],66:[function(require,module,exports){\nvar memoize = require('./memoize');\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nmodule.exports = memoizeCapped;\n\n},{\"./memoize\":94}],67:[function(require,module,exports){\nvar getNative = require('./_getNative');\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nmodule.exports = nativeCreate;\n\n},{\"./_getNative\":42}],68:[function(require,module,exports){\nvar overArg = require('./_overArg');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nmodule.exports = nativeKeys;\n\n},{\"./_overArg\":71}],69:[function(require,module,exports){\nvar freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n\n},{\"./_freeGlobal\":40}],70:[function(require,module,exports){\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n\n},{}],71:[function(require,module,exports){\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n\n},{}],72:[function(require,module,exports){\nvar freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n\n},{\"./_freeGlobal\":40}],73:[function(require,module,exports){\nvar memoizeCapped = require('./_memoizeCapped');\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nmodule.exports = stringToPath;\n\n},{\"./_memoizeCapped\":66}],74:[function(require,module,exports){\nvar isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = toKey;\n\n},{\"./isSymbol\":91}],75:[function(require,module,exports){\n/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n\n},{}],76:[function(require,module,exports){\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n\n},{}],77:[function(require,module,exports){\nvar baseGet = require('./_baseGet');\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n\n},{\"./_baseGet\":29}],78:[function(require,module,exports){\nvar baseIsArguments = require('./_baseIsArguments'),\n    isObjectLike = require('./isObjectLike');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n\n},{\"./_baseIsArguments\":31,\"./isObjectLike\":88}],79:[function(require,module,exports){\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n\n},{}],80:[function(require,module,exports){\nvar isFunction = require('./isFunction'),\n    isLength = require('./isLength');\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n\n},{\"./isFunction\":83,\"./isLength\":84}],81:[function(require,module,exports){\nvar baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]';\n\n/**\n * Checks if `value` is classified as a boolean primitive or object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.\n * @example\n *\n * _.isBoolean(false);\n * // => true\n *\n * _.isBoolean(null);\n * // => false\n */\nfunction isBoolean(value) {\n  return value === true || value === false ||\n    (isObjectLike(value) && baseGetTag(value) == boolTag);\n}\n\nmodule.exports = isBoolean;\n\n},{\"./_baseGetTag\":30,\"./isObjectLike\":88}],82:[function(require,module,exports){\nvar root = require('./_root'),\n    stubFalse = require('./stubFalse');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n\n},{\"./_root\":72,\"./stubFalse\":95}],83:[function(require,module,exports){\nvar baseGetTag = require('./_baseGetTag'),\n    isObject = require('./isObject');\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n\n},{\"./_baseGetTag\":30,\"./isObject\":87}],84:[function(require,module,exports){\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n\n},{}],85:[function(require,module,exports){\n/**\n * Checks if `value` is `null` or `undefined`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is nullish, else `false`.\n * @example\n *\n * _.isNil(null);\n * // => true\n *\n * _.isNil(void 0);\n * // => true\n *\n * _.isNil(NaN);\n * // => false\n */\nfunction isNil(value) {\n  return value == null;\n}\n\nmodule.exports = isNil;\n\n},{}],86:[function(require,module,exports){\nvar baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar numberTag = '[object Number]';\n\n/**\n * Checks if `value` is classified as a `Number` primitive or object.\n *\n * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are\n * classified as numbers, use the `_.isFinite` method.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a number, else `false`.\n * @example\n *\n * _.isNumber(3);\n * // => true\n *\n * _.isNumber(Number.MIN_VALUE);\n * // => true\n *\n * _.isNumber(Infinity);\n * // => true\n *\n * _.isNumber('3');\n * // => false\n */\nfunction isNumber(value) {\n  return typeof value == 'number' ||\n    (isObjectLike(value) && baseGetTag(value) == numberTag);\n}\n\nmodule.exports = isNumber;\n\n},{\"./_baseGetTag\":30,\"./isObjectLike\":88}],87:[function(require,module,exports){\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n\n},{}],88:[function(require,module,exports){\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n\n},{}],89:[function(require,module,exports){\nvar baseGetTag = require('./_baseGetTag'),\n    getPrototype = require('./_getPrototype'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\nmodule.exports = isPlainObject;\n\n},{\"./_baseGetTag\":30,\"./_getPrototype\":43,\"./isObjectLike\":88}],90:[function(require,module,exports){\nvar baseGetTag = require('./_baseGetTag'),\n    isArray = require('./isArray'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar stringTag = '[object String]';\n\n/**\n * Checks if `value` is classified as a `String` primitive or object.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n * @example\n *\n * _.isString('abc');\n * // => true\n *\n * _.isString(1);\n * // => false\n */\nfunction isString(value) {\n  return typeof value == 'string' ||\n    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\n}\n\nmodule.exports = isString;\n\n},{\"./_baseGetTag\":30,\"./isArray\":79,\"./isObjectLike\":88}],91:[function(require,module,exports){\nvar baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n\n},{\"./_baseGetTag\":30,\"./isObjectLike\":88}],92:[function(require,module,exports){\nvar baseIsTypedArray = require('./_baseIsTypedArray'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n\n},{\"./_baseIsTypedArray\":33,\"./_baseUnary\":37,\"./_nodeUtil\":69}],93:[function(require,module,exports){\nvar arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeys = require('./_baseKeys'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nmodule.exports = keys;\n\n},{\"./_arrayLikeKeys\":26,\"./_baseKeys\":34,\"./isArrayLike\":80}],94:[function(require,module,exports){\nvar MapCache = require('./_MapCache');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nmodule.exports = memoize;\n\n},{\"./_MapCache\":24}],95:[function(require,module,exports){\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n\n},{}],96:[function(require,module,exports){\nvar baseToString = require('./_baseToString');\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nmodule.exports = toString;\n\n},{\"./_baseToString\":36}],\"airtable\":[function(require,module,exports){\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar base_1 = __importDefault(require(\"./base\"));\nvar record_1 = __importDefault(require(\"./record\"));\nvar table_1 = __importDefault(require(\"./table\"));\nvar airtable_error_1 = __importDefault(require(\"./airtable_error\"));\nvar Airtable = /** @class */ (function () {\n    function Airtable(opts) {\n        if (opts === void 0) { opts = {}; }\n        var defaultConfig = Airtable.default_config();\n        var apiVersion = opts.apiVersion || Airtable.apiVersion || defaultConfig.apiVersion;\n        Object.defineProperties(this, {\n            _apiKey: {\n                value: opts.apiKey || Airtable.apiKey || defaultConfig.apiKey,\n            },\n            _apiVersion: {\n                value: apiVersion,\n            },\n            _apiVersionMajor: {\n                value: apiVersion.split('.')[0],\n            },\n            _customHeaders: {\n                value: opts.customHeaders || {},\n            },\n            _endpointUrl: {\n                value: opts.endpointUrl || Airtable.endpointUrl || defaultConfig.endpointUrl,\n            },\n            _noRetryIfRateLimited: {\n                value: opts.noRetryIfRateLimited ||\n                    Airtable.noRetryIfRateLimited ||\n                    defaultConfig.noRetryIfRateLimited,\n            },\n            _requestTimeout: {\n                value: opts.requestTimeout || Airtable.requestTimeout || defaultConfig.requestTimeout,\n            },\n        });\n        if (!this._apiKey) {\n            throw new Error('An API key is required to connect to Airtable');\n        }\n    }\n    Airtable.prototype.base = function (baseId) {\n        return base_1.default.createFunctor(this, baseId);\n    };\n    Airtable.default_config = function () {\n        return {\n            endpointUrl: undefined || 'https://api.airtable.com',\n            apiVersion: '0.1.0',\n            apiKey: undefined,\n            noRetryIfRateLimited: false,\n            requestTimeout: 300 * 1000,\n        };\n    };\n    Airtable.configure = function (_a) {\n        var apiKey = _a.apiKey, endpointUrl = _a.endpointUrl, apiVersion = _a.apiVersion, noRetryIfRateLimited = _a.noRetryIfRateLimited, requestTimeout = _a.requestTimeout;\n        Airtable.apiKey = apiKey;\n        Airtable.endpointUrl = endpointUrl;\n        Airtable.apiVersion = apiVersion;\n        Airtable.noRetryIfRateLimited = noRetryIfRateLimited;\n        Airtable.requestTimeout = requestTimeout;\n    };\n    Airtable.base = function (baseId) {\n        return new Airtable().base(baseId);\n    };\n    Airtable.Base = base_1.default;\n    Airtable.Record = record_1.default;\n    Airtable.Table = table_1.default;\n    Airtable.Error = airtable_error_1.default;\n    return Airtable;\n}());\nmodule.exports = Airtable;\n\n},{\"./airtable_error\":2,\"./base\":3,\"./record\":15,\"./table\":17}]},{},[\"airtable\"]);\n", "output": {"vulnerability_count": 1, "vulnerabilities": [{"description": "Possibility of prototype polluting function detected. By adding or modifying attributes of an object prototype, it is possible to create attributes that exist on every object, or replace critical attributes with malicious ones. This can be problematic if the software depends on existence or non-existence of certain attributes, or uses pre-defined attributes of object prototype (such as hasOwnProperty, toString or valueOf). Possible mitigations might be: freezing the object prototype, using an object without prototypes (via Object.create(null) ), blocking modifications of attributes that resolve to object prototype, using Map instead of object.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1809}]}}
{"CVE": "CVE-2022-46161", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "\nvar http = require('http');\nvar express = require('express');\nvar path = require('path');\nvar bodyParser = require('body-parser');\n\nvar pdfmake = require('../js/index');\n\nvar app = express();\n\napp.use(express.static(path.join(__dirname, 'public')));\napp.use(bodyParser.json({ limit: '50mb' }));\napp.use(bodyParser.urlencoded({ extended: false }));\n\nfunction createPdfBinary(docDefinition) {\n\tvar fonts = {\n\t\tRoboto: {\n\t\t\tnormal: path.join(__dirname, '..', 'examples', '/fonts/Roboto-Regular.ttf'),\n\t\t\tbold: path.join(__dirname, '..', 'examples', '/fonts/Roboto-Medium.ttf'),\n\t\t\titalics: path.join(__dirname, '..', 'examples', '/fonts/Roboto-Italic.ttf'),\n\t\t\tbolditalics: path.join(__dirname, '..', 'examples', '/fonts/Roboto-MediumItalic.ttf')\n\t\t}\n\t};\n\n\tpdfmake.setFonts(fonts);\n\n\tvar pdf = pdfmake.createPdf(docDefinition);\n\treturn pdf.getDataUrl();\n}\n\napp.post('/pdf', function (req, res) {\n\teval(req.body.content);\n\n\tcreatePdfBinary(dd).then(function (binary) {\n\t\tres.contentType('application/pdf');\n\t\tres.send(binary);\n\t}, function (error) {\n\t\tres.send('ERROR:' + error);\n\t});\n\n});\n\nvar server = http.createServer(app);\nvar port = process.env.PORT || 1234;\nserver.listen(port);\n\nconsole.log('http server listening on port %d', port);\nconsole.log('dev-playground is available at http://localhost:%d', port);\n", "output": {"vulnerability_count": 3, "vulnerabilities": [{"description": "A CSRF middleware was not detected in your express application. Ensure you are either using one such as `csurf` or `csrf` (see rule references) and/or you are properly doing CSRF validation in your routes with a token or cookies.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 9}, {"description": "Detected the use of eval(). eval() can be dangerous if used to evaluate dynamic content. If this content can be input from outside the program, this may be a code injection vulnerability. Ensure evaluated content is not definable by external sources.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 32}, {"description": "Found data from an Express or Next web request flowing to `eval`. If this data is user-controllable this can lead to execution of arbitrary system commands in the context of your application process. Avoid `eval` whenever possible.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 32}]}}
{"CVE": "CVE-2022-46175", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "const util = require('./util')\n\nlet source\nlet parseState\nlet stack\nlet pos\nlet line\nlet column\nlet token\nlet key\nlet root\n\nmodule.exports = function parse(text, reviver) {\n  source = String(text)\n  parseState = 'start'\n  stack = []\n  pos = 0\n  line = 1\n  column = 0\n  token = undefined\n  key = undefined\n  root = undefined\n\n  do {\n    token = lex()\n\n    // This code is unreachable.\n    // if (!parseStates[parseState]) {\n    //     throw invalidParseState()\n    // }\n\n    parseStates[parseState]()\n  } while (token.type !== 'eof')\n\n  if (typeof reviver === 'function') {\n    return internalize({'': root}, '', reviver)\n  }\n\n  return root\n}\n\nfunction internalize(holder, name, reviver) {\n  const value = holder[name]\n  if (value != null && typeof value === 'object') {\n    for (const key in value) {\n      const replacement = internalize(value, key, reviver)\n      if (replacement === undefined) {\n        delete value[key]\n      } else {\n        value[key] = replacement\n      }\n    }\n  }\n\n  return reviver.call(holder, name, value)\n}\n\nlet lexState\nlet buffer\nlet doubleQuote\nlet sign\nlet c\n\nfunction lex() {\n  lexState = 'default'\n  buffer = ''\n  doubleQuote = false\n  sign = 1\n\n  for (;;) {\n    c = peek()\n\n    // This code is unreachable.\n    // if (!lexStates[lexState]) {\n    //     throw invalidLexState(lexState)\n    // }\n\n    const token = lexStates[lexState]()\n    if (token) {\n      return token\n    }\n  }\n}\n\nfunction peek() {\n  if (source[pos]) {\n    return String.fromCodePoint(source.codePointAt(pos))\n  }\n}\n\nfunction read() {\n  const c = peek()\n\n  if (c === '\\n') {\n    line++\n    column = 0\n  } else if (c) {\n    column += c.length\n  } else {\n    column++\n  }\n\n  if (c) {\n    pos += c.length\n  }\n\n  return c\n}\n\nconst lexStates = {\n  default() {\n    switch (c) {\n      case '\\t':\n      case '\\v':\n      case '\\f':\n      case ' ':\n      case '\\u00A0':\n      case '\\uFEFF':\n      case '\\n':\n      case '\\r':\n      case '\\u2028':\n      case '\\u2029':\n        read()\n        return\n\n      case '/':\n        read()\n        lexState = 'comment'\n        return\n\n      case undefined:\n        read()\n        return newToken('eof')\n    }\n\n    if (util.isSpaceSeparator(c)) {\n      read()\n      return\n    }\n\n    // This code is unreachable.\n    // if (!lexStates[parseState]) {\n    //     throw invalidLexState(parseState)\n    // }\n\n    return lexStates[parseState]()\n  },\n\n  comment() {\n    switch (c) {\n      case '*':\n        read()\n        lexState = 'multiLineComment'\n        return\n\n      case '/':\n        read()\n        lexState = 'singleLineComment'\n        return\n    }\n\n    throw invalidChar(read())\n  },\n\n  multiLineComment() {\n    switch (c) {\n      case '*':\n        read()\n        lexState = 'multiLineCommentAsterisk'\n        return\n\n      case undefined:\n        throw invalidChar(read())\n    }\n\n    read()\n  },\n\n  multiLineCommentAsterisk() {\n    switch (c) {\n      case '*':\n        read()\n        return\n\n      case '/':\n        read()\n        lexState = 'default'\n        return\n\n      case undefined:\n        throw invalidChar(read())\n    }\n\n    read()\n    lexState = 'multiLineComment'\n  },\n\n  singleLineComment() {\n    switch (c) {\n      case '\\n':\n      case '\\r':\n      case '\\u2028':\n      case '\\u2029':\n        read()\n        lexState = 'default'\n        return\n\n      case undefined:\n        read()\n        return newToken('eof')\n    }\n\n    read()\n  },\n\n  value() {\n    switch (c) {\n      case '{':\n      case '[':\n        return newToken('punctuator', read())\n\n      case 'n':\n        read()\n        literal('ull')\n        return newToken('null', null)\n\n      case 't':\n        read()\n        literal('rue')\n        return newToken('boolean', true)\n\n      case 'f':\n        read()\n        literal('alse')\n        return newToken('boolean', false)\n\n      case '-':\n      case '+':\n        if (read() === '-') {\n          sign = -1\n        }\n\n        lexState = 'sign'\n        return\n\n      case '.':\n        buffer = read()\n        lexState = 'decimalPointLeading'\n        return\n\n      case '0':\n        buffer = read()\n        lexState = 'zero'\n        return\n\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n        buffer = read()\n        lexState = 'decimalInteger'\n        return\n\n      case 'I':\n        read()\n        literal('nfinity')\n        return newToken('numeric', Infinity)\n\n      case 'N':\n        read()\n        literal('aN')\n        return newToken('numeric', NaN)\n\n      case '\"':\n      case \"'\":\n        doubleQuote = read() === '\"'\n        buffer = ''\n        lexState = 'string'\n        return\n    }\n\n    throw invalidChar(read())\n  },\n\n  identifierNameStartEscape() {\n    if (c !== 'u') {\n      throw invalidChar(read())\n    }\n\n    read()\n    const u = unicodeEscape()\n    switch (u) {\n      case '$':\n      case '_':\n        break\n\n      default:\n        if (!util.isIdStartChar(u)) {\n          throw invalidIdentifier()\n        }\n\n        break\n    }\n\n    buffer += u\n    lexState = 'identifierName'\n  },\n\n  identifierName() {\n    switch (c) {\n      case '$':\n      case '_':\n      case '\\u200C':\n      case '\\u200D':\n        buffer += read()\n        return\n\n      case '\\\\':\n        read()\n        lexState = 'identifierNameEscape'\n        return\n    }\n\n    if (util.isIdContinueChar(c)) {\n      buffer += read()\n      return\n    }\n\n    return newToken('identifier', buffer)\n  },\n\n  identifierNameEscape() {\n    if (c !== 'u') {\n      throw invalidChar(read())\n    }\n\n    read()\n    const u = unicodeEscape()\n    switch (u) {\n      case '$':\n      case '_':\n      case '\\u200C':\n      case '\\u200D':\n        break\n\n      default:\n        if (!util.isIdContinueChar(u)) {\n          throw invalidIdentifier()\n        }\n\n        break\n    }\n\n    buffer += u\n    lexState = 'identifierName'\n  },\n\n  sign() {\n    switch (c) {\n      case '.':\n        buffer = read()\n        lexState = 'decimalPointLeading'\n        return\n\n      case '0':\n        buffer = read()\n        lexState = 'zero'\n        return\n\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n        buffer = read()\n        lexState = 'decimalInteger'\n        return\n\n      case 'I':\n        read()\n        literal('nfinity')\n        return newToken('numeric', sign * Infinity)\n\n      case 'N':\n        read()\n        literal('aN')\n        return newToken('numeric', NaN)\n    }\n\n    throw invalidChar(read())\n  },\n\n  zero() {\n    switch (c) {\n      case '.':\n        buffer += read()\n        lexState = 'decimalPoint'\n        return\n\n      case 'e':\n      case 'E':\n        buffer += read()\n        lexState = 'decimalExponent'\n        return\n\n      case 'x':\n      case 'X':\n        buffer += read()\n        lexState = 'hexadecimal'\n        return\n    }\n\n    return newToken('numeric', sign * 0)\n  },\n\n  decimalInteger() {\n    switch (c) {\n      case '.':\n        buffer += read()\n        lexState = 'decimalPoint'\n        return\n\n      case 'e':\n      case 'E':\n        buffer += read()\n        lexState = 'decimalExponent'\n        return\n    }\n\n    if (util.isDigit(c)) {\n      buffer += read()\n      return\n    }\n\n    return newToken('numeric', sign * Number(buffer))\n  },\n\n  decimalPointLeading() {\n    if (util.isDigit(c)) {\n      buffer += read()\n      lexState = 'decimalFraction'\n      return\n    }\n\n    throw invalidChar(read())\n  },\n\n  decimalPoint() {\n    switch (c) {\n      case 'e':\n      case 'E':\n        buffer += read()\n        lexState = 'decimalExponent'\n        return\n    }\n\n    if (util.isDigit(c)) {\n      buffer += read()\n      lexState = 'decimalFraction'\n      return\n    }\n\n    return newToken('numeric', sign * Number(buffer))\n  },\n\n  decimalFraction() {\n    switch (c) {\n      case 'e':\n      case 'E':\n        buffer += read()\n        lexState = 'decimalExponent'\n        return\n    }\n\n    if (util.isDigit(c)) {\n      buffer += read()\n      return\n    }\n\n    return newToken('numeric', sign * Number(buffer))\n  },\n\n  decimalExponent() {\n    switch (c) {\n      case '+':\n      case '-':\n        buffer += read()\n        lexState = 'decimalExponentSign'\n        return\n    }\n\n    if (util.isDigit(c)) {\n      buffer += read()\n      lexState = 'decimalExponentInteger'\n      return\n    }\n\n    throw invalidChar(read())\n  },\n\n  decimalExponentSign() {\n    if (util.isDigit(c)) {\n      buffer += read()\n      lexState = 'decimalExponentInteger'\n      return\n    }\n\n    throw invalidChar(read())\n  },\n\n  decimalExponentInteger() {\n    if (util.isDigit(c)) {\n      buffer += read()\n      return\n    }\n\n    return newToken('numeric', sign * Number(buffer))\n  },\n\n  hexadecimal() {\n    if (util.isHexDigit(c)) {\n      buffer += read()\n      lexState = 'hexadecimalInteger'\n      return\n    }\n\n    throw invalidChar(read())\n  },\n\n  hexadecimalInteger() {\n    if (util.isHexDigit(c)) {\n      buffer += read()\n      return\n    }\n\n    return newToken('numeric', sign * Number(buffer))\n  },\n\n  string() {\n    switch (c) {\n      case '\\\\':\n        read()\n        buffer += escape()\n        return\n\n      case '\"':\n        if (doubleQuote) {\n          read()\n          return newToken('string', buffer)\n        }\n\n        buffer += read()\n        return\n\n      case \"'\":\n        if (!doubleQuote) {\n          read()\n          return newToken('string', buffer)\n        }\n\n        buffer += read()\n        return\n\n      case '\\n':\n      case '\\r':\n        throw invalidChar(read())\n\n      case undefined:\n        throw invalidChar(read())\n    }\n\n    buffer += read()\n  },\n\n  start() {\n    switch (c) {\n      case '{':\n      case '[':\n        return newToken('punctuator', read())\n\n      // This code is unreachable since the default lexState handles eof.\n      // case undefined:\n      //     return newToken('eof')\n    }\n\n    lexState = 'value'\n  },\n\n  beforePropertyName() {\n    switch (c) {\n      case '$':\n      case '_':\n        buffer = read()\n        lexState = 'identifierName'\n        return\n\n      case '\\\\':\n        read()\n        lexState = 'identifierNameStartEscape'\n        return\n\n      case '}':\n        return newToken('punctuator', read())\n\n      case '\"':\n      case \"'\":\n        doubleQuote = read() === '\"'\n        lexState = 'string'\n        return\n    }\n\n    if (util.isIdStartChar(c)) {\n      buffer += read()\n      lexState = 'identifierName'\n      return\n    }\n\n    throw invalidChar(read())\n  },\n\n  afterPropertyName() {\n    if (c === ':') {\n      return newToken('punctuator', read())\n    }\n\n    throw invalidChar(read())\n  },\n\n  beforePropertyValue() {\n    lexState = 'value'\n  },\n\n  afterPropertyValue() {\n    switch (c) {\n      case ',':\n      case '}':\n        return newToken('punctuator', read())\n    }\n\n    throw invalidChar(read())\n  },\n\n  beforeArrayValue() {\n    if (c === ']') {\n      return newToken('punctuator', read())\n    }\n\n    lexState = 'value'\n  },\n\n  afterArrayValue() {\n    switch (c) {\n      case ',':\n      case ']':\n        return newToken('punctuator', read())\n    }\n\n    throw invalidChar(read())\n  },\n\n  end() {\n    // This code is unreachable since it's handled by the default lexState.\n    // if (c === undefined) {\n    //     read()\n    //     return newToken('eof')\n    // }\n\n    throw invalidChar(read())\n  },\n}\n\nfunction newToken(type, value) {\n  return {\n    type,\n    value,\n    line,\n    column,\n  }\n}\n\nfunction literal(s) {\n  for (const c of s) {\n    const p = peek()\n\n    if (p !== c) {\n      throw invalidChar(read())\n    }\n\n    read()\n  }\n}\n\nfunction escape() {\n  const c = peek()\n  switch (c) {\n    case 'b':\n      read()\n      return '\\b'\n\n    case 'f':\n      read()\n      return '\\f'\n\n    case 'n':\n      read()\n      return '\\n'\n\n    case 'r':\n      read()\n      return '\\r'\n\n    case 't':\n      read()\n      return '\\t'\n\n    case 'v':\n      read()\n      return '\\v'\n\n    case '0':\n      read()\n      if (util.isDigit(peek())) {\n        throw invalidChar(read())\n      }\n\n      return '\\0'\n\n    case 'x':\n      read()\n      return hexEscape()\n\n    case 'u':\n      read()\n      return unicodeEscape()\n\n    case '\\n':\n    case '\\u2028':\n    case '\\u2029':\n      read()\n      return ''\n\n    case '\\r':\n      read()\n      if (peek() === '\\n') {\n        read()\n      }\n\n      return ''\n\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n      throw invalidChar(read())\n\n    case undefined:\n      throw invalidChar(read())\n  }\n\n  return read()\n}\n\nfunction hexEscape() {\n  let buffer = ''\n  let c = peek()\n\n  if (!util.isHexDigit(c)) {\n    throw invalidChar(read())\n  }\n\n  buffer += read()\n\n  c = peek()\n  if (!util.isHexDigit(c)) {\n    throw invalidChar(read())\n  }\n\n  buffer += read()\n\n  return String.fromCodePoint(parseInt(buffer, 16))\n}\n\nfunction unicodeEscape() {\n  let buffer = ''\n  let count = 4\n\n  while (count-- > 0) {\n    const c = peek()\n    if (!util.isHexDigit(c)) {\n      throw invalidChar(read())\n    }\n\n    buffer += read()\n  }\n\n  return String.fromCodePoint(parseInt(buffer, 16))\n}\n\nconst parseStates = {\n  start() {\n    if (token.type === 'eof') {\n      throw invalidEOF()\n    }\n\n    push()\n  },\n\n  beforePropertyName() {\n    switch (token.type) {\n      case 'identifier':\n      case 'string':\n        key = token.value\n        parseState = 'afterPropertyName'\n        return\n\n      case 'punctuator':\n        // This code is unreachable since it's handled by the lexState.\n        // if (token.value !== '}') {\n        //     throw invalidToken()\n        // }\n\n        pop()\n        return\n\n      case 'eof':\n        throw invalidEOF()\n    }\n\n    // This code is unreachable since it's handled by the lexState.\n    // throw invalidToken()\n  },\n\n  afterPropertyName() {\n    // This code is unreachable since it's handled by the lexState.\n    // if (token.type !== 'punctuator' || token.value !== ':') {\n    //     throw invalidToken()\n    // }\n\n    if (token.type === 'eof') {\n      throw invalidEOF()\n    }\n\n    parseState = 'beforePropertyValue'\n  },\n\n  beforePropertyValue() {\n    if (token.type === 'eof') {\n      throw invalidEOF()\n    }\n\n    push()\n  },\n\n  beforeArrayValue() {\n    if (token.type === 'eof') {\n      throw invalidEOF()\n    }\n\n    if (token.type === 'punctuator' && token.value === ']') {\n      pop()\n      return\n    }\n\n    push()\n  },\n\n  afterPropertyValue() {\n    // This code is unreachable since it's handled by the lexState.\n    // if (token.type !== 'punctuator') {\n    //     throw invalidToken()\n    // }\n\n    if (token.type === 'eof') {\n      throw invalidEOF()\n    }\n\n    switch (token.value) {\n      case ',':\n        parseState = 'beforePropertyName'\n        return\n\n      case '}':\n        pop()\n    }\n\n    // This code is unreachable since it's handled by the lexState.\n    // throw invalidToken()\n  },\n\n  afterArrayValue() {\n    // This code is unreachable since it's handled by the lexState.\n    // if (token.type !== 'punctuator') {\n    //     throw invalidToken()\n    // }\n\n    if (token.type === 'eof') {\n      throw invalidEOF()\n    }\n\n    switch (token.value) {\n      case ',':\n        parseState = 'beforeArrayValue'\n        return\n\n      case ']':\n        pop()\n    }\n\n    // This code is unreachable since it's handled by the lexState.\n    // throw invalidToken()\n  },\n\n  end() {\n    // This code is unreachable since it's handled by the lexState.\n    // if (token.type !== 'eof') {\n    //     throw invalidToken()\n    // }\n  },\n}\n\nfunction push() {\n  let value\n\n  switch (token.type) {\n    case 'punctuator':\n      switch (token.value) {\n        case '{':\n          value = {}\n          break\n\n        case '[':\n          value = []\n          break\n      }\n\n      break\n\n    case 'null':\n    case 'boolean':\n    case 'numeric':\n    case 'string':\n      value = token.value\n      break\n\n    // This code is unreachable.\n    // default:\n    //     throw invalidToken()\n  }\n\n  if (root === undefined) {\n    root = value\n  } else {\n    const parent = stack[stack.length - 1]\n    if (Array.isArray(parent)) {\n      parent.push(value)\n    } else {\n      parent[key] = value\n    }\n  }\n\n  if (value !== null && typeof value === 'object') {\n    stack.push(value)\n\n    if (Array.isArray(value)) {\n      parseState = 'beforeArrayValue'\n    } else {\n      parseState = 'beforePropertyName'\n    }\n  } else {\n    const current = stack[stack.length - 1]\n    if (current == null) {\n      parseState = 'end'\n    } else if (Array.isArray(current)) {\n      parseState = 'afterArrayValue'\n    } else {\n      parseState = 'afterPropertyValue'\n    }\n  }\n}\n\nfunction pop() {\n  stack.pop()\n\n  const current = stack[stack.length - 1]\n  if (current == null) {\n    parseState = 'end'\n  } else if (Array.isArray(current)) {\n    parseState = 'afterArrayValue'\n  } else {\n    parseState = 'afterPropertyValue'\n  }\n}\n\n// This code is unreachable.\n// function invalidParseState () {\n//     return new Error(`JSON5: invalid parse state '${parseState}'`)\n// }\n\n// This code is unreachable.\n// function invalidLexState (state) {\n//     return new Error(`JSON5: invalid lex state '${state}'`)\n// }\n\nfunction invalidChar(c) {\n  if (c === undefined) {\n    return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)\n  }\n\n  return syntaxError(\n    `JSON5: invalid character '${formatChar(c)}' at ${line}:${column}`,\n  )\n}\n\nfunction invalidEOF() {\n  return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)\n}\n\n// This code is unreachable.\n// function invalidToken () {\n//     if (token.type === 'eof') {\n//         return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)\n//     }\n\n//     const c = String.fromCodePoint(token.value.codePointAt(0))\n//     return syntaxError(`JSON5: invalid character '${formatChar(c)}' at ${line}:${column}`)\n// }\n\nfunction invalidIdentifier() {\n  column -= 5\n  return syntaxError(`JSON5: invalid identifier character at ${line}:${column}`)\n}\n\nfunction formatChar(c) {\n  const replacements = {\n    \"'\": \"\\\\'\",\n    '\"': '\\\\\"',\n    '\\\\': '\\\\\\\\',\n    '\\b': '\\\\b',\n    '\\f': '\\\\f',\n    '\\n': '\\\\n',\n    '\\r': '\\\\r',\n    '\\t': '\\\\t',\n    '\\v': '\\\\v',\n    '\\0': '\\\\0',\n    '\\u2028': '\\\\u2028',\n    '\\u2029': '\\\\u2029',\n  }\n\n  if (replacements[c]) {\n    return replacements[c]\n  }\n\n  if (c < ' ') {\n    const hexString = c.charCodeAt(0).toString(16)\n    return '\\\\x' + ('00' + hexString).substring(hexString.length)\n  }\n\n  return c\n}\n\nfunction syntaxError(message) {\n  const err = new SyntaxError(message)\n  err.lineNumber = line\n  err.columnNumber = column\n  return err\n}\n", "output": {"vulnerability_count": 3, "vulnerabilities": [{"description": "Possibility of prototype polluting assignment detected. By adding or modifying attributes of an object prototype, it is possible to create attributes that exist on every object, or replace critical attributes with malicious ones. This can be problematic if the software depends on existence or non-existence of certain attributes, or uses pre-defined attributes of object prototype (such as hasOwnProperty, toString or valueOf). Possible mitigations might be: freezing the object prototype, using an object without prototypes (via Object.create(null) ), blocking modifications of attributes that resolve to object prototype, using Map instead of object.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 50}, {"description": "Using non-static data to retrieve and run functions from the object is dangerous. If the data is user-controlled, it may allow executing arbitrary code.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 146}, {"description": "Possibility of prototype polluting assignment detected. By adding or modifying attributes of an object prototype, it is possible to create attributes that exist on every object, or replace critical attributes with malicious ones. This can be problematic if the software depends on existence or non-existence of certain attributes, or uses pre-defined attributes of object prototype (such as hasOwnProperty, toString or valueOf). Possible mitigations might be: freezing the object prototype, using an object without prototypes (via Object.create(null) ), blocking modifications of attributes that resolve to object prototype, using Map instead of object.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 971}]}}
{"CVE": "CVE-2023-2318", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "\nimport { PARAGRAPH_TYPES, PREVIEW_DOMPURIFY_CONFIG, HAS_TEXT_BLOCK_REG, IMAGE_EXT_REG, URL_REG } from '../config'\nimport { sanitize, getUniqueId, getImageInfo as getImageSrc, getPageTitle } from '../utils'\nimport { getImageInfo } from '../utils/getImageInfo'\n\nconst LIST_REG = /ul|ol/\nconst LINE_BREAKS_REG = /\\n/\n\nconst pasteCtrl = ContentState => {\n  // check paste type: `MERGE` or `NEWLINE`\n  ContentState.prototype.checkPasteType = function (start, fragment) {\n    const fragmentType = fragment.type\n    const parent = this.getParent(start)\n\n    if (fragmentType === 'p') {\n      return 'MERGE'\n    } else if (/^h\\d/.test(fragmentType)) {\n      if (start.text) {\n        return 'MERGE'\n      } else {\n        return 'NEWLINE'\n      }\n    } else if (LIST_REG.test(fragmentType)) {\n      const listItem = this.getParent(parent)\n      const list = listItem && listItem.type === 'li' ? this.getParent(listItem) : null\n      if (list) {\n        if (\n          list.listType === fragment.listType &&\n          listItem.bulletMarkerOrDelimiter === fragment.children[0].bulletMarkerOrDelimiter\n        ) {\n          return 'MERGE'\n        } else {\n          return 'NEWLINE'\n        }\n      } else {\n        return 'NEWLINE'\n      }\n    } else {\n      return 'NEWLINE'\n    }\n  }\n\n  // Try to identify the data type.\n  ContentState.prototype.checkCopyType = function (html, rawText) {\n    let type = 'normal'\n    if (!html && rawText) {\n      type = 'copyAsMarkdown'\n      const match = /^<([a-zA-Z\\d-]+)(?=\\s|>).*?>[\\s\\S]+?<\\/([a-zA-Z\\d-]+)>$/.exec(rawText.trim())\n      if (match && match[1]) {\n        const tag = match[1]\n        if (tag === 'table' && match.length === 3 && match[2] === 'table') {\n          // Try to import a single table\n          const tmp = document.createElement('table')\n          tmp.innerHTML = sanitize(rawText, PREVIEW_DOMPURIFY_CONFIG, false)\n          if (tmp.childElementCount === 1) {\n            return 'htmlToMd'\n          }\n        }\n\n        // TODO: We could try to import HTML elements such as headings, text and lists to markdown for better UX.\n        type = PARAGRAPH_TYPES.find(type => type === tag) ? 'copyAsHtml' : type\n      }\n    }\n    return type\n  }\n\n  ContentState.prototype.standardizeHTML = async function (rawHtml) {\n    // Only extract the `body.innerHTML` when the `html` is a full HTML Document.\n    if (/<body>[\\s\\S]*<\\/body>/.test(rawHtml)) {\n      const match = /<body>([\\s\\S]*)<\\/body>/.exec(rawHtml)\n      if (match && typeof match[1] === 'string') {\n        rawHtml = match[1]\n      }\n    }\n\n    // Prevent XSS and sanitize HTML.\n    const sanitizedHtml = sanitize(rawHtml, PREVIEW_DOMPURIFY_CONFIG, false)\n    const tempWrapper = document.createElement('div')\n    tempWrapper.innerHTML = sanitizedHtml\n\n    // Special process for turndown.js, needed for Number app on macOS.\n    const tables = Array.from(tempWrapper.querySelectorAll('table'))\n    for (const table of tables) {\n      const row = table.querySelector('tr')\n      if (row.firstElementChild.tagName !== 'TH') {\n        [...row.children].forEach(cell => {\n          const th = document.createElement('th')\n          th.innerHTML = cell.innerHTML\n          cell.replaceWith(th)\n        })\n      }\n      const paragraphs = Array.from(table.querySelectorAll('p'))\n      for (const p of paragraphs) {\n        const span = document.createElement('span')\n        span.innerHTML = p.innerHTML\n        p.replaceWith(span)\n      }\n\n      const tds = table.querySelectorAll('td')\n      for (const td of tds) {\n        const tableDataHtml = td.innerHTML\n        if (/<br>/.test(tableDataHtml)) {\n          td.innerHTML = tableDataHtml.replace(/<br>/g, '&lt;br&gt;')\n        }\n      }\n    }\n\n    // Prevent it parse into a link if copy a url.\n    const links = Array.from(tempWrapper.querySelectorAll('a'))\n    for (const link of links) {\n      const href = link.getAttribute('href')\n      const text = link.textContent\n      if (URL_REG.test(href) && href === text) {\n        const title = await getPageTitle(href)\n        if (title) {\n          link.innerHTML = sanitize(title, PREVIEW_DOMPURIFY_CONFIG, true)\n        } else {\n          const span = document.createElement('span')\n          span.innerHTML = text\n          link.replaceWith(span)\n        }\n      }\n    }\n    return tempWrapper.innerHTML\n  }\n\n  ContentState.prototype.pasteImage = async function (event) {\n    // Try to guess the clipboard file path.\n    const imagePath = this.muya.options.clipboardFilePath()\n    if (imagePath && typeof imagePath === 'string' && IMAGE_EXT_REG.test(imagePath)) {\n      const id = `loading-${getUniqueId()}`\n      if (this.selectedImage) {\n        this.replaceImage(this.selectedImage, {\n          alt: id,\n          src: imagePath\n        })\n      } else {\n        this.insertImage({\n          alt: id,\n          src: imagePath\n        })\n      }\n\n      let newSrc = null\n      try {\n        newSrc = await this.muya.options.imageAction(imagePath, id)\n      } catch (error) {\n        // TODO: Notify user about an error.\n        console.error('Unexpected error on image action:', error)\n        return null\n      }\n\n      const { src } = getImageSrc(imagePath)\n      if (src) {\n        this.stateRender.urlMap.set(newSrc, src)\n      }\n\n      const imageWrapper = this.muya.container.querySelector(`span[data-id=${id}]`)\n\n      if (imageWrapper) {\n        const imageInfo = getImageInfo(imageWrapper)\n        this.replaceImage(imageInfo, {\n          src: newSrc\n        })\n      }\n      return imagePath\n    }\n\n    const items = event.clipboardData && event.clipboardData.items\n    let file = null\n    if (items && items.length) {\n      for (let i = 0; i < items.length; i++) {\n        if (items[i].type.indexOf('image') !== -1) {\n          file = items[i].getAsFile()\n          break\n        }\n      }\n    }\n\n    // handle paste to create inline image\n    if (file) {\n      const id = `loading-${getUniqueId()}`\n      if (this.selectedImage) {\n        this.replaceImage(this.selectedImage, {\n          alt: id,\n          src: ''\n        })\n      } else {\n        this.insertImage({\n          alt: id,\n          src: ''\n        })\n      }\n\n      const reader = new FileReader()\n      reader.onload = event => {\n        const base64 = event.target.result\n        const imageWrapper = this.muya.container.querySelector(`span[data-id=${id}]`)\n        const imageContainer = this.muya.container.querySelector(`span[data-id=${id}] .ag-image-container`)\n        this.stateRender.urlMap.set(id, base64)\n        if (imageContainer) {\n          imageWrapper.classList.remove('ag-empty-image')\n          imageWrapper.classList.add('ag-image-success')\n          const image = document.createElement('img')\n          image.src = base64\n          imageContainer.appendChild(image)\n        }\n      }\n      reader.readAsDataURL(file)\n\n      let newSrc = null\n      try {\n        newSrc = await this.muya.options.imageAction(file, id)\n      } catch (error) {\n        // TODO: Notify user about an error.\n        console.error('Unexpected error on image action:', error)\n        return null\n      }\n\n      const base64 = this.stateRender.urlMap.get(id)\n      if (base64) {\n        this.stateRender.urlMap.set(newSrc, base64)\n        this.stateRender.urlMap.delete(id)\n      }\n      const imageWrapper = this.muya.container.querySelector(`span[data-id=${id}]`)\n\n      if (imageWrapper) {\n        const imageInfo = getImageInfo(imageWrapper)\n        this.replaceImage(imageInfo, {\n          src: newSrc\n        })\n      }\n      return file\n    }\n    return null\n  }\n\n  // Handle global events.\n  ContentState.prototype.docPasteHandler = async function (event) {\n    // TODO: Pasting into CodeMirror will not work for special data like images\n    // or tables (HTML) because it's not handled.\n\n    const file = await this.pasteImage(event)\n    if (file) {\n      return event.preventDefault()\n    }\n\n    if (this.selectedTableCells) {\n      const { start } = this.cursor\n      const startBlock = this.getBlock(start.key)\n      const { selectedTableCells: stc } = this\n\n      // Exactly one table cell is selected. Replace the cells text via default handler.\n      if (startBlock && startBlock.functionType === 'cellContent' && stc.row === 1 && stc.column === 1) {\n        this.pasteHandler(event)\n        return event.preventDefault()\n      }\n    }\n  }\n\n  // Handle `normal` and `pasteAsPlainText` paste for preview mode.\n  ContentState.prototype.pasteHandler = async function (event, type = 'normal', rawText, rawHtml) {\n    event.preventDefault()\n    event.stopPropagation()\n\n    const text = rawText || event.clipboardData.getData('text/plain')\n    let html = rawHtml || event.clipboardData.getData('text/html')\n\n    // Support pasted URLs from Firefox.\n    if (URL_REG.test(text) && !/\\s/.test(text) && !html) {\n      html = `<a href=\"${text}\">${text}</a>`\n    }\n\n    // Remove crap from HTML such as meta data and styles and sanitize HTML,\n    // but `text` may still contain dangerous HTML.\n    html = await this.standardizeHTML(html)\n\n    let copyType = this.checkCopyType(html, text)\n    const { start, end } = this.cursor\n    const startBlock = this.getBlock(start.key)\n    const endBlock = this.getBlock(end.key)\n    const parent = this.getParent(startBlock)\n\n    if (copyType === 'htmlToMd') {\n      html = sanitize(text, PREVIEW_DOMPURIFY_CONFIG, false)\n      copyType = 'normal'\n    }\n\n    if (start.key !== end.key) {\n      this.cutHandler()\n      return this.pasteHandler(event, type, rawText, rawHtml)\n    }\n\n    // NOTE: We should parse HTML if we can and use it instead the image (see GH#1271).\n    if (!html) {\n      const file = await this.pasteImage(event)\n      if (file) {\n        return\n      }\n    }\n\n    const appendHtml = (text) => {\n      startBlock.text = startBlock.text.substring(0, start.offset) + text + startBlock.text.substring(start.offset)\n      const { key } = start\n      const offset = start.offset + text.length\n      this.cursor = {\n        start: { key, offset },\n        end: { key, offset }\n      }\n    }\n\n    // Prepare paste\n    if (startBlock.type === 'span' && startBlock.functionType === 'languageInput') {\n      // Extract the first line from the language identifier (GH#553)\n      let language = text.trim().match(/^.*$/m)[0] || ''\n      const oldLanguageLength = startBlock.text.length\n      let offset = 0\n      if (start.offset !== 0 || end.offset !== oldLanguageLength) {\n        const prePartText = startBlock.text.substring(0, start.offset)\n        const postPartText = startBlock.text.substring(end.offset)\n\n        // Expect that the language doesn't contain new lines\n        language = prePartText + language + postPartText\n        offset = prePartText.length + language.length\n      } else {\n        offset = language.length\n      }\n\n      startBlock.text = language\n\n      const key = startBlock.key\n      this.cursor = {\n        start: { key, offset },\n        end: { key, offset }\n      }\n\n      // Hide code picker float box\n      const { eventCenter } = this.muya\n      eventCenter.dispatch('muya-code-picker', { reference: null })\n\n      // Update code block language and render\n      this.updateCodeLanguage(startBlock, language)\n      return\n    }\n\n    if (startBlock.type === 'span' && startBlock.functionType === 'codeContent') {\n      const blockText = startBlock.text\n      const prePartText = blockText.substring(0, start.offset)\n      const postPartText = blockText.substring(end.offset)\n      startBlock.text = prePartText + text + postPartText\n      const { key } = startBlock\n      const offset = start.offset + text.length\n      this.cursor = {\n        start: { key, offset },\n        end: { key, offset }\n      }\n\n      return this.partialRender()\n    }\n\n    if (startBlock.functionType === 'cellContent') {\n      let isOneCellSelected = false\n      if (this.selectedTableCells) {\n        const { selectedTableCells: stc } = this\n        // Replace cells text when one cell is selected.\n        if (stc.row === 1 && stc.column === 1) {\n          isOneCellSelected = true\n        } else {\n          // Cancel event, multiple cells are selected.\n          return this.partialRender()\n        }\n      }\n\n      const { key } = startBlock\n      const pendingText = text.trim().replace(/\\n/g, '<br/>')\n      let offset = pendingText.length\n      if (isOneCellSelected) {\n        // Replace text and deselect cell.\n        startBlock.text = pendingText\n        this.selectedTableCells = null\n      } else {\n        offset += start.offset\n        startBlock.text = startBlock.text.substring(0, start.offset) + pendingText + startBlock.text.substring(end.offset)\n      }\n\n      this.cursor = {\n        start: { key, offset },\n        end: { key, offset }\n      }\n      return this.partialRender()\n    }\n\n    // Handle paste event and transform data into internal block structure.\n    if (copyType === 'copyAsHtml') {\n      switch (type) {\n        case 'normal': {\n          const htmlBlock = this.createBlockP(text.trim())\n          this.insertAfter(htmlBlock, parent)\n          this.removeBlock(parent)\n          // handler heading\n          this.insertHtmlBlock(htmlBlock)\n          break\n        }\n        case 'pasteAsPlainText': {\n          const lines = text.trim().split(LINE_BREAKS_REG)\n          let htmlBlock = null\n\n          if (!startBlock.text || lines.length > 1) {\n            htmlBlock = this.createBlockP((startBlock.text ? lines.slice(1) : lines).join('\\n'))\n          }\n          if (htmlBlock) {\n            this.insertAfter(htmlBlock, parent)\n            this.insertHtmlBlock(htmlBlock)\n          }\n          if (startBlock.text) {\n            appendHtml(lines[0])\n          } else {\n            this.removeBlock(parent)\n          }\n          break\n        }\n      }\n      return this.partialRender()\n    }\n\n    const stateFragments = type === 'pasteAsPlainText' || copyType === 'copyAsMarkdown'\n      ? this.markdownToState(text)\n      : this.html2State(html)\n\n    if (stateFragments.length <= 0) {\n      return\n    }\n\n    // Step 1: if select content, cut the content, and chop the block text into two part by the cursor.\n    const cacheText = endBlock.text.substring(end.offset)\n    startBlock.text = startBlock.text.substring(0, start.offset)\n\n    // Step 2: when insert the fragments, check begin a new block, or insert into pre block.\n    const firstFragment = stateFragments[0]\n    const tailFragments = stateFragments.slice(1)\n    const pasteType = this.checkPasteType(startBlock, firstFragment)\n\n    const getLastBlock = blocks => {\n      const len = blocks.length\n      const lastBlock = blocks[len - 1]\n\n      if (lastBlock.children.length === 0 && HAS_TEXT_BLOCK_REG.test(lastBlock.type)) {\n        return lastBlock\n      } else {\n        if (lastBlock.editable === false) {\n          return getLastBlock(blocks[len - 2].children)\n        } else {\n          return getLastBlock(lastBlock.children)\n        }\n      }\n    }\n\n    const lastBlock = getLastBlock(stateFragments)\n    let key = lastBlock.key\n    let offset = lastBlock.text.length\n    lastBlock.text += cacheText\n\n    switch (pasteType) {\n      case 'MERGE': {\n        if (LIST_REG.test(firstFragment.type)) {\n          const listItems = firstFragment.children\n          const firstListItem = listItems[0]\n          const liChildren = firstListItem.children\n          const originListItem = this.getParent(parent)\n          const originList = this.getParent(originListItem)\n          const targetListType = firstFragment.children[0].isLooseListItem\n          const originListType = originList.children[0].isLooseListItem\n          // No matter copy loose list to tight list or vice versa, the result is one loose list.\n          if (targetListType !== originListType) {\n            if (!targetListType) {\n              firstFragment.children.forEach(item => (item.isLooseListItem = true))\n            } else {\n              originList.children.forEach(item => (item.isLooseListItem = true))\n            }\n          }\n\n          if (liChildren[0].type === 'p') {\n            // TODO @JOCS\n            startBlock.text += liChildren[0].children[0].text\n            const tail = liChildren.slice(1)\n            if (tail.length) {\n              tail.forEach(t => {\n                this.appendChild(originListItem, t)\n              })\n            }\n            const firstFragmentTail = listItems.slice(1)\n            if (firstFragmentTail.length) {\n              firstFragmentTail.forEach(t => {\n                this.appendChild(originList, t)\n              })\n            }\n          } else {\n            listItems.forEach(c => {\n              this.appendChild(originList, c)\n            })\n          }\n          let target = originList\n          tailFragments.forEach(block => {\n            this.insertAfter(block, target)\n            target = block\n          })\n        } else if (firstFragment.type === 'p' || /^h\\d/.test(firstFragment.type)) {\n          const text = firstFragment.children[0].text\n          const lines = text.split('\\n')\n          let target = parent\n          if (parent.headingStyle === 'atx') {\n            startBlock.text += lines[0]\n            if (lines.length > 1) {\n              const pBlock = this.createBlockP(lines.slice(1).join('\\n'))\n              this.insertAfter(parent, pBlock)\n              target = pBlock\n            }\n          } else {\n            startBlock.text += text\n          }\n\n          tailFragments.forEach(block => {\n            this.insertAfter(block, target)\n            target = block\n          })\n        }\n        break\n      }\n      case 'NEWLINE': {\n        let target = parent\n        stateFragments.forEach(block => {\n          this.insertAfter(block, target)\n          target = block\n        })\n        if (startBlock.text.length === 0) {\n          this.removeBlock(parent)\n        }\n        break\n      }\n      default: {\n        throw new Error('unknown paste type')\n      }\n    }\n\n    // Step 3: set cursor and render\n    let cursorBlock = this.getBlock(key)\n    if (!cursorBlock) {\n      key = startBlock.key\n      offset = startBlock.text.length - cacheText.length\n      cursorBlock = startBlock\n    }\n\n    this.cursor = {\n      start: {\n        key, offset\n      },\n      end: {\n        key, offset\n      }\n    }\n    this.checkInlineUpdate(cursorBlock)\n    this.partialRender()\n    this.muya.dispatchSelectionChange()\n    this.muya.dispatchSelectionFormats()\n    return this.muya.dispatchChange()\n  }\n}\n\nexport default pasteCtrl\n", "output": {"vulnerability_count": 15, "vulnerabilities": [{"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 54}, {"description": "User controlled data in a `tmp.innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 54}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 79}, {"description": "User controlled data in a `tempWrapper.innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 79}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 88}, {"description": "User controlled data in a `th.innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 88}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 95}, {"description": "User controlled data in a `span.innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 95}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 103}, {"description": "User controlled data in a `td.innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 103}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 116}, {"description": "User controlled data in a `link.innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 116}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 119}, {"description": "User controlled data in a `span.innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 119}, {"description": "This template literal looks like HTML and has interpolated variables. These variables are not HTML-encoded by default. If the variables contain HTML tags, these may be interpreted by the browser, resulting in cross-site scripting (XSS).", "risk": "Medium", "conceptual_fix": "Not provided", "line": 271}]}}
{"CVE": "CVE-2023-2332", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n * @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n * @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\n\npimcore.registerNS(\"pimcore.bundle.EcommerceFramework.pricing.config.item\");\npimcore.bundle.EcommerceFramework.pricing.config.item = Class.create({\n\n    /**\n     * pimcore.bundle.EcommerceFramework.pricing.config.panel\n     */\n    parent: {},\n\n\n    /**\n     * constructor\n     * @param parent\n     * @param data\n     */\n    initialize: function(parent, data) {\n        this.parent = parent;\n        this.data = data;\n        this.currentIndex = 0;\n\n        this.tabPanel = new Ext.TabPanel({\n            title: this.data.name,\n            closable: true,\n            deferredRender: false,\n            forceLayout: true,\n            id: \"pimcore_pricing_panel_\" + this.data.id,\n            buttons: [{\n                text: t(\"save\"),\n                iconCls: \"pimcore_icon_apply\",\n                handler: this.save.bind(this)\n            }],\n            items: [\n                this.getSettings(),\n                this.getConditions(),\n                this.getActions()\n            ]\n        });\n        this.tabPanel.on(\"beforedestroy\", function () {\n            delete this.parent.panels[\"pricingrule_\" + this.data.id];\n        }.bind(this));\n\n\n        // add saved conditions\n        if(this.data.condition)\n        {\n            var list = this;\n            var level = 0;\n            var open = 0;\n            var handleCondition = function(condition){\n                if(condition.type == 'Bracket')\n                {\n                    // workarround for brackets\n                    level++;\n                    Ext.each(condition.conditions, function(item, index, allItems){\n                        item.condition.operator = item.operator;\n\n                        if(level > 1)\n                        {\n                            if(index == 0)\n                            {\n                                item.condition.bracketLeft = true;\n                                open++;\n                            }\n                            if(index == allItems.length -1 && open > 0)\n                            {\n                                item.condition.bracketRight = true;\n                                open--;\n                            }\n                        }\n\n                        handleCondition(item.condition);\n                    });\n                }\n                else\n                {\n                    // normal condition\n                    list.addCondition(\"condition\" + ucfirst(condition.type), condition);\n                }\n            };\n\n            handleCondition(this.data.condition);\n        }\n\n        // add saved actions\n        if(this.data.actions)\n        {\n            var list = this;\n            Ext.each(this.data.actions, function(action){\n                list.addAction(\"action\" + ucfirst(action.type), action);\n            });\n        }\n\n        // ...\n        var panel = this.parent.getTabPanel();\n        panel.add(this.tabPanel);\n        panel.setActiveTab(this.tabPanel);\n        panel.updateLayout();\n    },\n\n    activate: function () {\n        var panel = this.parent.getTabPanel();\n        panel.setActiveTab(this.tabPanel);\n        panel.updateLayout();\n    },\n\n    /**\n     * Basic rule Settings\n     * @returns Ext.form.FormPanel\n     */\n    getSettings: function () {\n        var data = this.data;\n\n        // create tabs for available languages\n        var langTabs = [];\n        Ext.each(pimcore.settings.websiteLanguages, function(lang){\n            var tab = {\n                title: pimcore.available_languages[ lang ],\n                items: [{\n                    xtype: \"textfield\",\n                    name: \"label.\" + lang,\n                    fieldLabel: t(\"label\"),\n                    width: 350,\n                    value: data.label[ lang ]\n                }, {\n                    xtype: \"textarea\",\n                    name: \"description.\" + lang,\n                    fieldLabel: t(\"description\"),\n                    width: 500,\n                    height: 100,\n                    value: data.description[ lang ]\n                }]\n            };\n\n            langTabs.push( tab );\n        });\n\n        // ...\n        this.settingsForm = new Ext.form.FormPanel({\n            title: t(\"settings\"),\n            bodyStyle: \"padding:10px;\",\n            autoScroll: true,\n            //border:false,\n            items: [{\n                style: \"margin-bottom: 10px\",\n                cls: \"object_localizedfields_panel\",\n                xtype: 'panel',\n                items: [{\n                    xtype: \"tabpanel\",\n                    defaults: {\n                        autoHeight:true\n                        ,\n                        bodyStyle:'padding:10px;'\n                    },\n                    items: langTabs\n                }]\n                }, {\n                name: \"behavior\",\n                fieldLabel: t(\"bundle_ecommerce_pricing_config_behavior\"),\n                xtype: \"combo\",\n                store: [\n                    [\"additiv\", t(\"bundle_ecommerce_pricing_config_additiv\")],\n                    [\"stopExecute\", t(\"bundle_ecommerce_pricing_config_stopExecute\")]\n                ],\n                mode: \"local\",\n                width: 300,\n                editable: false,\n                value: this.data.behavior,\n                triggerAction: \"all\"\n            }, {\n                xtype: \"checkbox\",\n                name: \"active\",\n                fieldLabel: t(\"active\"),\n                checked: this.data.active == \"1\"\n            }]\n        });\n\n        return this.settingsForm;\n    },\n\n    /**\n     * @returns Ext.Panel\n     */\n    getConditions: function() {\n\n        // init\n        var _this = this;\n        var addMenu = [];\n        var itemTypes = Object.keys(pimcore.bundle.EcommerceFramework.pricing.conditions);\n        // show only defined conditions\n        Ext.each(this.parent.condition, function (condition) {\n            var method = \"condition\" + condition;\n            if(itemTypes.indexOf(method) != -1)\n            {\n                addMenu.push({\n                    iconCls: \"bundle_ecommerce_pricing_icon_\" + method,\n                    text: pimcore.bundle.EcommerceFramework.pricing.conditions[method](null, null,true),\n                    handler: _this.addCondition.bind(_this, method)\n                });\n            }\n        });\n\n\n        this.conditionsContainer = new Ext.Panel({\n            title: t(\"conditions\"),\n            autoScroll: true,\n            forceLayout: true,\n            tbar: [{\n                iconCls: \"pimcore_icon_add\",\n                menu: addMenu\n            }],\n            border: false\n        });\n\n        return this.conditionsContainer;\n    },\n\n    /**\n     * @returns {*}\n     * @todo\n     */\n    getActions: function () {\n\n        // init\n        var _this = this;\n        var addMenu = [];\n        var itemTypes = Object.keys(pimcore.bundle.EcommerceFramework.pricing.actions);\n\n        // show only defined actions\n        Ext.each(this.parent.action, function (action) {\n            var method = \"action\" + action;\n            if(itemTypes.indexOf(method) != -1)\n            {\n                addMenu.push({\n                    iconCls: \"bundle_ecommerce_pricing_icon_\" + method,\n                    text: pimcore.bundle.EcommerceFramework.pricing.actions[method](null, null,true),\n                    handler: _this.addAction.bind(_this, method)\n                });\n            }\n        });\n\n\n        this.actionsContainer = new Ext.Panel({\n            title: t(\"actions\"),\n            autoScroll: true,\n            forceLayout: true,\n            bodyStyle: 'padding: 0 10px 10px 10px;',\n            tbar: [{\n                iconCls: \"pimcore_icon_add\",\n                menu: addMenu\n            }],\n            border: false\n        });\n\n        return this.actionsContainer;\n    },\n\n\n    /**\n     * add condition item\n     * @param type\n     * @param data\n     */\n    addCondition: function (type, data) {\n\n        // create condition\n        var item = pimcore.bundle.EcommerceFramework.pricing.conditions[type](this, data);\n\n        // add logic for brackets\n        var tab = this;\n        item.on(\"afterrender\", function (el) {\n            el.getEl().applyStyles({position: \"relative\", \"min-height\": \"40px\", \"border-bottom\": \"1px solid #d0d0d0\"});\n            var leftBracket = el.getEl().insertHtml(\"beforeEnd\",\n                '<div class=\"pimcore_targeting_bracket pimcore_targeting_bracket_left\">(</div>', true);\n            var rightBracket = el.getEl().insertHtml(\"beforeEnd\",\n                '<div class=\"pimcore_targeting_bracket pimcore_targeting_bracket_right\">)</div>', true);\n\n            if(data[\"bracketLeft\"]){\n                leftBracket.addCls(\"pimcore_targeting_bracket_active\");\n            }\n            if(data[\"bracketRight\"]){\n                rightBracket.addCls(\"pimcore_targeting_bracket_active\");\n            }\n\n            // open\n            leftBracket.on(\"click\", function (ev, el) {\n                var bracket = Ext.get(el);\n                bracket.toggleCls(\"pimcore_targeting_bracket_active\");\n\n                tab.recalculateBracketIdent(tab.conditionsContainer.items);\n            });\n\n            // close\n            rightBracket.on(\"click\", function (ev, el) {\n                var bracket = Ext.get(el);\n                bracket.toggleCls(\"pimcore_targeting_bracket_active\");\n\n                tab.recalculateBracketIdent(tab.conditionsContainer.items);\n            });\n\n            // make ident\n            tab.recalculateBracketIdent(tab.conditionsContainer.items);\n        });\n\n        this.conditionsContainer.add(item);\n        item.updateLayout();\n        this.conditionsContainer.updateLayout();\n\n        this.currentIndex++;\n\n        this.recalculateButtonStatus();\n    },\n\n    /**\n     * add action item\n     * @param type\n     * @param data\n     */\n    addAction: function (type, data) {\n\n        var item = pimcore.bundle.EcommerceFramework.pricing.actions[type](this, data);\n\n        this.actionsContainer.add(item);\n        item.updateLayout();\n        this.actionsContainer.updateLayout();\n    },\n\n    /**\n     * save config\n     */\n    save: function () {\n        var saveData = {};\n\n        // general settings\n        saveData[\"settings\"] = this.settingsForm.getForm().getFieldValues();\n\n        // get defined conditions\n        var conditionsData = [];\n        var operator;\n        var conditions = this.conditionsContainer.items.getRange();\n        for (var i=0; i<conditions.length; i++) {\n            var condition = {};\n\n            // collect condition settings\n            for(var c=0; c<conditions[i].items.length; c++)\n            {\n                var item = conditions[i].items.getAt(c);\n\n                try {\n                    // workaround for pimcore.object.tags.objects\n                    if(item.reference)\n                    {\n                        condition[ item.reference.getName() ] = item.reference.getValue();\n                    }\n                    else if(item.form)\n                    {\n                        condition[ item.name ] = item.getForm().getFieldValues();\n                    }\n                    else if(item.xtype === 'datefield')\n                    {\n                        condition[ item.name ] = item.getSubmitValue();\n                    }\n                    else\n                    {\n                        condition[ item.getName() ] = item.getValue();\n\n                    }\n                } catch (e){}\n\n            }\n            condition['type'] = conditions[i].type;\n\n            // get the operator (AND, OR, AND_NOT)\n            var tb = conditions[i].getDockedItems()[0];\n            if (tb.getComponent(\"toggle_or\").pressed) {\n                operator = \"or\";\n            } else if (tb.getComponent(\"toggle_and_not\").pressed) {\n                operator = \"and_not\";\n            } else {\n                operator = \"and\";\n            }\n            condition[\"operator\"] = operator;\n\n            // get the brackets\n            condition[\"bracketLeft\"] = Ext.get(conditions[i].getEl().query(\".pimcore_targeting_bracket_left\")[0])\n                                                                .hasCls(\"pimcore_targeting_bracket_active\");\n            condition[\"bracketRight\"] = Ext.get(conditions[i].getEl().query(\".pimcore_targeting_bracket_right\")[0])\n                                                                .hasCls(\"pimcore_targeting_bracket_active\");\n\n            conditionsData.push(condition);\n        }\n        saveData[\"conditions\"] = conditionsData;\n\n        // get defined actions\n        var actionData = [];\n        var actions = this.actionsContainer.items.getRange();\n        for (let i=0; i<actions.length; i++) {\n            let action = {};\n            action = actions[i].getForm().getFieldValues();\n            action['type'] = actions[i].type;\n\n            if (!actions[i].getForm().isValid()) {\n                console.error('Price action invalid');\n                return;\n            }\n\n            actionData.push(action);\n        }\n        saveData[\"actions\"] = actionData;\n\n        // send data\n        Ext.Ajax.request({\n            url: Routing.generate('pimcore_ecommerceframework_pricing_save'),\n            params: {\n                id: this.data.id,\n                data: Ext.encode(saveData)\n            },\n            method: \"PUT\",\n            success: this.saveOnComplete.bind(this)\n        });\n    },\n\n    /**\n     * saved\n     */\n    saveOnComplete: function (response) {\n        this.parent.refresh(this.parent.getTree().getRootNode());\n\n        var response = Ext.decode(response.responseText);\n\n        if (response.success) {\n            pimcore.helpers.showNotification(t(\"success\"), t(\"saved_successfully\"), \"success\");\n        } else {\n            pimcore.helpers.showNotification(t(\"error\"), t(response.message), \"error\", );\n        }\n    },\n\n    recalculateButtonStatus: function () {\n        var conditions = this.conditionsContainer.items.getRange();\n        for (var i=0; i<conditions.length; i++) {\n            var tb = conditions[i].getDockedItems()[0];\n            if(i==0) {\n                tb.getComponent(\"toggle_and\").hide();\n                tb.getComponent(\"toggle_or\").hide();\n                tb.getComponent(\"toggle_and_not\").hide();\n            } else {\n                tb.getComponent(\"toggle_and\").show();\n                tb.getComponent(\"toggle_or\").show();\n                tb.getComponent(\"toggle_and_not\").show();\n            }\n        }\n    },\n\n    /**\n     * make ident for bracket\n     * @param list\n     */\n    recalculateBracketIdent: function(list) {\n        var ident = 0, lastIdent = 0, margin = 20;\n        var colors = [\"transparent\",\"#007bff\", \"#00ff99\", \"#e1a6ff\", \"#ff3c00\", \"#000000\"];\n\n        list.each(function (condition) {\n\n            // only rendered conditions\n            if(condition.rendered == false) {\n                return;\n            }\n\n            // html from this condition\n            var item = condition.getEl();\n\n\n            // apply ident margin\n            item.applyStyles({\n                \"margin-left\": margin * ident + \"px\",\n                \"margin-right\": margin * ident + \"px\"\n            });\n\n\n            // apply colors\n            if(ident > 0) {\n                item.applyStyles({\n                    \"border-left\": \"1px solid \" + colors[ident],\n                    \"border-right\": \"1px solid \" + colors[ident]\n                });\n            } else {\n                item.applyStyles({\n                    \"border-left\": \"0px\",\n                    \"border-right\": \"0px\"\n                });\n            }\n\n\n            // apply specials :-)\n            if(ident == 0) {\n                item.applyStyles({\n                    \"margin-top\": \"10px\"\n                });\n            } else if(ident == lastIdent) {\n                item.applyStyles({\n                    \"margin-top\": \"0px\",\n                    \"margin-bottom\": \"0px\"\n                });\n            } else {\n                item.applyStyles({\n                    \"margin-top\": \"5px\"\n                });\n            }\n\n\n            // remember current ident\n            lastIdent = ident;\n\n\n            // check if a bracket is open\n            if(item.select('.pimcore_targeting_bracket_left.pimcore_targeting_bracket_active').getCount() == 1)\n            {\n                ident++;\n            }\n            // check if a bracket is close\n            else if(item.select('.pimcore_targeting_bracket_right.pimcore_targeting_bracket_active').getCount() == 1)\n            {\n                if(ident > 0) {\n                    ident--;\n                }\n            }\n        });\n\n        this.conditionsContainer.updateLayout();\n    }\n});\n\n\n/**\n * CONDITION TYPES\n */\npimcore.registerNS(\"pimcore.bundle.EcommerceFramework.pricing.conditions\");\npimcore.bundle.EcommerceFramework.pricing.conditions = {\n\n    detectBlockIndex: function (blockElement, container) {\n        // detect index\n        var index;\n\n        for(var s=0; s<container.items.items.length; s++) {\n            if(container.items.items[s].getId() == blockElement.getId()) {\n                index = s;\n                break;\n            }\n        }\n        return index;\n    },\n\n    /**\n     * @param name\n     * @param index\n     * @param parent\n     * @param data\n     * @param iconCls\n     * @returns {Array}\n     * @todo idents berechnung ausfhren wenn eine condition verschoben wird\n     */\n    getTopBar: function (name, index, parent, data, iconCls) {\n\n        var toggleGroup = \"g_\" + index + parent.data.id;\n        if(!data[\"operator\"]) {\n            data.operator = \"and\";\n        }\n\n        return [{\n            iconCls: iconCls,\n            disabled: true\n        }, {\n            xtype: \"tbtext\",\n            text: \"<b>\" + name + \"</b>\"\n        },\"-\",{\n            iconCls: \"pimcore_icon_up\",\n            handler: function (blockId, parent) {\n\n                var container = parent.conditionsContainer;\n                var blockElement = Ext.getCmp(blockId);\n                var index = pimcore.bundle.EcommerceFramework.pricing.conditions.detectBlockIndex(blockElement, container);\n                var tmpContainer = pimcore.viewport;\n\n                var newIndex = index-1;\n                if(newIndex < 0) {\n                    newIndex = 0;\n                }\n\n                // move this node temorary to an other so ext recognizes a change\n                container.remove(blockElement, false);\n                tmpContainer.add(blockElement);\n                container.updateLayout();\n                tmpContainer.updateLayout();\n\n                // move the element to the right position\n                tmpContainer.remove(blockElement,false);\n                container.insert(newIndex, blockElement);\n                container.updateLayout();\n                tmpContainer.updateLayout();\n\n                parent.recalculateButtonStatus();\n\n                pimcore.layout.refresh();\n\n                parent.recalculateBracketIdent(parent.conditionsContainer.items);\n            }.bind(window, index, parent)\n        },{\n            iconCls: \"pimcore_icon_down\",\n            handler: function (blockId, parent) {\n\n                var container = parent.conditionsContainer;\n                var blockElement = Ext.getCmp(blockId);\n                var index = pimcore.bundle.EcommerceFramework.pricing.conditions.detectBlockIndex(blockElement, container);\n                var tmpContainer = pimcore.viewport;\n\n                // move this node temorary to an other so ext recognizes a change\n                container.remove(blockElement, false);\n                tmpContainer.add(blockElement);\n                container.updateLayout();\n                tmpContainer.updateLayout();\n\n                // move the element to the right position\n                tmpContainer.remove(blockElement,false);\n                container.insert(index+1, blockElement);\n                container.updateLayout();\n                tmpContainer.updateLayout();\n\n                parent.recalculateButtonStatus();\n\n                pimcore.layout.refresh();\n                parent.recalculateBracketIdent(parent.conditionsContainer.items);\n\n            }.bind(window, index, parent)\n        },\"-\", {\n            text: t(\"AND\"),\n            toggleGroup: toggleGroup,\n            enableToggle: true,\n            itemId: \"toggle_and\",\n            pressed: (data.operator == \"and\") ? true : false\n        },{\n            text: t(\"OR\"),\n            toggleGroup: toggleGroup,\n            enableToggle: true,\n            itemId: \"toggle_or\",\n            pressed: (data.operator == \"or\") ? true : false\n        },{\n            text: t(\"AND_NOT\"),\n            toggleGroup: toggleGroup,\n            enableToggle: true,\n            itemId: \"toggle_and_not\",\n            pressed: (data.operator == \"and_not\") ? true : false\n        },\"->\",{\n            iconCls: \"pimcore_icon_delete\",\n            handler: function (index, parent) {\n                parent.conditionsContainer.remove(Ext.getCmp(index));\n                parent.recalculateButtonStatus();\n                parent.recalculateBracketIdent(parent.conditionsContainer.items);\n            }.bind(window, index, parent)\n        }];\n    },\n\n    /**\n     * @param panel\n     * @param data\n     * @param getName\n     * @returns Ext.form.FormPanel\n     */\n    conditionDateRange: function (panel, data, getName) {\n\n        //\n        var niceName = t(\"bundle_ecommerce_pricing_config_condition_daterange\");\n        if(typeof getName != \"undefined\" && getName) {\n            return niceName;\n        }\n\n        // check params\n        if(typeof data == \"undefined\") {\n            data = {};\n        }\n\n        // create item\n        var myId = Ext.id();\n        var item =  new Ext.form.FormPanel({\n            id: myId,\n            type: 'DateRange',\n            forceLayout: true,\n            style: \"margin: 10px 0 0 0\",\n            bodyStyle: \"padding: 10px 30px 10px 30px; min-height:30px;\",\n            tbar: this.getTopBar(niceName, myId, panel, data, \"bundle_ecommerce_pricing_icon_conditionDateRange\"),\n            items: [{\n                xtype:'datefield',\n                fieldLabel: t(\"from\"),\n                name: \"starting\",\n                format: 'd.m.Y',\n                altFormats: 'U',\n                value: data.starting,\n                width: 400\n            },{\n                xtype:'datefield',\n                fieldLabel: t(\"to\"),\n                name: \"ending\",\n                format: 'd.m.Y',\n                altFormats: 'U',\n                value: data.ending,\n                width: 400\n            }],\n            listeners: {\n\n            }\n        });\n\n        return item;\n    },\n\n    /**\n     * @param panel\n     * @param data\n     * @param getName\n     * @returns Ext.form.FormPanel\n     */\n    conditionCatalogProduct: function (panel, data, getName) {\n\n        var niceName = t(\"product\");\n        if(typeof getName != \"undefined\" && getName) {\n            return niceName;\n        }\n\n        if(typeof data == \"undefined\") {\n            data = {};\n        }\n        var myId = Ext.id();\n\n        var item =  new Ext.form.FormPanel({\n            id: myId,\n            type: 'CatalogProduct',\n            forceLayout: true,\n            style: \"margin: 10px 0 0 0\",\n            bodyStyle: \"padding: 10px 30px 10px 30px; min-height:40px;\",\n            tbar: this.getTopBar(niceName, myId, panel, data, \"bundle_ecommerce_pricing_icon_conditionCatalogProduct\"),\n            items: [\n                new pimcore.bundle.EcommerceFramework.pricing.config.objects(data.products, {\n                    name: \"products\",\n                    title: \"\",\n                    visibleFields: \"path\",\n                    height: 200,\n                    width: 500,\n                    columns: [],\n\n                    // ?\n                    columnType: null,\n                    datatype: \"data\",\n                    fieldtype: \"objects\",\n\n                    // ??\n                    index: false,\n                    invisible: false,\n                    lazyLoading: false,\n                    locked: false,\n                    mandatory: false,\n                    maxItems: \"\",\n                    noteditable: false,\n                    permissions: null,\n                    phpdocType: \"array\",\n                    queryColumnType: \"text\",\n                    relationType: true,\n                    style: \"\",\n                    tooltip: \"\",\n                    visibleGridView: false,\n                    visibleSearch: false\n                }).getLayoutEdit()\n            ]\n        });\n\n        return item;\n    },\n\n\n    /**\n     * @param panel\n     * @param data\n     * @param getName\n     * @returns Ext.form.FormPanel\n     */\n    conditionCatalogCategory: function (panel, data, getName) {\n\n        var niceName = t(\"category\");\n        if(typeof getName != \"undefined\" && getName) {\n            return niceName;\n        }\n\n        if(typeof data == \"undefined\") {\n            data = {};\n        }\n        var myId = Ext.id();\n\n        var item =  new Ext.form.FormPanel({\n            id: myId,\n            type: 'CatalogCategory',\n            forceLayout: true,\n            style: \"margin: 10px 0 0 0\",\n            bodyStyle: \"padding: 0px 30px 10px 30px; min-height:40px;\",\n            tbar: this.getTopBar(niceName, myId, panel, data, \"bundle_ecommerce_pricing_icon_conditionCatalogCategory\"),\n            items: [\n                new pimcore.bundle.EcommerceFramework.pricing.config.objects(data.categories, {\n                    name: \"categories\",\n                    title: \"\",\n                    visibleFields: \"path\",\n                    height: 200,\n                    width: 500,\n                    columns: [],\n\n                    // ?\n                    columnType: null,\n                    datatype: \"data\",\n                    fieldtype: \"objects\",\n\n                    // ??\n                    index: false,\n                    invisible: false,\n                    lazyLoading: false,\n                    locked: false,\n                    mandatory: false,\n                    maxItems: \"\",\n                    noteditable: false,\n                    permissions: null,\n                    phpdocType: \"array\",\n                    queryColumnType: \"text\",\n                    relationType: true,\n                    style: \"\",\n                    tooltip: \"\",\n                    visibleGridView: false,\n                    visibleSearch: false\n                }).getLayoutEdit()\n            ]\n        });\n\n        return item;\n    },\n\n\n    /**\n     * @param panel\n     * @param data\n     * @param getName\n     * @returns Ext.form.FormPanel\n     */\n    conditionCartAmount: function (panel, data, getName) {\n\n        var niceName = t(\"bundle_ecommerce_pricing_config_condition_cart_amount\");\n        if(typeof getName != \"undefined\" && getName) {\n            return niceName;\n        }\n\n        if(typeof data == \"undefined\") {\n            data = {};\n        }\n        var myId = Ext.id();\n\n        var item =  new Ext.form.FormPanel({\n            id: myId,\n            type: 'CartAmount',\n            forceLayout: true,\n            style: \"margin: 10px 0 0 0\",\n            bodyStyle: \"padding: 10px 30px 10px 30px; min-height:40px;\",\n            tbar: this.getTopBar(niceName, myId, panel, data, \"bundle_ecommerce_pricing_icon_conditionCartAmount\"),\n            items: [{\n                xtype: \"numberfield\",\n                fieldLabel: t(\"bundle_ecommerce_pricing_config_condition_cart_amount\"),\n                name: \"limit\",\n                width: 300,\n                value: data.limit\n            }]\n        });\n\n        return item;\n    },\n\n\n    /**\n     * @param panel\n     * @param data\n     * @param getName\n     * @returns Ext.form.FormPanel\n     */\n    conditionToken: function (panel, data, getName) {\n\n        //\n        var niceName = t(\"bundle_ecommerce_pricing_config_condition_token\");\n        if(typeof getName != \"undefined\" && getName) {\n            return niceName;\n        }\n\n        // check params\n        if(typeof data == \"undefined\") {\n            data = {};\n        }\n\n        // create item\n        var myId = Ext.id();\n        var item =  new Ext.form.FormPanel({\n            id: myId,\n            type: 'Token',\n            forceLayout: true,\n            style: \"margin: 10px 0 0 0\",\n            bodyStyle: \"padding: 10px 30px 10px 30px; min-height:40px;\",\n            tbar: this.getTopBar(niceName, myId, panel, data, \"bundle_ecommerce_pricing_icon_conditionToken\"),\n            items: [{\n                xtype: \"textfield\",\n                fieldLabel: t(\"value\"),\n                name: \"token\",\n                width: 200,\n                value: data.token\n            }],\n        });\n\n        return item;\n    },\n\n\n    /**\n     * @param panel\n     * @param data\n     * @param getName\n     * @returns Ext.form.FormPanel\n     */\n    conditionSold: function (panel, data, getName) {\n\n        //\n        var niceName = t(\"bundle_ecommerce_pricing_config_condition_sold\");\n        if(typeof getName != \"undefined\" && getName) {\n            return niceName;\n        }\n\n        // check params\n        if(typeof data == \"undefined\") {\n            data = {};\n        }\n\n        // create item\n        var myId = Ext.id();\n        var item =  new Ext.form.FormPanel({\n            id: myId,\n            type: 'Sold',\n            forceLayout: true,\n            style: \"margin: 10px 0 0 0\",\n            bodyStyle: \"padding: 10px 30px 10px 30px; min-height:40px;\",\n            tbar: this.getTopBar(niceName, myId, panel, data, \"bundle_ecommerce_pricing_icon_conditionSold\"),\n            items: [{\n                xtype: \"numberfield\",\n                fieldLabel: t(\"bundle_ecommerce_pricing_config_condition_sold_count\"),\n                name: \"count\",\n                width: 300,\n                value: data.count\n            }],\n        });\n\n        return item;\n    },\n\n\n    /**\n     * @param panel\n     * @param data\n     * @param getName\n     * @returns Ext.form.FormPanel\n     */\n    conditionSales: function (panel, data, getName) {\n\n        //\n        var niceName = t(\"bundle_ecommerce_pricing_config_condition_sales\");\n        if(typeof getName != \"undefined\" && getName) {\n            return niceName;\n        }\n\n        // check params\n        if(typeof data == \"undefined\") {\n            data = {};\n        }\n\n        // create item\n        var myId = Ext.id();\n        var item =  new Ext.form.FormPanel({\n            id: myId,\n            type: 'Sales',\n            forceLayout: true,\n            style: \"margin: 10px 0 0 0\",\n            bodyStyle: \"padding: 10px 30px 10px 30px; min-height:40px;\",\n            tbar: this.getTopBar(niceName, myId, panel, data, \"bundle_ecommerce_pricing_icon_conditionSales\"),\n            items: [{\n                xtype: \"numberfield\",\n                fieldLabel: t(\"amount\"),\n                name: \"amount\",\n                width: 300,\n                value: data.amount\n            }],\n        });\n\n        return item;\n    },\n\n\n    /**\n     * @param panel\n     * @param data\n     * @param getName\n     * @returns Ext.form.FormPanel\n     */\n    conditionClientIp: function (panel, data, getName) {\n\n        //\n        var niceName = 'IP';\n        if(typeof getName != \"undefined\" && getName) {\n            return niceName;\n        }\n\n\n        // create item\n        var myId = Ext.id();\n        var item =  new Ext.form.FormPanel({\n            id: myId,\n            type: 'ClientIp',\n            forceLayout: true,\n            style: \"margin: 10px 0 0 0\",\n            bodyStyle: \"padding: 10px 30px 10px 30px; min-height:40px;\",\n            tbar: this.getTopBar(niceName, myId, panel, data, \"bundle_ecommerce_pricing_icon_conditionClientIp\"),\n            items: [{\n                xtype: \"textfield\",\n                fieldLabel: 'IP',\n                name: \"ip\",\n                width: 300,\n                value: data.ip\n            }]\n        });\n\n\n        // set default value\n        if(data.ip == undefined)\n        {\n            Ext.Ajax.request({\n                url: Routing.generate('pimcore_admin_settings_getsystem'),\n                success: function (response) {\n\n                    var settings = Ext.decode(response.responseText);\n                    item.getForm().findField('ip').setValue( settings.config.client_ip );\n\n                }.bind(this)\n            });\n        }\n\n\n        return item;\n    },\n\n    /**\n     * @param panel\n     * @param data\n     * @param getName\n     * @returns Ext.form.FormPanel\n     */\n    conditionVoucherToken: function (panel, data, getName) {\n        var niceName = t(\"bundle_ecommerce_pricing_config_condition_voucherToken\");\n        if(typeof getName != \"undefined\" && getName) {\n            return niceName;\n        }\n\n        // check params\n        if(typeof data == \"undefined\") {\n            data = {\n                error_messages: {}\n            };\n        }\n\n\n        var langTabs = [];\n        Ext.each(pimcore.settings.websiteLanguages, function(lang){\n            var tab = {\n                title: pimcore.available_languages[ lang ],\n                items: [{\n                    xtype: \"textfield\",\n                    name: lang,\n                    fieldLabel: t(\"error_message\"),\n                    width: 600,\n                    value: data.error_messages ? data.error_messages[ lang ] : ''\n                }]\n            };\n\n            langTabs.push( tab );\n        });\n\n        // create item\n        var myId = Ext.id();\n        var item =  new Ext.form.FormPanel({\n            id: myId,\n            type: 'VoucherToken',\n            forceLayout: true,\n            style: \"margin: 10px 0 0 0\",\n            bodyStyle: \"padding: 10px 30px 10px 30px; min-height:40px;\",\n            tbar: this.getTopBar(niceName, myId, panel, data, \"bundle_ecommerce_pricing_icon_conditionVoucherToken\"),\n            items: [\n                new pimcore.bundle.EcommerceFramework.pricing.config.objects(data.whiteList, {\n                    classes: [\n                        \"OnlineShopVoucherSeries\"\n                    ],\n                    name: \"whiteList\",\n                    title: \"White List\",\n                    visibleFields: \"path\",\n                    height: 200,\n                    width: 600,\n                    columns: [],\n                    columnType: null,\n                    datatype: \"data\",\n                    fieldtype: \"objects\",\n                    index: false,\n                    invisible: false,\n                    lazyLoading: false,\n                    locked: false,\n                    mandatory: false,\n                    maxItems: \"\",\n                    noteditable: false,\n                    permissions: null,\n                    phpdocType: \"array\",\n                    queryColumnType: \"text\",\n                    relationType: true,\n                    style: \"\",\n                    tooltip: \"\",\n                    visibleGridView: false,\n                    visibleSearch: false\n                }).getLayoutEdit(),\n                Ext.create('Ext.form.Panel', {\n                    style: \"margin-bottom: 10px\",\n                    cls: \"object_localizedfields_panel\",\n                    name: 'error_messages',\n                    isFormPanel: true,\n                    items: [{\n                        xtype: \"tabpanel\",\n                        style: \"margin-bottom: 30px\",\n                        defaults: {\n                            autoHeight: true,\n                            bodyStyle: 'padding:10px;'\n                        },\n                        items: langTabs\n                    }]\n                })\n            ]\n        });\n\n        return item;\n    },\n\n    /**\n     * @param panel\n     * @param data\n     * @param getName\n     * @returns Ext.form.FormPanel\n     */\n    conditionTenant: function (panel, data, getName) {\n        var niceName = t(\"bundle_ecommerce_pricing_config_condition_tenant\");\n        if (typeof getName !== \"undefined\" && getName) {\n            return niceName;\n        }\n\n        // check params\n        if (typeof data === \"undefined\") {\n            data = {};\n        }\n\n        // create item\n        var myId = Ext.id();\n        var item = new Ext.form.FormPanel({\n            id: myId,\n            type: 'Tenant',\n            forceLayout: true,\n            style: \"margin: 10px 0 0 0\",\n            bodyStyle: \"padding: 10px 30px 10px 30px; min-height:40px;\",\n            tbar: this.getTopBar(niceName, myId, panel, data, \"bundle_ecommerce_pricing_icon_conditionTenant\"),\n            items: [{\n                xtype: \"textfield\",\n                fieldLabel: t(\"bundle_ecommerce_pricing_config_condition_tenant\"),\n                name: \"tenant\",\n                width: 350,\n                value: data.tenant\n            }]\n        });\n\n        return item;\n    },\n\n    /**\n     * @param panel\n     * @param data\n     * @param getName\n     * @returns Ext.form.FormPanel\n     */\n    conditionTargetGroup: function (panel, data, getName) {\n        var niceName = t(\"bundle_ecommerce_pricing_config_condition_targetgroup\");\n        if (typeof getName !== \"undefined\" && getName) {\n            return niceName;\n        }\n\n        // check params\n        if (typeof data === \"undefined\") {\n            data = {};\n        }\n\n\n        this.targetGroupStore = Ext.create('Ext.data.JsonStore', {\n            autoLoad: true,\n            proxy: {\n                type: 'ajax',\n                url: Routing.generate('pimcore_admin_targeting_targetgrouplist')\n            },\n            fields: [\"id\", \"text\"],\n            listeners: {\n                load: function() {\n                    this.targetGroup.setValue(data.targetGroupId);\n                }.bind(this)\n            }\n        });\n\n        this.targetGroup = new Ext.form.ComboBox({\n            displayField:'text',\n            valueField: \"id\",\n            name: \"targetGroupId\",\n            fieldLabel: t(\"bundle_ecommerce_pricing_config_condition_targetgroup\"),\n            store: this.targetGroupStore,\n            editable: false,\n            triggerAction: 'all',\n            width: 500,\n            listeners: {\n            }\n        });\n\n\n        // create item\n        var myId = Ext.id();\n        var item = new Ext.form.FormPanel({\n            id: myId,\n            type: 'TargetGroup',\n            forceLayout: true,\n            style: \"margin: 10px 0 0 0\",\n            bodyStyle: \"padding: 10px 30px 10px 30px; min-height:40px;\",\n            tbar: this.getTopBar(niceName, myId, panel, data, \"bundle_ecommerce_pricing_icon_conditionTargetGroup\"),\n            items: [\n                this.targetGroup,\n                {\n                    xtype: \"numberfield\",\n                    fieldLabel: t(\"bundle_ecommerce_pricing_config_condition_targetgroup_threshold\"),\n                    name: \"threshold\",\n                    width: 200,\n                    value: data.threshold\n                }\n            ]\n        });\n\n        return item;\n    }\n};\n\n\n/**\n * ACTION TYPES\n */\npimcore.registerNS(\"pimcore.bundle.EcommerceFramework.pricing.actions\");\npimcore.bundle.EcommerceFramework.pricing.actions = {\n\n    /**\n     * @param name\n     * @param index\n     * @param parent\n     * @param data\n     * @param iconCls\n     * @returns {Array}\n     */\n    getTopBar: function (name, index, parent, data, iconCls) {\n        return [\n            {\n                iconCls: iconCls,\n                disabled: true\n            },\n            {\n                xtype: \"tbtext\",\n                text: \"<b>\" + name + \"</b>\"\n            },\n            \"->\",\n            {\n                iconCls: \"pimcore_icon_delete\",\n                handler: function (index, parent) {\n                    parent.actionsContainer.remove(Ext.getCmp(index));\n                }.bind(window, index, parent)\n        }];\n    },\n\n    /**\n     * @param panel\n     * @param data\n     * @param getName\n     * @returns Ext.form.FormPanel\n     */\n    actionGift: function (panel, data, getName) {\n\n        // getName macro\n        var niceName = t(\"bundle_ecommerce_pricing_config_action_gift\");\n        if(typeof getName != \"undefined\" && getName) {\n            return niceName;\n        }\n\n        // check params\n        if(typeof data == \"undefined\") {\n            data = {};\n        }\n\n        // config\n        var iconCls = 'bundle_ecommerce_pricing_icon_actionGift';\n\n        // create item\n        var myId = Ext.id();\n        var item =  new Ext.form.FormPanel({\n            id: myId,\n            type: 'Gift',\n            forceLayout: true,\n            border: true,\n            style: \"margin: 10px 0 0 0\",\n            bodyStyle: \"padding: 10px 30px 10px 30px; min-height:40px;\",\n            tbar: this.getTopBar(niceName, myId, panel, data, iconCls),\n            items: [\n                {\n                    xtype: \"textfield\",\n                    fieldLabel: t(\"product\"),\n                    name: \"product\",\n                    width: 500,\n                    cls: \"input_drop_target\",\n                    value: data.product,\n                    listeners: {\n                        \"render\": function (el) {\n                            new Ext.dd.DropZone(el.getEl(), {\n                                reference: this,\n                                ddGroup: \"element\",\n                                getTargetFromEvent: function(e) {\n                                    return this.getEl();\n                                }.bind(el),\n\n                                onNodeOver : function(target, dd, e, data) {\n                                    return Ext.dd.DropZone.prototype.dropAllowed;\n                                },\n\n                                onNodeDrop : function (target, dd, e, data) {\n                                    var record = data.records[0];\n                                    var data = record.data;\n\n                                    if (data.type == \"object\" || data.type == \"variant\") {\n                                        this.setValue(data.path);\n                                        return true;\n                                    }\n                                    return false;\n                                }.bind(el)\n                            });\n                        }\n                    }\n                }\n            ]\n        });\n\n        return item;\n    },\n\n    /**\n     * @param panel\n     * @param data\n     * @param getName\n     * @returns Ext.form.FormPanel\n     */\n    actionCartDiscount: function (panel, data, getName) {\n\n        // getName macro\n        var niceName = t(\"bundle_ecommerce_pricing_config_action_cart_discount\");\n        if(typeof getName != \"undefined\" && getName) {\n            return niceName;\n        }\n\n        // check params\n        if(typeof data == \"undefined\") {\n            data = {};\n        }\n\n        // config\n        var iconCls = 'bundle_ecommerce_pricing_icon_actionCartDiscount';\n\n        // create item\n        var myId = Ext.id();\n        var item =  new Ext.form.FormPanel({\n            id: myId,\n            type: 'CartDiscount',\n            forceLayout: true,\n            border: true,\n            style: \"margin: 10px 0 0 0\",\n            bodyStyle: \"padding: 10px 30px 10px 30px; min-height:40px;\",\n            tbar: this.getTopBar(niceName, myId, panel, data, iconCls),\n            items: [\n                {\n                    xtype: \"numberfield\",\n                    fieldLabel: t(\"bundle_ecommerce_pricing_config_action_cart_discount_amount\"),\n                    name: \"amount\",\n                    width: 200,\n                    value: data.amount,\n                    minValue: 0\n                }, {\n                    xtype: \"numberfield\",\n                    fieldLabel: t(\"bundle_ecommerce_pricing_config_action_cart_discount_percent\"),\n                    name: \"percent\",\n                    width: 200,\n                    value: data.percent,\n                    maxValue: 100,\n                    minValue: 0\n                }\n            ]\n        });\n\n        return item;\n    },\n\n    /**\n     * @param panel\n     * @param data\n     * @param getName\n     * @returns Ext.form.FormPanel\n     */\n    actionProductDiscount: function (panel, data, getName) {\n\n        // getName macro\n        var niceName = t(\"bundle_ecommerce_pricing_config_action_product_discount\");\n        if(typeof getName != \"undefined\" && getName) {\n            return niceName;\n        }\n\n        // check params\n        if(typeof data == \"undefined\") {\n            data = {};\n        }\n\n        // config\n        var iconCls = 'bundle_ecommerce_pricing_icon_actionProductDiscount';\n\n        // create item\n        var myId = Ext.id();\n        var item =  new Ext.form.FormPanel({\n            id: myId,\n            type: 'ProductDiscount',\n            forceLayout: true,\n            border: true,\n            style: \"margin: 10px 0 0 0\",\n            bodyStyle: \"padding: 10px 30px 10px 30px; min-height:40px;\",\n            tbar: this.getTopBar(niceName, myId, panel, data, iconCls),\n            items: [\n                {\n                    xtype: \"numberfield\",\n                    fieldLabel: t(\"bundle_ecommerce_pricing_config_action_product_discount_amount\"),\n                    name: \"amount\",\n                    width: 200,\n                    value: data.amount,\n                    minValue: 0\n                }, {\n                    xtype: \"numberfield\",\n                    fieldLabel: t(\"bundle_ecommerce_pricing_config_action_product_discount_percent\"),\n                    name: \"percent\",\n                    width: 200,\n                    value: data.percent,\n                    maxValue: 100,\n                    minValue: 0\n                }\n            ]\n        });\n\n        return item;\n    },\n\n    /**\n     * @param panel\n     * @param data\n     * @param getName\n     * @returns Ext.form.FormPanel\n     */\n    actionFreeShipping: function (panel, data, getName) {\n\n        // getName macro\n        var niceName = t(\"bundle_ecommerce_pricing_config_action_free_shipping\");\n        if(typeof getName != \"undefined\" && getName) {\n            return niceName;\n        }\n\n        // check params\n        if(typeof data == \"undefined\") {\n            data = {};\n        }\n\n        // config\n        var iconCls = 'bundle_ecommerce_pricing_icon_actionFreeShipping';\n\n        // create item\n        var myId = Ext.id();\n        var item =  new Ext.form.FormPanel({\n            id: myId,\n            type: 'FreeShipping',\n            forceLayout: true,\n            border: true,\n            style: \"margin: 10px 0 0 0\",\n//            bodyStyle: \"padding: 10px 30px 10px 30px; min-height:40px;\",\n            tbar: this.getTopBar(niceName, myId, panel, data, iconCls)\n        });\n\n        return item;\n    }\n};\n", "output": {"vulnerability_count": 6, "vulnerabilities": [{"description": "Using non-static data to retrieve and run functions from the object is dangerous. If the data is user-controlled, it may allow executing arbitrary code.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 209}, {"description": "Using non-static data to retrieve and run functions from the object is dangerous. If the data is user-controlled, it may allow executing arbitrary code.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 248}, {"description": "Using non-static data to retrieve and run functions from the object is dangerous. If the data is user-controlled, it may allow executing arbitrary code.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 279}, {"description": "Using non-static data to retrieve and run functions from the object is dangerous. If the data is user-controlled, it may allow executing arbitrary code.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 333}, {"description": "`action` is assigned twice; the first assignment is useless", "risk": "Medium", "conceptual_fix": "Not provided", "line": 410}, {"description": "Detected a useless comparison operation `ident == ident` or `ident != ident`. This operation is always true. If testing for floating point NaN, use `math.isnan`, or `cmath.isnan` if the number is complex.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 507}]}}
{"CVE": "CVE-2023-23556", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// RUN: %hermes -non-strict -O %s | %FileCheck %s\n// RUN: %hermes -non-strict -O0 %s | %FileCheck %s\n\n// TODO: fix BigInt to number conversion (it should never result in NaN).\nprint(Number(0xffffffffffffffffffffffffffffffffn));\n// CHECK: NaN\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2023-23557", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "/*\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include \"JSLibInternal.h\"\n\n#include \"hermes/FrontEndDefs/Builtins.h\"\n#include \"hermes/Support/Base64vlq.h\"\n#include \"hermes/VM/Callable.h\"\n#include \"hermes/VM/JSArray.h\"\n#include \"hermes/VM/JSArrayBuffer.h\"\n#include \"hermes/VM/JSLib.h\"\n#include \"hermes/VM/JSRegExp.h\"\n#include \"hermes/VM/Operations.h\"\n#include \"hermes/VM/PrimitiveBox.h\"\n#include \"hermes/VM/StackFrame-inline.h\"\n#include \"hermes/VM/StringView.h\"\n\n#include <random>\n\nnamespace hermes {\nnamespace vm {\n\n/// Set the parent of an object failing silently on any error.\nCallResult<HermesValue>\nsilentObjectSetPrototypeOf(void *, Runtime &runtime, NativeArgs args) {\n  JSObject *O = dyn_vmcast<JSObject>(args.getArg(0));\n  if (!O)\n    return HermesValue::encodeUndefinedValue();\n\n  JSObject *parent;\n  HermesValue V = args.getArg(1);\n  if (V.isNull())\n    parent = nullptr;\n  else if (V.isObject())\n    parent = vmcast<JSObject>(V);\n  else\n    return HermesValue::encodeUndefinedValue();\n\n  (void)JSObject::setParent(O, runtime, parent);\n\n  // Ignore exceptions.\n  runtime.clearThrownValue();\n\n  return HermesValue::encodeUndefinedValue();\n}\n\n/// ES6.0 12.2.9.3 Runtime Semantics: GetTemplateObject ( templateLiteral )\n/// Given a template literal, return a template object that looks like this:\n/// [cookedString0, cookedString1, ..., raw: [rawString0, rawString1]].\n/// This object is frozen, as well as the 'raw' object nested inside.\n/// We only pass the parts from the template literal that are needed to\n/// construct this object. That is, the raw strings and cooked strings.\n/// Arguments: \\p templateObjID is the unique id associated with the template\n/// object. \\p dup is a boolean, when it is true, cooked strings are the same as\n/// raw strings. Then raw strings are passed. Finally cooked strings are\n/// optionally passed if \\p dup is true.\nCallResult<HermesValue>\nhermesBuiltinGetTemplateObject(void *, Runtime &runtime, NativeArgs args) {\n  if (LLVM_UNLIKELY(args.getArgCount() < 3)) {\n    return runtime.raiseTypeError(\"At least three arguments expected\");\n  }\n  if (LLVM_UNLIKELY(!args.getArg(0).isNumber())) {\n    return runtime.raiseTypeError(\"First argument should be a number\");\n  }\n  if (LLVM_UNLIKELY(!args.getArg(1).isBool())) {\n    return runtime.raiseTypeError(\"Second argument should be a bool\");\n  }\n\n  GCScope gcScope{runtime};\n\n  // Try finding the template object in the template object cache.\n  uint32_t templateObjID = args.getArg(0).getNumberAs<uint32_t>();\n  auto savedCB = runtime.getStackFrames().begin()->getSavedCodeBlock();\n  if (LLVM_UNLIKELY(!savedCB)) {\n    return runtime.raiseTypeError(\"Cannot be called from native code\");\n  }\n  RuntimeModule *runtimeModule = savedCB->getRuntimeModule();\n  JSObject *cachedTemplateObj =\n      runtimeModule->findCachedTemplateObject(templateObjID);\n  if (cachedTemplateObj) {\n    return HermesValue::encodeObjectValue(cachedTemplateObj);\n  }\n\n  bool dup = args.getArg(1).getBool();\n  if (LLVM_UNLIKELY(!dup && args.getArgCount() % 2 == 1)) {\n    return runtime.raiseTypeError(\n        \"There must be the same number of raw and cooked strings.\");\n  }\n  uint32_t count = dup ? args.getArgCount() - 2 : args.getArgCount() / 2 - 1;\n\n  // Create template object and raw object.\n  auto arrRes = JSArray::create(runtime, count, 0);\n  if (LLVM_UNLIKELY(arrRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto rawObj = Handle<JSObject>::vmcast(*arrRes);\n  auto arrRes2 = JSArray::create(runtime, count, 0);\n  if (LLVM_UNLIKELY(arrRes2 == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto templateObj = Handle<JSObject>::vmcast(*arrRes2);\n\n  // Set cooked and raw strings as elements in template object and raw object,\n  // respectively.\n  DefinePropertyFlags dpf = DefinePropertyFlags::getDefaultNewPropertyFlags();\n  dpf.writable = 0;\n  dpf.configurable = 0;\n  MutableHandle<> idx{runtime};\n  MutableHandle<> rawValue{runtime};\n  MutableHandle<> cookedValue{runtime};\n  uint32_t cookedBegin = dup ? 2 : 2 + count;\n  auto marker = gcScope.createMarker();\n  for (uint32_t i = 0; i < count; ++i) {\n    idx = HermesValue::encodeNumberValue(i);\n\n    cookedValue = args.getArg(cookedBegin + i);\n    auto putRes = JSObject::defineOwnComputedPrimitive(\n        templateObj, runtime, idx, dpf, cookedValue);\n    assert(\n        putRes != ExecutionStatus::EXCEPTION && *putRes &&\n        \"Failed to set cooked value to template object.\");\n\n    rawValue = args.getArg(2 + i);\n    putRes = JSObject::defineOwnComputedPrimitive(\n        rawObj, runtime, idx, dpf, rawValue);\n    assert(\n        putRes != ExecutionStatus::EXCEPTION && *putRes &&\n        \"Failed to set raw value to raw object.\");\n\n    gcScope.flushToMarker(marker);\n  }\n  // Make 'length' property on the raw object read-only.\n  DefinePropertyFlags readOnlyDPF{};\n  readOnlyDPF.setWritable = 1;\n  readOnlyDPF.setConfigurable = 1;\n  readOnlyDPF.writable = 0;\n  readOnlyDPF.configurable = 0;\n  auto readOnlyRes = JSObject::defineOwnProperty(\n      rawObj,\n      runtime,\n      Predefined::getSymbolID(Predefined::length),\n      readOnlyDPF,\n      Runtime::getUndefinedValue(),\n      PropOpFlags().plusThrowOnError());\n  if (LLVM_UNLIKELY(readOnlyRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  if (LLVM_UNLIKELY(!*readOnlyRes)) {\n    return runtime.raiseTypeError(\n        \"Failed to set 'length' property on the raw object read-only.\");\n  }\n  JSObject::preventExtensions(rawObj.get());\n\n  // Set raw object as a read-only non-enumerable property of the template\n  // object.\n  PropertyFlags constantPF{};\n  constantPF.writable = 0;\n  constantPF.configurable = 0;\n  constantPF.enumerable = 0;\n  auto putNewRes = JSObject::defineNewOwnProperty(\n      templateObj,\n      runtime,\n      Predefined::getSymbolID(Predefined::raw),\n      constantPF,\n      rawObj);\n  if (LLVM_UNLIKELY(putNewRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  // Make 'length' property on the template object read-only.\n  readOnlyRes = JSObject::defineOwnProperty(\n      templateObj,\n      runtime,\n      Predefined::getSymbolID(Predefined::length),\n      readOnlyDPF,\n      Runtime::getUndefinedValue(),\n      PropOpFlags().plusThrowOnError());\n  if (LLVM_UNLIKELY(readOnlyRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  if (LLVM_UNLIKELY(!*readOnlyRes)) {\n    return runtime.raiseTypeError(\n        \"Failed to set 'length' property on the raw object read-only.\");\n  }\n  JSObject::preventExtensions(templateObj.get());\n\n  // Cache the template object.\n  runtimeModule->cacheTemplateObject(templateObjID, templateObj);\n\n  return templateObj.getHermesValue();\n}\n\n/// If the first argument is not an object, throw a type error with the second\n/// argument as a message.\n///\n/// \\code\n///   HermesBuiltin.ensureObject = function(value, errorMessage) {...}\n/// \\endcode\nCallResult<HermesValue>\nhermesBuiltinEnsureObject(void *, Runtime &runtime, NativeArgs args) {\n  if (LLVM_LIKELY(args.getArg(0).isObject()))\n    return HermesValue::encodeUndefinedValue();\n\n  return runtime.raiseTypeError(args.getArgHandle(1));\n}\n\n/// Perform the GetMethod() abstract operation.\n///\n/// \\code\n///   HermesBuiltin.getMethod = function(object, property) {...}\n/// \\endcode\nCallResult<HermesValue>\nhermesBuiltinGetMethod(void *, Runtime &runtime, NativeArgs args) {\n  return getMethod(runtime, args.getArgHandle(0), args.getArgHandle(1))\n      .toCallResultHermesValue();\n}\n\n/// Throw a type error with the argument as a message.\n///\n/// \\code\n///   HermesBuiltin.throwTypeError = function(errorMessage) {...}\n/// \\endcode\nCallResult<HermesValue>\nhermesBuiltinThrowTypeError(void *, Runtime &runtime, NativeArgs args) {\n  return runtime.raiseTypeError(args.getArgHandle(0));\n}\n\n/// Set the isDelegated flag on the GeneratorInnerFunction which calls\n/// this function.\n/// \\pre the caller must be an interpreted GeneratorInnerFunction\n/// \\return `undefined`\nCallResult<HermesValue>\nhermesBuiltinGeneratorSetDelegated(void *, Runtime &runtime, NativeArgs args) {\n  auto *gen = dyn_vmcast<GeneratorInnerFunction>(\n      runtime.getCurrentFrame().getPreviousFrame().getCalleeClosureOrCBRef());\n  if (!gen) {\n    return runtime.raiseTypeError(\n        \"generatorSetDelegated can only be called as part of yield*\");\n  }\n  gen->setIsDelegated(true);\n  return HermesValue::encodeUndefinedValue();\n}\n\nnamespace {\n\nCallResult<HermesValue> copyDataPropertiesSlowPath_RJS(\n    Runtime &runtime,\n    Handle<JSObject> target,\n    Handle<JSObject> from,\n    Handle<JSObject> excludedItems) {\n  assert(\n      from->isProxyObject() &&\n      \"copyDataPropertiesSlowPath_RJS is only for Proxy\");\n\n  // 5. Let keys be ? from.[[OwnPropertyKeys]]().\n  auto cr = JSProxy::getOwnPropertyKeys(\n      from,\n      runtime,\n      OwnKeysFlags()\n          .plusIncludeSymbols()\n          .plusIncludeNonSymbols()\n          .plusIncludeNonEnumerable());\n  if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto keys = *cr;\n\n  MutableHandle<> nextKeyHandle{runtime};\n  MutableHandle<> propValueHandle{runtime};\n  MutableHandle<SymbolID> tmpSymbolStorage{runtime};\n  GCScopeMarkerRAII marker{runtime};\n  // 6. For each element nextKey of keys in List order, do\n  for (uint32_t nextKeyIdx = 0, endIdx = keys->getEndIndex();\n       nextKeyIdx < endIdx;\n       ++nextKeyIdx) {\n    marker.flush();\n    nextKeyHandle = keys->at(runtime, nextKeyIdx).unboxToHV(runtime);\n    if (nextKeyHandle->isNumber()) {\n      CallResult<PseudoHandle<StringPrimitive>> strRes =\n          toString_RJS(runtime, nextKeyHandle);\n      if (LLVM_UNLIKELY(strRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      nextKeyHandle = strRes->getHermesValue();\n    }\n\n    // b. For each element e of excludedItems in List order, do\n    //   i. If SameValue(e, nextKey) is true, then\n    //     1. Set excluded to true.\n    if (excludedItems) {\n      assert(\n          !excludedItems->isProxyObject() &&\n          \"internal excludedItems object is a proxy\");\n      ComputedPropertyDescriptor desc;\n      CallResult<bool> cr = JSObject::getOwnComputedPrimitiveDescriptor(\n          excludedItems,\n          runtime,\n          nextKeyHandle,\n          JSObject::IgnoreProxy::Yes,\n          tmpSymbolStorage,\n          desc);\n      if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))\n        return ExecutionStatus::EXCEPTION;\n      if (*cr)\n        continue;\n    }\n\n    //   i. Let desc be ? from.[[GetOwnProperty]](nextKey).\n    ComputedPropertyDescriptor desc;\n    CallResult<bool> crb =\n        JSProxy::getOwnProperty(from, runtime, nextKeyHandle, desc, nullptr);\n    if (LLVM_UNLIKELY(crb == ExecutionStatus::EXCEPTION))\n      return ExecutionStatus::EXCEPTION;\n    //   ii. If desc is not undefined and desc.[[Enumerable]] is true, then\n    if (*crb && desc.flags.enumerable) {\n      //     1. Let propValue be ? Get(from, nextKey).\n      CallResult<PseudoHandle<>> crv =\n          JSProxy::getComputed(from, runtime, nextKeyHandle, from);\n      if (LLVM_UNLIKELY(crv == ExecutionStatus::EXCEPTION))\n        return ExecutionStatus::EXCEPTION;\n      propValueHandle = std::move(*crv);\n      //     2. Perform ! CreateDataProperty(target, nextKey, propValue).\n      crb = JSObject::defineOwnComputed(\n          target,\n          runtime,\n          nextKeyHandle,\n          DefinePropertyFlags::getDefaultNewPropertyFlags(),\n          propValueHandle);\n      if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))\n        return ExecutionStatus::EXCEPTION;\n      assert(\n          crb != ExecutionStatus::EXCEPTION && *crb &&\n          \"CreateDataProperty failed\");\n    }\n  }\n  return target.getHermesValue();\n}\n\n} // namespace\n\n/// \\code\n///   HermesBuiltin.copyDataProperties =\n///         function (target, source, excludedItems) {}\n/// \\endcode\n///\n/// Copy all enumerable own properties of object \\p source, that are not also\n/// properties of \\p excludedItems, into \\p target, which must be an object, and\n/// return \\p target. If \\p excludedItems is not specified, it is assumed\n/// to be empty.\nCallResult<HermesValue>\nhermesBuiltinCopyDataProperties(void *, Runtime &runtime, NativeArgs args) {\n  GCScope gcScope{runtime};\n\n  // 1. Assert: Type(target) is Object.\n  Handle<JSObject> target = args.dyncastArg<JSObject>(0);\n  // To be safe, ignore non-objects.\n  if (!target)\n    return HermesValue::encodeUndefinedValue();\n\n  // 3. If source is undefined or null, return target.\n  Handle<> untypedSource = args.getArgHandle(1);\n  if (untypedSource->isNull() || untypedSource->isUndefined())\n    return target.getHermesValue();\n\n  // 4. Let from be ! ToObject(source).\n  Handle<JSObject> source = untypedSource->isObject()\n      ? Handle<JSObject>::vmcast(untypedSource)\n      : Handle<JSObject>::vmcast(\n            runtime.makeHandle(*toObject(runtime, untypedSource)));\n\n  // 2. Assert: excludedItems is a List of property keys.\n  // In Hermes, excludedItems is represented as a JSObject, created by\n  // bytecode emitted by the compiler, whose keys are the excluded\n  // propertyKeys\n  Handle<JSObject> excludedItems = args.dyncastArg<JSObject>(2);\n  assert(\n      (!excludedItems || !excludedItems->isProxyObject()) &&\n      \"excludedItems internal List is a Proxy\");\n\n  if (source->isProxyObject()) {\n    return copyDataPropertiesSlowPath_RJS(\n        runtime, target, source, excludedItems);\n  }\n\n  MutableHandle<> nameHandle{runtime};\n  MutableHandle<> valueHandle{runtime};\n  MutableHandle<SymbolID> tmpSymbolStorage{runtime};\n\n  // Process all named properties/symbols.\n  bool success = JSObject::forEachOwnPropertyWhile(\n      source,\n      runtime,\n      // indexedCB.\n      [&source,\n       &target,\n       &excludedItems,\n       &nameHandle,\n       &valueHandle,\n       &tmpSymbolStorage](\n          Runtime &runtime, uint32_t index, ComputedPropertyDescriptor desc) {\n        if (!desc.flags.enumerable)\n          return true;\n\n        nameHandle = HermesValue::encodeNumberValue(index);\n\n        if (excludedItems) {\n          assert(\n              !excludedItems->isProxyObject() &&\n              \"internal excludedItems object is a proxy\");\n          ComputedPropertyDescriptor xdesc;\n          auto cr = JSObject::getOwnComputedPrimitiveDescriptor(\n              excludedItems,\n              runtime,\n              nameHandle,\n              JSObject::IgnoreProxy::Yes,\n              tmpSymbolStorage,\n              xdesc);\n          if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))\n            return false;\n          if (*cr)\n            return true;\n        }\n\n        valueHandle = JSObject::getOwnIndexed(\n            createPseudoHandle(source.get()), runtime, index);\n\n        if (LLVM_UNLIKELY(\n                JSObject::defineOwnComputedPrimitive(\n                    target,\n                    runtime,\n                    nameHandle,\n                    DefinePropertyFlags::getDefaultNewPropertyFlags(),\n                    valueHandle) == ExecutionStatus::EXCEPTION)) {\n          return false;\n        }\n\n        return true;\n      },\n      // namedCB.\n      [&source, &target, &excludedItems, &valueHandle](\n          Runtime &runtime, SymbolID sym, NamedPropertyDescriptor desc) {\n        if (!desc.flags.enumerable)\n          return true;\n        if (InternalProperty::isInternal(sym))\n          return true;\n\n        // Skip excluded items.\n        if (excludedItems) {\n          auto cr = JSObject::hasNamedOrIndexed(excludedItems, runtime, sym);\n          assert(\n              cr != ExecutionStatus::EXCEPTION &&\n              \"hasNamedOrIndex failed, which can only happen with a proxy, \"\n              \"but excludedItems should never be a proxy\");\n          if (*cr)\n            return true;\n        }\n\n        auto cr =\n            JSObject::getNamedPropertyValue_RJS(source, runtime, source, desc);\n        if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))\n          return false;\n\n        valueHandle = std::move(*cr);\n\n        // sym can be an index-like property, so we have to bypass the assert in\n        // defineOwnPropertyInternal.\n        if (LLVM_UNLIKELY(\n                JSObject::defineOwnPropertyInternal(\n                    target,\n                    runtime,\n                    sym,\n                    DefinePropertyFlags::getDefaultNewPropertyFlags(),\n                    valueHandle) == ExecutionStatus::EXCEPTION)) {\n          return false;\n        }\n\n        return true;\n      });\n\n  if (LLVM_UNLIKELY(!success))\n    return ExecutionStatus::EXCEPTION;\n\n  return target.getHermesValue();\n}\n\n/// \\code\n///   HermesBuiltin.copyRestArgs = function (from) {}\n/// \\endcode\n/// Copy the callers parameters starting from index \\c from (where the first\n/// parameter is index 0) into a JSArray.\nCallResult<HermesValue>\nhermesBuiltinCopyRestArgs(void *, Runtime &runtime, NativeArgs args) {\n  GCScopeMarkerRAII marker{runtime};\n\n  // Obtain the caller's stack frame.\n  auto frames = runtime.getStackFrames();\n  auto it = frames.begin();\n  ++it;\n  // Check for the extremely unlikely case where there is no caller frame.\n  if (LLVM_UNLIKELY(it == frames.end()))\n    return HermesValue::encodeUndefinedValue();\n\n  // \"from\" should be a number.\n  if (!args.getArg(0).isNumber())\n    return HermesValue::encodeUndefinedValue();\n  uint32_t from = truncateToUInt32(args.getArg(0).getNumber());\n\n  uint32_t argCount = it->getArgCount();\n  uint32_t length = from <= argCount ? argCount - from : 0;\n\n  auto cr = JSArray::create(runtime, length, length);\n  if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))\n    return ExecutionStatus::EXCEPTION;\n  auto array = *cr;\n  JSArray::setStorageEndIndex(array, runtime, length);\n\n  for (uint32_t i = 0; i != length; ++i) {\n    const auto shv =\n        SmallHermesValue::encodeHermesValue(it->getArgRef(from), runtime);\n    JSArray::unsafeSetExistingElementAt(*array, runtime, i, shv);\n    ++from;\n  }\n\n  return array.getHermesValue();\n}\n\n/// \\code\n///   HermesBuiltin.arraySpread = function(target, source, nextIndex) {}\n/// /endcode\n/// ES9.0 12.2.5.2\n/// Iterate the iterable source (as if using a for-of) and copy the values from\n/// the spread source into the target array, starting at `nextIndex`.\n/// \\return the next empty index in the array to use for additional properties.\nCallResult<HermesValue>\nhermesBuiltinArraySpread(void *, Runtime &runtime, NativeArgs args) {\n  GCScopeMarkerRAII topMarker{runtime};\n  Handle<JSArray> target = args.dyncastArg<JSArray>(0);\n  // To be safe, check for non-arrays.\n  if (!target) {\n    return runtime.raiseTypeError(\n        \"HermesBuiltin.arraySpread requires an array target\");\n  }\n\n  MutableHandle<> nextValue{runtime};\n\n  Handle<JSArray> arr = args.dyncastArg<JSArray>(1);\n  if (arr) {\n    // Copying from an array, first check and make sure that\n    // `arr[Symbol.iterator]` hasn't been changed by the user.\n    NamedPropertyDescriptor desc;\n    PseudoHandle<JSObject> propObj =\n        createPseudoHandle(JSObject::getNamedDescriptorPredefined(\n            arr, runtime, Predefined::SymbolIterator, desc));\n    if (LLVM_LIKELY(propObj) && LLVM_LIKELY(!desc.flags.proxyObject)) {\n      PseudoHandle<> slotValue = createPseudoHandle(\n          JSObject::getNamedSlotValueUnsafe(propObj.get(), runtime, desc)\n              .unboxToHV(runtime));\n      propObj.invalidate();\n      if (LLVM_LIKELY(\n              slotValue->getRaw() == runtime.arrayPrototypeValues.getRaw())) {\n        slotValue.invalidate();\n        auto nextIndex = args.getArg(2).getNumberAs<JSArray::size_type>();\n        MutableHandle<> idxHandle{runtime};\n        GCScopeMarkerRAII marker{runtime};\n        for (JSArray::size_type i = 0; i < JSArray::getLength(*arr, runtime);\n             ++i) {\n          marker.flush();\n          // Fast path: look up the property in indexed storage.\n          nextValue = arr->at(runtime, i).unboxToHV(runtime);\n          if (LLVM_UNLIKELY(nextValue->isEmpty())) {\n            // Slow path, just run the full getComputed_RJS path.\n            // Runs when there is a hole, accessor, non-regular property, etc.\n            idxHandle = HermesValue::encodeNumberValue(i);\n            CallResult<PseudoHandle<>> valueRes =\n                JSObject::getComputed_RJS(arr, runtime, idxHandle);\n            if (LLVM_UNLIKELY(valueRes == ExecutionStatus::EXCEPTION)) {\n              return ExecutionStatus::EXCEPTION;\n            }\n            nextValue = std::move(*valueRes);\n          }\n          // It is valid to use setElementAt here because we know that\n          // `target` was created immediately prior to running the spread\n          // and no non-standard properties were added to it,\n          // because the only actions that can be performed between array\n          // creation and running this spread are DefineOwnProperty calls with\n          // standard flags (as well as other spread operations, which do the\n          // same thing).\n          JSArray::setElementAt(target, runtime, nextIndex, nextValue);\n          ++nextIndex;\n        }\n\n        if (LLVM_UNLIKELY(\n                JSArray::setLengthProperty(target, runtime, nextIndex) ==\n                ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n\n        return HermesValue::encodeNumberValue(nextIndex);\n      }\n    }\n  }\n\n  // 3. Let iteratorRecord be ? GetIterator(spreadObj).\n  auto iteratorRecordRes = getIterator(runtime, args.getArgHandle(1));\n  if (LLVM_UNLIKELY(iteratorRecordRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  IteratorRecord iteratorRecord = *iteratorRecordRes;\n\n  MutableHandle<> nextIndex{runtime, args.getArg(2)};\n\n  // 4. Repeat,\n  for (GCScopeMarkerRAII marker{runtime}; /* nothing */; marker.flush()) {\n    // a. Let next be ? IteratorStep(iteratorRecord).\n    auto nextRes = iteratorStep(runtime, iteratorRecord);\n    if (LLVM_UNLIKELY(nextRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    Handle<JSObject> next = *nextRes;\n\n    // b. If next is false, return nextIndex.\n    if (!next) {\n      return nextIndex.getHermesValue();\n    }\n    // c. Let nextValue be ? IteratorValue(next).\n    auto nextItemRes = JSObject::getNamed_RJS(\n        next, runtime, Predefined::getSymbolID(Predefined::value));\n    if (LLVM_UNLIKELY(nextItemRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    nextValue = std::move(*nextItemRes);\n\n    // d. Let status be CreateDataProperty(array,\n    //    ToString(ToUint32(nextIndex)), nextValue).\n    // e. Assert: status is true.\n    if (LLVM_UNLIKELY(\n            JSArray::defineOwnComputed(\n                target,\n                runtime,\n                nextIndex,\n                DefinePropertyFlags::getDefaultNewPropertyFlags(),\n                nextValue) == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n\n    // f. Let nextIndex be nextIndex + 1.\n    nextIndex = HermesValue::encodeNumberValue(nextIndex->getNumber() + 1);\n  }\n\n  return nextIndex.getHermesValue();\n}\n\n/// \\code\n///   HermesBuiltin.apply = function(fn, argArray, thisVal(opt)) {}\n/// /endcode\n/// Faster version of Function.prototype.apply which does not use its `this`\n/// argument.\n/// `argArray` must be a JSArray with no getters.\n/// Equivalent to fn.apply(thisVal, argArray) if thisVal is provided.\n/// If thisVal is not provided, equivalent to running `new fn` and passing the\n/// arguments in argArray.\nCallResult<HermesValue>\nhermesBuiltinApply(void *, Runtime &runtime, NativeArgs args) {\n  GCScopeMarkerRAII marker{runtime};\n\n  Handle<Callable> fn = args.dyncastArg<Callable>(0);\n  if (LLVM_UNLIKELY(!fn)) {\n    return runtime.raiseTypeErrorForValue(\n        args.getArgHandle(0), \" is not a function\");\n  }\n\n  Handle<JSArray> argArray = args.dyncastArg<JSArray>(1);\n  if (LLVM_UNLIKELY(!argArray)) {\n    return runtime.raiseTypeError(\"args must be an array\");\n  }\n\n  uint32_t len = JSArray::getLength(*argArray, runtime);\n\n  bool isConstructor = args.getArgCount() == 2;\n\n  MutableHandle<> thisVal{runtime};\n  if (isConstructor) {\n    auto thisValRes = Callable::createThisForConstruct(fn, runtime);\n    if (LLVM_UNLIKELY(thisValRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    thisVal = thisValRes->getHermesValue();\n  } else {\n    thisVal = args.getArg(2);\n  }\n\n  ScopedNativeCallFrame newFrame{\n      runtime, len, *fn, isConstructor, thisVal.getHermesValue()};\n  if (LLVM_UNLIKELY(newFrame.overflowed()))\n    return runtime.raiseStackOverflow(Runtime::StackOverflowKind::NativeStack);\n\n  for (uint32_t i = 0; i < len; ++i) {\n    assert(!argArray->at(runtime, i).isEmpty() && \"arg array must be dense\");\n    HermesValue arg = argArray->at(runtime, i).unboxToHV(runtime);\n    newFrame->getArgRef(i) = LLVM_UNLIKELY(arg.isEmpty())\n        ? HermesValue::encodeUndefinedValue()\n        : arg;\n  }\n  if (isConstructor) {\n    auto res = Callable::construct(fn, runtime, thisVal);\n    if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    return res->getHermesValue();\n  }\n  auto res = Callable::call(fn, runtime);\n  if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  return res->getHermesValue();\n}\n\n/// HermesBuiltin.exportAll(exports, source) will copy exported named\n/// properties from `source` to `exports`, defining them on `exports` as\n/// non-configurable.\n/// Note that the default exported property on `source` is ignored,\n/// as are non-enumerable properties on `source`.\nCallResult<HermesValue>\nhermesBuiltinExportAll(void *, Runtime &runtime, NativeArgs args) {\n  Handle<JSObject> exports = args.dyncastArg<JSObject>(0);\n  if (LLVM_UNLIKELY(!exports)) {\n    return runtime.raiseTypeError(\n        \"exportAll() exports argument must be object\");\n  }\n\n  Handle<JSObject> source = args.dyncastArg<JSObject>(1);\n  if (LLVM_UNLIKELY(!source) || LLVM_UNLIKELY(source->isProxyObject())) {\n    return runtime.raiseTypeError(\n        \"exportAll() source argument must be non-Proxy object\");\n  }\n\n  MutableHandle<> propertyHandle{runtime};\n\n  auto dpf = DefinePropertyFlags::getDefaultNewPropertyFlags();\n  dpf.configurable = 0;\n\n  CallResult<bool> defineRes{ExecutionStatus::EXCEPTION};\n\n  // Iterate the named properties excluding those which use Symbols.\n  bool result = HiddenClass::forEachPropertyWhile(\n      runtime.makeHandle(source->getClass(runtime)),\n      runtime,\n      [&source, &exports, &propertyHandle, &dpf, &defineRes](\n          Runtime &runtime, SymbolID id, NamedPropertyDescriptor desc) {\n        if (!desc.flags.enumerable)\n          return true;\n\n        if (id == Predefined::getSymbolID(Predefined::defaultExport)) {\n          return true;\n        }\n\n        propertyHandle =\n            JSObject::getNamedSlotValueUnsafe(*source, runtime, desc)\n                .unboxToHV(runtime);\n        defineRes = JSObject::defineOwnProperty(\n            exports, runtime, id, dpf, propertyHandle);\n        if (LLVM_UNLIKELY(defineRes == ExecutionStatus::EXCEPTION)) {\n          return false;\n        }\n\n        return true;\n      });\n  if (LLVM_UNLIKELY(!result)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  return HermesValue::encodeUndefinedValue();\n}\n\nCallResult<HermesValue>\nhermesBuiltinExponentiate(void *ctx, Runtime &runtime, NativeArgs args) {\n  CallResult<HermesValue> res = toNumeric_RJS(runtime, args.getArgHandle(0));\n  if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  if (LLVM_LIKELY(!res->isBigInt())) {\n    double left = res->getNumber();\n    // Using ? toNumber() here causes an exception to be raised if args[1] is a\n    // BigInt.\n    CallResult<HermesValue> res = toNumber_RJS(runtime, args.getArgHandle(1));\n    if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    return HermesValue::encodeNumberValue(expOp(left, res->getNumber()));\n  }\n\n  Handle<BigIntPrimitive> lhs = runtime.makeHandle(res->getBigInt());\n\n  // Can't use toBigInt() here as it converts boolean/strings to bigint.\n  res = toNumeric_RJS(runtime, args.getArgHandle(1));\n  if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  if (!res->isBigInt()) {\n    return runtime.raiseTypeErrorForValue(\n        \"Cannot convert \", args.getArgHandle(1), \" to BigInt\");\n  }\n\n  return BigIntPrimitive::exponentiate(\n      runtime, std::move(lhs), runtime.makeHandle(res->getBigInt()));\n}\n\nCallResult<HermesValue> hermesBuiltinInitRegexNamedGroups(\n    void *ctx,\n    Runtime &runtime,\n    NativeArgs args) {\n  auto *regexp = dyn_vmcast<JSRegExp>(args.getArg(0));\n  auto *groupsObj = dyn_vmcast<JSObject>(args.getArg(1));\n  regexp->setGroupNameMappings(runtime, groupsObj);\n  return HermesValue::encodeUndefinedValue();\n}\n\nvoid createHermesBuiltins(\n    Runtime &runtime,\n    llvh::MutableArrayRef<Callable *> builtins) {\n  auto defineInternMethod = [&](BuiltinMethod::Enum builtinIndex,\n                                Predefined::Str symID,\n                                NativeFunctionPtr func,\n                                uint8_t count = 0) {\n    auto method = NativeFunction::create(\n        runtime,\n        Handle<JSObject>::vmcast(&runtime.functionPrototype),\n        nullptr /* context */,\n        func,\n        Predefined::getSymbolID(symID),\n        count,\n        Runtime::makeNullHandle<JSObject>());\n\n    assert(builtins[builtinIndex] == nullptr && \"builtin already defined\");\n    builtins[builtinIndex] = *method;\n  };\n\n  // HermesBuiltin function properties\n  namespace P = Predefined;\n  namespace B = BuiltinMethod;\n  defineInternMethod(\n      B::HermesBuiltin_silentSetPrototypeOf,\n      P::silentSetPrototypeOf,\n      silentObjectSetPrototypeOf,\n      2);\n  defineInternMethod(\n      B::HermesBuiltin_getTemplateObject,\n      P::getTemplateObject,\n      hermesBuiltinGetTemplateObject);\n  defineInternMethod(\n      B::HermesBuiltin_ensureObject,\n      P::ensureObject,\n      hermesBuiltinEnsureObject,\n      2);\n  defineInternMethod(\n      B::HermesBuiltin_getMethod, P::getMethod, hermesBuiltinGetMethod, 2);\n  defineInternMethod(\n      B::HermesBuiltin_throwTypeError,\n      P::throwTypeError,\n      hermesBuiltinThrowTypeError,\n      1);\n  defineInternMethod(\n      B::HermesBuiltin_generatorSetDelegated,\n      P::generatorSetDelegated,\n      hermesBuiltinGeneratorSetDelegated,\n      1);\n  defineInternMethod(\n      B::HermesBuiltin_copyDataProperties,\n      P::copyDataProperties,\n      hermesBuiltinCopyDataProperties,\n      3);\n  defineInternMethod(\n      B::HermesBuiltin_copyRestArgs,\n      P::copyRestArgs,\n      hermesBuiltinCopyRestArgs,\n      1);\n  defineInternMethod(\n      B::HermesBuiltin_arraySpread,\n      P::arraySpread,\n      hermesBuiltinArraySpread,\n      2);\n  defineInternMethod(B::HermesBuiltin_apply, P::apply, hermesBuiltinApply, 2);\n  defineInternMethod(\n      B::HermesBuiltin_exportAll, P::exportAll, hermesBuiltinExportAll);\n  defineInternMethod(\n      B::HermesBuiltin_exponentiationOperator,\n      P::exponentiationOperator,\n      hermesBuiltinExponentiate);\n  defineInternMethod(\n      B::HermesBuiltin_initRegexNamedGroups,\n      P::initRegexNamedGroups,\n      hermesBuiltinInitRegexNamedGroups);\n\n  // Define the 'requireFast' function, which takes a number argument.\n  defineInternMethod(\n      B::HermesBuiltin_requireFast, P::requireFast, requireFast, 1);\n}\n\n} // namespace vm\n} // namespace hermes\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2023-24832", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "/*\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include \"JSLibInternal.h\"\n\n#include \"hermes/BCGen/HBC/BytecodeFileFormat.h\"\n#include \"hermes/Support/Base64vlq.h\"\n#include \"hermes/Support/OSCompat.h\"\n#include \"hermes/VM/Callable.h\"\n#include \"hermes/VM/JSArray.h\"\n#include \"hermes/VM/JSArrayBuffer.h\"\n#include \"hermes/VM/JSLib.h\"\n#include \"hermes/VM/JSLib/RuntimeCommonStorage.h\"\n#include \"hermes/VM/JSTypedArray.h\"\n#include \"hermes/VM/JSWeakMapImpl.h\"\n#include \"hermes/VM/Operations.h\"\n#include \"hermes/VM/StackFrame-inline.h\"\n#include \"hermes/VM/StringView.h\"\n\n#include <cstring>\n#include <random>\n#pragma GCC diagnostic push\n\n#ifdef HERMES_COMPILER_SUPPORTS_WSHORTEN_64_TO_32\n#pragma GCC diagnostic ignored \"-Wshorten-64-to-32\"\n#endif\nnamespace hermes {\nnamespace vm {\n\n/// \\return a SymbolID  for a given C string \\p s.\nstatic inline CallResult<Handle<SymbolID>> symbolForCStr(\n    Runtime &rt,\n    const char *s) {\n  return rt.getIdentifierTable().getSymbolHandle(rt, ASCIIRef{s, strlen(s)});\n}\n\n// ES7 24.1.1.3\nCallResult<HermesValue>\nhermesInternalDetachArrayBuffer(void *, Runtime &runtime, NativeArgs args) {\n  auto buffer = args.dyncastArg<JSArrayBuffer>(0);\n  if (!buffer) {\n    return runtime.raiseTypeError(\n        \"Cannot use detachArrayBuffer on something which \"\n        \"is not an ArrayBuffer foo\");\n  }\n  if (LLVM_UNLIKELY(\n          JSArrayBuffer::detach(runtime, buffer) == ExecutionStatus::EXCEPTION))\n    return ExecutionStatus::EXCEPTION;\n  // \"void\" return\n  return HermesValue::encodeUndefinedValue();\n}\n\nCallResult<HermesValue>\nhermesInternalGetEpilogues(void *, Runtime &runtime, NativeArgs args) {\n  // Create outer array with one element per module.\n  auto eps = runtime.getEpilogues();\n  auto outerLen = eps.size();\n  auto outerResult = JSArray::create(runtime, outerLen, outerLen);\n\n  if (outerResult == ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto outer = *outerResult;\n  if (outer->setStorageEndIndex(outer, runtime, outerLen) ==\n      ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  // Set each element to a Uint8Array holding the epilogue for that module.\n  for (unsigned i = 0; i < outerLen; ++i) {\n    auto innerLen = eps[i].size();\n    if (innerLen != 0) {\n      auto result = Uint8Array::allocate(runtime, innerLen);\n      if (result == ExecutionStatus::EXCEPTION) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      auto ta = result.getValue();\n      std::memcpy(ta->begin(runtime), eps[i].begin(), innerLen);\n      const auto shv = SmallHermesValue::encodeObjectValue(*ta, runtime);\n      JSArray::unsafeSetExistingElementAt(*outer, runtime, i, shv);\n    }\n  }\n  return HermesValue::encodeObjectValue(*outer);\n}\n\n/// Used for testing, determines how many live values\n/// are in the given WeakMap or WeakSet.\nCallResult<HermesValue>\nhermesInternalGetWeakSize(void *, Runtime &runtime, NativeArgs args) {\n  if (auto M = args.dyncastArg<JSWeakMap>(0)) {\n    return HermesValue::encodeNumberValue(\n        JSWeakMap::debugFreeSlotsAndGetSize(runtime, *M));\n  }\n\n  if (auto S = args.dyncastArg<JSWeakSet>(0)) {\n    return HermesValue::encodeNumberValue(\n        JSWeakSet::debugFreeSlotsAndGetSize(runtime, *S));\n  }\n\n  return runtime.raiseTypeError(\n      \"getWeakSize can only be called on a WeakMap/WeakSet\");\n}\n\nnamespace {\n/// Populates the instrumentes stats object using \\p addProp as the handler for\n/// adding properties to the object. \\p addProp's should be invocable with\n/// (const char *), or (const char *, double). The first prototype is used when\n/// property passthrough is enable (i.e., the \\p addProp will figure out what\n/// the property value is), and the second, when new/actual values should be\n/// recorded. Note that any property below added with PASSTHROUGH_PROP is only\n/// populated in passthrough mode (i.e., when replaying calls to\n/// getInstrumentedStats during synth trace replay).\ntemplate <typename AP>\nExecutionStatus populateInstrumentedStats(Runtime &runtime, AP addProp) {\n  constexpr bool addPropTakesValue =\n      std::is_invocable_v<AP, const char *, double>;\n  constexpr bool addPropGeneratesValue = std::is_invocable_v<AP, const char *>;\n  static_assert(\n      addPropGeneratesValue || addPropTakesValue, \"invalid addProp prototype\");\n\n  // PASSTHROUGH_PROP is used to populate the instrumented stats objects with\n  // properties that are no longer being returned by hermes, but at one point\n  // where, and thus are kept here for synth trace playback compatibility only.\n#define PASSTHROUGH_PROP(name)                                          \\\n  do {                                                                  \\\n    if constexpr (addPropGeneratesValue) {                              \\\n      if (LLVM_UNLIKELY(addProp(name) == ExecutionStatus::EXCEPTION)) { \\\n        return ExecutionStatus::EXCEPTION;                              \\\n      }                                                                 \\\n    }                                                                   \\\n  } while (0)\n\n#define ADD_PROP(name, value)                                                  \\\n  do {                                                                         \\\n    if constexpr (addPropGeneratesValue) {                                     \\\n      PASSTHROUGH_PROP(name);                                                  \\\n    } else {                                                                   \\\n      if (LLVM_UNLIKELY(addProp(name, value) == ExecutionStatus::EXCEPTION)) { \\\n        return ExecutionStatus::EXCEPTION;                                     \\\n      }                                                                        \\\n    }                                                                          \\\n  } while (0)\n\n  auto &heap = runtime.getHeap();\n  GCBase::HeapInfo info;\n  heap.getHeapInfo(info);\n\n  // To ensure synth trace compatibility, properties should not be removed nor\n  // reordered. To \"remove\" a property use PASSTHROUGH_PROP instead of ADD_PROP.\n  PASSTHROUGH_PROP(\"js_hostFunctionTime\");\n  PASSTHROUGH_PROP(\"js_hostFunctionCPUTime\");\n  PASSTHROUGH_PROP(\"js_hostFunctionCount\");\n  PASSTHROUGH_PROP(\"js_evaluateJSTime\");\n  PASSTHROUGH_PROP(\"js_evaluateJSCPUTime\");\n  PASSTHROUGH_PROP(\"js_evaluateJSCount\");\n  PASSTHROUGH_PROP(\"js_incomingFunctionTime\");\n  PASSTHROUGH_PROP(\"js_incomingFunctionCPUTime\");\n  PASSTHROUGH_PROP(\"js_incomingFunctionCount\");\n  ADD_PROP(\"js_VMExperiments\", runtime.getVMExperimentFlags());\n  PASSTHROUGH_PROP(\"js_hermesTime\");\n  PASSTHROUGH_PROP(\"js_hermesCPUTime\");\n  PASSTHROUGH_PROP(\"js_hermesThreadMinorFaults\");\n  PASSTHROUGH_PROP(\"js_hermesThreadMajorFaults\");\n  ADD_PROP(\"js_numGCs\", heap.getNumGCs());\n  ADD_PROP(\"js_gcCPUTime\", heap.getGCCPUTime());\n  ADD_PROP(\"js_gcTime\", heap.getGCTime());\n  ADD_PROP(\"js_totalAllocatedBytes\", info.totalAllocatedBytes);\n  ADD_PROP(\"js_allocatedBytes\", info.allocatedBytes);\n  ADD_PROP(\"js_heapSize\", info.heapSize);\n  ADD_PROP(\"js_mallocSizeEstimate\", info.mallocSizeEstimate);\n  ADD_PROP(\"js_vaSize\", info.va);\n  ADD_PROP(\"js_markStackOverflows\", info.numMarkStackOverflows);\n  PASSTHROUGH_PROP(\"js_hermesVolCtxSwitches\");\n  PASSTHROUGH_PROP(\"js_hermesInvolCtxSwitches\");\n  PASSTHROUGH_PROP(\"js_pageSize\");\n  PASSTHROUGH_PROP(\"js_threadAffinityMask\");\n  PASSTHROUGH_PROP(\"js_threadCPU\");\n  PASSTHROUGH_PROP(\"js_bytecodePagesResident\");\n  PASSTHROUGH_PROP(\"js_bytecodePagesResidentRuns\");\n  PASSTHROUGH_PROP(\"js_bytecodePagesAccessed\");\n  PASSTHROUGH_PROP(\"js_bytecodeSize\");\n  PASSTHROUGH_PROP(\"js_bytecodePagesTraceHash\");\n  PASSTHROUGH_PROP(\"js_bytecodeIOTime\");\n  PASSTHROUGH_PROP(\"js_bytecodePagesTraceSample\");\n\n#undef PASSTHROUGH_PROP\n#undef ADD_PROP\n\n  return ExecutionStatus::RETURNED;\n}\n\n/// Converts \\p val to a HermesValue.\nCallResult<HermesValue> statsTableValueToHermesValue(\n    Runtime &runtime,\n    const MockedEnvironment::StatsTableValue &val) {\n  if (val.isNum()) {\n    return HermesValue::encodeDoubleValue(val.num());\n  }\n\n  auto strRes =\n      StringPrimitive::create(runtime, createASCIIRef(val.str().c_str()));\n  if (LLVM_UNLIKELY(strRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  return *strRes;\n}\n} // namespace\n\n/// \\return an object containing various instrumented statistics.\nCallResult<HermesValue>\nhermesInternalGetInstrumentedStats(void *, Runtime &runtime, NativeArgs args) {\n  GCScope gcScope(runtime);\n  auto resultHandle = runtime.makeHandle(JSObject::create(runtime));\n  // Printing the values would be unstable, so prevent that.\n  if (runtime.shouldStabilizeInstructionCount())\n    return resultHandle.getHermesValue();\n\n  MockedEnvironment::StatsTable *statsTable = nullptr;\n  auto *const storage = runtime.getCommonStorage();\n  if (storage->env) {\n    if (!storage->env->callsToHermesInternalGetInstrumentedStats.empty()) {\n      statsTable =\n          &storage->env->callsToHermesInternalGetInstrumentedStats.front();\n    }\n  }\n\n  std::unique_ptr<MockedEnvironment::StatsTable> newStatsTable;\n  if (storage->shouldTrace) {\n    newStatsTable.reset(new MockedEnvironment::StatsTable());\n  }\n\n  /// Adds \\p key with \\p val to the resultHandle object. \\p newStatsTableVal is\n  /// the value \\p key should have in the newStatsTable object (i.e., during\n  /// synth trace recording).\n  auto addToResultHandle =\n      [&](llvh::StringRef key, HermesValue val, auto newStatsTableVal) {\n        Handle<> valHandle = runtime.makeHandle(val);\n        auto keySym = symbolForCStr(runtime, key.data());\n        if (LLVM_UNLIKELY(keySym == ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n\n        auto status = JSObject::defineNewOwnProperty(\n            resultHandle,\n            runtime,\n            **keySym,\n            PropertyFlags::defaultNewNamedPropertyFlags(),\n            valHandle);\n\n        if (LLVM_UNLIKELY(status == ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n\n        if (newStatsTable) {\n          newStatsTable->try_emplace(key, newStatsTableVal);\n        }\n\n        return ExecutionStatus::RETURNED;\n      };\n\n  ExecutionStatus populateRes;\n  if (!statsTable) {\n    /// Adds a property to resultHandle. \\p key provides its name, and \\p val,\n    /// its value. Adds {\\p key, \\p val} to newStatsTable if it is not null.\n    populateRes = populateInstrumentedStats(\n        runtime, [&](llvh::StringRef key, double val) {\n          GCScopeMarkerRAII marker{gcScope};\n\n          return addToResultHandle(\n              key, HermesValue::encodeDoubleValue(val), val);\n        });\n  } else {\n    /// Adds a property named \\p key to resultHandle if it is present in\n    /// statsTable. Also copies it to newStatsTable if it is not null. Does\n    /// nothing if \\p key is not in statsTable.\n    populateRes = populateInstrumentedStats(runtime, [&](llvh::StringRef key) {\n      auto it = statsTable->find(key);\n      if (it == statsTable->end()) {\n        return ExecutionStatus::RETURNED;\n      }\n\n      GCScopeMarkerRAII marker{gcScope};\n\n      auto valRes = statsTableValueToHermesValue(runtime, it->getValue());\n      if (LLVM_UNLIKELY(valRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n\n      return addToResultHandle(key, *valRes, it->getValue());\n    });\n  }\n\n  if (LLVM_UNLIKELY(populateRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  if (storage->env && statsTable) {\n    storage->env->callsToHermesInternalGetInstrumentedStats.pop_front();\n  }\n  if (LLVM_UNLIKELY(storage->shouldTrace)) {\n    storage->tracedEnv.callsToHermesInternalGetInstrumentedStats.push_back(\n        *newStatsTable);\n  }\n\n  return resultHandle.getHermesValue();\n}\n\n/// \\return a static string summarising the presence and resolution type of\n/// CommonJS modules across all RuntimeModules that have been loaded into \\c\n/// runtime.\nstatic const char *getCJSModuleModeDescription(Runtime &runtime) {\n  bool hasCJSModulesDynamic = false;\n  bool hasCJSModulesStatic = false;\n  for (const auto &runtimeModule : runtime.getRuntimeModules()) {\n    if (runtimeModule.hasCJSModules()) {\n      hasCJSModulesDynamic = true;\n    }\n    if (runtimeModule.hasCJSModulesStatic()) {\n      hasCJSModulesStatic = true;\n    }\n  }\n  if (hasCJSModulesDynamic && hasCJSModulesStatic) {\n    return \"Mixed dynamic/static\";\n  }\n  if (hasCJSModulesDynamic) {\n    return \"Dynamically resolved\";\n  }\n  if (hasCJSModulesStatic) {\n    return \"Statically resolved\";\n  }\n  return \"None\";\n}\n\n/// \\return an object mapping keys to runtime property values.\nCallResult<HermesValue>\nhermesInternalGetRuntimeProperties(void *, Runtime &runtime, NativeArgs args) {\n  GCScope gcScope(runtime);\n  auto resultHandle = runtime.makeHandle(JSObject::create(runtime));\n  MutableHandle<> tmpHandle{runtime};\n\n  /// Add a property \\p value keyed under \\p key to resultHandle.\n  /// Return an ExecutionStatus.\n  auto addProperty = [&](Handle<> value, const char *key) {\n    auto keySym = symbolForCStr(runtime, key);\n    if (LLVM_UNLIKELY(keySym == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    return JSObject::defineNewOwnProperty(\n        resultHandle,\n        runtime,\n        **keySym,\n        PropertyFlags::defaultNewNamedPropertyFlags(),\n        value);\n  };\n\n#ifdef HERMES_FACEBOOK_BUILD\n  tmpHandle =\n      HermesValue::encodeBoolValue(std::strstr(__FILE__, \"hermes-snapshot\"));\n  if (LLVM_UNLIKELY(\n          addProperty(tmpHandle, \"Snapshot VM\") ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n#endif\n\n  tmpHandle = HermesValue::encodeDoubleValue(::hermes::hbc::BYTECODE_VERSION);\n  if (LLVM_UNLIKELY(\n          addProperty(tmpHandle, \"Bytecode Version\") ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  tmpHandle = HermesValue::encodeBoolValue(runtime.builtinsAreFrozen());\n  if (LLVM_UNLIKELY(\n          addProperty(tmpHandle, \"Builtins Frozen\") ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  tmpHandle = HermesValue::encodeNumberValue(runtime.getVMExperimentFlags());\n  if (LLVM_UNLIKELY(\n          addProperty(tmpHandle, \"VM Experiments\") ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  const char buildMode[] =\n#ifdef HERMES_SLOW_DEBUG\n      \"SlowDebug\"\n#elif !defined(NDEBUG)\n      \"Debug\"\n#else\n      \"Release\"\n#endif\n      ;\n  auto buildModeRes = StringPrimitive::create(\n      runtime, ASCIIRef(buildMode, sizeof(buildMode) - 1));\n  if (LLVM_UNLIKELY(buildModeRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  tmpHandle = *buildModeRes;\n  if (LLVM_UNLIKELY(\n          addProperty(tmpHandle, \"Build\") == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  std::string gcKind = runtime.getHeap().getKindAsStr();\n  auto gcKindRes = StringPrimitive::create(\n      runtime, ASCIIRef(gcKind.c_str(), gcKind.length()));\n  if (LLVM_UNLIKELY(gcKindRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  tmpHandle = *gcKindRes;\n  if (LLVM_UNLIKELY(\n          addProperty(tmpHandle, \"GC\") == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n#ifdef HERMES_RELEASE_VERSION\n  auto relVerRes =\n      StringPrimitive::create(runtime, createASCIIRef(HERMES_RELEASE_VERSION));\n  if (LLVM_UNLIKELY(relVerRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  tmpHandle = *relVerRes;\n  if (LLVM_UNLIKELY(\n          addProperty(tmpHandle, \"OSS Release Version\") ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n#endif\n\n  const char *cjsModuleMode = getCJSModuleModeDescription(runtime);\n  auto cjsModuleModeRes =\n      StringPrimitive::create(runtime, createASCIIRef(cjsModuleMode));\n  if (LLVM_UNLIKELY(cjsModuleModeRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  tmpHandle = *cjsModuleModeRes;\n  if (LLVM_UNLIKELY(\n          addProperty(tmpHandle, \"CommonJS Modules\") ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  return resultHandle.getHermesValue();\n}\n\n#ifdef HERMESVM_PLATFORM_LOGGING\nstatic void logGCStats(Runtime &runtime, const char *msg) {\n  // The GC stats can exceed the android logcat length limit, of\n  // 1024 bytes.  Break it up.\n  std::string stats;\n  {\n    llvh::raw_string_ostream os(stats);\n    runtime.printHeapStats(os);\n  }\n  auto copyRegionFrom = [&stats](size_t from) -> size_t {\n    size_t rBrace = stats.find(\"},\", from);\n    if (rBrace == std::string::npos) {\n      std::string portion = stats.substr(from);\n      hermesLog(\"HermesVM\", \"%s\", portion.c_str());\n      return stats.size();\n    }\n\n    // Add 2 for the length of the search string, to get to the end.\n    const size_t to = rBrace + 2;\n    std::string portion = stats.substr(from, to - from);\n    hermesLog(\"HermesVM\", \"%s\", portion.c_str());\n    return to;\n  };\n\n  hermesLog(\"HermesVM\", \"%s:\", msg);\n  for (size_t ind = 0; ind < stats.size(); ind = copyRegionFrom(ind))\n    ;\n}\n#endif\n\nCallResult<HermesValue>\nhermesInternalTTIReached(void *, Runtime &runtime, NativeArgs args) {\n  runtime.ttiReached();\n#ifdef HERMESVM_LLVM_PROFILE_DUMP\n  __llvm_profile_dump();\n  throw jsi::JSINativeException(\"TTI reached; profiling done\");\n#endif\n#ifdef HERMESVM_PLATFORM_LOGGING\n  logGCStats(runtime, \"TTI call\");\n#endif\n  return HermesValue::encodeUndefinedValue();\n}\n\nCallResult<HermesValue>\nhermesInternalTTRCReached(void *, Runtime &runtime, NativeArgs args) {\n  // Currently does nothing, but could change in the future.\n  return HermesValue::encodeUndefinedValue();\n}\n\nCallResult<HermesValue>\nhermesInternalIsProxy(void *, Runtime &runtime, NativeArgs args) {\n  Handle<JSObject> obj = args.dyncastArg<JSObject>(0);\n  return HermesValue::encodeBoolValue(obj && obj->isProxyObject());\n}\n\nCallResult<HermesValue>\nhermesInternalHasPromise(void *, Runtime &runtime, NativeArgs args) {\n  return HermesValue::encodeBoolValue(runtime.hasES6Promise());\n}\n\nCallResult<HermesValue>\nhermesInternalUseEngineQueue(void *, Runtime &runtime, NativeArgs args) {\n  return HermesValue::encodeBoolValue(runtime.hasMicrotaskQueue());\n}\n\n/// \\code\n///   HermesInternal.enqueueJob = function (func) {}\n/// \\endcode\nCallResult<HermesValue>\nhermesInternalEnqueueJob(void *, Runtime &runtime, NativeArgs args) {\n  auto callable = args.dyncastArg<Callable>(0);\n  if (!callable) {\n    return runtime.raiseTypeError(\n        \"Argument to HermesInternal.enqueueJob must be callable\");\n  }\n  runtime.enqueueJob(callable.get());\n  return HermesValue::encodeUndefinedValue();\n}\n\n/// \\code\n///   HermesInternal.drainJobs = function () {}\n/// \\endcode\n/// Throw if the drainJobs throws.\nCallResult<HermesValue>\nhermesInternalDrainJobs(void *, Runtime &runtime, NativeArgs args) {\n  auto drainRes = runtime.drainJobs();\n  if (drainRes == ExecutionStatus::EXCEPTION) {\n    // No need to rethrow since it's already throw.\n    return ExecutionStatus::EXCEPTION;\n  }\n  return HermesValue::encodeUndefinedValue();\n}\n\n#ifdef HERMESVM_EXCEPTION_ON_OOM\n/// Gets the current call stack as a JS String value.  Intended (only)\n/// to allow testing of Runtime::callStack() from JS code.\nCallResult<HermesValue>\nhermesInternalGetCallStack(void *, Runtime &runtime, NativeArgs args) {\n  std::string stack = runtime.getCallStackNoAlloc();\n  return StringPrimitive::create(runtime, ASCIIRef(stack.data(), stack.size()));\n}\n#endif // HERMESVM_EXCEPTION_ON_OOM\n\n/// \\return the code block associated with \\p callableHandle if it is a\n/// (possibly bound) JS function, or nullptr otherwise.\nstatic const CodeBlock *getLeafCodeBlock(\n    Handle<Callable> callableHandle,\n    Runtime &runtime) {\n  const Callable *callable = callableHandle.get();\n  while (auto *bound = dyn_vmcast<BoundFunction>(callable)) {\n    callable = bound->getTarget(runtime);\n  }\n  if (auto *asFunction = dyn_vmcast<const JSFunction>(callable)) {\n    return asFunction->getCodeBlock(runtime);\n  }\n  return nullptr;\n}\n\n/// \\return the file name associated with \\p codeBlock, if any.\n/// This mirrors the way we print file names for code blocks in JSError.\nstatic CallResult<HermesValue> getCodeBlockFileName(\n    Runtime &runtime,\n    const CodeBlock *codeBlock,\n    OptValue<hbc::DebugSourceLocation> location) {\n  RuntimeModule *runtimeModule = codeBlock->getRuntimeModule();\n  if (!runtimeModule->getBytecode()->isLazy()) {\n    // Lazy code blocks do not have debug information (and will hermes_fatal if\n    // you try to access it), so only touch it for non-lazy blocks.\n    if (location) {\n      auto debugInfo = runtimeModule->getBytecode()->getDebugInfo();\n      return StringPrimitive::createEfficient(\n          runtime, debugInfo->getFilenameByID(location->filenameId));\n    } else {\n      llvh::StringRef sourceURL = runtimeModule->getSourceURL();\n      if (!sourceURL.empty()) {\n        return StringPrimitive::createEfficient(runtime, sourceURL);\n      }\n    }\n  }\n  return HermesValue::encodeUndefinedValue();\n}\n\n/// \\code\n///   HermesInternal.getFunctionLocation function (func) {}\n/// \\endcode\n/// Returns an object describing the source location of func.\n/// The following properties may be present:\n/// * fileName (string)\n/// * lineNumber (number) - 1 based\n/// * columnNumber (number) - 1 based\n/// * segmentID (number) - 0 based\n/// * virtualOffset (number) - 0 based\n/// * isNative (boolean)\n/// TypeError if func is not a function.\nCallResult<HermesValue>\nhermesInternalGetFunctionLocation(void *, Runtime &runtime, NativeArgs args) {\n  GCScope gcScope(runtime);\n\n  auto callable = args.dyncastArg<Callable>(0);\n  if (!callable) {\n    return runtime.raiseTypeError(\n        \"Argument to HermesInternal.getFunctionLocation must be callable\");\n  }\n  auto resultHandle = runtime.makeHandle(JSObject::create(runtime));\n  MutableHandle<> tmpHandle{runtime};\n\n  auto codeBlock = getLeafCodeBlock(callable, runtime);\n  bool isNative = !codeBlock;\n  auto res = JSObject::defineOwnProperty(\n      resultHandle,\n      runtime,\n      Predefined::getSymbolID(Predefined::isNative),\n      DefinePropertyFlags::getDefaultNewPropertyFlags(),\n      runtime.getBoolValue(isNative));\n  assert(res != ExecutionStatus::EXCEPTION && \"Failed to set isNative\");\n  (void)res;\n\n  if (codeBlock) {\n    OptValue<hbc::DebugSourceLocation> location =\n        codeBlock->getSourceLocation();\n    if (location) {\n      tmpHandle = HermesValue::encodeNumberValue(location->line);\n      res = JSObject::defineOwnProperty(\n          resultHandle,\n          runtime,\n          Predefined::getSymbolID(Predefined::lineNumber),\n          DefinePropertyFlags::getDefaultNewPropertyFlags(),\n          tmpHandle);\n      assert(res != ExecutionStatus::EXCEPTION && \"Failed to set lineNumber\");\n      (void)res;\n\n      tmpHandle = HermesValue::encodeNumberValue(location->column);\n      res = JSObject::defineOwnProperty(\n          resultHandle,\n          runtime,\n          Predefined::getSymbolID(Predefined::columnNumber),\n          DefinePropertyFlags::getDefaultNewPropertyFlags(),\n          tmpHandle);\n      assert(res != ExecutionStatus::EXCEPTION && \"Failed to set columnNumber\");\n      (void)res;\n    } else {\n      tmpHandle = HermesValue::encodeNumberValue(\n          codeBlock->getRuntimeModule()->getBytecode()->getSegmentID());\n      res = JSObject::defineOwnProperty(\n          resultHandle,\n          runtime,\n          Predefined::getSymbolID(Predefined::segmentID),\n          DefinePropertyFlags::getDefaultNewPropertyFlags(),\n          tmpHandle);\n      assert(res != ExecutionStatus::EXCEPTION && \"Failed to set segmentID\");\n      (void)res;\n\n      tmpHandle = HermesValue::encodeNumberValue(codeBlock->getVirtualOffset());\n      res = JSObject::defineOwnProperty(\n          resultHandle,\n          runtime,\n          Predefined::getSymbolID(Predefined::virtualOffset),\n          DefinePropertyFlags::getDefaultNewPropertyFlags(),\n          tmpHandle);\n      assert(\n          res != ExecutionStatus::EXCEPTION && \"Failed to set virtualOffset\");\n      (void)res;\n    }\n\n    auto fileNameRes = getCodeBlockFileName(runtime, codeBlock, location);\n    if (LLVM_UNLIKELY(fileNameRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    tmpHandle = *fileNameRes;\n    res = JSObject::defineOwnProperty(\n        resultHandle,\n        runtime,\n        Predefined::getSymbolID(Predefined::fileName),\n        DefinePropertyFlags::getDefaultNewPropertyFlags(),\n        tmpHandle);\n    assert(res != ExecutionStatus::EXCEPTION && \"Failed to set fileName\");\n    (void)res;\n  }\n  JSObject::preventExtensions(*resultHandle);\n  return resultHandle.getHermesValue();\n}\n\n/// \\code\n///   HermesInternal.setPromiseRejectionTrackingHook = function (func) {}\n/// \\endcode\n/// Register the function which can be used to *enable* Promise rejection\n/// tracking when the user calls it.\n/// For example, when using the npm `promise` polyfill:\n/// \\code\n///   HermesInternal.setPromiseRejectionTrackingHook(\n///     require('./rejection-tracking.js').enable\n///   );\n/// \\endcode\nCallResult<HermesValue> hermesInternalSetPromiseRejectionTrackingHook(\n    void *,\n    Runtime &runtime,\n    NativeArgs args) {\n  runtime.promiseRejectionTrackingHook_ = args.getArg(0);\n  return HermesValue::encodeUndefinedValue();\n}\n\n/// \\code\n///   HermesInternal.enablePromiseRejectionTracker = function (opts) {}\n/// \\endcode\n/// Enable promise rejection tracking with the given opts.\nCallResult<HermesValue> hermesInternalEnablePromiseRejectionTracker(\n    void *,\n    Runtime &runtime,\n    NativeArgs args) {\n  auto opts = args.getArgHandle(0);\n  auto func = Handle<Callable>::dyn_vmcast(\n      Handle<>(&runtime.promiseRejectionTrackingHook_));\n  if (!func) {\n    return runtime.raiseTypeError(\n        \"Promise rejection tracking hook was not registered\");\n  }\n  return Callable::executeCall1(\n             func, runtime, Runtime::getUndefinedValue(), opts.getHermesValue())\n      .toCallResultHermesValue();\n}\n\n#ifdef HERMES_ENABLE_FUZZILLI\n\n/// Internal \"fuzzilli\" function used by the Fuzzilli fuzzer\n/// (https://github.com/googleprojectzero/fuzzilli) to sanity-check the engine.\n/// This function is conditionally defined in Hermes internal VM code rather\n/// than in an external fuzzing module so to catch build misconfigurations, e.g.\n/// we want to make sure that the VM is compiled with assertions enabled and\n/// doing this check out of the VM (e.g. in the fuzzing harness) doesn't\n/// guarantee that the VM has asserts on.\n///\n/// This function is defined as follow:\n/// \\code\n/// HermesInternal.fuzzilli = function(op, arg) {}\n/// \\endcode\n/// The first argument \"op\", is a string specifying the operation to be\n/// performed. Currently supported values of \"op\" are \"FUZZILLI_CRASH\", used to\n/// simulate a crash, and \"FUZZILLI_PRINT\", used to send data over Fuzzilli's\n/// ata write file decriptor (REPRL_DWFD). The secong argument \"arg\" can be an\n/// integer specifying the type of crash (if op is \"FUZZILLI_CRASH\") or a string\n/// which value will be sent to fuzzilli (if op is \"FUZZILLI_PRINT\")\nCallResult<HermesValue>\nhermesInternalFuzzilli(void *, Runtime &runtime, NativeArgs args) {\n  // REPRL = read-eval-print-reset-loop\n  // This file descriptor is being opened by Fuzzilli\n  constexpr int REPRL_DWFD = 103; // Data write file decriptor\n\n  auto operationRes = toString_RJS(runtime, args.getArgHandle(0));\n  if (LLVM_UNLIKELY(operationRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto operation = StringPrimitive::createStringView(\n      runtime, runtime.makeHandle(std::move(*operationRes)));\n\n  if (operation.equals(createUTF16Ref(u\"FUZZILLI_CRASH\"))) {\n    auto crashTypeRes = toIntegerOrInfinity(runtime, args.getArgHandle(1));\n    if (LLVM_UNLIKELY(crashTypeRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    switch (crashTypeRes->getNumberAs<int>()) {\n      case 0:\n        *((int *)0x41414141) = 0x1337;\n        break;\n      case 1:\n        assert(0);\n        break;\n      case 2:\n        std::abort();\n        break;\n    }\n  } else if (operation.equals(createUTF16Ref(u\"FUZZILLI_PRINT\"))) {\n    static FILE *fzliout = fdopen(REPRL_DWFD, \"w\");\n    if (!fzliout) {\n      fprintf(\n          stderr,\n          \"Fuzzer output channel not available, printing to stdout instead\\n\");\n      fzliout = stdout;\n    }\n\n    auto printRes = toString_RJS(runtime, args.getArgHandle(1));\n    if (LLVM_UNLIKELY(printRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    auto print = StringPrimitive::createStringView(\n        runtime, runtime.makeHandle(std::move(*printRes)));\n\n    vm::SmallU16String<32> allocator;\n    std::string outputString;\n    ::hermes::convertUTF16ToUTF8WithReplacements(\n        outputString, print.getUTF16Ref(allocator));\n    fprintf(fzliout, \"%s\\n\", outputString.c_str());\n    fflush(fzliout);\n  }\n\n  return HermesValue::encodeUndefinedValue();\n}\n#endif // HERMES_ENABLE_FUZZILLI\n\nstatic CallResult<HermesValue>\nhermesInternalIsLazy(void *, Runtime &runtime, NativeArgs args) {\n  auto callable = args.dyncastArg<Callable>(0);\n  if (!callable) {\n    return HermesValue::encodeBoolValue(false);\n  }\n\n  auto codeBlock = getLeafCodeBlock(callable, runtime);\n  if (!codeBlock) {\n    // Native function is never lazy.\n    return HermesValue::encodeBoolValue(false);\n  }\n\n  RuntimeModule *runtimeModule = codeBlock->getRuntimeModule();\n  return HermesValue::encodeBoolValue(\n      runtimeModule && runtimeModule->getBytecode()->isLazy());\n}\n\nHandle<JSObject> createHermesInternalObject(\n    Runtime &runtime,\n    const JSLibFlags &flags) {\n  namespace P = Predefined;\n  Handle<JSObject> intern = runtime.makeHandle(JSObject::create(runtime));\n  GCScope gcScope{runtime};\n\n  DefinePropertyFlags constantDPF =\n      DefinePropertyFlags::getDefaultNewPropertyFlags();\n  constantDPF.enumerable = 0;\n  constantDPF.writable = 0;\n  constantDPF.configurable = 0;\n\n  auto defineInternMethod =\n      [&](Predefined::Str symID, NativeFunctionPtr func, uint8_t count = 0) {\n        (void)defineMethod(\n            runtime,\n            intern,\n            Predefined::getSymbolID(symID),\n            nullptr /* context */,\n            func,\n            count,\n            constantDPF);\n      };\n\n  auto defineInternMethodAndSymbol =\n      [&](const char *name, NativeFunctionPtr func, uint8_t count = 0) {\n        ASCIIRef ref = createASCIIRef(name);\n        Handle<SymbolID> symHandle = runtime.ignoreAllocationFailure(\n            runtime.getIdentifierTable().getSymbolHandle(runtime, ref));\n        (void)defineMethod(\n            runtime,\n            intern,\n            *symHandle,\n            nullptr /* context */,\n            func,\n            count,\n            constantDPF);\n      };\n\n  // suppress unused-variable warning\n  (void)defineInternMethodAndSymbol;\n\n  // Make a copy of the original String.prototype.concat implementation that we\n  // can use internally.\n  // TODO: we can't make HermesInternal.concat a static builtin method now\n  // because this method should be called with a meaningful `this`, but\n  // CallBuiltin instruction does not support it.\n  auto propRes = JSObject::getNamed_RJS(\n      runtime.makeHandle<JSObject>(runtime.stringPrototype),\n      runtime,\n      Predefined::getSymbolID(Predefined::concat));\n  assert(\n      propRes != ExecutionStatus::EXCEPTION && !(*propRes)->isUndefined() &&\n      \"Failed to get String.prototype.concat.\");\n  auto putRes = JSObject::defineOwnProperty(\n      intern,\n      runtime,\n      Predefined::getSymbolID(Predefined::concat),\n      constantDPF,\n      runtime.makeHandle(std::move(*propRes)));\n  assert(\n      putRes != ExecutionStatus::EXCEPTION && *putRes &&\n      \"Failed to set HermesInternal.concat.\");\n  (void)putRes;\n\n  // HermesInternal functions that are known to be safe and are required to be\n  // present by the VM internals even under a security-sensitive environment\n  // where HermesInternal might be explicitly disabled.\n  defineInternMethod(P::hasPromise, hermesInternalHasPromise);\n  defineInternMethod(P::enqueueJob, hermesInternalEnqueueJob);\n  defineInternMethod(\n      P::setPromiseRejectionTrackingHook,\n      hermesInternalSetPromiseRejectionTrackingHook);\n  defineInternMethod(\n      P::enablePromiseRejectionTracker,\n      hermesInternalEnablePromiseRejectionTracker);\n  defineInternMethod(P::useEngineQueue, hermesInternalUseEngineQueue);\n\n#ifdef HERMES_ENABLE_FUZZILLI\n  defineInternMethod(P::fuzzilli, hermesInternalFuzzilli);\n#endif\n\n  // All functions are known to be safe can be defined above this flag check.\n  if (!flags.enableHermesInternal) {\n    JSObject::preventExtensions(*intern);\n    return intern;\n  }\n\n  // HermesInternal functions that are not necessarily required but are\n  // generally considered harmless to be exposed by default.\n  defineInternMethod(P::getEpilogues, hermesInternalGetEpilogues);\n  defineInternMethod(\n      P::getInstrumentedStats, hermesInternalGetInstrumentedStats);\n  defineInternMethod(\n      P::getRuntimeProperties, hermesInternalGetRuntimeProperties);\n  defineInternMethod(P::ttiReached, hermesInternalTTIReached);\n  defineInternMethod(P::ttrcReached, hermesInternalTTRCReached);\n  defineInternMethod(P::getFunctionLocation, hermesInternalGetFunctionLocation);\n\n  // HermesInternal function that are only meant to be used for testing purpose.\n  // They can change language semantics and are security risks.\n  if (flags.enableHermesInternalTestMethods) {\n    defineInternMethod(\n        P::detachArrayBuffer, hermesInternalDetachArrayBuffer, 1);\n    defineInternMethod(P::getWeakSize, hermesInternalGetWeakSize);\n    defineInternMethod(\n        P::copyDataProperties, hermesBuiltinCopyDataProperties, 3);\n    defineInternMethodAndSymbol(\"isProxy\", hermesInternalIsProxy);\n    defineInternMethodAndSymbol(\"isLazy\", hermesInternalIsLazy);\n    defineInternMethod(P::drainJobs, hermesInternalDrainJobs);\n  }\n\n#ifdef HERMESVM_EXCEPTION_ON_OOM\n  defineInternMethodAndSymbol(\"getCallStack\", hermesInternalGetCallStack, 0);\n#endif // HERMESVM_EXCEPTION_ON_OOM\n\n  JSObject::preventExtensions(*intern);\n\n  return intern;\n}\n\n} // namespace vm\n} // namespace hermes\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2023-24833", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "/*\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n//===----------------------------------------------------------------------===//\n/// \\file\n/// ES5.1 15.4 Initialize the Array constructor.\n//===----------------------------------------------------------------------===//\n\n#include \"JSLibInternal.h\"\n\n#include \"hermes/ADT/SafeInt.h\"\n#include \"hermes/VM/HandleRootOwner-inline.h\"\n#include \"hermes/VM/JSLib/Sorting.h\"\n#include \"hermes/VM/Operations.h\"\n#include \"hermes/VM/StringBuilder.h\"\n#include \"hermes/VM/StringRefUtils.h\"\n#include \"hermes/VM/StringView.h\"\n\n#include \"llvh/ADT/ScopeExit.h\"\n#pragma GCC diagnostic push\n\n#ifdef HERMES_COMPILER_SUPPORTS_WSHORTEN_64_TO_32\n#pragma GCC diagnostic ignored \"-Wshorten-64-to-32\"\n#endif\nnamespace hermes {\nnamespace vm {\n\n//===----------------------------------------------------------------------===//\n/// Array.\n\nHandle<JSObject> createArrayConstructor(Runtime &runtime) {\n  auto arrayPrototype = Handle<JSArray>::vmcast(&runtime.arrayPrototype);\n\n  // Array.prototype.xxx methods.\n  defineMethod(\n      runtime,\n      arrayPrototype,\n      Predefined::getSymbolID(Predefined::toString),\n      nullptr,\n      arrayPrototypeToString,\n      0);\n  defineMethod(\n      runtime,\n      arrayPrototype,\n      Predefined::getSymbolID(Predefined::toLocaleString),\n      nullptr,\n      arrayPrototypeToLocaleString,\n      0);\n  defineMethod(\n      runtime,\n      arrayPrototype,\n      Predefined::getSymbolID(Predefined::at),\n      nullptr,\n      arrayPrototypeAt,\n      1);\n  defineMethod(\n      runtime,\n      arrayPrototype,\n      Predefined::getSymbolID(Predefined::concat),\n      nullptr,\n      arrayPrototypeConcat,\n      1);\n  defineMethod(\n      runtime,\n      arrayPrototype,\n      Predefined::getSymbolID(Predefined::join),\n      nullptr,\n      arrayPrototypeJoin,\n      1);\n  defineMethod(\n      runtime,\n      arrayPrototype,\n      Predefined::getSymbolID(Predefined::push),\n      nullptr,\n      arrayPrototypePush,\n      1);\n  defineMethod(\n      runtime,\n      arrayPrototype,\n      Predefined::getSymbolID(Predefined::sort),\n      nullptr,\n      arrayPrototypeSort,\n      1);\n  defineMethod(\n      runtime,\n      arrayPrototype,\n      Predefined::getSymbolID(Predefined::forEach),\n      nullptr,\n      arrayPrototypeForEach,\n      1);\n  defineMethod(\n      runtime,\n      arrayPrototype,\n      Predefined::getSymbolID(Predefined::flat),\n      nullptr,\n      arrayPrototypeFlat,\n      0);\n  defineMethod(\n      runtime,\n      arrayPrototype,\n      Predefined::getSymbolID(Predefined::flatMap),\n      nullptr,\n      arrayPrototypeFlatMap,\n      1);\n\n  defineMethod(\n      runtime,\n      arrayPrototype,\n      Predefined::getSymbolID(Predefined::keys),\n      (void *)IterationKind::Key,\n      arrayPrototypeIterator,\n      0);\n  defineMethod(\n      runtime,\n      arrayPrototype,\n      Predefined::getSymbolID(Predefined::values),\n      (void *)IterationKind::Value,\n      arrayPrototypeIterator,\n      0);\n  defineMethod(\n      runtime,\n      arrayPrototype,\n      Predefined::getSymbolID(Predefined::entries),\n      (void *)IterationKind::Entry,\n      arrayPrototypeIterator,\n      0);\n\n  auto propValue = runtime.ignoreAllocationFailure(JSObject::getNamed_RJS(\n      arrayPrototype, runtime, Predefined::getSymbolID(Predefined::values)));\n  runtime.arrayPrototypeValues = std::move(propValue);\n\n  DefinePropertyFlags dpf = DefinePropertyFlags::getNewNonEnumerableFlags();\n\n  runtime.ignoreAllocationFailure(JSObject::defineOwnProperty(\n      arrayPrototype,\n      runtime,\n      Predefined::getSymbolID(Predefined::SymbolIterator),\n      dpf,\n      Handle<>(&runtime.arrayPrototypeValues)));\n\n  auto cons = defineSystemConstructor<JSArray>(\n      runtime,\n      Predefined::getSymbolID(Predefined::Array),\n      arrayConstructor,\n      arrayPrototype,\n      1,\n      CellKind::JSArrayKind);\n\n  defineMethod(\n      runtime,\n      cons,\n      Predefined::getSymbolID(Predefined::isArray),\n      nullptr,\n      arrayIsArray,\n      1);\n\n  defineMethod(\n      runtime,\n      arrayPrototype,\n      Predefined::getSymbolID(Predefined::slice),\n      nullptr,\n      arrayPrototypeSlice,\n      2);\n  defineMethod(\n      runtime,\n      arrayPrototype,\n      Predefined::getSymbolID(Predefined::splice),\n      nullptr,\n      arrayPrototypeSplice,\n      2);\n  defineMethod(\n      runtime,\n      arrayPrototype,\n      Predefined::getSymbolID(Predefined::copyWithin),\n      nullptr,\n      arrayPrototypeCopyWithin,\n      2);\n  defineMethod(\n      runtime,\n      arrayPrototype,\n      Predefined::getSymbolID(Predefined::pop),\n      nullptr,\n      arrayPrototypePop,\n      0);\n  defineMethod(\n      runtime,\n      arrayPrototype,\n      Predefined::getSymbolID(Predefined::shift),\n      nullptr,\n      arrayPrototypeShift,\n      0);\n  defineMethod(\n      runtime,\n      arrayPrototype,\n      Predefined::getSymbolID(Predefined::unshift),\n      nullptr,\n      arrayPrototypeUnshift,\n      1);\n  defineMethod(\n      runtime,\n      arrayPrototype,\n      Predefined::getSymbolID(Predefined::indexOf),\n      nullptr,\n      arrayPrototypeIndexOf,\n      1);\n  defineMethod(\n      runtime,\n      arrayPrototype,\n      Predefined::getSymbolID(Predefined::lastIndexOf),\n      nullptr,\n      arrayPrototypeLastIndexOf,\n      1);\n  defineMethod(\n      runtime,\n      arrayPrototype,\n      Predefined::getSymbolID(Predefined::every),\n      nullptr,\n      arrayPrototypeEvery,\n      1);\n  defineMethod(\n      runtime,\n      arrayPrototype,\n      Predefined::getSymbolID(Predefined::some),\n      nullptr,\n      arrayPrototypeSome,\n      1);\n  defineMethod(\n      runtime,\n      arrayPrototype,\n      Predefined::getSymbolID(Predefined::map),\n      nullptr,\n      arrayPrototypeMap,\n      1);\n  defineMethod(\n      runtime,\n      arrayPrototype,\n      Predefined::getSymbolID(Predefined::filter),\n      nullptr,\n      arrayPrototypeFilter,\n      1);\n  defineMethod(\n      runtime,\n      arrayPrototype,\n      Predefined::getSymbolID(Predefined::fill),\n      nullptr,\n      arrayPrototypeFill,\n      1);\n  defineMethod(\n      runtime,\n      arrayPrototype,\n      Predefined::getSymbolID(Predefined::find),\n      nullptr,\n      arrayPrototypeFind,\n      1);\n  defineMethod(\n      runtime,\n      arrayPrototype,\n      Predefined::getSymbolID(Predefined::findIndex),\n      // Pass a non-null pointer here to indicate we're finding the index.\n      (void *)true,\n      arrayPrototypeFind,\n      1);\n  defineMethod(\n      runtime,\n      arrayPrototype,\n      Predefined::getSymbolID(Predefined::findLast),\n      nullptr,\n      arrayPrototypeFindLast,\n      1);\n  defineMethod(\n      runtime,\n      arrayPrototype,\n      Predefined::getSymbolID(Predefined::findLastIndex),\n      // Pass a non-null pointer here to indicate we're finding the index.\n      (void *)true,\n      arrayPrototypeFindLast,\n      1);\n  defineMethod(\n      runtime,\n      arrayPrototype,\n      Predefined::getSymbolID(Predefined::reduce),\n      nullptr,\n      arrayPrototypeReduce,\n      1);\n  defineMethod(\n      runtime,\n      arrayPrototype,\n      Predefined::getSymbolID(Predefined::reduceRight),\n      nullptr,\n      arrayPrototypeReduceRight,\n      1);\n  defineMethod(\n      runtime,\n      arrayPrototype,\n      Predefined::getSymbolID(Predefined::reverse),\n      nullptr,\n      arrayPrototypeReverse,\n      0);\n  defineMethod(\n      runtime,\n      arrayPrototype,\n      Predefined::getSymbolID(Predefined::includes),\n      nullptr,\n      arrayPrototypeIncludes,\n      1);\n\n  defineMethod(\n      runtime,\n      cons,\n      Predefined::getSymbolID(Predefined::of),\n      nullptr,\n      arrayOf,\n      0);\n  defineMethod(\n      runtime,\n      cons,\n      Predefined::getSymbolID(Predefined::from),\n      nullptr,\n      arrayFrom,\n      1);\n\n  return cons;\n}\n\nCallResult<HermesValue>\narrayConstructor(void *, Runtime &runtime, NativeArgs args) {\n  MutableHandle<JSArray> selfHandle{runtime};\n\n  // If constructor, use the allocated object, otherwise allocate a new one.\n  // Everything else is the same after that.\n  if (args.isConstructorCall())\n    selfHandle = vmcast<JSArray>(args.getThisArg());\n  else {\n    auto arrRes = JSArray::create(runtime, 0, 0);\n    if (LLVM_UNLIKELY(arrRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    selfHandle = arrRes->get();\n  }\n\n  // Possibility 1: new Array(number)\n  if (args.getArgCount() == 1 && args.getArg(0).isNumber()) {\n    double number = args.getArg(0).getNumber();\n    uint32_t len = truncateToUInt32(number);\n    if (len != number) {\n      return runtime.raiseRangeError(\"invalid array length\");\n    }\n\n    auto st = JSArray::setLengthProperty(selfHandle, runtime, len);\n    (void)st;\n    assert(\n        st != ExecutionStatus::EXCEPTION && *st &&\n        \"Cannot set length of a new array\");\n\n    return selfHandle.getHermesValue();\n  }\n\n  // Possibility 2: new Array(elements...)\n  uint32_t len = args.getArgCount();\n\n  // Resize the array.\n  auto st = JSArray::setLengthProperty(selfHandle, runtime, len);\n  (void)st;\n  assert(\n      st != ExecutionStatus::EXCEPTION && *st &&\n      \"Cannot set length of a new array\");\n\n  // Initialize the elements.\n  uint32_t index = 0;\n  GCScopeMarkerRAII marker(runtime);\n  for (Handle<> arg : args.handles()) {\n    JSArray::setElementAt(selfHandle, runtime, index++, arg);\n    marker.flush();\n  }\n\n  return selfHandle.getHermesValue();\n}\n\nCallResult<HermesValue>\narrayIsArray(void *, Runtime &runtime, NativeArgs args) {\n  CallResult<bool> res = isArray(runtime, dyn_vmcast<JSObject>(args.getArg(0)));\n  if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  return HermesValue::encodeBoolValue(*res);\n}\n\n/// ES5.1 15.4.4.5.\nCallResult<HermesValue>\narrayPrototypeToString(void *, Runtime &runtime, NativeArgs args) {\n  auto objRes = toObject(runtime, args.getThisHandle());\n  if (LLVM_UNLIKELY(objRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto array = runtime.makeHandle<JSObject>(objRes.getValue());\n\n  auto propRes = JSObject::getNamed_RJS(\n      array, runtime, Predefined::getSymbolID(Predefined::join));\n  if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto func =\n      Handle<Callable>::dyn_vmcast(runtime.makeHandle(std::move(*propRes)));\n\n  if (!func) {\n    // If not callable, set func to be Object.prototype.toString.\n    return directObjectPrototypeToString(runtime, array);\n  }\n\n  return Callable::executeCall0(func, runtime, array).toCallResultHermesValue();\n}\n\nCallResult<HermesValue>\narrayPrototypeToLocaleString(void *, Runtime &runtime, NativeArgs args) {\n  GCScope gcScope{runtime};\n  auto objRes = toObject(runtime, args.getThisHandle());\n  if (LLVM_UNLIKELY(objRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto array = runtime.makeHandle<JSObject>(objRes.getValue());\n\n  auto emptyString = runtime.getPredefinedStringHandle(Predefined::emptyString);\n\n  if (runtime.insertVisitedObject(*array))\n    return emptyString.getHermesValue();\n  auto cycleScope =\n      llvh::make_scope_exit([&] { runtime.removeVisitedObject(*array); });\n\n  auto propRes = JSObject::getNamed_RJS(\n      array, runtime, Predefined::getSymbolID(Predefined::length));\n  if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto intRes = toUInt32_RJS(runtime, runtime.makeHandle(std::move(*propRes)));\n  if (LLVM_UNLIKELY(intRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  uint32_t len = intRes->getNumber();\n\n  // TODO: Get a list-separator String for the host environment's locale.\n  // Use a comma as a separator for now, as JSC does.\n  const char16_t separator = u',';\n\n  // Final size of the result string. Initialize to account for the separators.\n  SafeUInt32 size(len - 1);\n\n  if (len == 0) {\n    return emptyString.getHermesValue();\n  }\n\n  // Array to store each of the strings of the elements.\n  auto arrRes = JSArray::create(runtime, len, len);\n  if (LLVM_UNLIKELY(arrRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto strings = *arrRes;\n\n  // Index into the array.\n  MutableHandle<> i{runtime, HermesValue::encodeNumberValue(0)};\n\n  auto marker = gcScope.createMarker();\n  while (i->getNumber() < len) {\n    gcScope.flushToMarker(marker);\n    if (LLVM_UNLIKELY(\n            (propRes = JSObject::getComputed_RJS(array, runtime, i)) ==\n            ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    auto E = runtime.makeHandle(std::move(*propRes));\n    if (E->isUndefined() || E->isNull()) {\n      // Empty string for undefined or null element. No need to add to size.\n      JSArray::setElementAt(strings, runtime, i->getNumber(), emptyString);\n    } else {\n      if (LLVM_UNLIKELY(\n              (objRes = toObject(runtime, E)) == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      auto elementObj = runtime.makeHandle<JSObject>(objRes.getValue());\n\n      // Retrieve the toLocaleString function.\n      if (LLVM_UNLIKELY(\n              (propRes = JSObject::getNamed_RJS(\n                   elementObj,\n                   runtime,\n                   Predefined::getSymbolID(Predefined::toLocaleString))) ==\n              ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      if (auto func = Handle<Callable>::dyn_vmcast(\n              runtime.makeHandle(std::move(*propRes)))) {\n        // If ECMA 402 is implemented, it provides a superseding\n        // definition of Array.prototype.toLocaleString.  The only\n        // difference between these two definitions is that in ECMA\n        // 402, two arguments (locales and options), if provided, are\n        // passed on from this function to the element's\n        // \"toLocaleString\" method.\n        auto callRes =\n#ifdef HERMES_ENABLE_INTL\n            Callable::executeCall2(\n                func, runtime, elementObj, args.getArg(0), args.getArg(1));\n#else\n            Callable::executeCall0(func, runtime, elementObj);\n#endif\n        if (LLVM_UNLIKELY(callRes == ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n        auto strRes =\n            toString_RJS(runtime, runtime.makeHandle(std::move(*callRes)));\n        if (LLVM_UNLIKELY(strRes == ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n        auto elementStr = runtime.makeHandle(std::move(*strRes));\n        uint32_t strLength = elementStr->getStringLength();\n        // Throw RangeError on overflow.\n        size.add(strLength);\n        if (LLVM_UNLIKELY(size.isOverflowed())) {\n          return runtime.raiseRangeError(\n              \"resulting string length exceeds limit\");\n        }\n        JSArray::setElementAt(strings, runtime, i->getNumber(), elementStr);\n      } else {\n        return runtime.raiseTypeError(\"toLocaleString() not callable\");\n      }\n    }\n    i = HermesValue::encodeNumberValue(i->getNumber() + 1);\n  }\n\n  // Create and then populate the result string.\n  auto builder = StringBuilder::createStringBuilder(runtime, size);\n  if (builder == ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  MutableHandle<StringPrimitive> element{runtime};\n  element = strings->at(runtime, 0).getString(runtime);\n  builder->appendStringPrim(element);\n  for (uint32_t j = 1; j < len; ++j) {\n    // Every element after the first needs a separator before it.\n    builder->appendCharacter(separator);\n    element = strings->at(runtime, j).getString(runtime);\n    builder->appendStringPrim(element);\n  }\n  return HermesValue::encodeStringValue(*builder->getStringPrimitive());\n}\n\n// 23.1.3.1\nCallResult<HermesValue>\narrayPrototypeAt(void *, Runtime &runtime, NativeArgs args) {\n  GCScope gcScope(runtime);\n  // 1. Let O be ? ToObject(this value).\n  auto objRes = toObject(runtime, args.getThisHandle());\n  if (LLVM_UNLIKELY(objRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto O = runtime.makeHandle<JSObject>(objRes.getValue());\n\n  // 2. Let len be ? LengthOfArrayLike(O).\n  Handle<JSArray> jsArr = Handle<JSArray>::dyn_vmcast(O);\n  uint32_t len = 0;\n  if (LLVM_LIKELY(jsArr)) {\n    // Fast path for getting the length.\n    len = JSArray::getLength(jsArr.get(), runtime);\n  } else {\n    // Slow path\n    CallResult<PseudoHandle<>> propRes = JSObject::getNamed_RJS(\n        O, runtime, Predefined::getSymbolID(Predefined::length));\n    if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    auto lenRes = toLength(runtime, runtime.makeHandle(std::move(*propRes)));\n    if (LLVM_UNLIKELY(lenRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    len = lenRes->getNumber();\n  }\n\n  // 3. Let relativeIndex be ? ToIntegerOrInfinity(index).\n  auto idx = args.getArgHandle(0);\n  auto relativeIndexRes = toIntegerOrInfinity(runtime, idx);\n  if (relativeIndexRes == ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  const double relativeIndex = relativeIndexRes->getNumber();\n\n  double k;\n  // 4. If relativeIndex  0, then\n  if (relativeIndex >= 0) {\n    // a. Let k be relativeIndex.\n    k = relativeIndex;\n  } else {\n    // 5. Else,\n    // a. Let k be len + relativeIndex.\n    k = len + relativeIndex;\n  }\n\n  // 6. If k < 0 or k  len, return undefined.\n  if (k < 0 || k >= len) {\n    return HermesValue::encodeUndefinedValue();\n  }\n\n  // 7. Return ? Get(O, ! ToString((k))).\n  if (LLVM_LIKELY(jsArr)) {\n    const SmallHermesValue elm = jsArr->at(runtime, k);\n    if (elm.isEmpty()) {\n      return HermesValue::encodeUndefinedValue();\n    } else {\n      return elm.unboxToHV(runtime);\n    }\n  }\n  CallResult<PseudoHandle<>> propRes = JSObject::getComputed_RJS(\n      O, runtime, runtime.makeHandle(HermesValue::encodeDoubleValue(k)));\n  if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  return propRes->getHermesValue();\n}\n\nCallResult<HermesValue>\narrayPrototypeConcat(void *, Runtime &runtime, NativeArgs args) {\n  GCScope gcScope(runtime);\n  auto objRes = toObject(runtime, args.getThisHandle());\n  if (LLVM_UNLIKELY(objRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto O = runtime.makeHandle<JSObject>(objRes.getValue());\n\n  // Need a signed type here to account for uint32 and -1.\n  int64_t argCount = args.getArgCount();\n\n  // Precompute the final size of the array so it can be preallocated.\n  // Note this is necessarily an estimate because an accessor on one array\n  // may change the length of subsequent arrays.\n  SafeUInt32 finalSizeEstimate{0};\n  if (JSArray *arr = dyn_vmcast<JSArray>(O.get())) {\n    finalSizeEstimate.add(JSArray::getLength(arr, runtime));\n  } else {\n    finalSizeEstimate.add(1);\n  }\n  for (int64_t i = 0; i < argCount; ++i) {\n    if (JSArray *arr = dyn_vmcast<JSArray>(args.getArg(i))) {\n      finalSizeEstimate.add(JSArray::getLength(arr, runtime));\n    } else {\n      finalSizeEstimate.add(1);\n    }\n  }\n  if (finalSizeEstimate.isOverflowed()) {\n    return runtime.raiseTypeError(\"Array.prototype.concat result out of space\");\n  }\n\n  // Resultant array.\n  auto arrRes =\n      JSArray::create(runtime, *finalSizeEstimate, *finalSizeEstimate);\n  if (LLVM_UNLIKELY(arrRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto A = *arrRes;\n\n  // Index to insert into A.\n  uint64_t n = 0;\n\n  // Temporary handle for an object.\n  MutableHandle<JSObject> objHandle{runtime};\n  // Temporary handle for an array.\n  MutableHandle<JSArray> arrHandle{runtime};\n  // Index to read from in the array that's being concatenated.\n  MutableHandle<> kHandle{runtime};\n  // Index to put into the resultant array.\n  MutableHandle<> nHandle{runtime};\n  // Temporary handle to use when holding intermediate elements.\n  MutableHandle<> tmpHandle{runtime};\n  // Used to find the object in the prototype chain that has index as property.\n  MutableHandle<JSObject> propObj{runtime};\n  MutableHandle<SymbolID> tmpPropNameStorage{runtime};\n  auto marker = gcScope.createMarker();\n  ComputedPropertyDescriptor desc;\n\n  // Loop first through the \"this\" value and then through the arguments.\n  // If i == -1, use the \"this\" value, else use the ith argument.\n  tmpHandle = O.getHermesValue();\n  for (int64_t i = -1; i < argCount; ++i, tmpHandle = args.getArg(i)) {\n    CallResult<bool> spreadable = isConcatSpreadable(runtime, tmpHandle);\n    if (LLVM_UNLIKELY(spreadable == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    if (*spreadable) {\n      // 7.d. If spreadable is true, then\n      objHandle = vmcast<JSObject>(*tmpHandle);\n      arrHandle = dyn_vmcast<JSArray>(*tmpHandle);\n\n      uint64_t len;\n      if (LLVM_LIKELY(arrHandle)) {\n        // Fast path: E is an array.\n        len = JSArray::getLength(*arrHandle, runtime);\n      } else {\n        CallResult<PseudoHandle<>> propRes = JSObject::getNamed_RJS(\n            objHandle, runtime, Predefined::getSymbolID(Predefined::length));\n        if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n        tmpHandle = std::move(*propRes);\n        auto lengthRes = toLength(runtime, tmpHandle);\n        if (LLVM_UNLIKELY(lengthRes == ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n        len = lengthRes->getNumberAs<uint64_t>();\n      }\n\n      // 5.c.iii. If n + len > 2^53 - 1, throw a TypeError exception\n      if (LLVM_UNLIKELY(n + len > ((uint64_t)1 << 53) - 1)) {\n        return runtime.raiseTypeError(\n            \"Array.prototype.concat result out of space\");\n      }\n\n      // We know we are going to set elements in the range [n, n+len),\n      // regardless of any changes to 'arrHandle' (see ES5.1 15.4.4.4). Ensure\n      // we have capacity.\n      if (LLVM_UNLIKELY(n + len > A->getEndIndex()) &&\n          LLVM_LIKELY(n + len < UINT32_MAX)) {\n        // Only set the endIndex if it's going to be a valid length.\n        if (LLVM_UNLIKELY(\n                A->setStorageEndIndex(A, runtime, n + len) ==\n                ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n      }\n\n      // Note that we must increase n every iteration even if nothing was\n      // appended to the result array.\n      // 5.c.iv. Repeat, while k < len\n      for (uint64_t k = 0; k < len; ++k, ++n) {\n        SmallHermesValue subElement = LLVM_LIKELY(arrHandle)\n            ? arrHandle->at(runtime, k)\n            : SmallHermesValue::encodeEmptyValue();\n        if (LLVM_LIKELY(!subElement.isEmpty()) &&\n            LLVM_LIKELY(n < A->getEndIndex())) {\n          // Fast path: quickly set element without making any extra calls.\n          // Cast is safe because A->getEndIndex must be in uint32_t range.\n          JSArray::unsafeSetExistingElementAt(\n              A.get(), runtime, static_cast<uint32_t>(n), subElement);\n        } else {\n          // Slow path fallback if there's an empty slot in arr.\n          // We have to use getComputedPrimitiveDescriptor because the property\n          // may exist anywhere in the prototype chain.\n          kHandle = HermesValue::encodeDoubleValue(k);\n          JSObject::getComputedPrimitiveDescriptor(\n              objHandle, runtime, kHandle, propObj, tmpPropNameStorage, desc);\n          CallResult<PseudoHandle<>> propRes =\n              JSObject::getComputedPropertyValue_RJS(\n                  objHandle,\n                  runtime,\n                  propObj,\n                  tmpPropNameStorage,\n                  desc,\n                  kHandle);\n          if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n            return ExecutionStatus::EXCEPTION;\n          }\n          if (LLVM_LIKELY(!(*propRes)->isEmpty())) {\n            tmpHandle = std::move(*propRes);\n            nHandle = HermesValue::encodeDoubleValue(n);\n            if (LLVM_UNLIKELY(\n                    JSArray::defineOwnComputedPrimitive(\n                        A,\n                        runtime,\n                        nHandle,\n                        DefinePropertyFlags::getDefaultNewPropertyFlags(),\n                        tmpHandle) == ExecutionStatus::EXCEPTION)) {\n              return ExecutionStatus::EXCEPTION;\n            }\n          }\n          gcScope.flushToMarker(marker);\n        }\n      }\n      gcScope.flushToMarker(marker);\n    } else {\n      // 5.d.i. NOTE: E is added as a single item rather than spread.\n      // 5.d.ii. If n >= 2**53 - 1, throw a TypeError exception.\n      if (LLVM_UNLIKELY(n >= ((uint64_t)1 << 53) - 1)) {\n        return runtime.raiseTypeError(\n            \"Array.prototype.concat result out of space\");\n      }\n      // Otherwise, just put the value into the next slot.\n      if (LLVM_LIKELY(n < UINT32_MAX)) {\n        JSArray::setElementAt(A, runtime, n, tmpHandle);\n      } else {\n        nHandle = HermesValue::encodeDoubleValue(n);\n        auto cr = valueToSymbolID(runtime, nHandle);\n        if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n        if (LLVM_UNLIKELY(\n                JSArray::defineOwnProperty(\n                    A,\n                    runtime,\n                    **cr,\n                    DefinePropertyFlags::getDefaultNewPropertyFlags(),\n                    tmpHandle) == ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n      }\n      gcScope.flushToMarker(marker);\n      ++n;\n    }\n  }\n  // Update the array's length. We never expect this to fail since we just\n  // created the array.\n  if (n > UINT32_MAX) {\n    return runtime.raiseRangeError(\"invalid array length\");\n  }\n  auto res = JSArray::setLengthProperty(A, runtime, static_cast<uint32_t>(n));\n  assert(\n      res == ExecutionStatus::RETURNED &&\n      \"Setting length of new array should never fail\");\n  (void)res;\n  return A.getHermesValue();\n}\n\n/// ES5.1 15.4.4.5.\nCallResult<HermesValue>\narrayPrototypeJoin(void *, Runtime &runtime, NativeArgs args) {\n  GCScope gcScope(runtime);\n  auto objRes = toObject(runtime, args.getThisHandle());\n  if (LLVM_UNLIKELY(objRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto O = runtime.makeHandle<JSObject>(objRes.getValue());\n\n  auto emptyString = runtime.getPredefinedStringHandle(Predefined::emptyString);\n\n  if (runtime.insertVisitedObject(*O))\n    return emptyString.getHermesValue();\n  auto cycleScope =\n      llvh::make_scope_exit([&] { runtime.removeVisitedObject(*O); });\n\n  auto propRes = JSObject::getNamed_RJS(\n      O, runtime, Predefined::getSymbolID(Predefined::length));\n  if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto intRes = toLengthU64(runtime, runtime.makeHandle(std::move(*propRes)));\n  if (LLVM_UNLIKELY(intRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  uint64_t len = *intRes;\n\n  // Use comma for separator if the first argument is undefined.\n  auto separator = args.getArg(0).isUndefined()\n      ? runtime.makeHandle(HermesValue::encodeStringValue(\n            runtime.getPredefinedString(Predefined::comma)))\n      : args.getArgHandle(0);\n  auto strRes = toString_RJS(runtime, separator);\n  if (LLVM_UNLIKELY(strRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto sep = runtime.makeHandle(std::move(*strRes));\n\n  if (len == 0) {\n    return HermesValue::encodeStringValue(\n        runtime.getPredefinedString(Predefined::emptyString));\n  }\n\n  // Track the size of the resultant string. Use a 64-bit value to detect\n  // overflow.\n  SafeUInt32 size;\n\n  // Storage for the strings for each element.\n  if (LLVM_UNLIKELY(len > JSArray::StorageType::maxElements())) {\n    return runtime.raiseRangeError(\"Out of memory for array elements.\");\n  }\n  auto arrRes = JSArray::create(runtime, len, 0);\n  if (LLVM_UNLIKELY(arrRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto strings = *arrRes;\n\n  // Call toString on all the elements of the array.\n  for (MutableHandle<> i{runtime, HermesValue::encodeNumberValue(0)};\n       i->getNumber() < len;\n       i = HermesValue::encodeNumberValue(i->getNumber() + 1)) {\n    // Add the size of the separator, except the first time.\n    if (i->getNumberAs<uint32_t>())\n      size.add(sep->getStringLength());\n\n    GCScope gcScope2(runtime);\n    if (LLVM_UNLIKELY(\n            (propRes = JSObject::getComputed_RJS(O, runtime, i)) ==\n            ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n\n    auto elem = runtime.makeHandle(std::move(*propRes));\n\n    if (elem->isUndefined() || elem->isNull()) {\n      JSArray::setElementAt(strings, runtime, i->getNumber(), emptyString);\n    } else {\n      // Otherwise, call toString_RJS() and push the result, incrementing size.\n      auto strRes = toString_RJS(runtime, elem);\n      if (LLVM_UNLIKELY(strRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      auto S = runtime.makeHandle(std::move(*strRes));\n      size.add(S->getStringLength());\n      JSArray::setElementAt(strings, runtime, i->getNumber(), S);\n    }\n\n    // Check for string overflow on every iteration to create the illusion that\n    // we are appending to the string. Also, prevent uint32_t overflow.\n    if (size.isOverflowed()) {\n      return runtime.raiseRangeError(\"String is too long\");\n    }\n  }\n\n  // Allocate the complete result.\n  auto builder = StringBuilder::createStringBuilder(runtime, size);\n  if (builder == ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  MutableHandle<StringPrimitive> element{runtime};\n  element = strings->at(runtime, 0).getString(runtime);\n  builder->appendStringPrim(element);\n  for (size_t i = 1; i < len; ++i) {\n    builder->appendStringPrim(sep);\n    element = strings->at(runtime, i).getString(runtime);\n    builder->appendStringPrim(element);\n  }\n  return HermesValue::encodeStringValue(*builder->getStringPrimitive());\n}\n\n/// ES9.0 22.1.3.18.\nCallResult<HermesValue>\narrayPrototypePush(void *, Runtime &runtime, NativeArgs args) {\n  GCScope gcScope(runtime);\n\n  // 1. Let O be ? ToObject(this value).\n  auto objRes = toObject(runtime, args.getThisHandle());\n  if (LLVM_UNLIKELY(objRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto O = runtime.makeHandle<JSObject>(objRes.getValue());\n\n  MutableHandle<> len{runtime};\n\n  // 2. Let len be ? ToLength(? Get(O, \"length\")).\n  Handle<JSArray> arr = Handle<JSArray>::dyn_vmcast(O);\n  if (LLVM_LIKELY(arr)) {\n    // Fast path for getting the length.\n    len =\n        HermesValue::encodeNumberValue(JSArray::getLength(arr.get(), runtime));\n  } else {\n    // Slow path, used when pushing onto non-array objects.\n    auto propRes = JSObject::getNamed_RJS(\n        O, runtime, Predefined::getSymbolID(Predefined::length));\n    if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    auto lenRes = toLength(runtime, runtime.makeHandle(std::move(*propRes)));\n    if (LLVM_UNLIKELY(lenRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    len = lenRes.getValue();\n  }\n\n  // 3. Let items be a List whose elements are, in left to right order, the\n  // arguments that were passed to this function invocation.\n  // 4. Let argCount be the number of elements in items.\n  uint32_t argCount = args.getArgCount();\n\n  // 5. If len + argCount > 2**53-1, throw a TypeError exception.\n  if (len->getNumber() + (double)argCount > std::pow(2.0, 53) - 1) {\n    return runtime.raiseTypeError(\"Array length exceeded in push()\");\n  }\n\n  auto marker = gcScope.createMarker();\n  // 6. Repeat, while items is not empty\n  for (auto arg : args.handles()) {\n    // a. Remove the first element from items and let E be the value of the\n    // element.\n    // b. Perform ? Set(O, ! ToString(len), E, true).\n    // NOTE: If the prototype has an index-like non-writable property at\n    // index n, we have to fail to push.\n    // If the prototype has an index-like accessor at index n,\n    // then we have to attempt to call the setter.\n    // Must call putComputed because the array prototype could have values for\n    // keys that haven't been inserted into O yet.\n    if (LLVM_UNLIKELY(\n            JSObject::putComputed_RJS(\n                O, runtime, len, arg, PropOpFlags().plusThrowOnError()) ==\n            ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    gcScope.flushToMarker(marker);\n    // c. Let len be len+1.\n    len = HermesValue::encodeDoubleValue(len->getNumber() + 1);\n  }\n\n  // 7. Perform ? Set(O, \"length\", len, true).\n  if (LLVM_UNLIKELY(\n          JSObject::putNamed_RJS(\n              O,\n              runtime,\n              Predefined::getSymbolID(Predefined::length),\n              len,\n              PropOpFlags().plusThrowOnError()) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  // 8. Return len.\n  return len.get();\n}\n\nnamespace {\n/// General object sorting model used by custom sorting routines.\n/// Provides a model by which to less and swap elements, using the [[Get]],\n/// [[Put]], and [[Delete]] internal methods of a supplied Object. Should be\n/// allocated on the stack, because it creates its own internal GCScope, with\n/// reusable MutableHandle<>-s that are used in the less and swap methods.\n/// These allow for quick accesses without allocating a great number of new\n/// handles every time we want to compare different elements.\n/// Usage example:\n///   StandardSortModel sm{runtime, obj, compareFn};\n///   quickSort(sm, 0, length);\n/// Note that this is generic and does nothing different if passed a JSArray.\nclass StandardSortModel : public SortModel {\n private:\n  /// Runtime to sort in.\n  Runtime &runtime_;\n\n  /// Scope to allocate handles in, gets destroyed with this.\n  GCScope gcScope_;\n\n  /// JS comparison function, return -1 for less, 0 for equal, 1 for greater.\n  /// If null, then use the built in < operator.\n  Handle<Callable> compareFn_;\n\n  /// Object to sort elements [0, length).\n  Handle<JSObject> obj_;\n\n  /// Temporary handles for property name.\n  MutableHandle<SymbolID> aTmpNameStorage_;\n  MutableHandle<SymbolID> bTmpNameStorage_;\n\n  /// Preallocate handles in the current GCScope so that we don't have to make\n  /// new handles in every method call.\n\n  /// Handles for two indices.\n  MutableHandle<> aHandle_;\n  MutableHandle<> bHandle_;\n\n  /// Handles for the values at two indices.\n  MutableHandle<> aValue_;\n  MutableHandle<> bValue_;\n\n  /// Handles for the objects the values are retrieved from.\n  MutableHandle<JSObject> aDescObjHandle_;\n  MutableHandle<JSObject> bDescObjHandle_;\n\n  /// Marker created after initializing all fields so handles allocated later\n  /// can be flushed.\n  GCScope::Marker gcMarker_;\n\n public:\n  StandardSortModel(\n      Runtime &runtime,\n      Handle<JSObject> obj,\n      Handle<Callable> compareFn)\n      : runtime_(runtime),\n        gcScope_(runtime),\n        compareFn_(compareFn),\n        obj_(obj),\n        aTmpNameStorage_(runtime),\n        bTmpNameStorage_(runtime),\n        aHandle_(runtime),\n        bHandle_(runtime),\n        aValue_(runtime),\n        bValue_(runtime),\n        aDescObjHandle_(runtime),\n        bDescObjHandle_(runtime),\n        gcMarker_(gcScope_.createMarker()) {}\n\n  /// Use getComputed and putComputed to swap the values at obj[a] and obj[b].\n  ExecutionStatus swap(uint32_t a, uint32_t b) override {\n    // Ensure that we don't leave here with any new handles.\n    GCScopeMarkerRAII gcMarker{gcScope_, gcMarker_};\n\n    aHandle_ = HermesValue::encodeDoubleValue(a);\n    bHandle_ = HermesValue::encodeDoubleValue(b);\n\n    ComputedPropertyDescriptor aDesc;\n    JSObject::getComputedPrimitiveDescriptor(\n        obj_, runtime_, aHandle_, aDescObjHandle_, aTmpNameStorage_, aDesc);\n\n    ComputedPropertyDescriptor bDesc;\n    JSObject::getComputedPrimitiveDescriptor(\n        obj_, runtime_, bHandle_, bDescObjHandle_, bTmpNameStorage_, bDesc);\n\n    if (aDescObjHandle_) {\n      if (LLVM_LIKELY(!aDesc.flags.proxyObject)) {\n        auto res = JSObject::getComputedPropertyValue_RJS(\n            obj_,\n            runtime_,\n            aDescObjHandle_,\n            aTmpNameStorage_,\n            aDesc,\n            aDescObjHandle_);\n        if (res == ExecutionStatus::EXCEPTION) {\n          return ExecutionStatus::EXCEPTION;\n        }\n        if (LLVM_LIKELY(!(*res)->isEmpty())) {\n          aValue_ = std::move(*res);\n        }\n      } else {\n        auto keyRes = toPropertyKey(runtime_, aHandle_);\n        if (keyRes == ExecutionStatus::EXCEPTION) {\n          return ExecutionStatus::EXCEPTION;\n        }\n        aHandle_ = keyRes->get();\n        CallResult<bool> hasPropRes = JSProxy::getOwnProperty(\n            aDescObjHandle_, runtime_, aHandle_, aDesc, nullptr);\n        if (hasPropRes == ExecutionStatus::EXCEPTION) {\n          return ExecutionStatus::EXCEPTION;\n        }\n        if (*hasPropRes) {\n          auto res =\n              JSProxy::getComputed(aDescObjHandle_, runtime_, aHandle_, obj_);\n          if (res == ExecutionStatus::EXCEPTION) {\n            return ExecutionStatus::EXCEPTION;\n          }\n          aValue_ = std::move(*res);\n        } else {\n          aDescObjHandle_ = nullptr;\n        }\n      }\n    }\n    if (bDescObjHandle_) {\n      if (LLVM_LIKELY(!bDesc.flags.proxyObject)) {\n        auto res = JSObject::getComputedPropertyValue_RJS(\n            obj_,\n            runtime_,\n            bDescObjHandle_,\n            bTmpNameStorage_,\n            bDesc,\n            bDescObjHandle_);\n        if (res == ExecutionStatus::EXCEPTION) {\n          return ExecutionStatus::EXCEPTION;\n        }\n        if (LLVM_LIKELY(!(*res)->isEmpty())) {\n          bValue_ = std::move(*res);\n        }\n      } else {\n        auto keyRes = toPropertyKey(runtime_, bHandle_);\n        if (keyRes == ExecutionStatus::EXCEPTION) {\n          return ExecutionStatus::EXCEPTION;\n        }\n        bHandle_ = keyRes->get();\n        CallResult<bool> hasPropRes = JSProxy::getOwnProperty(\n            bDescObjHandle_, runtime_, bHandle_, bDesc, nullptr);\n        if (hasPropRes == ExecutionStatus::EXCEPTION) {\n          return ExecutionStatus::EXCEPTION;\n        }\n        if (*hasPropRes) {\n          auto res =\n              JSProxy::getComputed(bDescObjHandle_, runtime_, bHandle_, obj_);\n          if (res == ExecutionStatus::EXCEPTION) {\n            return ExecutionStatus::EXCEPTION;\n          }\n          bValue_ = std::move(*res);\n        } else {\n          bDescObjHandle_ = nullptr;\n        }\n      }\n    }\n\n    if (bDescObjHandle_) {\n      if (LLVM_UNLIKELY(\n              JSObject::putComputed_RJS(\n                  obj_,\n                  runtime_,\n                  aHandle_,\n                  bValue_,\n                  PropOpFlags().plusThrowOnError()) ==\n              ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n    } else {\n      if (LLVM_UNLIKELY(\n              JSObject::deleteComputed(\n                  obj_, runtime_, aHandle_, PropOpFlags().plusThrowOnError()) ==\n              ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n    }\n\n    if (aDescObjHandle_) {\n      if (LLVM_UNLIKELY(\n              JSObject::putComputed_RJS(\n                  obj_,\n                  runtime_,\n                  bHandle_,\n                  aValue_,\n                  PropOpFlags().plusThrowOnError()) ==\n              ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n    } else {\n      if (LLVM_UNLIKELY(\n              JSObject::deleteComputed(\n                  obj_, runtime_, bHandle_, PropOpFlags().plusThrowOnError()) ==\n              ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n    }\n\n    return ExecutionStatus::RETURNED;\n  }\n\n  /// If compareFn isn't null, return compareFn(obj[a], obj[b])\n  /// If compareFn is null, return -1 if obj[a] < obj[b], 1 if obj[a] > obj[b],\n  /// 0 otherwise\n  CallResult<int> compare(uint32_t a, uint32_t b) override {\n    // Ensure that we don't leave here with any new handles.\n    GCScopeMarkerRAII gcMarker{gcScope_, gcMarker_};\n\n    aHandle_ = HermesValue::encodeDoubleValue(a);\n    bHandle_ = HermesValue::encodeDoubleValue(b);\n\n    ComputedPropertyDescriptor aDesc;\n    JSObject::getComputedPrimitiveDescriptor(\n        obj_, runtime_, aHandle_, aDescObjHandle_, aTmpNameStorage_, aDesc);\n    CallResult<PseudoHandle<>> propRes = JSObject::getComputedPropertyValue_RJS(\n        obj_, runtime_, aDescObjHandle_, aTmpNameStorage_, aDesc, aHandle_);\n    if (propRes == ExecutionStatus::EXCEPTION) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    if ((*propRes)->isEmpty()) {\n      // Spec defines empty as greater than everything.\n      return 1;\n    }\n    aValue_ = std::move(*propRes);\n    assert(!aValue_->isEmpty());\n\n    ComputedPropertyDescriptor bDesc;\n    JSObject::getComputedPrimitiveDescriptor(\n        obj_, runtime_, bHandle_, bDescObjHandle_, bTmpNameStorage_, bDesc);\n    if ((propRes = JSObject::getComputedPropertyValue_RJS(\n             obj_,\n             runtime_,\n             bDescObjHandle_,\n             bTmpNameStorage_,\n             bDesc,\n             bHandle_)) == ExecutionStatus::EXCEPTION) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    if ((*propRes)->isEmpty()) {\n      // Spec defines empty as greater than everything.\n      return -1;\n    }\n    bValue_ = std::move(*propRes);\n    assert(!bValue_->isEmpty());\n\n    if (aValue_->isUndefined()) {\n      // Spec defines undefined as greater than everything.\n      return 1;\n    }\n    if (bValue_->isUndefined()) {\n      // Spec defines undefined as greater than everything.\n      return -1;\n    }\n\n    if (compareFn_) {\n      // If we have a compareFn, just use that.\n      auto callRes = Callable::executeCall2(\n          compareFn_,\n          runtime_,\n          Runtime::getUndefinedValue(),\n          aValue_.get(),\n          bValue_.get());\n      if (LLVM_UNLIKELY(callRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      auto intRes =\n          toNumber_RJS(runtime_, runtime_.makeHandle(std::move(*callRes)));\n      if (LLVM_UNLIKELY(intRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      // Cannot return intRes's value directly because it can be NaN\n      auto res = intRes->getNumber();\n      return (res < 0) ? -1 : (res > 0 ? 1 : 0);\n    } else {\n      // Convert both arguments to strings and compare\n      auto aValueRes = toString_RJS(runtime_, aValue_);\n      if (LLVM_UNLIKELY(aValueRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      aValue_ = aValueRes->getHermesValue();\n\n      auto bValueRes = toString_RJS(runtime_, bValue_);\n      if (LLVM_UNLIKELY(bValueRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      bValue_ = bValueRes->getHermesValue();\n\n      return aValue_->getString()->compare(bValue_->getString());\n    }\n  }\n};\n\n/// Perform a sort of a sparse object by querying its properties first.\n/// It cannot be a proxy or a host object because they are not guaranteed to\n/// be able to list their properties.\nCallResult<HermesValue> sortSparse(\n    Runtime &runtime,\n    Handle<JSObject> O,\n    Handle<Callable> compareFn,\n    uint64_t len) {\n  GCScope gcScope{runtime};\n\n  assert(\n      !O->isHostObject() && !O->isProxyObject() &&\n      \"only non-exotic objects can be sparsely sorted\");\n\n  // This is a \"non-fast\" object, meaning we need to create a symbol for every\n  // property name. On the assumption that it is sparse, get all properties\n  // first, so that we only have to read the existing properties.\n\n  auto crNames = JSObject::getOwnPropertyNames(O, runtime, false);\n  if (crNames == ExecutionStatus::EXCEPTION)\n    return ExecutionStatus::EXCEPTION;\n  // Get the underlying storage containing the names.\n  auto names = runtime.makeHandle((*crNames)->getIndexedStorage(runtime));\n  if (!names) {\n    // Indexed storage can be null if there's nothing to store.\n    return O.getHermesValue();\n  }\n\n  // Find out how many sortable numeric properties we have.\n  JSArray::StorageType::size_type numProps = 0;\n  for (JSArray::StorageType::size_type e = names->size(runtime); numProps != e;\n       ++numProps) {\n    SmallHermesValue hv = names->at(runtime, numProps);\n    // Stop at the first non-number.\n    if (!hv.isNumber())\n      break;\n    // Stop if the property name is beyond \"len\".\n    if (hv.getNumber(runtime) >= len)\n      break;\n  }\n\n  // If we didn't find any numeric properties, there is nothing to do.\n  if (numProps == 0)\n    return O.getHermesValue();\n\n  // Create a new array which we will actually sort.\n  auto crArray = JSArray::create(runtime, numProps, numProps);\n  if (crArray == ExecutionStatus::EXCEPTION)\n    return ExecutionStatus::EXCEPTION;\n  auto array = *crArray;\n  if (JSArray::setStorageEndIndex(array, runtime, numProps) ==\n      ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  MutableHandle<> propName{runtime};\n  MutableHandle<> propVal{runtime};\n  GCScopeMarkerRAII gcMarker{gcScope};\n\n  // Copy all sortable properties into the array and delete them from the\n  // source. Deleting all sortable properties makes it easy to just copy the\n  // sorted result back in the end.\n  for (decltype(numProps) i = 0; i != numProps; ++i) {\n    gcMarker.flush();\n\n    propName = names->at(runtime, i).unboxToHV(runtime);\n    auto res = JSObject::getComputed_RJS(O, runtime, propName);\n    if (res == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    // Skip empty values.\n    if (res->getHermesValue().isEmpty())\n      continue;\n\n    const auto shv = SmallHermesValue::encodeHermesValue(res->get(), runtime);\n    JSArray::unsafeSetExistingElementAt(*array, runtime, i, shv);\n\n    if (JSObject::deleteComputed(\n            O, runtime, propName, PropOpFlags().plusThrowOnError()) ==\n        ExecutionStatus::EXCEPTION) {\n      return ExecutionStatus::EXCEPTION;\n    }\n  }\n  gcMarker.flush();\n\n  {\n    StandardSortModel sm(runtime, array, compareFn);\n    if (LLVM_UNLIKELY(\n            quickSort(&sm, 0u, numProps) == ExecutionStatus::EXCEPTION))\n      return ExecutionStatus::EXCEPTION;\n  }\n\n  // Time to copy back the values.\n  for (decltype(numProps) i = 0; i != numProps; ++i) {\n    gcMarker.flush();\n\n    auto hv = array->at(runtime, i).unboxToHV(runtime);\n    assert(\n        !hv.isEmpty() &&\n        \"empty values cannot appear in the array out of nowhere\");\n    propVal = hv;\n\n    propName = HermesValue::encodeNumberValue(i);\n\n    if (JSObject::putComputed_RJS(\n            O, runtime, propName, propVal, PropOpFlags().plusThrowOnError()) ==\n        ExecutionStatus::EXCEPTION) {\n      return ExecutionStatus::EXCEPTION;\n    }\n  }\n\n  return O.getHermesValue();\n}\n} // anonymous namespace\n\n/// ES5.1 15.4.4.11.\nCallResult<HermesValue>\narrayPrototypeSort(void *, Runtime &runtime, NativeArgs args) {\n  // Null if not a callable compareFn.\n  auto compareFn = Handle<Callable>::dyn_vmcast(args.getArgHandle(0));\n  if (!args.getArg(0).isUndefined() && !compareFn) {\n    return runtime.raiseTypeError(\"Array sort argument must be callable\");\n  }\n\n  auto objRes = toObject(runtime, args.getThisHandle());\n  if (LLVM_UNLIKELY(objRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto O = runtime.makeHandle<JSObject>(objRes.getValue());\n\n  auto propRes = JSObject::getNamed_RJS(\n      O, runtime, Predefined::getSymbolID(Predefined::length));\n  if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto intRes = toLengthU64(runtime, runtime.makeHandle(std::move(*propRes)));\n  if (LLVM_UNLIKELY(intRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  uint64_t len = *intRes;\n\n  // If we are not sorting a regular dense array, use a special routine which\n  // first copies all properties into an array.\n  // Proxies  and host objects however are excluded because they are weird.\n  if (!O->isProxyObject() && !O->isHostObject() && !O->hasFastIndexProperties())\n    return sortSparse(runtime, O, compareFn, len);\n\n  // This is the \"fast\" path. We are sorting an array with indexed storage.\n  StandardSortModel sm(runtime, O, compareFn);\n\n  // Use our custom sort routine. We can't use std::sort because it performs\n  // optimizations that allow it to bypass calls to std::swap, but our swap\n  // function is special, since it needs to use the internal Object functions.\n  if (LLVM_UNLIKELY(quickSort(&sm, 0u, len) == ExecutionStatus::EXCEPTION))\n    return ExecutionStatus::EXCEPTION;\n\n  return O.getHermesValue();\n}\n\ninline CallResult<HermesValue>\narrayPrototypeForEach(void *, Runtime &runtime, NativeArgs args) {\n  GCScope gcScope(runtime);\n  auto objRes = toObject(runtime, args.getThisHandle());\n  if (LLVM_UNLIKELY(objRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto O = runtime.makeHandle<JSObject>(objRes.getValue());\n\n  auto propRes = JSObject::getNamed_RJS(\n      O, runtime, Predefined::getSymbolID(Predefined::length));\n  if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto intRes = toLengthU64(runtime, runtime.makeHandle(std::move(*propRes)));\n  if (LLVM_UNLIKELY(intRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  uint64_t len = *intRes;\n\n  auto callbackFn = args.dyncastArg<Callable>(0);\n  if (!callbackFn) {\n    return runtime.raiseTypeError(\n        \"Array.prototype.forEach() requires a callable argument\");\n  }\n\n  // Index to execute the callback on.\n  MutableHandle<> k{runtime, HermesValue::encodeDoubleValue(0)};\n\n  MutableHandle<JSObject> descObjHandle{runtime};\n  MutableHandle<SymbolID> tmpPropNameStorage{runtime};\n\n  // Loop through and execute the callback on all existing values.\n  // TODO: Implement a fast path for actual arrays.\n  auto marker = gcScope.createMarker();\n  while (k->getDouble() < len) {\n    gcScope.flushToMarker(marker);\n\n    ComputedPropertyDescriptor desc;\n    JSObject::getComputedPrimitiveDescriptor(\n        O, runtime, k, descObjHandle, tmpPropNameStorage, desc);\n    CallResult<PseudoHandle<>> propRes = JSObject::getComputedPropertyValue_RJS(\n        O, runtime, descObjHandle, tmpPropNameStorage, desc, k);\n    if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    if (LLVM_LIKELY(!(*propRes)->isEmpty())) {\n      auto kValue = std::move(*propRes);\n      if (LLVM_UNLIKELY(\n              Callable::executeCall3(\n                  callbackFn,\n                  runtime,\n                  args.getArgHandle(1),\n                  kValue.get(),\n                  k.get(),\n                  O.getHermesValue()) == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n    }\n\n    k = HermesValue::encodeDoubleValue(k->getDouble() + 1);\n  }\n\n  return HermesValue::encodeUndefinedValue();\n}\n\n/// ES10 22.1.3.10.1 FlattenIntoArray\n/// mapperFunction may be null to signify its absence.\n/// If mapperFunction is null, thisArg is ignored.\nstatic CallResult<uint64_t> flattenIntoArray(\n    Runtime &runtime,\n    Handle<JSArray> target,\n    Handle<JSObject> source,\n    uint64_t sourceLen,\n    uint64_t start,\n    double depth,\n    Handle<Callable> mapperFunction,\n    Handle<> thisArg) {\n  ScopedNativeDepthTracker depthTracker{runtime};\n  if (LLVM_UNLIKELY(depthTracker.overflowed())) {\n    return runtime.raiseStackOverflow(Runtime::StackOverflowKind::NativeStack);\n  }\n\n  if (!mapperFunction) {\n    assert(\n        thisArg->isUndefined() &&\n        \"thisArg must be undefined if there is no mapper\");\n  }\n\n  GCScope gcScope{runtime};\n  // 1. Let targetIndex be start.\n  uint64_t targetIndex = start;\n  // 2. Let sourceIndex be 0.\n  uint64_t sourceIndex = 0;\n\n  // Temporary storage for sourceIndex and targetIndex.\n  MutableHandle<> indexHandle{runtime};\n  MutableHandle<SymbolID> tmpPropNameStorage{runtime};\n  MutableHandle<JSObject> propObj{runtime};\n  MutableHandle<> element{runtime};\n  MutableHandle<> lenResHandle{runtime};\n\n  auto marker = gcScope.createMarker();\n\n  // 3. Repeat, while sourceIndex < sourceLen\n  while (sourceIndex < sourceLen) {\n    gcScope.flushToMarker(marker);\n\n    // a. Let P be ! ToString(sourceIndex).\n    // b. Let exists be ? HasProperty(source, P).\n    ComputedPropertyDescriptor desc{};\n    indexHandle = HermesValue::encodeNumberValue(sourceIndex);\n    if (LLVM_UNLIKELY(\n            JSObject::getComputedDescriptor(\n                source,\n                runtime,\n                indexHandle,\n                propObj,\n                tmpPropNameStorage,\n                desc) == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    // c. If exists is true, then\n    // i. Let element be ? Get(source, P).\n    CallResult<PseudoHandle<>> elementRes =\n        JSObject::getComputedPropertyValue_RJS(\n            source, runtime, propObj, tmpPropNameStorage, desc, indexHandle);\n    if (LLVM_UNLIKELY(elementRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    if (LLVM_LIKELY(!(*elementRes)->isEmpty())) {\n      element = std::move(*elementRes);\n\n      // ii. If mapperFunction is present, then\n      if (mapperFunction) {\n        // 1. Assert: thisArg is present.\n        assert(!thisArg->isEmpty() && \"mapperFunction requires a thisArg\");\n        // 2. Set element to ? Call(mapperFunction, thisArg ,  element,\n        // sourceIndex, source ).\n        elementRes = Callable::executeCall3(\n            mapperFunction,\n            runtime,\n            thisArg,\n            element.getHermesValue(),\n            HermesValue::encodeNumberValue(sourceIndex),\n            source.getHermesValue());\n        if (LLVM_UNLIKELY(elementRes == ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n        element = std::move(*elementRes);\n      }\n      // iii. Let shouldFlatten be false.\n      bool shouldFlatten = false;\n      if (depth > 0) {\n        // iv. If depth > 0, then\n        // 1. Set shouldFlatten to ? IsArray(element).\n        // NOTE: isArray accepts nullptr for the obj argument.\n        CallResult<bool> shouldFlattenRes =\n            isArray(runtime, dyn_vmcast<JSObject>(element.get()));\n        if (LLVM_UNLIKELY(shouldFlattenRes == ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n        shouldFlatten = *shouldFlattenRes;\n      }\n      if (shouldFlatten) {\n        // It is valid to cast `element` to JSObject because shouldFlatten is\n        // only true when `isArray(element)` is true.\n        // v. If shouldFlatten is true, then\n        // 1. Let elementLen be ? ToLength(? Get(element, \"length\")).\n        CallResult<PseudoHandle<>> lenRes = JSObject::getNamed_RJS(\n            Handle<JSObject>::vmcast(element),\n            runtime,\n            Predefined::getSymbolID(Predefined::length));\n        if (LLVM_UNLIKELY(lenRes == ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n        lenResHandle = std::move(*lenRes);\n        CallResult<uint64_t> elementLenRes = toLengthU64(runtime, lenResHandle);\n        if (LLVM_UNLIKELY(elementLenRes == ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n        uint64_t elementLen = *elementLenRes;\n        // 2. Set targetIndex to ? FlattenIntoArray(target, element, elementLen,\n        // targetIndex, depth - 1).\n        CallResult<uint64_t> targetIndexRes = flattenIntoArray(\n            runtime,\n            target,\n            Handle<JSObject>::vmcast(element),\n            elementLen,\n            targetIndex,\n            depth - 1,\n            runtime.makeNullHandle<Callable>(),\n            runtime.getUndefinedValue());\n        if (LLVM_UNLIKELY(targetIndexRes == ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n        targetIndex = *targetIndexRes;\n      } else {\n        // vi. Else,\n        // 1. If targetIndex  2**53-1, throw a TypeError exception.\n        if (targetIndex >= ((uint64_t)1 << 53) - 1) {\n          return runtime.raiseTypeError(\"flattened array exceeds length limit\");\n        }\n        // 2. Perform ? CreateDataPropertyOrThrow(\n        //                target, !ToString(targetIndex), element).\n        indexHandle = HermesValue::encodeNumberValue(targetIndex);\n        if (LLVM_UNLIKELY(\n                JSObject::defineOwnComputed(\n                    target,\n                    runtime,\n                    indexHandle,\n                    DefinePropertyFlags::getDefaultNewPropertyFlags(),\n                    element,\n                    PropOpFlags().plusThrowOnError()) ==\n                ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n\n        // 3. Increase targetIndex by 1.\n        ++targetIndex;\n      }\n    }\n    // d. Increase sourceIndex by 1.\n    ++sourceIndex;\n  }\n  // 4. Return targetIndex.\n  return targetIndex;\n}\n\nCallResult<HermesValue>\narrayPrototypeFlat(void *ctx, Runtime &runtime, NativeArgs args) {\n  // 1. Let O be ? ToObject(this value).\n  CallResult<HermesValue> ORes = toObject(runtime, args.getThisHandle());\n  if (LLVM_UNLIKELY(ORes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto O = runtime.makeHandle<JSObject>(*ORes);\n\n  // 2. Let sourceLen be ? ToLength(? Get(O, \"length\")).\n  CallResult<PseudoHandle<>> lenRes = JSObject::getNamed_RJS(\n      O, runtime, Predefined::getSymbolID(Predefined::length));\n  if (LLVM_UNLIKELY(lenRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  CallResult<uint64_t> sourceLenRes =\n      toLengthU64(runtime, runtime.makeHandle(std::move(*lenRes)));\n  if (LLVM_UNLIKELY(sourceLenRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  uint64_t sourceLen = *sourceLenRes;\n\n  // 3. Let depthNum be 1.\n  double depthNum = 1;\n  if (!args.getArg(0).isUndefined()) {\n    // 4. If depth is not undefined, then\n    // a.     Set depthNum to ? ToIntegerOrInfinity(depth).\n    auto depthNumRes = toIntegerOrInfinity(runtime, args.getArgHandle(0));\n    if (LLVM_UNLIKELY(depthNumRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    depthNum = depthNumRes->getNumber();\n  }\n  // 5. Let A be ? ArraySpeciesCreate(O, 0).\n  auto ARes = JSArray::create(runtime, 0, 0);\n  if (LLVM_UNLIKELY(ARes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto A = *ARes;\n\n  // 6. Perform ? FlattenIntoArray(A, O, sourceLen, 0, depthNum).\n  if (LLVM_UNLIKELY(\n          flattenIntoArray(\n              runtime,\n              A,\n              O,\n              sourceLen,\n              0,\n              depthNum,\n              runtime.makeNullHandle<Callable>(),\n              runtime.getUndefinedValue()) == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  // 7. Return A.\n  return A.getHermesValue();\n}\n\nCallResult<HermesValue>\narrayPrototypeFlatMap(void *ctx, Runtime &runtime, NativeArgs args) {\n  // 1. Let O be ? ToObject(this value).\n  CallResult<HermesValue> ORes = toObject(runtime, args.getThisHandle());\n  if (LLVM_UNLIKELY(ORes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto O = runtime.makeHandle<JSObject>(*ORes);\n\n  // 2. Let sourceLen be ? ToLength(? Get(O, \"length\")).\n  CallResult<PseudoHandle<>> lenRes = JSObject::getNamed_RJS(\n      O, runtime, Predefined::getSymbolID(Predefined::length));\n  if (LLVM_UNLIKELY(lenRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  CallResult<uint64_t> sourceLenRes =\n      toLengthU64(runtime, runtime.makeHandle(std::move(*lenRes)));\n  if (LLVM_UNLIKELY(sourceLenRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  uint64_t sourceLen = *sourceLenRes;\n\n  // 3. If IsCallable(mapperFunction) is false, throw a TypeError exception.\n  Handle<Callable> mapperFunction = args.dyncastArg<Callable>(0);\n  if (!mapperFunction) {\n    return runtime.raiseTypeError(\"flatMap mapper must be callable\");\n  }\n  // 4. If thisArg is present, let T be thisArg; else let T be undefined.\n  auto T = args.getArgHandle(1);\n  // 5. Let A be ? ArraySpeciesCreate(O, 0).\n  auto ARes = JSArray::create(runtime, 0, 0);\n  if (LLVM_UNLIKELY(ARes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto A = *ARes;\n\n  // 6. Perform ? FlattenIntoArray(A, O, sourceLen, 0, 1, mapperFunction, T).\n  if (LLVM_UNLIKELY(\n          flattenIntoArray(runtime, A, O, sourceLen, 0, 1, mapperFunction, T) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  // 7. Return A.\n  return A.getHermesValue();\n}\n\nCallResult<HermesValue>\narrayPrototypeIterator(void *ctx, Runtime &runtime, NativeArgs args) {\n  IterationKind kind = *reinterpret_cast<IterationKind *>(&ctx);\n  assert(\n      kind < IterationKind::NumKinds &&\n      \"arrayPrototypeIterator with wrong kind\");\n  auto objRes = toObject(runtime, args.getThisHandle());\n  if (LLVM_UNLIKELY(objRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto obj = runtime.makeHandle<JSObject>(*objRes);\n  return JSArrayIterator::create(runtime, obj, kind).getHermesValue();\n}\n\nCallResult<HermesValue>\narrayPrototypeSlice(void *, Runtime &runtime, NativeArgs args) {\n  GCScope gcScope(runtime);\n  auto objRes = toObject(runtime, args.getThisHandle());\n  if (LLVM_UNLIKELY(objRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto O = runtime.makeHandle<JSObject>(objRes.getValue());\n\n  auto propRes = JSObject::getNamed_RJS(\n      O, runtime, Predefined::getSymbolID(Predefined::length));\n  if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto lenRes = toLengthU64(runtime, runtime.makeHandle(std::move(*propRes)));\n  if (LLVM_UNLIKELY(lenRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  double len = *lenRes;\n\n  auto intRes = toIntegerOrInfinity(runtime, args.getArgHandle(0));\n  if (LLVM_UNLIKELY(intRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  // Start index. If negative, then offset from the right side of the array.\n  double relativeStart = intRes->getNumber();\n  // Index that we're currently copying from.\n  // Starts at the actual start value, computed from relativeStart.\n  MutableHandle<> k{\n      runtime,\n      HermesValue::encodeDoubleValue(\n          relativeStart < 0 ? std::max(len + relativeStart, 0.0)\n                            : std::min(relativeStart, len))};\n\n  // End index. If negative, then offset from the right side of the array.\n  double relativeEnd;\n  if (args.getArg(1).isUndefined()) {\n    relativeEnd = len;\n  } else {\n    if (LLVM_UNLIKELY(\n            (intRes = toIntegerOrInfinity(runtime, args.getArgHandle(1))) ==\n            ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    relativeEnd = intRes->getNumber();\n  }\n  // Actual end index.\n  double fin = relativeEnd < 0 ? std::max(len + relativeEnd, 0.0)\n                               : std::min(relativeEnd, len);\n\n  // Create the result array.\n  double count = std::max(fin - k->getNumber(), 0.0);\n  if (LLVM_UNLIKELY(count > JSArray::StorageType::maxElements())) {\n    return runtime.raiseRangeError(\"Out of memory for array elements.\");\n  }\n  auto arrRes = JSArray::create(runtime, count, count);\n  if (LLVM_UNLIKELY(arrRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto A = *arrRes;\n\n  // Next index in A to write to.\n  uint32_t n = 0;\n\n  MutableHandle<JSObject> descObjHandle{runtime};\n  MutableHandle<SymbolID> tmpPropNameStorage{runtime};\n  MutableHandle<> kValue{runtime};\n  auto marker = gcScope.createMarker();\n\n  // Copy the elements between the actual start and end indices into A.\n  // TODO: Implement a fast path for actual arrays.\n  while (k->getNumber() < fin) {\n    ComputedPropertyDescriptor desc;\n    JSObject::getComputedPrimitiveDescriptor(\n        O, runtime, k, descObjHandle, tmpPropNameStorage, desc);\n    CallResult<PseudoHandle<>> propRes = JSObject::getComputedPropertyValue_RJS(\n        O, runtime, descObjHandle, tmpPropNameStorage, desc, k);\n    if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    if (LLVM_LIKELY(!(*propRes)->isEmpty())) {\n      kValue = std::move(*propRes);\n      JSArray::setElementAt(A, runtime, n, kValue);\n    }\n    k = HermesValue::encodeDoubleValue(k->getNumber() + 1);\n    ++n;\n\n    gcScope.flushToMarker(marker);\n  }\n\n  if (LLVM_UNLIKELY(\n          JSArray::setLengthProperty(A, runtime, n) ==\n          ExecutionStatus::EXCEPTION))\n    return ExecutionStatus::EXCEPTION;\n  return A.getHermesValue();\n}\n\nCallResult<HermesValue>\narrayPrototypeSplice(void *, Runtime &runtime, NativeArgs args) {\n  GCScope gcScope(runtime);\n  auto objRes = toObject(runtime, args.getThisHandle());\n  if (LLVM_UNLIKELY(objRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto O = runtime.makeHandle<JSObject>(objRes.getValue());\n\n  auto propRes = JSObject::getNamed_RJS(\n      O, runtime, Predefined::getSymbolID(Predefined::length));\n  if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto lenRes = toLengthU64(runtime, runtime.makeHandle(std::move(*propRes)));\n  if (LLVM_UNLIKELY(lenRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  double len = *lenRes;\n\n  auto intRes = toIntegerOrInfinity(runtime, args.getArgHandle(0));\n  if (LLVM_UNLIKELY(intRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  double relativeStart = intRes->getNumber();\n  // Index to start the deletion/insertion at.\n  double actualStart = relativeStart < 0 ? std::max(len + relativeStart, 0.0)\n                                         : std::min(relativeStart, len);\n\n  // Implement the newer calculation of actualDeleteCount (ES6.0),\n  // since 5.1 doesn't define behavior for less than 2 arguments.\n  uint32_t argCount = args.getArgCount();\n  uint64_t actualDeleteCount;\n  uint64_t insertCount;\n  switch (argCount) {\n    case 0:\n      insertCount = 0;\n      actualDeleteCount = 0;\n      break;\n    case 1:\n      // If just one argument specified, delete everything until the end.\n      insertCount = 0;\n      actualDeleteCount = len - actualStart;\n      break;\n    default:\n      // Otherwise, use the specified delete count.\n      if (LLVM_UNLIKELY(\n              (intRes = toIntegerOrInfinity(runtime, args.getArgHandle(1))) ==\n              ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      insertCount = argCount - 2;\n      actualDeleteCount =\n          std::min(std::max(intRes->getNumber(), 0.0), len - actualStart);\n  }\n\n  // If len+insertCountactualDeleteCount > 2^53-1, throw a TypeError exception.\n  // Checks for overflow as well.\n  auto lenAfterInsert = len + insertCount;\n  if (LLVM_UNLIKELY(\n          lenAfterInsert < len ||\n          lenAfterInsert - actualDeleteCount > (1LLU << 53) - 1)) {\n    return runtime.raiseTypeError(\"Array.prototype.splice result out of space\");\n  }\n\n  // Let A be ? ArraySpeciesCreate(O, actualDeleteCount).\n  if (LLVM_UNLIKELY(actualDeleteCount > JSArray::StorageType::maxElements())) {\n    return runtime.raiseRangeError(\"Out of memory for array elements.\");\n  }\n  auto arrRes = JSArray::create(runtime, actualDeleteCount, actualDeleteCount);\n  if (LLVM_UNLIKELY(arrRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto A = *arrRes;\n\n  // Indices used for various copies in loops below.\n  MutableHandle<> from{runtime};\n  MutableHandle<> to{runtime};\n\n  // Value storage used for copying values.\n  MutableHandle<SymbolID> tmpPropNameStorage{runtime};\n  MutableHandle<JSObject> fromDescObjHandle{runtime};\n  MutableHandle<> fromValue{runtime};\n\n  MutableHandle<> i{runtime};\n  MutableHandle<> k{runtime};\n\n  auto gcMarker = gcScope.createMarker();\n\n  {\n    // Copy actualDeleteCount elements to A, starting at actualStart.\n    // TODO: Add a fast path for actual arrays.\n    for (uint32_t j = 0; j < actualDeleteCount; ++j) {\n      from = HermesValue::encodeDoubleValue(actualStart + j);\n\n      ComputedPropertyDescriptor fromDesc;\n      JSObject::getComputedPrimitiveDescriptor(\n          O, runtime, from, fromDescObjHandle, tmpPropNameStorage, fromDesc);\n      CallResult<PseudoHandle<>> propRes =\n          JSObject::getComputedPropertyValue_RJS(\n              O,\n              runtime,\n              fromDescObjHandle,\n              tmpPropNameStorage,\n              fromDesc,\n              from);\n      if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      if (LLVM_LIKELY(!(*propRes)->isEmpty())) {\n        fromValue = std::move(*propRes);\n        JSArray::setElementAt(A, runtime, j, fromValue);\n      }\n\n      gcScope.flushToMarker(gcMarker);\n    }\n\n    if (LLVM_UNLIKELY(\n            JSArray::setLengthProperty(A, runtime, actualDeleteCount) ==\n            ExecutionStatus::EXCEPTION))\n      return ExecutionStatus::EXCEPTION;\n  }\n\n  // Perform ? Set(A, \"length\", actualDeleteCount, true).\n  if (LLVM_UNLIKELY(\n          JSObject::putNamed_RJS(\n              A,\n              runtime,\n              Predefined::getSymbolID(Predefined::length),\n              runtime.makeHandle(\n                  HermesValue::encodeNumberValue(actualDeleteCount)),\n              PropOpFlags().plusThrowOnError()) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  // Number of new items to add to the array.\n  uint32_t itemCount = args.getArgCount() > 2 ? args.getArgCount() - 2 : 0;\n\n  if (itemCount < actualDeleteCount) {\n    // Inserting less items than deleting.\n\n    // Copy items from (k + actualDeleteCount) to (k + itemCount).\n    // This leaves itemCount spaces to copy the arguments into.\n    // TODO: Add a fast path for actual arrays.\n    for (double j = actualStart; j < len - actualDeleteCount; ++j) {\n      from = HermesValue::encodeDoubleValue(j + actualDeleteCount);\n      to = HermesValue::encodeDoubleValue(j + itemCount);\n      ComputedPropertyDescriptor fromDesc;\n      JSObject::getComputedPrimitiveDescriptor(\n          O, runtime, from, fromDescObjHandle, tmpPropNameStorage, fromDesc);\n      CallResult<PseudoHandle<>> propRes =\n          JSObject::getComputedPropertyValue_RJS(\n              O,\n              runtime,\n              fromDescObjHandle,\n              tmpPropNameStorage,\n              fromDesc,\n              from);\n      if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      if (LLVM_LIKELY(!(*propRes)->isEmpty())) {\n        fromValue = std::move(*propRes);\n        if (LLVM_UNLIKELY(\n                JSObject::putComputed_RJS(\n                    O,\n                    runtime,\n                    to,\n                    fromValue,\n                    PropOpFlags().plusThrowOnError()) ==\n                ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n      } else {\n        if (LLVM_UNLIKELY(\n                JSObject::deleteComputed(\n                    O, runtime, to, PropOpFlags().plusThrowOnError()) ==\n                ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n      }\n\n      gcScope.flushToMarker(gcMarker);\n    }\n\n    // Use i here to refer to (k-1) in the spec, and reindex the loop.\n    i = HermesValue::encodeDoubleValue(len - 1);\n\n    // Delete the remaining elements from the right that we didn't copy into.\n    // TODO: Add a fast path for actual arrays.\n    while (i->getNumber() > len - actualDeleteCount + itemCount - 1) {\n      if (LLVM_UNLIKELY(\n              JSObject::deleteComputed(\n                  O, runtime, i, PropOpFlags().plusThrowOnError()) ==\n              ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      i = HermesValue::encodeDoubleValue(i->getDouble() - 1);\n      gcScope.flushToMarker(gcMarker);\n    }\n  } else if (itemCount > actualDeleteCount) {\n    // Inserting more items than deleting.\n\n    // Start from the right, and copy elements to the right.\n    // This makes space to insert the elements from the arguments.\n    // TODO: Add a fast path for actual arrays.\n    for (double j = len - actualDeleteCount; j > actualStart; --j) {\n      from = HermesValue::encodeDoubleValue(j + actualDeleteCount - 1);\n      to = HermesValue::encodeDoubleValue(j + itemCount - 1);\n\n      ComputedPropertyDescriptor fromDesc;\n      JSObject::getComputedPrimitiveDescriptor(\n          O, runtime, from, fromDescObjHandle, tmpPropNameStorage, fromDesc);\n      CallResult<PseudoHandle<>> propRes =\n          JSObject::getComputedPropertyValue_RJS(\n              O,\n              runtime,\n              fromDescObjHandle,\n              tmpPropNameStorage,\n              fromDesc,\n              from);\n      if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      if (LLVM_LIKELY(!(*propRes)->isEmpty())) {\n        fromValue = std::move(*propRes);\n        if (LLVM_UNLIKELY(\n                JSObject::putComputed_RJS(\n                    O,\n                    runtime,\n                    to,\n                    fromValue,\n                    PropOpFlags().plusThrowOnError()) ==\n                ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n      } else {\n        // fromPresent is false\n        if (LLVM_UNLIKELY(\n                JSObject::deleteComputed(\n                    O, runtime, to, PropOpFlags().plusThrowOnError()) ==\n                ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n      }\n\n      gcScope.flushToMarker(gcMarker);\n    }\n  }\n\n  {\n    // Finally, just copy the elements from the args into the array.\n    // TODO: Add a fast path for actual arrays.\n    k = HermesValue::encodeDoubleValue(actualStart);\n    for (size_t j = 2; j < argCount; ++j) {\n      if (LLVM_UNLIKELY(\n              JSObject::putComputed_RJS(\n                  O,\n                  runtime,\n                  k,\n                  args.getArgHandle(j),\n                  PropOpFlags().plusThrowOnError()) ==\n              ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      k = HermesValue::encodeDoubleValue(k->getDouble() + 1);\n      gcScope.flushToMarker(gcMarker);\n    }\n  }\n\n  if (LLVM_UNLIKELY(\n          JSObject::putNamed_RJS(\n              O,\n              runtime,\n              Predefined::getSymbolID(Predefined::length),\n              runtime.makeHandle(HermesValue::encodeDoubleValue(\n                  len - actualDeleteCount + itemCount)),\n              PropOpFlags().plusThrowOnError()) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  return A.getHermesValue();\n}\n\nCallResult<HermesValue>\narrayPrototypeCopyWithin(void *, Runtime &runtime, NativeArgs args) {\n  GCScope gcScope{runtime};\n\n  // 1. Let O be ToObject(this value).\n  // 2. ReturnIfAbrupt(O).\n  auto oRes = toObject(runtime, args.getThisHandle());\n  if (LLVM_UNLIKELY(oRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto O = runtime.makeHandle<JSObject>(*oRes);\n\n  // 3. Let len be ToLength(Get(O, \"length\")).\n  // 4. ReturnIfAbrupt(len).\n  // Use doubles for all lengths and indices to allow for proper Infinity\n  // handling, because ToInteger may return Infinity and we must do double\n  // arithmetic.\n  auto propRes = JSObject::getNamed_RJS(\n      O, runtime, Predefined::getSymbolID(Predefined::length));\n  if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto lenRes = toLengthU64(runtime, runtime.makeHandle(std::move(*propRes)));\n  if (LLVM_UNLIKELY(lenRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  double len = *lenRes;\n\n  // 5. Let relativeTarget be ToIntegerOrInfinity(target).\n  // 6. ReturnIfAbrupt(relativeTarget).\n  auto relativeTargetRes = toIntegerOrInfinity(runtime, args.getArgHandle(0));\n  if (LLVM_UNLIKELY(relativeTargetRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  double relativeTarget = relativeTargetRes->getNumber();\n\n  // 7. If relativeTarget < 0, let to be max((len + relativeTarget),0); else let\n  // to be min(relativeTarget, len).\n  double to = relativeTarget < 0 ? std::max((len + relativeTarget), (double)0)\n                                 : std::min(relativeTarget, len);\n\n  // 8. Let relativeStart be ToIntegerOrInfinity(start).\n  // 9. ReturnIfAbrupt(relativeStart).\n  auto relativeStartRes = toIntegerOrInfinity(runtime, args.getArgHandle(1));\n  if (LLVM_UNLIKELY(relativeStartRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  double relativeStart = relativeStartRes->getNumber();\n\n  // 10. If relativeStart < 0, let from be max((len + relativeStart),0); else\n  // let from be min(relativeStart, len).\n  double from = relativeStart < 0 ? std::max((len + relativeStart), (double)0)\n                                  : std::min(relativeStart, len);\n\n  // 11. If end is undefined, let relativeEnd be len; else let relativeEnd be\n  // ToIntegerOrInfinity(end).\n  // 12. ReturnIfAbrupt(relativeEnd).\n  double relativeEnd;\n  if (args.getArg(2).isUndefined()) {\n    relativeEnd = len;\n  } else {\n    auto relativeEndRes = toIntegerOrInfinity(runtime, args.getArgHandle(2));\n    if (LLVM_UNLIKELY(relativeEndRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    relativeEnd = relativeEndRes->getNumber();\n  }\n\n  // 13. If relativeEnd < 0, let final be max((len + relativeEnd),0); else let\n  // final be min(relativeEnd, len).\n  double fin = relativeEnd < 0 ? std::max((len + relativeEnd), (double)0)\n                               : std::min(relativeEnd, len);\n\n  // 14. Let count be min(final-from, len-to).\n  double count = std::min(fin - from, len - to);\n\n  int direction;\n  if (from < to && to < from + count) {\n    // 15. If from<to and to<from+count\n    // a. Let direction be -1.\n    direction = -1;\n    // b. Let from be from + count -1.\n    from = from + count - 1;\n    // c. Let to be to + count -1.\n    to = to + count - 1;\n  } else {\n    // 16. Else,\n    // a. Let direction = 1.\n    direction = 1;\n  }\n\n  MutableHandle<> fromHandle{runtime, HermesValue::encodeNumberValue(from)};\n  MutableHandle<> toHandle{runtime, HermesValue::encodeNumberValue(to)};\n\n  MutableHandle<SymbolID> fromNameTmpStorage{runtime};\n  MutableHandle<JSObject> fromObj{runtime};\n  MutableHandle<> fromVal{runtime};\n\n  GCScopeMarkerRAII marker{gcScope};\n  for (; count > 0; marker.flush()) {\n    // 17. Repeat, while count > 0\n    // a. Let fromKey be ToString(from).\n    // b. Let toKey be ToString(to).\n\n    // c. Let fromPresent be HasProperty(O, fromKey).\n    // d. ReturnIfAbrupt(fromPresent).\n    ComputedPropertyDescriptor fromDesc;\n    if (LLVM_UNLIKELY(\n            JSObject::getComputedDescriptor(\n                O,\n                runtime,\n                fromHandle,\n                fromObj,\n                fromNameTmpStorage,\n                fromDesc) == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    CallResult<PseudoHandle<>> fromValRes =\n        JSObject::getComputedPropertyValue_RJS(\n            O, runtime, fromObj, fromNameTmpStorage, fromDesc, fromHandle);\n    if (LLVM_UNLIKELY(fromValRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    // e. If fromPresent is true, then\n    if (LLVM_LIKELY(!(*fromValRes)->isEmpty())) {\n      // i. Let fromVal be Get(O, fromKey).\n      // ii. ReturnIfAbrupt(fromVal).\n      fromVal = std::move(*fromValRes);\n\n      // iii. Let setStatus be Set(O, toKey, fromVal, true).\n      // iv. ReturnIfAbrupt(setStatus).\n      if (LLVM_UNLIKELY(\n              JSObject::putComputed_RJS(\n                  O,\n                  runtime,\n                  toHandle,\n                  fromVal,\n                  PropOpFlags().plusThrowOnError()) ==\n              ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n    } else {\n      // f. Else fromPresent is false,\n      // i. Let deleteStatus be DeletePropertyOrThrow(O, toKey).\n      // ii. ReturnIfAbrupt(deleteStatus).\n      if (LLVM_UNLIKELY(\n              JSObject::deleteComputed(\n                  O, runtime, toHandle, PropOpFlags().plusThrowOnError()) ==\n              ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n    }\n\n    // g. Let from be from + direction.\n    fromHandle =\n        HermesValue::encodeNumberValue(fromHandle->getNumber() + direction);\n    // h. Let to be to + direction.\n    toHandle =\n        HermesValue::encodeNumberValue(toHandle->getNumber() + direction);\n\n    // i. Let count be count  1.\n    --count;\n  }\n  // 18. Return O.\n  return O.getHermesValue();\n}\n\nCallResult<HermesValue>\narrayPrototypePop(void *, Runtime &runtime, NativeArgs args) {\n  GCScope gcScope(runtime);\n  auto res = toObject(runtime, args.getThisHandle());\n  if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto O = runtime.makeHandle<JSObject>(res.getValue());\n\n  auto propRes = JSObject::getNamed_RJS(\n      O, runtime, Predefined::getSymbolID(Predefined::length));\n  if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto intRes = toLengthU64(runtime, runtime.makeHandle(std::move(*propRes)));\n  if (LLVM_UNLIKELY(intRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  uint64_t len = *intRes;\n\n  if (len == 0) {\n    if (LLVM_UNLIKELY(\n            JSObject::putNamed_RJS(\n                O,\n                runtime,\n                Predefined::getSymbolID(Predefined::length),\n                runtime.makeHandle(HermesValue::encodeDoubleValue(0)),\n                PropOpFlags().plusThrowOnError()) ==\n            ExecutionStatus::EXCEPTION))\n      return ExecutionStatus::EXCEPTION;\n    return HermesValue::encodeUndefinedValue();\n  }\n\n  auto idxVal = runtime.makeHandle(HermesValue::encodeDoubleValue(len - 1));\n  if (LLVM_UNLIKELY(\n          (propRes = JSObject::getComputed_RJS(O, runtime, idxVal)) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto element = runtime.makeHandle(std::move(*propRes));\n  if (LLVM_UNLIKELY(\n          JSObject::deleteComputed(\n              O, runtime, idxVal, PropOpFlags().plusThrowOnError()) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  if (LLVM_UNLIKELY(\n          JSObject::putNamed_RJS(\n              O,\n              runtime,\n              Predefined::getSymbolID(Predefined::length),\n              runtime.makeHandle(HermesValue::encodeDoubleValue(len - 1)),\n              PropOpFlags().plusThrowOnError()) == ExecutionStatus::EXCEPTION))\n    return ExecutionStatus::EXCEPTION;\n  return element.get();\n}\n\nCallResult<HermesValue>\narrayPrototypeShift(void *, Runtime &runtime, NativeArgs args) {\n  GCScope gcScope(runtime);\n  auto objRes = toObject(runtime, args.getThisHandle());\n  if (LLVM_UNLIKELY(objRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto O = runtime.makeHandle<JSObject>(objRes.getValue());\n\n  auto propRes = JSObject::getNamed_RJS(\n      O, runtime, Predefined::getSymbolID(Predefined::length));\n  if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto intRes = toLengthU64(runtime, runtime.makeHandle(std::move(*propRes)));\n  if (LLVM_UNLIKELY(intRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  uint64_t len = *intRes;\n\n  if (len == 0) {\n    // Need to set length to 0 per spec.\n    if (JSObject::putNamed_RJS(\n            O,\n            runtime,\n            Predefined::getSymbolID(Predefined::length),\n            runtime.makeHandle(HermesValue::encodeDoubleValue(0)),\n            PropOpFlags().plusThrowOnError()) == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return HermesValue::encodeUndefinedValue();\n  }\n\n  auto idxVal = runtime.makeHandle(HermesValue::encodeDoubleValue(0));\n  if (LLVM_UNLIKELY(\n          (propRes = JSObject::getComputed_RJS(O, runtime, idxVal)) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto first = runtime.makeHandle(std::move(*propRes));\n\n  MutableHandle<> from{runtime, HermesValue::encodeDoubleValue(1)};\n  MutableHandle<> to{runtime};\n\n  MutableHandle<SymbolID> fromNameTmpStorage{runtime};\n  MutableHandle<JSObject> fromDescObjHandle{runtime};\n  MutableHandle<> fromVal{runtime};\n\n  // Move every element to the left one slot.\n  // TODO: Add a fast path for actual arrays.\n  while (from->getDouble() < len) {\n    GCScopeMarkerRAII marker{gcScope};\n\n    // Moving an element from \"from\" to \"from - 1\".\n    to = HermesValue::encodeDoubleValue(from->getDouble() - 1);\n\n    ComputedPropertyDescriptor fromDesc;\n    JSObject::getComputedPrimitiveDescriptor(\n        O, runtime, from, fromDescObjHandle, fromNameTmpStorage, fromDesc);\n    CallResult<PseudoHandle<>> propRes = JSObject::getComputedPropertyValue_RJS(\n        O, runtime, fromDescObjHandle, fromNameTmpStorage, fromDesc, from);\n    if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n\n    if (LLVM_LIKELY(!(*propRes)->isEmpty())) {\n      // fromPresent is true, so read fromVal and set the \"to\" index.\n      fromVal = std::move(*propRes);\n      if (LLVM_UNLIKELY(\n              JSObject::putComputed_RJS(\n                  O, runtime, to, fromVal, PropOpFlags().plusThrowOnError()) ==\n              ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n    } else {\n      // fromVal is not present so move the empty slot to the left.\n      if (LLVM_UNLIKELY(\n              JSObject::deleteComputed(\n                  O, runtime, to, PropOpFlags().plusThrowOnError()) ==\n              ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n    }\n\n    from = HermesValue::encodeDoubleValue(from->getDouble() + 1);\n  }\n\n  // Delete last element of the array.\n  if (LLVM_UNLIKELY(\n          JSObject::deleteComputed(\n              O,\n              runtime,\n              runtime.makeHandle(HermesValue::encodeDoubleValue(len - 1)),\n              PropOpFlags().plusThrowOnError()) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  // Decrement length.\n  if (LLVM_UNLIKELY(\n          JSObject::putNamed_RJS(\n              O,\n              runtime,\n              Predefined::getSymbolID(Predefined::length),\n              runtime.makeHandle(HermesValue::encodeDoubleValue(len - 1)),\n              PropOpFlags().plusThrowOnError()) == ExecutionStatus::EXCEPTION))\n    return ExecutionStatus::EXCEPTION;\n  return first.get();\n}\n\n/// Used to help with indexOf and lastIndexOf.\n/// \\p reverse true if searching in reverse (lastIndexOf), false otherwise.\nstatic inline CallResult<HermesValue>\nindexOfHelper(Runtime &runtime, NativeArgs args, const bool reverse) {\n  GCScope gcScope(runtime);\n  auto objRes = toObject(runtime, args.getThisHandle());\n  if (LLVM_UNLIKELY(objRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto O = runtime.makeHandle<JSObject>(objRes.getValue());\n\n  auto propRes = JSObject::getNamed_RJS(\n      O, runtime, Predefined::getSymbolID(Predefined::length));\n  if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto lenRes = toLengthU64(runtime, runtime.makeHandle(std::move(*propRes)));\n  if (LLVM_UNLIKELY(lenRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  double len = *lenRes;\n\n  // Early return before running into any coercions on args.\n  // 2. Let len be ? LengthOfArrayLike(O).\n  // 3. If len is 0, return -1.\n  if (len == 0) {\n    return HermesValue::encodeDoubleValue(-1);\n  }\n\n  // Relative index to start the search at.\n  auto intRes = toIntegerOrInfinity(runtime, args.getArgHandle(1));\n  double n;\n  if (args.getArgCount() > 1) {\n    if (LLVM_UNLIKELY(intRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    n = intRes->getNumber();\n    if (LLVM_UNLIKELY(n == 0)) {\n      // To handle the special case when n is -0, we need to make sure it's 0.\n      n = 0;\n    }\n  } else {\n    n = !reverse ? 0 : len - 1;\n  }\n\n  // Actual index to start the search at.\n  MutableHandle<> k{runtime};\n  if (!reverse) {\n    if (n >= 0) {\n      k = HermesValue::encodeDoubleValue(n);\n    } else {\n      // If len - abs(n) < 0, set k=0. Otherwise set k = len - abs(n).\n      k = HermesValue::encodeDoubleValue(std::max(len - std::abs(n), 0.0));\n    }\n  } else {\n    if (n >= 0) {\n      k = HermesValue::encodeDoubleValue(std::min(n, len - 1));\n    } else {\n      k = HermesValue::encodeDoubleValue(len - std::abs(n));\n    }\n  }\n\n  MutableHandle<SymbolID> tmpPropNameStorage{runtime};\n  MutableHandle<JSObject> descObjHandle{runtime};\n\n  // Search for the element.\n  auto searchElement = args.getArgHandle(0);\n  auto marker = gcScope.createMarker();\n  while (true) {\n    gcScope.flushToMarker(marker);\n    // Check that we're not done yet.\n    if (!reverse) {\n      if (k->getDouble() >= len) {\n        break;\n      }\n    } else {\n      if (k->getDouble() < 0) {\n        break;\n      }\n    }\n    ComputedPropertyDescriptor desc;\n    JSObject::getComputedPrimitiveDescriptor(\n        O, runtime, k, descObjHandle, tmpPropNameStorage, desc);\n    CallResult<PseudoHandle<>> propRes = JSObject::getComputedPropertyValue_RJS(\n        O, runtime, descObjHandle, tmpPropNameStorage, desc, k);\n    if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    if (!(*propRes)->isEmpty() &&\n        strictEqualityTest(searchElement.get(), propRes->get())) {\n      return k.get();\n    }\n    // Update the index based on the direction of the search.\n    k = HermesValue::encodeDoubleValue(k->getDouble() + (reverse ? -1 : 1));\n  }\n\n  // Not found, return -1.\n  return HermesValue::encodeDoubleValue(-1);\n}\n\nCallResult<HermesValue>\narrayPrototypeUnshift(void *, Runtime &runtime, NativeArgs args) {\n  GCScope gcScope(runtime);\n  auto objRes = toObject(runtime, args.getThisHandle());\n  if (LLVM_UNLIKELY(objRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto O = runtime.makeHandle<JSObject>(objRes.getValue());\n\n  auto propRes = JSObject::getNamed_RJS(\n      O, runtime, Predefined::getSymbolID(Predefined::length));\n  if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto intRes = toLengthU64(runtime, runtime.makeHandle(std::move(*propRes)));\n  if (LLVM_UNLIKELY(intRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  uint64_t len = *intRes;\n  size_t argCount = args.getArgCount();\n\n  // 4. If argCount > 0, then\n  if (argCount > 0) {\n    // If len+ argCount > (2 ^ 53) -1, throw a TypeError exception.\n    if (LLVM_UNLIKELY(len + argCount >= ((uint64_t)1 << 53) - 1)) {\n      return runtime.raiseTypeError(\n          \"Array.prototype.unshift result out of space\");\n    }\n\n    // Loop indices.\n    MutableHandle<> k{runtime, HermesValue::encodeDoubleValue(len)};\n    MutableHandle<> j{runtime, HermesValue::encodeDoubleValue(0)};\n\n    // Indices to copy from/to when shifting.\n    MutableHandle<> from{runtime};\n    MutableHandle<> to{runtime};\n\n    // Value that is being copied.\n    MutableHandle<SymbolID> fromNameTmpStorage{runtime};\n    MutableHandle<JSObject> fromDescObjHandle{runtime};\n    MutableHandle<> fromValue{runtime};\n\n    // Move elements to the right by argCount to account for the new elements.\n    // TODO: Add a fast path for actual arrays.\n    auto marker = gcScope.createMarker();\n    while (k->getDouble() > 0) {\n      gcScope.flushToMarker(marker);\n      from = HermesValue::encodeDoubleValue(k->getDouble() - 1);\n      to = HermesValue::encodeDoubleValue(k->getDouble() + argCount - 1);\n\n      ComputedPropertyDescriptor fromDesc;\n      JSObject::getComputedPrimitiveDescriptor(\n          O, runtime, from, fromDescObjHandle, fromNameTmpStorage, fromDesc);\n      CallResult<PseudoHandle<>> propRes =\n          JSObject::getComputedPropertyValue_RJS(\n              O,\n              runtime,\n              fromDescObjHandle,\n              fromNameTmpStorage,\n              fromDesc,\n              from);\n      if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n\n      if (LLVM_LIKELY(!(*propRes)->isEmpty())) {\n        fromValue = std::move(*propRes);\n        if (LLVM_UNLIKELY(\n                JSObject::putComputed_RJS(\n                    O,\n                    runtime,\n                    to,\n                    fromValue,\n                    PropOpFlags().plusThrowOnError()) ==\n                ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n      } else {\n        // Shift the empty slot by deleting at the destination.\n        if (LLVM_UNLIKELY(\n                JSObject::deleteComputed(\n                    O, runtime, to, PropOpFlags().plusThrowOnError()) ==\n                ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n      }\n      k = HermesValue::encodeDoubleValue(k->getDouble() - 1);\n    }\n\n    // Put the arguments into the beginning of the array.\n    for (auto arg : args.handles()) {\n      if (LLVM_UNLIKELY(\n              JSObject::putComputed_RJS(\n                  O, runtime, j, arg, PropOpFlags().plusThrowOnError()) ==\n              ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      gcScope.flushToMarker(marker);\n      j = HermesValue::encodeDoubleValue(j->getDouble() + 1);\n    }\n  }\n\n  // Increment length by argCount.\n  auto newLen = HermesValue::encodeDoubleValue(len + argCount);\n  if (LLVM_UNLIKELY(\n          JSObject::putNamed_RJS(\n              O,\n              runtime,\n              Predefined::getSymbolID(Predefined::length),\n              runtime.makeHandle(newLen),\n              PropOpFlags().plusThrowOnError()) == ExecutionStatus::EXCEPTION))\n    return ExecutionStatus::EXCEPTION;\n  return newLen;\n}\n\nCallResult<HermesValue>\narrayPrototypeIndexOf(void *, Runtime &runtime, NativeArgs args) {\n  return indexOfHelper(runtime, args, false);\n}\n\nCallResult<HermesValue>\narrayPrototypeLastIndexOf(void *, Runtime &runtime, NativeArgs args) {\n  return indexOfHelper(runtime, args, true);\n}\n\n/// Helper function for every/some.\n/// \\param every true if calling every(), false if calling some().\nstatic inline CallResult<HermesValue>\neverySomeHelper(Runtime &runtime, NativeArgs args, const bool every) {\n  GCScope gcScope(runtime);\n  auto objRes = toObject(runtime, args.getThisHandle());\n  if (LLVM_UNLIKELY(objRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto O = runtime.makeHandle<JSObject>(objRes.getValue());\n\n  auto propRes = JSObject::getNamed_RJS(\n      O, runtime, Predefined::getSymbolID(Predefined::length));\n  if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto intRes = toLengthU64(runtime, runtime.makeHandle(std::move(*propRes)));\n  if (LLVM_UNLIKELY(intRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  uint64_t len = *intRes;\n\n  auto callbackFn = args.dyncastArg<Callable>(0);\n  if (!callbackFn) {\n    return runtime.raiseTypeError(\n        \"Array.prototype.every() requires a callable argument\");\n  }\n\n  // Index to check the callback on.\n  MutableHandle<> k{runtime, HermesValue::encodeDoubleValue(0)};\n\n  // Value at index k;\n  MutableHandle<SymbolID> tmpPropNameStorage{runtime};\n  MutableHandle<JSObject> descObjHandle{runtime};\n  MutableHandle<> kValue{runtime};\n\n  // Loop through and run the callback.\n  auto marker = gcScope.createMarker();\n  while (k->getDouble() < len) {\n    gcScope.flushToMarker(marker);\n\n    ComputedPropertyDescriptor desc;\n    JSObject::getComputedPrimitiveDescriptor(\n        O, runtime, k, descObjHandle, tmpPropNameStorage, desc);\n    CallResult<PseudoHandle<>> propRes = JSObject::getComputedPropertyValue_RJS(\n        O, runtime, descObjHandle, tmpPropNameStorage, desc, k);\n    if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    if (LLVM_LIKELY(!(*propRes)->isEmpty())) {\n      // kPresent is true, call the callback on the kth element.\n      kValue = std::move(*propRes);\n      auto callRes = Callable::executeCall3(\n          callbackFn,\n          runtime,\n          args.getArgHandle(1),\n          kValue.get(),\n          k.get(),\n          O.getHermesValue());\n      if (LLVM_UNLIKELY(callRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      auto testResult = std::move(*callRes);\n      if (every) {\n        // Done if one is false.\n        if (!toBoolean(testResult.get())) {\n          return HermesValue::encodeBoolValue(false);\n        }\n      } else {\n        // Done if one is true.\n        if (toBoolean(testResult.get())) {\n          return HermesValue::encodeBoolValue(true);\n        }\n      }\n    }\n\n    k = HermesValue::encodeDoubleValue(k->getDouble() + 1);\n  }\n\n  // If we're looking for every, then we finished without returning true.\n  // If we're looking for some, then we finished without returning false.\n  return HermesValue::encodeBoolValue(every);\n}\n\nCallResult<HermesValue>\narrayPrototypeEvery(void *, Runtime &runtime, NativeArgs args) {\n  return everySomeHelper(runtime, args, true);\n}\n\nCallResult<HermesValue>\narrayPrototypeSome(void *, Runtime &runtime, NativeArgs args) {\n  return everySomeHelper(runtime, args, false);\n}\n\nCallResult<HermesValue>\narrayPrototypeMap(void *, Runtime &runtime, NativeArgs args) {\n  GCScope gcScope(runtime);\n  auto objRes = toObject(runtime, args.getThisHandle());\n  if (LLVM_UNLIKELY(objRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto O = runtime.makeHandle<JSObject>(objRes.getValue());\n\n  auto propRes = JSObject::getNamed_RJS(\n      O, runtime, Predefined::getSymbolID(Predefined::length));\n  if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto intRes = toLengthU64(runtime, runtime.makeHandle(std::move(*propRes)));\n  if (LLVM_UNLIKELY(intRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  uint64_t len = *intRes;\n\n  auto callbackFn = args.dyncastArg<Callable>(0);\n  if (!callbackFn) {\n    return runtime.raiseTypeError(\n        \"Array.prototype.map() requires a callable argument\");\n  }\n\n  // Resultant array.\n  if (LLVM_UNLIKELY(len > JSArray::StorageType::maxElements())) {\n    return runtime.raiseRangeError(\"Out of memory for array elements.\");\n  }\n  auto arrRes = JSArray::create(runtime, len, len);\n  if (LLVM_UNLIKELY(arrRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto A = *arrRes;\n\n  // Current index to execute callback on.\n  MutableHandle<> k{runtime, HermesValue::encodeDoubleValue(0)};\n\n  MutableHandle<SymbolID> tmpPropNameStorage{runtime};\n  MutableHandle<JSObject> descObjHandle{runtime};\n\n  // Main loop to execute callback and store the results in A.\n  // TODO: Implement a fast path for actual arrays.\n  auto marker = gcScope.createMarker();\n  while (k->getDouble() < len) {\n    gcScope.flushToMarker(marker);\n\n    ComputedPropertyDescriptor desc;\n    JSObject::getComputedPrimitiveDescriptor(\n        O, runtime, k, descObjHandle, tmpPropNameStorage, desc);\n    CallResult<PseudoHandle<>> propRes = JSObject::getComputedPropertyValue_RJS(\n        O, runtime, descObjHandle, tmpPropNameStorage, desc, k);\n    if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    if (LLVM_LIKELY(!(*propRes)->isEmpty())) {\n      // kPresent is true, execute callback and store result in A[k].\n      auto kValue = std::move(*propRes);\n      auto callRes = Callable::executeCall3(\n          callbackFn,\n          runtime,\n          args.getArgHandle(1),\n          kValue.get(),\n          k.get(),\n          O.getHermesValue());\n      if (LLVM_UNLIKELY(callRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      JSArray::setElementAt(\n          A, runtime, k->getDouble(), runtime.makeHandle(std::move(*callRes)));\n    }\n\n    k = HermesValue::encodeDoubleValue(k->getDouble() + 1);\n  }\n\n  return A.getHermesValue();\n}\n\nCallResult<HermesValue>\narrayPrototypeFilter(void *, Runtime &runtime, NativeArgs args) {\n  GCScope gcScope(runtime);\n  auto objRes = toObject(runtime, args.getThisHandle());\n  if (LLVM_UNLIKELY(objRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto O = runtime.makeHandle<JSObject>(objRes.getValue());\n\n  auto propRes = JSObject::getNamed_RJS(\n      O, runtime, Predefined::getSymbolID(Predefined::length));\n  if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto intRes = toLengthU64(runtime, runtime.makeHandle(std::move(*propRes)));\n  if (LLVM_UNLIKELY(intRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  uint64_t len = *intRes;\n\n  auto callbackFn = args.dyncastArg<Callable>(0);\n  if (!callbackFn) {\n    return runtime.raiseTypeError(\n        \"Array.prototype.filter() requires a callable argument\");\n  }\n\n  if (LLVM_UNLIKELY(len > JSArray::StorageType::maxElements())) {\n    return runtime.raiseRangeError(\"Out of memory for array elements.\");\n  }\n  auto arrRes = JSArray::create(runtime, len, 0);\n  if (LLVM_UNLIKELY(arrRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto A = *arrRes;\n\n  // Index in the original array.\n  MutableHandle<> k{runtime, HermesValue::encodeDoubleValue(0)};\n  // Index to copy to in the new array.\n  uint32_t to = 0;\n\n  // Value at index k.\n  MutableHandle<SymbolID> tmpPropNameStorage{runtime};\n  MutableHandle<JSObject> descObjHandle{runtime};\n  MutableHandle<> kValue{runtime};\n\n  auto marker = gcScope.createMarker();\n  while (k->getDouble() < len) {\n    gcScope.flushToMarker(marker);\n\n    ComputedPropertyDescriptor desc;\n    JSObject::getComputedPrimitiveDescriptor(\n        O, runtime, k, descObjHandle, tmpPropNameStorage, desc);\n    CallResult<PseudoHandle<>> propRes = JSObject::getComputedPropertyValue_RJS(\n        O, runtime, descObjHandle, tmpPropNameStorage, desc, k);\n    if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    if (LLVM_LIKELY(!(*propRes)->isEmpty())) {\n      kValue = std::move(*propRes);\n      // Call the callback.\n      auto callRes = Callable::executeCall3(\n          callbackFn,\n          runtime,\n          args.getArgHandle(1),\n          kValue.get(),\n          k.get(),\n          O.getHermesValue());\n      if (LLVM_UNLIKELY(callRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      if (toBoolean(callRes->get())) {\n        // Add the element to the array if it passes the callback.\n        JSArray::setElementAt(A, runtime, to, kValue);\n        ++to;\n      }\n    }\n\n    k = HermesValue::encodeDoubleValue(k->getDouble() + 1);\n  }\n\n  if (LLVM_UNLIKELY(\n          JSArray::setLengthProperty(A, runtime, to) ==\n          ExecutionStatus::EXCEPTION))\n    return ExecutionStatus::EXCEPTION;\n  return A.getHermesValue();\n}\n\nCallResult<HermesValue>\narrayPrototypeFill(void *, Runtime &runtime, NativeArgs args) {\n  GCScope gcScope(runtime);\n  auto objRes = toObject(runtime, args.getThisHandle());\n  if (LLVM_UNLIKELY(objRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto O = runtime.makeHandle<JSObject>(objRes.getValue());\n  // Get the length.\n  auto propRes = JSObject::getNamed_RJS(\n      O, runtime, Predefined::getSymbolID(Predefined::length));\n  if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto lenRes = toLengthU64(runtime, runtime.makeHandle(std::move(*propRes)));\n  if (LLVM_UNLIKELY(lenRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  double len = *lenRes;\n  // Get the value to be filled.\n  MutableHandle<> value(runtime, args.getArg(0));\n  // Get the relative start and end.\n  auto intRes = toIntegerOrInfinity(runtime, args.getArgHandle(1));\n  if (LLVM_UNLIKELY(intRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  double relativeStart = intRes->getNumber();\n  // Index to start the deletion/insertion at.\n  double actualStart = relativeStart < 0 ? std::max(len + relativeStart, 0.0)\n                                         : std::min(relativeStart, len);\n  double relativeEnd;\n  if (args.getArg(2).isUndefined()) {\n    relativeEnd = len;\n  } else {\n    if (LLVM_UNLIKELY(\n            (intRes = toIntegerOrInfinity(runtime, args.getArgHandle(2))) ==\n            ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    relativeEnd = intRes->getNumber();\n  }\n  // Actual end index.\n  double actualEnd = relativeEnd < 0 ? std::max(len + relativeEnd, 0.0)\n                                     : std::min(relativeEnd, len);\n  MutableHandle<> k(runtime, HermesValue::encodeDoubleValue(actualStart));\n  auto marker = gcScope.createMarker();\n  while (k->getDouble() < actualEnd) {\n    if (LLVM_UNLIKELY(\n            JSObject::putComputed_RJS(\n                O, runtime, k, value, PropOpFlags().plusThrowOnError()) ==\n            ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    k.set(HermesValue::encodeDoubleValue(k->getDouble() + 1));\n    gcScope.flushToMarker(marker);\n  }\n  return O.getHermesValue();\n}\n\nstatic CallResult<HermesValue>\nfindHelper(void *ctx, bool reverse, Runtime &runtime, NativeArgs args) {\n  GCScope gcScope{runtime};\n  bool findIndex = ctx != nullptr;\n  auto objRes = toObject(runtime, args.getThisHandle());\n  if (LLVM_UNLIKELY(objRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto O = runtime.makeHandle<JSObject>(objRes.getValue());\n\n  // Get the length.\n  auto propRes = JSObject::getNamed_RJS(\n      O, runtime, Predefined::getSymbolID(Predefined::length));\n  if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto intRes = toLengthU64(runtime, runtime.makeHandle(std::move(*propRes)));\n  if (LLVM_UNLIKELY(intRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  double len = *intRes;\n\n  auto predicate = args.dyncastArg<Callable>(0);\n  if (!predicate) {\n    return runtime.raiseTypeError(\"Find argument must be a function\");\n  }\n\n  // \"this\" argument to the callback function.\n  auto T = args.getArgHandle(1);\n  MutableHandle<> kHandle{runtime};\n  MutableHandle<> kValue{runtime};\n  auto marker = gcScope.createMarker();\n  for (size_t i = 0; i < len; ++i) {\n    kHandle = HermesValue::encodeNumberValue(reverse ? (len - i - 1) : i);\n    gcScope.flushToMarker(marker);\n    if (LLVM_UNLIKELY(\n            (propRes = JSObject::getComputed_RJS(O, runtime, kHandle)) ==\n            ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    kValue = std::move(*propRes);\n    auto callRes = Callable::executeCall3(\n        predicate,\n        runtime,\n        T,\n        kValue.getHermesValue(),\n        kHandle.getHermesValue(),\n        O.getHermesValue());\n    if (LLVM_UNLIKELY(callRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    bool testResult = toBoolean(callRes->get());\n    if (testResult) {\n      // If this is index find variant, then return the index k.\n      // Else, return the value at the index k.\n      return findIndex ? kHandle.getHermesValue() : kValue.getHermesValue();\n    }\n  }\n\n  // Failure case for Array.prototype.findIndex is -1.\n  // Failure case for Array.prototype.find is undefined.\n  // The last variants share the same failure case values.\n  return findIndex ? HermesValue::encodeNumberValue(-1)\n                   : HermesValue::encodeUndefinedValue();\n}\n\nCallResult<HermesValue>\narrayPrototypeFind(void *ctx, Runtime &runtime, NativeArgs args) {\n  return findHelper(ctx, false, runtime, args);\n}\n\nCallResult<HermesValue>\narrayPrototypeFindLast(void *ctx, Runtime &runtime, NativeArgs args) {\n  return findHelper(ctx, true, runtime, args);\n}\n\n/// Helper for reduce and reduceRight.\n/// \\param reverse set to true to reduceRight, false to reduce from the left.\nstatic inline CallResult<HermesValue>\nreduceHelper(Runtime &runtime, NativeArgs args, const bool reverse) {\n  GCScope gcScope(runtime);\n  auto objRes = toObject(runtime, args.getThisHandle());\n  if (LLVM_UNLIKELY(objRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto O = runtime.makeHandle<JSObject>(objRes.getValue());\n\n  auto propRes = JSObject::getNamed_RJS(\n      O, runtime, Predefined::getSymbolID(Predefined::length));\n  if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto intRes = toLengthU64(runtime, runtime.makeHandle(std::move(*propRes)));\n  if (LLVM_UNLIKELY(intRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  double len = *intRes;\n\n  size_t argCount = args.getArgCount();\n\n  auto callbackFn = args.dyncastArg<Callable>(0);\n  if (!callbackFn) {\n    return runtime.raiseTypeError(\n        \"Array.prototype.reduce() requires a callable argument\");\n  }\n\n  // Can't reduce an empty array without an initial value.\n  if (len == 0 && argCount < 2) {\n    return runtime.raiseTypeError(\n        \"Array.prototype.reduce() requires an initial value with empty array\");\n  }\n\n  // Current index in the reduction iteration.\n  MutableHandle<> k{\n      runtime, HermesValue::encodeDoubleValue(reverse ? len - 1 : 0)};\n  MutableHandle<SymbolID> kNameTmpStorage{runtime};\n  MutableHandle<JSObject> kDescObjHandle{runtime};\n\n  MutableHandle<> accumulator{runtime};\n\n  auto marker = gcScope.createMarker();\n\n  // How much to increment k by each iteration of a loop.\n  double increment = reverse ? -1 : 1;\n\n  // Initialize the accumulator to either the intialValue arg or the first value\n  // of the array.\n  if (argCount >= 2) {\n    accumulator = args.getArg(1);\n  } else {\n    bool kPresent = false;\n    while (!kPresent) {\n      gcScope.flushToMarker(marker);\n      if (!reverse) {\n        if (k->getDouble() >= len) {\n          break;\n        }\n      } else {\n        if (k->getDouble() < 0) {\n          break;\n        }\n      }\n      ComputedPropertyDescriptor kDesc;\n      JSObject::getComputedPrimitiveDescriptor(\n          O, runtime, k, kDescObjHandle, kNameTmpStorage, kDesc);\n      CallResult<PseudoHandle<>> propRes =\n          JSObject::getComputedPropertyValue_RJS(\n              O, runtime, kDescObjHandle, kNameTmpStorage, kDesc, k);\n      if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      if (LLVM_LIKELY(!(*propRes)->isEmpty())) {\n        kPresent = true;\n        accumulator = std::move(*propRes);\n      }\n      k = HermesValue::encodeDoubleValue(k->getDouble() + increment);\n    }\n    if (!kPresent) {\n      return runtime.raiseTypeError(\n          \"Array.prototype.reduce() requires an intial value with empty array\");\n    }\n  }\n\n  // Perform the reduce.\n  while (true) {\n    gcScope.flushToMarker(marker);\n    if (!reverse) {\n      if (k->getDouble() >= len) {\n        break;\n      }\n    } else {\n      if (k->getDouble() < 0) {\n        break;\n      }\n    }\n\n    ComputedPropertyDescriptor kDesc;\n    JSObject::getComputedPrimitiveDescriptor(\n        O, runtime, k, kDescObjHandle, kNameTmpStorage, kDesc);\n    CallResult<PseudoHandle<>> propRes = JSObject::getComputedPropertyValue_RJS(\n        O, runtime, kDescObjHandle, kNameTmpStorage, kDesc, k);\n    if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    if (LLVM_LIKELY(!(*propRes)->isEmpty())) {\n      // kPresent is true, run the accumulation step.\n      auto kValue = std::move(*propRes);\n      auto callRes = Callable::executeCall4(\n          callbackFn,\n          runtime,\n          Runtime::getUndefinedValue(),\n          accumulator.get(),\n          kValue.get(),\n          k.get(),\n          O.getHermesValue());\n      if (LLVM_UNLIKELY(callRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      accumulator = std::move(*callRes);\n    }\n    k = HermesValue::encodeDoubleValue(k->getDouble() + increment);\n  }\n\n  return accumulator.get();\n}\n\nCallResult<HermesValue>\narrayPrototypeReduce(void *, Runtime &runtime, NativeArgs args) {\n  return reduceHelper(runtime, args, false);\n}\n\nCallResult<HermesValue>\narrayPrototypeReduceRight(void *, Runtime &runtime, NativeArgs args) {\n  return reduceHelper(runtime, args, true);\n}\n\n/// ES10.0 22.1.3.23.\nCallResult<HermesValue>\narrayPrototypeReverse(void *, Runtime &runtime, NativeArgs args) {\n  GCScope gcScope(runtime);\n  auto objRes = toObject(runtime, args.getThisHandle());\n  if (LLVM_UNLIKELY(objRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto O = runtime.makeHandle<JSObject>(objRes.getValue());\n\n  MutableHandle<> lower{runtime, HermesValue::encodeDoubleValue(0)};\n  MutableHandle<> upper{runtime};\n\n  // The values at the lower and upper indices.\n  MutableHandle<> lowerValue{runtime};\n  MutableHandle<> upperValue{runtime};\n\n  auto marker = gcScope.createMarker();\n\n  auto propRes = JSObject::getNamed_RJS(\n      O, runtime, Predefined::getSymbolID(Predefined::length));\n  if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto lenRes = toLengthU64(runtime, runtime.makeHandle(std::move(*propRes)));\n  if (LLVM_UNLIKELY(lenRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  uint64_t len = *lenRes;\n\n  // Indices used in the reversal process.\n  uint64_t middle = len / 2;\n\n  while (lower->getDouble() != middle) {\n    gcScope.flushToMarker(marker);\n    upper = HermesValue::encodeDoubleValue(len - lower->getNumber() - 1);\n\n    CallResult<bool> lowerExistsRes = JSObject::hasComputed(O, runtime, lower);\n    if (LLVM_UNLIKELY(lowerExistsRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    if (*lowerExistsRes) {\n      CallResult<PseudoHandle<>> lowerValueRes =\n          JSObject::getComputed_RJS(O, runtime, lower);\n      if (LLVM_UNLIKELY(lowerValueRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      lowerValue = std::move(*lowerValueRes);\n      gcScope.flushToMarker(marker);\n    }\n\n    CallResult<bool> upperExistsRes = JSObject::hasComputed(O, runtime, upper);\n    if (LLVM_UNLIKELY(upperExistsRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    if (*upperExistsRes) {\n      CallResult<PseudoHandle<>> upperValueRes =\n          JSObject::getComputed_RJS(O, runtime, upper);\n      if (LLVM_UNLIKELY(upperValueRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      upperValue = std::move(*upperValueRes);\n      gcScope.flushToMarker(marker);\n    }\n\n    // Handle cases in which lower/upper do/don't exist.\n    if (*lowerExistsRes && *upperExistsRes) {\n      if (LLVM_UNLIKELY(\n              JSObject::putComputed_RJS(\n                  O,\n                  runtime,\n                  lower,\n                  upperValue,\n                  PropOpFlags().plusThrowOnError()) ==\n              ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      if (LLVM_UNLIKELY(\n              JSObject::putComputed_RJS(\n                  O,\n                  runtime,\n                  upper,\n                  lowerValue,\n                  PropOpFlags().plusThrowOnError()) ==\n              ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n    } else if (*upperExistsRes) {\n      if (LLVM_UNLIKELY(\n              JSObject::putComputed_RJS(\n                  O,\n                  runtime,\n                  lower,\n                  upperValue,\n                  PropOpFlags().plusThrowOnError()) ==\n              ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      if (LLVM_UNLIKELY(\n              JSObject::deleteComputed(\n                  O, runtime, upper, PropOpFlags().plusThrowOnError()) ==\n              ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n    } else if (*lowerExistsRes) {\n      if (LLVM_UNLIKELY(\n              JSObject::deleteComputed(\n                  O, runtime, lower, PropOpFlags().plusThrowOnError()) ==\n              ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      if (LLVM_UNLIKELY(\n              JSObject::putComputed_RJS(\n                  O,\n                  runtime,\n                  upper,\n                  lowerValue,\n                  PropOpFlags().plusThrowOnError()) ==\n              ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n    }\n\n    lower = HermesValue::encodeDoubleValue(lower->getDouble() + 1);\n  }\n\n  return O.getHermesValue();\n}\n\nCallResult<HermesValue>\narrayPrototypeIncludes(void *, Runtime &runtime, NativeArgs args) {\n  GCScope gcScope{runtime};\n\n  // 1. Let O be ? ToObject(this value).\n  auto oRes = toObject(runtime, args.getThisHandle());\n  if (LLVM_UNLIKELY(oRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto O = runtime.makeHandle<JSObject>(*oRes);\n\n  // 2. Let len be ? ToLength(? Get(O, \"length\")).\n  auto lenPropRes = JSObject::getNamed_RJS(\n      O, runtime, Predefined::getSymbolID(Predefined::length));\n  if (LLVM_UNLIKELY(lenPropRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto lenRes =\n      toLengthU64(runtime, runtime.makeHandle(std::move(*lenPropRes)));\n  if (LLVM_UNLIKELY(lenRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  double len = *lenRes;\n\n  // 3. If len is 0, return false.\n  if (len == 0) {\n    return HermesValue::encodeBoolValue(false);\n  }\n\n  // 4. Let n be ? ToIntegerOrInfinity(fromIndex).\n  // (If fromIndex is undefined, this step produces the value 0.)\n  auto nRes = toIntegerOrInfinity(runtime, args.getArgHandle(1));\n  if (LLVM_UNLIKELY(nRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  // Use double here, because ToInteger may return Infinity.\n  double n = nRes->getNumber();\n\n  double k;\n  if (n >= 0) {\n    // 5. If n  0, then\n    // 5a. Let k be n.\n    k = n;\n  } else {\n    // 6. Else n < 0,\n    // 6a. Let k be len + n.\n    k = len + n;\n    // 6b. If k < 0, let k be 0.\n    if (k < 0) {\n      k = 0;\n    }\n  }\n\n  MutableHandle<> kHandle{runtime};\n\n  // 7. Repeat, while k < len\n  auto marker = gcScope.createMarker();\n  while (k < len) {\n    gcScope.flushToMarker(marker);\n\n    // 7a. Let elementK be the result of ? Get(O, ! ToString(k)).\n    kHandle = HermesValue::encodeNumberValue(k);\n    auto elementKRes = JSObject::getComputed_RJS(O, runtime, kHandle);\n    if (LLVM_UNLIKELY(elementKRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n\n    // 7b. If SameValueZero(searchElement, elementK) is true, return true.\n    if (isSameValueZero(args.getArg(0), elementKRes->get())) {\n      return HermesValue::encodeBoolValue(true);\n    }\n\n    // 7c. Increase k by 1.\n    ++k;\n  }\n\n  // 8. Return false.\n  return HermesValue::encodeBoolValue(false);\n}\n\nCallResult<HermesValue> arrayOf(void *, Runtime &runtime, NativeArgs args) {\n  GCScope gcScope{runtime};\n\n  // 1. Let len be the actual number of arguments passed to this function.\n  uint32_t len = args.getArgCount();\n  // 2. Let items be the List of arguments passed to this function.\n  // 3. Let C be the this value.\n  auto C = args.getThisHandle();\n\n  MutableHandle<JSObject> A{runtime};\n  CallResult<bool> isConstructorRes = isConstructor(runtime, *C);\n  if (LLVM_UNLIKELY(isConstructorRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  // 4. If IsConstructor(C) is true, then\n  if (*isConstructorRes) {\n    // a. Let A be Construct(C, len).\n    auto aRes = Callable::executeConstruct1(\n        Handle<Callable>::vmcast(C),\n        runtime,\n        runtime.makeHandle(HermesValue::encodeNumberValue(len)));\n    if (LLVM_UNLIKELY(aRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    A = PseudoHandle<JSObject>::vmcast(std::move(*aRes));\n  } else {\n    // 5. Else,\n    // a. Let A be ArrayCreate(len).\n    auto aRes = JSArray::create(runtime, len, len);\n    if (LLVM_UNLIKELY(aRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    A = vmcast<JSObject>(aRes->getHermesValue());\n  }\n  // 7. Let k be 0.\n  MutableHandle<> k{runtime, HermesValue::encodeNumberValue(0)};\n  MutableHandle<> kValue{runtime};\n\n  GCScopeMarkerRAII marker{gcScope};\n  // 8. Repeat, while k < len\n  for (; k->getNumberAs<uint32_t>() < len; marker.flush()) {\n    // a. Let kValue be items[k].\n    kValue = args.getArg(k->getNumber());\n\n    // c. Let defineStatus be CreateDataPropertyOrThrow(A,Pk, kValue).\n    if (LLVM_UNLIKELY(\n            JSObject::defineOwnComputedPrimitive(\n                A,\n                runtime,\n                k,\n                DefinePropertyFlags::getDefaultNewPropertyFlags(),\n                kValue,\n                PropOpFlags().plusThrowOnError()) ==\n            ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n\n    // e. Increase k by 1.\n    k = HermesValue::encodeNumberValue(k->getNumber() + 1);\n  }\n\n  // 9. Let setStatus be Set(A, \"length\", len, true).\n  // 10. ReturnIfAbrupt(setStatus).\n  auto setStatus = JSObject::putNamed_RJS(\n      A,\n      runtime,\n      Predefined::getSymbolID(Predefined::length),\n      runtime.makeHandle(HermesValue::encodeNumberValue(len)),\n      PropOpFlags().plusThrowOnError());\n  if (LLVM_UNLIKELY(setStatus == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  // 11. Return A.\n  return A.getHermesValue();\n}\n\n/// ES6.0 22.1.2.1 Array.from ( items [ , mapfn [ , thisArg ] ] )\nCallResult<HermesValue> arrayFrom(void *, Runtime &runtime, NativeArgs args) {\n  GCScope gcScope{runtime};\n  auto itemsHandle = args.getArgHandle(0);\n  // 1. Let C be the this value.\n  auto C = args.getThisHandle();\n  // 2. If mapfn is undefined, let mapping be false.\n  // 3. else\n  MutableHandle<Callable> mapfn{runtime};\n  MutableHandle<> T{runtime, HermesValue::encodeUndefinedValue()};\n  if (!args.getArg(1).isUndefined()) {\n    mapfn = dyn_vmcast<Callable>(args.getArg(1));\n    // a. If IsCallable(mapfn) is false, throw a TypeError exception.\n    if (LLVM_UNLIKELY(!mapfn)) {\n      return runtime.raiseTypeError(\"Mapping function is not callable.\");\n    }\n    // b. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    if (args.getArgCount() >= 3) {\n      T = args.getArg(2);\n    }\n    // c. Let mapping be true\n  }\n  // 4. Let usingIterator be GetMethod(items, @@iterator).\n  // 5. ReturnIfAbrupt(usingIterator).\n  auto methodRes = getMethod(\n      runtime,\n      itemsHandle,\n      runtime.makeHandle(Predefined::getSymbolID(Predefined::SymbolIterator)));\n  if (LLVM_UNLIKELY(methodRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto usingIterator = runtime.makeHandle(methodRes->getHermesValue());\n\n  MutableHandle<JSObject> A{runtime};\n  // 6. If usingIterator is not undefined, then\n  if (!usingIterator->isUndefined()) {\n    CallResult<bool> isConstructorRes = isConstructor(runtime, *C);\n    if (LLVM_UNLIKELY(isConstructorRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    // a. If IsConstructor(C) is true, then\n    if (*isConstructorRes) {\n      GCScopeMarkerRAII markerConstruct{gcScope};\n      // i. Let A be Construct(C).\n      auto callRes =\n          Callable::executeConstruct0(Handle<Callable>::vmcast(C), runtime);\n      if (LLVM_UNLIKELY(callRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      A = PseudoHandle<JSObject>::vmcast(std::move(*callRes));\n    } else {\n      // b. Else,\n      //  i. Let A be ArrayCreate(0).\n      auto arrRes = JSArray::create(runtime, 0, 0);\n      if (LLVM_UNLIKELY(arrRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      A = arrRes->get();\n    }\n    // c. ReturnIfAbrupt(A).\n    // d. Let iterator be GetIterator(items, usingIterator).\n    // Assert we can cast usingIterator to a Callable otherwise getMethod would\n    // have thrown.\n    // e. ReturnIfAbrupt(iterator).\n    auto iterRes = getIterator(\n        runtime, args.getArgHandle(0), Handle<Callable>::vmcast(usingIterator));\n    if (LLVM_UNLIKELY(iterRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    auto iteratorRecord = *iterRes;\n    // f. Let k be 0.\n    MutableHandle<> k{runtime, HermesValue::encodeNumberValue(0)};\n    // g. Repeat\n    MutableHandle<> mappedValue{runtime};\n    MutableHandle<> nextValue{runtime};\n    while (true) {\n      GCScopeMarkerRAII marker1{runtime};\n      // ii. Let next be IteratorStep(iteratorRecord).\n      // iii. ReturnIfAbrupt(next).\n      auto next = iteratorStep(runtime, iteratorRecord);\n      if (LLVM_UNLIKELY(next == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      // iv. If next is false, then\n      if (!next.getValue()) {\n        // 1. Let setStatus be Set(A, \"length\", k, true).\n        // 2. ReturnIfAbrupt(setStatus).\n        // 3. Return A.\n        auto setStatus = JSObject::putNamed_RJS(\n            A,\n            runtime,\n            Predefined::getSymbolID(Predefined::length),\n            k,\n            PropOpFlags().plusThrowOnError());\n        if (LLVM_UNLIKELY(setStatus == ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n        return A.getHermesValue();\n      }\n      // v. Let nextValue be IteratorValue(next).\n      // vi. ReturnIfAbrupt(nextValue).\n      auto propRes = JSObject::getNamed_RJS(\n          *next, runtime, Predefined::getSymbolID(Predefined::value));\n      if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      nextValue = std::move(*propRes);\n      // vii. If mapping is true, then\n      if (mapfn) {\n        // 1. Let mappedValue be Call(mapfn, T, nextValue, k).\n        auto callRes = Callable::executeCall2(\n            mapfn, runtime, T, nextValue.getHermesValue(), k.getHermesValue());\n        // 2. If mappedValue is an abrupt completion, return\n        // IteratorClose(iterator, mappedValue).\n        if (LLVM_UNLIKELY(callRes == ExecutionStatus::EXCEPTION)) {\n          return iteratorCloseAndRethrow(runtime, iteratorRecord.iterator);\n        }\n        // 3. Let mappedValue be mappedValue.[[value]].\n        mappedValue = std::move(*callRes);\n      } else {\n        // viii. Else, let mappedValue be nextValue.\n        mappedValue = nextValue.getHermesValue();\n      }\n      // ix. Let defineStatus be CreateDataPropertyOrThrow(A, Pk, mappedValue).\n      // x. If defineStatus is an abrupt completion, return\n      // IteratorClose(iterator, defineStatus).\n      if (LLVM_UNLIKELY(\n              JSObject::defineOwnComputedPrimitive(\n                  A,\n                  runtime,\n                  k,\n                  DefinePropertyFlags::getDefaultNewPropertyFlags(),\n                  mappedValue,\n                  PropOpFlags().plusThrowOnError()) ==\n              ExecutionStatus::EXCEPTION)) {\n        return iteratorCloseAndRethrow(runtime, iteratorRecord.iterator);\n      }\n      // xi. Increase k by 1.\n      k = HermesValue::encodeNumberValue(k->getNumber() + 1);\n    }\n  }\n  // 7. Assert: items is not an Iterable so assume it is an array-like object.\n  // 8. Let arrayLike be ToObject(items).\n  auto objRes = toObject(runtime, itemsHandle);\n  // 9. ReturnIfAbrupt(arrayLike).\n  if (LLVM_UNLIKELY(objRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto arrayLike = runtime.makeHandle<JSObject>(objRes.getValue());\n  // 10. Let len be ToLength(Get(arrayLike, \"length\")).\n  // 11. ReturnIfAbrupt(len).\n  auto propRes = JSObject::getNamed_RJS(\n      arrayLike, runtime, Predefined::getSymbolID(Predefined::length));\n  if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto lengthRes = toLength(runtime, runtime.makeHandle(std::move(*propRes)));\n  if (LLVM_UNLIKELY(lengthRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  uint64_t len = lengthRes->getNumberAs<uint64_t>();\n  CallResult<bool> isConstructorRes = isConstructor(runtime, *C);\n  if (LLVM_UNLIKELY(isConstructorRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  // 12. If IsConstructor(C) is true, then\n  if (*isConstructorRes) {\n    // a. Let A be Construct(C, len).\n    auto callRes = Callable::executeConstruct1(\n        Handle<Callable>::vmcast(C),\n        runtime,\n        runtime.makeHandle(lengthRes.getValue()));\n    if (LLVM_UNLIKELY(callRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    A = PseudoHandle<JSObject>::vmcast(std::move(*callRes));\n  } else {\n    // 13. Else,\n    //  a. Let A be ArrayCreate(len).\n    if (LLVM_UNLIKELY(len > JSArray::StorageType::maxElements())) {\n      return runtime.raiseRangeError(\"Out of memory for array elements.\");\n    }\n    auto arrRes = JSArray::create(runtime, len, len);\n    if (LLVM_UNLIKELY(arrRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    A = arrRes->get();\n  }\n  // 14. ReturnIfAbrupt(A).\n  // 15. Let k be 0.\n  MutableHandle<> k{runtime, HermesValue::encodeNumberValue(0)};\n  // 16. Repeat, while k < len\n  MutableHandle<> mappedValue{runtime};\n  while (k->getNumberAs<uint32_t>() < len) {\n    GCScopeMarkerRAII marker2{runtime};\n    // b. Let kValue be Get(arrayLike, Pk).\n    propRes = JSObject::getComputed_RJS(arrayLike, runtime, k);\n    // c. ReturnIfAbrupt(kValue).\n    if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    // d. If mapping is true, then\n    if (mapfn) {\n      // i. Let mappedValue be Call(mapfn, T, kValue, k).\n      // ii. ReturnIfAbrupt(mappedValue).\n      auto callRes = Callable::executeCall2(\n          mapfn, runtime, T, propRes->get(), k.getHermesValue());\n      if (LLVM_UNLIKELY(callRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      mappedValue = std::move(*callRes);\n    } else {\n      // e. Else, let mappedValue be kValue.\n      mappedValue = std::move(*propRes);\n    }\n    // f. Let defineStatus be CreateDataPropertyOrThrow(A, Pk, mappedValue).\n    // g. ReturnIfAbrupt(defineStatus).\n    if (LLVM_UNLIKELY(\n            JSObject::defineOwnComputedPrimitive(\n                A,\n                runtime,\n                k,\n                DefinePropertyFlags::getDefaultNewPropertyFlags(),\n                mappedValue,\n                PropOpFlags().plusThrowOnError()) ==\n            ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    // h. Increase k by 1.\n    k = HermesValue::encodeNumberValue(k->getNumber() + 1);\n  }\n  // 17. Let setStatus be Set(A, \"length\", len, true).\n  auto setStatus = JSObject::putNamed_RJS(\n      A,\n      runtime,\n      Predefined::getSymbolID(Predefined::length),\n      k,\n      PropOpFlags().plusThrowOnError());\n  // 18. ReturnIfAbrupt(setStatus).\n  if (LLVM_UNLIKELY(setStatus == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  // 19. Return A.\n  return A.getHermesValue();\n}\n\n} // namespace vm\n} // namespace hermes\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2023-25933", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// RUN: %hermes -target=HBC -dump-ra -O %s | %FileCheckOrRegen --match-full-lines %s\n\nfunction count() {\n  return arguments.length;\n}\n\nfunction select(x) {\n  return arguments[x+1];\n}\n\nfunction build() {\n  return arguments;\n}\n\nfunction buffalobuffalo() {\n  if(arguments) {\n    return arguments + arguments;\n  }\n  return arguments;\n}\n\nfunction check_phi_handling(x) {\n  return x ? [1] : arguments;\n}\n\n// Auto-generated content below. Please do not modify manually.\n\n// CHECK:function global#0()#1 : undefined\n// CHECK-NEXT:frame = [], globals = [count, select, build, buffalobuffalo, check_phi_handling]\n// CHECK-NEXT:%BB0:\n// CHECK-NEXT:  $Reg0 @0 [1...11) \t%0 = HBCCreateEnvironmentInst %S{global#0()#1}\n// CHECK-NEXT:  $Reg2 @1 [2...4) \t%1 = HBCCreateFunctionInst %count#0#1()#2, %0\n// CHECK-NEXT:  $Reg1 @2 [3...12) \t%2 = HBCGetGlobalObjectInst\n// CHECK-NEXT:  $Reg2 @3 [empty]\t%3 = StorePropertyInst %1 : closure, %2 : object, \"count\" : string\n// CHECK-NEXT:  $Reg2 @4 [5...6) \t%4 = HBCCreateFunctionInst %select#0#1()#3, %0\n// CHECK-NEXT:  $Reg2 @5 [empty]\t%5 = StorePropertyInst %4 : closure, %2 : object, \"select\" : string\n// CHECK-NEXT:  $Reg2 @6 [7...8) \t%6 = HBCCreateFunctionInst %build#0#1()#4 : object, %0\n// CHECK-NEXT:  $Reg2 @7 [empty]\t%7 = StorePropertyInst %6 : closure, %2 : object, \"build\" : string\n// CHECK-NEXT:  $Reg2 @8 [9...10) \t%8 = HBCCreateFunctionInst %buffalobuffalo#0#1()#5 : string|number, %0\n// CHECK-NEXT:  $Reg2 @9 [empty]\t%9 = StorePropertyInst %8 : closure, %2 : object, \"buffalobuffalo\" : string\n// CHECK-NEXT:  $Reg0 @10 [11...12) \t%10 = HBCCreateFunctionInst %check_phi_handling#0#1()#6 : object, %0\n// CHECK-NEXT:  $Reg0 @11 [empty]\t%11 = StorePropertyInst %10 : closure, %2 : object, \"check_phi_handling\" : string\n// CHECK-NEXT:  $Reg0 @12 [13...14) \t%12 = HBCLoadConstInst undefined : undefined\n// CHECK-NEXT:  $Reg0 @13 [empty]\t%13 = ReturnInst %12 : undefined\n// CHECK-NEXT:function_end\n\n// CHECK:function count#0#1()#2\n// CHECK-NEXT:frame = []\n// CHECK-NEXT:%BB0:\n// CHECK-NEXT:  $Reg0 @0 [1...4) \t%0 = AllocStackInst $arguments\n// CHECK-NEXT:  $Reg1 @1 [2...3) \t%1 = HBCLoadConstInst undefined : undefined\n// CHECK-NEXT:  $Reg1 @2 [empty]\t%2 = StoreStackInst %1 : undefined, %0\n// CHECK-NEXT:  $Reg0 @3 [4...5) \t%3 = HBCGetArgumentsLengthInst %0\n// CHECK-NEXT:  $Reg0 @4 [empty]\t%4 = ReturnInst %3\n// CHECK-NEXT:function_end\n\n// CHECK:function select#0#1(x)#2\n// CHECK-NEXT:frame = []\n// CHECK-NEXT:%BB0:\n// CHECK-NEXT:  $Reg1 @0 [1...7) \t%0 = AllocStackInst $arguments\n// CHECK-NEXT:  $Reg0 @1 [2...3) \t%1 = HBCLoadConstInst undefined : undefined\n// CHECK-NEXT:  $Reg0 @2 [empty]\t%2 = StoreStackInst %1 : undefined, %0\n// CHECK-NEXT:  $Reg2 @3 [4...6) \t%3 = HBCLoadParamInst 1 : number\n// CHECK-NEXT:  $Reg0 @4 [5...6) \t%4 = HBCLoadConstInst 1 : number\n// CHECK-NEXT:  $Reg0 @5 [6...7) \t%5 = BinaryOperatorInst '+', %3, %4 : number\n// CHECK-NEXT:  $Reg0 @6 [7...8) \t%6 = HBCGetArgumentsPropByValInst %5 : string|number, %0\n// CHECK-NEXT:  $Reg0 @7 [empty]\t%7 = ReturnInst %6\n// CHECK-NEXT:function_end\n\n// CHECK:function build#0#1()#2 : object\n// CHECK-NEXT:frame = []\n// CHECK-NEXT:%BB0:\n// CHECK-NEXT:  $Reg0 @0 [1...5) \t%0 = AllocStackInst $arguments\n// CHECK-NEXT:  $Reg1 @1 [2...3) \t%1 = HBCLoadConstInst undefined : undefined\n// CHECK-NEXT:  $Reg1 @2 [empty]\t%2 = StoreStackInst %1 : undefined, %0\n// CHECK-NEXT:  $Reg1 @3 [empty]\t%3 = HBCReifyArgumentsInst %0\n// CHECK-NEXT:  $Reg0 @4 [5...6) \t%4 = LoadStackInst %0\n// CHECK-NEXT:  $Reg0 @5 [empty]\t%5 = ReturnInst %4\n// CHECK-NEXT:function_end\n\n// CHECK:function buffalobuffalo#0#1()#2 : string|number\n// CHECK-NEXT:frame = []\n// CHECK-NEXT:%BB0:\n// CHECK-NEXT:  $Reg0 @0 [1...5) \t%0 = AllocStackInst $arguments\n// CHECK-NEXT:  $Reg1 @1 [2...3) \t%1 = HBCLoadConstInst undefined : undefined\n// CHECK-NEXT:  $Reg1 @2 [empty]\t%2 = StoreStackInst %1 : undefined, %0\n// CHECK-NEXT:  $Reg1 @3 [empty]\t%3 = HBCReifyArgumentsInst %0\n// CHECK-NEXT:  $Reg0 @4 [5...6) \t%4 = LoadStackInst %0\n// CHECK-NEXT:  $Reg0 @5 [6...7) \t%5 = BinaryOperatorInst '+', %4, %4\n// CHECK-NEXT:  $Reg0 @6 [empty]\t%6 = ReturnInst %5 : string|number\n// CHECK-NEXT:function_end\n\n// CHECK:function check_phi_handling#0#1(x)#2 : object\n// CHECK-NEXT:frame = []\n// CHECK-NEXT:%BB0:\n// CHECK-NEXT:  $Reg0 @0 [1...7) \t%0 = AllocStackInst $arguments\n// CHECK-NEXT:  $Reg1 @1 [2...3) \t%1 = HBCLoadConstInst undefined : undefined\n// CHECK-NEXT:  $Reg1 @2 [empty]\t%2 = StoreStackInst %1 : undefined, %0\n// CHECK-NEXT:  $Reg1 @3 [4...5) \t%3 = HBCLoadParamInst 1 : number\n// CHECK-NEXT:  $Reg1 @4 [empty]\t%4 = CondBranchInst %3, %BB1, %BB2\n// CHECK-NEXT:%BB1:\n// CHECK-NEXT:  $Reg1 @9 [10...11) \t%5 = AllocArrayInst 1 : number, 1 : number\n// CHECK-NEXT:  $Reg0 @10 [11...13) \t%6 = MovInst %5 : object\n// CHECK-NEXT:  $Reg1 @11 [empty]\t%7 = BranchInst %BB3\n// CHECK-NEXT:%BB3:\n// CHECK-NEXT:  $Reg0 @12 [7...14) \t%8 = PhiInst %6 : object, %BB1, %13, %BB2\n// CHECK-NEXT:  $Reg0 @13 [7...15) \t%9 = MovInst %8 : object\n// CHECK-NEXT:  $Reg0 @14 [empty]\t%10 = ReturnInst %9 : object\n// CHECK-NEXT:%BB2:\n// CHECK-NEXT:  $Reg1 @5 [empty]\t%11 = HBCReifyArgumentsInst %0\n// CHECK-NEXT:  $Reg0 @6 [7...8) \t%12 = LoadStackInst %0\n// CHECK-NEXT:  $Reg0 @7 [8...13) \t%13 = MovInst %12\n// CHECK-NEXT:  $Reg1 @8 [empty]\t%14 = BranchInst %BB3\n// CHECK-NEXT:function_end\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2023-26042", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "<!DOCTYPE html>\n<html lang=\"{{ app.request.locale | replace({\"_\": \"-\"}) }}\"\n      {#  For the UX translator, just use the language part (before the _. should be 2 chars), otherwise it finds no translations #}\n      data-symfony-ux-translator-locale=\"{{ app.request.locale|u.truncate(2)  }}\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\">\n\n    <link rel=\"manifest\" href=\"{{ asset('manifest.json') }}\">\n\n    <meta name=\"mobile-web-app-capable\" content=\"yes\">\n    <meta name=\"apple-mobile-web-app-capable\" content=\"yes\">\n    <meta name=\"application-name\" content=\"Part-DB\">\n    <meta name=\"apple-mobile-web-app-title\" content=\"Part-DB\">\n    <meta name=\"msapplication-config\" content=\"{{ asset('icon/browserconfig.xml') }}\">\n    <meta name=\"theme-color\" content=\"#ffffff\">\n    <meta name=\"theme-color\" content=\"#ffffff\">\n    <meta name=\"msapplication-navbutton-color\" content=\"#ffffff\">\n    <meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black-translucent\">\n    <meta name=\"msapplication-starturl\" content=\"/en/\">\n\n    {# Turbo control headers #}\n    <meta name=\"turbo-cache-control\" content=\"no-cache\">\n    <meta name=\"turbo-refresh-method\" content=\"morph\">\n    <meta name=\"turbo-refresh-scroll\" content=\"preserve\">\n\n    <link rel=\"shortcut icon\" type=\"image/x-icon\" href=\"{{ asset('favicon.ico') }}\">\n    <link rel=\"apple-touch-icon\" sizes=\"180x180\" href=\"{{ asset('icon/apple-touch-icon.png') }}\">\n    <link rel=\"icon\" type=\"image/png\" href=\"{{ asset('icon/favicon-32x32.png') }}\" sizes=\"32x32\">\n    <link rel=\"icon\" type=\"image/png\" href=\"{{  asset('icon/favicon-16x16.png') }}\" sizes=\"16x16\">\n    <link rel=\"mask-icon\" href=\"{{ asset('icon/safari-pinned-tab.svg') }}\" color=\"#5bbad5\">\n\n    {# The content block is already escaped. so we must not escape it again. #}\n    <title>{% apply trim|raw %}{% block title %}{{ partdb_title }}{% endblock %}{% endapply %}</title>\n    {% set current_page_title = block(\"title\")|raw %}\n    {% block stylesheets %}\n        {# Include the main bootstrap theme based on user/global setting #}\n\n\n\n        {% if not app.user.theme is defined or app.user.theme is null %}\n            {% set theme = global_theme %}\n        {% else %}\n            {% set theme = app.user.theme %}\n        {% endif %}\n\n\n\n        {% if theme and theme in available_themes and encore_entry_exists('theme_' ~ theme) %}\n            {{ encore_entry_link_tags('theme_' ~ theme) }}\n        {% else %}\n            {{ encore_entry_link_tags('theme_bootstrap') }}\n        {% endif %}\n\n        {{ encore_entry_link_tags('app') }}\n    {% endblock %}\n\n    {% block javascripts %}\n        {{ encore_entry_script_tags('app') }}\n        {{ encore_entry_script_tags('webauthn_tfa') }}\n\n        {# load translation files for ckeditor #}\n        {% set two_chars_locale = app.request.locale|default(\"en\")|slice(0,2) %}\n        {% if two_chars_locale != \"en\" %}\n            <script src=\"{{ asset(\"build/ckeditor_translations/\" ~ two_chars_locale ~ \".js\") }}\"></script>\n        {% endif %}\n    {% endblock %}\n</head>\n<body data-base-url=\"{{ path('homepage', {'_locale': app.request.locale}) }}\" data-locale=\"{{ app.request.locale|default(\"en\")|slice(0,2) }}\">\n{% block body %}\n    <header>\n        <turbo-frame id=\"navbar-frame\" target=\"content\" data-turbo-action=\"advance\">\n            {% include \"_navbar.html.twig\" %}\n        </turbo-frame>\n    </header>\n\n    <main>\n        <div class=\"container-fluid\">\n            <div class=\"row\">\n                {% include \"_toast_container.html.twig\" %}\n\n                <div class=\"collapse d-md-block\" id=\"sidebar-container\">\n                    <nav  class=\"fixed-sidebar col-md-3 col-lg-2 bg-body\" id=\"fixed-sidebar\">\n                        <turbo-frame id=\"sidebar\" target=\"content\" data-turbo-action=\"advance\" data-turbo-permanent>\n                            {% include \"_sidebar.html.twig\" %}\n                        </turbo-frame>\n                        <noscript><b>{% trans %}vendor.base.javascript_hint{% endtrans %}</b></noscript>\n                    </nav>\n                </div>\n\n                <div class=\"col-md-9 col-lg-10 offset-md-3 offset-lg-2 ps-0\" id=\"main\">\n                    <div class=\"container-fluid me-0 pe-0\" id=\"content-container\">\n                        <turbo-frame id=\"content\" data-turbo-action=\"advance\">\n                            {# Here will be the real content be injected#}\n\n                            {% block content %}\n                            {% endblock %}\n\n                            {% include \"_turbo_control.html.twig\" %}\n\n                        </turbo-frame>\n                        {% block scripts %}\n\n                        {% endblock %}\n                    </div>\n                </div>\n            </div>\n        </div>\n    </main>\n\n    {# Back to top buton #}\n\n    <!-- Back to top button -->\n    <button id=\"back-to-top\" class=\"btn btn-primary back-to-top btn-sm\" role=\"button\" title=\"{% trans %}back_to_top{% endtrans %}\"\n            {{ stimulus_controller('common/back_to_top') }} {{ stimulus_action('common/back_to_top', 'backToTop') }}>\n        <i class=\"fas fa-angle-up fa-fw\"></i>\n    </button>\n\n    {# Must be outside of the sidebar or it will be hidden too #}\n    <button class=\"btn btn-outline-secondary btn-sm p-0 d-md-block d-none\" type=\"button\" id=\"sidebar-toggle-button\" title=\"{% trans %}sidebar.big.toggle{% endtrans %}\"\n            {{ stimulus_controller('common/hide_sidebar') }} {{ stimulus_action('common/hide_sidebar', 'toggleSidebar') }}>\n        <i class=\"fas fa-angle-left\"></i>\n    </button>\n\n{% endblock %}\n\n</body>\n</html>\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2023-26045", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "'use strict';\n\nconst validator = require('validator');\nconst winston = require('winston');\n\nconst db = require('../database');\nconst user = require('../user');\nconst groups = require('../groups');\nconst meta = require('../meta');\nconst flags = require('../flags');\nconst privileges = require('../privileges');\nconst notifications = require('../notifications');\nconst plugins = require('../plugins');\nconst events = require('../events');\nconst translator = require('../translator');\nconst sockets = require('../socket.io');\n\nconst usersAPI = module.exports;\n\nusersAPI.create = async function (caller, data) {\n\tif (!data) {\n\t\tthrow new Error('[[error:invalid-data]]');\n\t}\n\tconst uid = await user.create(data);\n\treturn await user.getUserData(uid);\n};\n\nusersAPI.update = async function (caller, data) {\n\tif (!caller.uid) {\n\t\tthrow new Error('[[error:invalid-uid]]');\n\t}\n\n\tif (!data || !data.uid) {\n\t\tthrow new Error('[[error:invalid-data]]');\n\t}\n\n\tconst oldUserData = await user.getUserFields(data.uid, ['email', 'username']);\n\tif (!oldUserData || !oldUserData.username) {\n\t\tthrow new Error('[[error:invalid-data]]');\n\t}\n\n\tconst [isAdminOrGlobalMod, canEdit] = await Promise.all([\n\t\tuser.isAdminOrGlobalMod(caller.uid),\n\t\tprivileges.users.canEdit(caller.uid, data.uid),\n\t]);\n\n\t// Changing own email/username requires password confirmation\n\tif (data.hasOwnProperty('email') || data.hasOwnProperty('username')) {\n\t\tawait isPrivilegedOrSelfAndPasswordMatch(caller, data);\n\t}\n\n\tif (!canEdit) {\n\t\tthrow new Error('[[error:no-privileges]]');\n\t}\n\n\tif (!isAdminOrGlobalMod && meta.config['username:disableEdit']) {\n\t\tdata.username = oldUserData.username;\n\t}\n\n\tif (!isAdminOrGlobalMod && meta.config['email:disableEdit']) {\n\t\tdata.email = oldUserData.email;\n\t}\n\n\tawait user.updateProfile(caller.uid, data);\n\tconst userData = await user.getUserData(data.uid);\n\n\tif (userData.username !== oldUserData.username) {\n\t\tawait events.log({\n\t\t\ttype: 'username-change',\n\t\t\tuid: caller.uid,\n\t\t\ttargetUid: data.uid,\n\t\t\tip: caller.ip,\n\t\t\toldUsername: oldUserData.username,\n\t\t\tnewUsername: userData.username,\n\t\t});\n\t}\n\treturn userData;\n};\n\nusersAPI.delete = async function (caller, { uid, password }) {\n\tawait processDeletion({ uid: uid, method: 'delete', password, caller });\n};\n\nusersAPI.deleteContent = async function (caller, { uid, password }) {\n\tawait processDeletion({ uid, method: 'deleteContent', password, caller });\n};\n\nusersAPI.deleteAccount = async function (caller, { uid, password }) {\n\tawait processDeletion({ uid, method: 'deleteAccount', password, caller });\n};\n\nusersAPI.deleteMany = async function (caller, data) {\n\tif (await canDeleteUids(data.uids)) {\n\t\tawait Promise.all(data.uids.map(uid => processDeletion({ uid, method: 'delete', caller })));\n\t}\n};\n\nusersAPI.updateSettings = async function (caller, data) {\n\tif (!caller.uid || !data || !data.settings) {\n\t\tthrow new Error('[[error:invalid-data]]');\n\t}\n\n\tconst canEdit = await privileges.users.canEdit(caller.uid, data.uid);\n\tif (!canEdit) {\n\t\tthrow new Error('[[error:no-privileges]]');\n\t}\n\n\tlet defaults = await user.getSettings(0);\n\tdefaults = {\n\t\tpostsPerPage: defaults.postsPerPage,\n\t\ttopicsPerPage: defaults.topicsPerPage,\n\t\tuserLang: defaults.userLang,\n\t\tacpLang: defaults.acpLang,\n\t};\n\t// load raw settings without parsing values to booleans\n\tconst current = await db.getObject(`user:${data.uid}:settings`);\n\tconst payload = { ...defaults, ...current, ...data.settings };\n\tdelete payload.uid;\n\n\treturn await user.saveSettings(data.uid, payload);\n};\n\nusersAPI.changePassword = async function (caller, data) {\n\tawait user.changePassword(caller.uid, Object.assign(data, { ip: caller.ip }));\n\tawait events.log({\n\t\ttype: 'password-change',\n\t\tuid: caller.uid,\n\t\ttargetUid: data.uid,\n\t\tip: caller.ip,\n\t});\n};\n\nusersAPI.follow = async function (caller, data) {\n\tawait user.follow(caller.uid, data.uid);\n\tplugins.hooks.fire('action:user.follow', {\n\t\tfromUid: caller.uid,\n\t\ttoUid: data.uid,\n\t});\n\n\tconst userData = await user.getUserFields(caller.uid, ['username', 'userslug']);\n\tconst { displayname } = userData;\n\n\tconst notifObj = await notifications.create({\n\t\ttype: 'follow',\n\t\tbodyShort: `[[notifications:user_started_following_you, ${displayname}]]`,\n\t\tnid: `follow:${data.uid}:uid:${caller.uid}`,\n\t\tfrom: caller.uid,\n\t\tpath: `/uid/${data.uid}/followers`,\n\t\tmergeId: 'notifications:user_started_following_you',\n\t});\n\tif (!notifObj) {\n\t\treturn;\n\t}\n\tnotifObj.user = userData;\n\tawait notifications.push(notifObj, [data.uid]);\n};\n\nusersAPI.unfollow = async function (caller, data) {\n\tawait user.unfollow(caller.uid, data.uid);\n\tplugins.hooks.fire('action:user.unfollow', {\n\t\tfromUid: caller.uid,\n\t\ttoUid: data.uid,\n\t});\n};\n\nusersAPI.ban = async function (caller, data) {\n\tif (!await privileges.users.hasBanPrivilege(caller.uid)) {\n\t\tthrow new Error('[[error:no-privileges]]');\n\t} else if (await user.isAdministrator(data.uid)) {\n\t\tthrow new Error('[[error:cant-ban-other-admins]]');\n\t}\n\n\tconst banData = await user.bans.ban(data.uid, data.until, data.reason);\n\tawait db.setObjectField(`uid:${data.uid}:ban:${banData.timestamp}`, 'fromUid', caller.uid);\n\n\tif (!data.reason) {\n\t\tdata.reason = await translator.translate('[[user:info.banned-no-reason]]');\n\t}\n\n\tsockets.in(`uid_${data.uid}`).emit('event:banned', {\n\t\tuntil: data.until,\n\t\treason: validator.escape(String(data.reason || '')),\n\t});\n\n\tawait flags.resolveFlag('user', data.uid, caller.uid);\n\tawait flags.resolveUserPostFlags(data.uid, caller.uid);\n\tawait events.log({\n\t\ttype: 'user-ban',\n\t\tuid: caller.uid,\n\t\ttargetUid: data.uid,\n\t\tip: caller.ip,\n\t\treason: data.reason || undefined,\n\t});\n\tplugins.hooks.fire('action:user.banned', {\n\t\tcallerUid: caller.uid,\n\t\tip: caller.ip,\n\t\tuid: data.uid,\n\t\tuntil: data.until > 0 ? data.until : undefined,\n\t\treason: data.reason || undefined,\n\t});\n\tconst canLoginIfBanned = await user.bans.canLoginIfBanned(data.uid);\n\tif (!canLoginIfBanned) {\n\t\tawait user.auth.revokeAllSessions(data.uid);\n\t}\n};\n\nusersAPI.unban = async function (caller, data) {\n\tif (!await privileges.users.hasBanPrivilege(caller.uid)) {\n\t\tthrow new Error('[[error:no-privileges]]');\n\t}\n\n\tawait user.bans.unban(data.uid);\n\n\tsockets.in(`uid_${data.uid}`).emit('event:unbanned');\n\n\tawait events.log({\n\t\ttype: 'user-unban',\n\t\tuid: caller.uid,\n\t\ttargetUid: data.uid,\n\t\tip: caller.ip,\n\t});\n\tplugins.hooks.fire('action:user.unbanned', {\n\t\tcallerUid: caller.uid,\n\t\tip: caller.ip,\n\t\tuid: data.uid,\n\t});\n};\n\nusersAPI.mute = async function (caller, data) {\n\tif (!await privileges.users.hasMutePrivilege(caller.uid)) {\n\t\tthrow new Error('[[error:no-privileges]]');\n\t} else if (await user.isAdministrator(data.uid)) {\n\t\tthrow new Error('[[error:cant-mute-other-admins]]');\n\t}\n\tconst reason = data.reason || '[[user:info.muted-no-reason]]';\n\tawait db.setObject(`user:${data.uid}`, {\n\t\tmutedUntil: data.until,\n\t\tmutedReason: reason,\n\t});\n\tconst now = Date.now();\n\tconst muteKey = `uid:${data.uid}:mute:${now}`;\n\tconst muteData = {\n\t\tfromUid: caller.uid,\n\t\tuid: data.uid,\n\t\ttimestamp: now,\n\t\texpire: data.until,\n\t};\n\tif (data.reason) {\n\t\tmuteData.reason = reason;\n\t}\n\tawait db.sortedSetAdd(`uid:${data.uid}:mutes:timestamp`, now, muteKey);\n\tawait db.setObject(muteKey, muteData);\n\tawait events.log({\n\t\ttype: 'user-mute',\n\t\tuid: caller.uid,\n\t\ttargetUid: data.uid,\n\t\tip: caller.ip,\n\t\treason: data.reason || undefined,\n\t});\n\tplugins.hooks.fire('action:user.muted', {\n\t\tcallerUid: caller.uid,\n\t\tip: caller.ip,\n\t\tuid: data.uid,\n\t\tuntil: data.until > 0 ? data.until : undefined,\n\t\treason: data.reason || undefined,\n\t});\n};\n\nusersAPI.unmute = async function (caller, data) {\n\tif (!await privileges.users.hasMutePrivilege(caller.uid)) {\n\t\tthrow new Error('[[error:no-privileges]]');\n\t}\n\n\tawait db.deleteObjectFields(`user:${data.uid}`, ['mutedUntil', 'mutedReason']);\n\n\tawait events.log({\n\t\ttype: 'user-unmute',\n\t\tuid: caller.uid,\n\t\ttargetUid: data.uid,\n\t\tip: caller.ip,\n\t});\n\tplugins.hooks.fire('action:user.unmuted', {\n\t\tcallerUid: caller.uid,\n\t\tip: caller.ip,\n\t\tuid: data.uid,\n\t});\n};\n\nasync function isPrivilegedOrSelfAndPasswordMatch(caller, data) {\n\tconst { uid } = caller;\n\tconst isSelf = parseInt(uid, 10) === parseInt(data.uid, 10);\n\tconst canEdit = await privileges.users.canEdit(uid, data.uid);\n\n\tif (!canEdit) {\n\t\tthrow new Error('[[error:no-privileges]]');\n\t}\n\tconst [hasPassword, passwordMatch] = await Promise.all([\n\t\tuser.hasPassword(data.uid),\n\t\tdata.password ? user.isPasswordCorrect(data.uid, data.password, caller.ip) : false,\n\t]);\n\n\tif (isSelf && hasPassword && !passwordMatch) {\n\t\tthrow new Error('[[error:invalid-password]]');\n\t}\n}\n\nasync function processDeletion({ uid, method, password, caller }) {\n\tconst isTargetAdmin = await user.isAdministrator(uid);\n\tconst isSelf = parseInt(uid, 10) === parseInt(caller.uid, 10);\n\tconst hasAdminPrivilege = await privileges.admin.can('admin:users', caller.uid);\n\n\tif (isSelf && meta.config.allowAccountDelete !== 1) {\n\t\tthrow new Error('[[error:account-deletion-disabled]]');\n\t} else if (!isSelf && !hasAdminPrivilege) {\n\t\tthrow new Error('[[error:no-privileges]]');\n\t} else if (isTargetAdmin) {\n\t\tthrow new Error('[[error:cant-delete-admin]');\n\t}\n\n\t// Privilege checks -- only deleteAccount is available for non-admins\n\tif (!hasAdminPrivilege && ['delete', 'deleteContent'].includes(method)) {\n\t\tthrow new Error('[[error:no-privileges]]');\n\t}\n\n\t// Self-deletions require a password\n\tconst hasPassword = await user.hasPassword(uid);\n\tif (isSelf && hasPassword) {\n\t\tconst ok = await user.isPasswordCorrect(uid, password, caller.ip);\n\t\tif (!ok) {\n\t\t\tthrow new Error('[[error:invalid-password]]');\n\t\t}\n\t}\n\n\tawait flags.resolveFlag('user', uid, caller.uid);\n\n\tlet userData;\n\tif (method === 'deleteAccount') {\n\t\tuserData = await user[method](uid);\n\t} else {\n\t\tuserData = await user[method](caller.uid, uid);\n\t}\n\tuserData = userData || {};\n\n\tsockets.server.sockets.emit('event:user_status_change', { uid: caller.uid, status: 'offline' });\n\n\tplugins.hooks.fire('action:user.delete', {\n\t\tcallerUid: caller.uid,\n\t\tuid: uid,\n\t\tip: caller.ip,\n\t\tuser: userData,\n\t});\n\n\tawait events.log({\n\t\ttype: `user-${method}`,\n\t\tuid: caller.uid,\n\t\ttargetUid: uid,\n\t\tip: caller.ip,\n\t\tusername: userData.username,\n\t\temail: userData.email,\n\t});\n}\n\nasync function canDeleteUids(uids) {\n\tif (!Array.isArray(uids)) {\n\t\tthrow new Error('[[error:invalid-data]]');\n\t}\n\tconst isMembers = await groups.isMembers(uids, 'administrators');\n\tif (isMembers.includes(true)) {\n\t\tthrow new Error('[[error:cant-delete-other-admins]]');\n\t}\n\n\treturn true;\n}\n\nusersAPI.search = async function (caller, data) {\n\tif (!data) {\n\t\tthrow new Error('[[error:invalid-data]]');\n\t}\n\tconst [allowed, isPrivileged] = await Promise.all([\n\t\tprivileges.global.can('search:users', caller.uid),\n\t\tuser.isPrivileged(caller.uid),\n\t]);\n\tlet filters = data.filters || [];\n\tfilters = Array.isArray(filters) ? filters : [filters];\n\tif (!allowed ||\n\t\t((\n\t\t\tdata.searchBy === 'ip' ||\n\t\t\tdata.searchBy === 'email' ||\n\t\t\tfilters.includes('banned') ||\n\t\t\tfilters.includes('flagged')\n\t\t) && !isPrivileged)\n\t) {\n\t\tthrow new Error('[[error:no-privileges]]');\n\t}\n\treturn await user.search({\n\t\tquery: data.query,\n\t\tsearchBy: data.searchBy || 'username',\n\t\tpage: data.page || 1,\n\t\tsortBy: data.sortBy || 'lastonline',\n\t\tfilters: filters,\n\t});\n};\n\nusersAPI.changePicture = async (caller, data) => {\n\tif (!data) {\n\t\tthrow new Error('[[error:invalid-data]]');\n\t}\n\n\tconst { type, url } = data;\n\tlet picture = '';\n\n\tawait user.checkMinReputation(caller.uid, data.uid, 'min:rep:profile-picture');\n\tconst canEdit = await privileges.users.canEdit(caller.uid, data.uid);\n\tif (!canEdit) {\n\t\tthrow new Error('[[error:no-privileges]]');\n\t}\n\n\tif (type === 'default') {\n\t\tpicture = '';\n\t} else if (type === 'uploaded') {\n\t\tpicture = await user.getUserField(data.uid, 'uploadedpicture');\n\t} else if (type === 'external' && url) {\n\t\tpicture = validator.escape(url);\n\t} else {\n\t\tconst returnData = await plugins.hooks.fire('filter:user.getPicture', {\n\t\t\tuid: caller.uid,\n\t\t\ttype: type,\n\t\t\tpicture: undefined,\n\t\t});\n\t\tpicture = returnData && returnData.picture;\n\t}\n\n\tconst validBackgrounds = await user.getIconBackgrounds(caller.uid);\n\tif (!validBackgrounds.includes(data.bgColor)) {\n\t\tdata.bgColor = validBackgrounds[0];\n\t}\n\n\tawait user.updateProfile(caller.uid, {\n\t\tuid: data.uid,\n\t\tpicture: picture,\n\t\t'icon:bgColor': data.bgColor,\n\t}, ['picture', 'icon:bgColor']);\n};\n\nusersAPI.generateExport = async (caller, { uid, type }) => {\n\tconst count = await db.incrObjectField('locks', `export:${uid}${type}`);\n\tif (count > 1) {\n\t\tthrow new Error('[[error:already-exporting]]');\n\t}\n\n\tconst child = require('child_process').fork(`./src/user/jobs/export-${type}.js`, [], {\n\t\tenv: process.env,\n\t});\n\tchild.send({ uid });\n\tchild.on('error', async (err) => {\n\t\twinston.error(err.stack);\n\t\tawait db.deleteObjectField('locks', `export:${uid}${type}`);\n\t});\n\tchild.on('exit', async () => {\n\t\tawait db.deleteObjectField('locks', `export:${uid}${type}`);\n\t\tconst userData = await user.getUserFields(uid, ['username', 'userslug']);\n\t\tconst { displayname } = userData;\n\t\tconst n = await notifications.create({\n\t\t\tbodyShort: `[[notifications:${type}-exported, ${displayname}]]`,\n\t\t\tpath: `/api/user/${userData.userslug}/export/${type}`,\n\t\t\tnid: `${type}:export:${uid}`,\n\t\t\tfrom: uid,\n\t\t});\n\t\tawait notifications.push(n, [caller.uid]);\n\t\tawait events.log({\n\t\t\ttype: `export:${type}`,\n\t\t\tuid: caller.uid,\n\t\t\ttargetUid: uid,\n\t\t\tip: caller.ip,\n\t\t});\n\t});\n};\n", "output": {"vulnerability_count": 2, "vulnerabilities": [{"description": "Using non-static data to retrieve and run functions from the object is dangerous. If the data is user-controlled, it may allow executing arbitrary code.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 338}, {"description": "Using non-static data to retrieve and run functions from the object is dangerous. If the data is user-controlled, it may allow executing arbitrary code.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 340}]}}
{"CVE": "CVE-2023-26046", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "package teler\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"net/http\"\n\n\t\"github.com/kitabisa/teler-waf/request\"\n\t\"github.com/kitabisa/teler-waf/threat\"\n\t\"gitlab.com/golang-commonmark/mdurl\"\n)\n\n// inThreatIndex checks if the given substring is in specific threat datasets\nfunc (t *Teler) inThreatIndex(kind threat.Threat, substr string) bool {\n\tif i := strings.Index(t.threat.data[kind], substr); i >= 0 {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// inWhitelist checks if the given substring is in whitelist patterns\nfunc (t *Teler) inWhitelist(r *http.Request) bool {\n\turi := toURLDecode(r.URL.RequestURI())\n\theaders := headersToRawString(r.Header)\n\tclientIP := getClientIP(r)\n\n\t// Check the request URI, headers, and client IP address against the whitelist\n\tfor _, pattern := range t.whitelistRegexes {\n\t\tif pattern.MatchString(uri) || pattern.MatchString(headers) || pattern.MatchString(clientIP) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// headersToRawString converts a map of http.Header to\n// multiline string, example:\n// from,\n//\n//\tHeader = map[string][]string{\n//\t\t\"Accept-Encoding\": {\"gzip, deflate\"},\n//\t\t\"Accept-Language\": {\"en-us\"},\n//\t\t\"Foo\": {\"Bar\", \"two\"},\n//\t}\n//\n// to\n//\n//\tHost: example.com\n//\taccept-encoding: gzip, deflate\n//\tAccept-Language: en-us\n//\tfOO: Bar\n//\tfoo: two\nfunc headersToRawString(headers http.Header) string {\n\tvar h strings.Builder\n\n\t// Iterate over the request headers and append each key-value pair to the builder\n\tfor key, values := range headers {\n\t\tfor _, value := range values {\n\t\t\th.WriteString(\n\t\t\t\tfmt.Sprintf(\"%s: %s\\n\", toURLDecode(key), toURLDecode(value)),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Returns the accumulated string of builder\n\treturn h.String()\n}\n\n// toURLDecode decode URL-decoded characters string using mdurl package\nfunc toURLDecode(s string) string {\n\treturn mdurl.Decode(s)\n}\n\n// isValidMethod check if the given request.Method is valid\nfunc isValidMethod(method request.Method) bool {\n\tswitch method {\n\tcase request.GET, request.HEAD, request.POST, request.PUT, request.PATCH:\n\tcase request.DELETE, request.CONNECT, request.OPTIONS, request.TRACE, request.ALL:\n\tcase \"\":\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// normalizeRawStringReader trim double-quotes of HTTP raw string,\n// replace double-escape of CR and LF, and double it in the end, and\n// returning as pointer of strings.Reader\nfunc normalizeRawStringReader(raw string) *strings.Reader {\n\tvar builder strings.Builder\n\n\traw = strings.Trim(raw, `\"`)\n\traw = strings.ReplaceAll(raw, \"\\\\n\", \"\\n\")\n\traw = strings.ReplaceAll(raw, \"\\\\r\", \"\\r\")\n\tbuilder.WriteString(raw)\n\tbuilder.WriteString(\"\\r\\n\\r\\n\")\n\n\treturn strings.NewReader(builder.String())\n}\n\n// getClientIP to get client IP address from request\nfunc getClientIP(r *http.Request) string {\n\t// Get the client's IP address from the X-Real-Ip header field\n\tclientIP := r.Header.Get(\"X-Real-Ip\")\n\n\t// If the X-Real-Ip header field is not present, try the X-Forwarded-For header field\n\tif clientIP == \"\" {\n\t\tclientIP = r.Header.Get(\"X-Forwarded-For\")\n\t}\n\n\t// If the X-Forwarded-For header field is not present, use the RemoteAddr field\n\tif clientIP == \"\" {\n\t\tclientIP = r.RemoteAddr\n\t}\n\n\t// Returning client IP address\n\treturn clientIP\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2023-26491", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "const entities = require('entities');\nconst cheerio = require('cheerio');\nconst { simplecc } = require('simplecc-wasm');\nconst got = require('@/utils/got');\nconst config = require('@/config').value;\nconst RE2 = require('re2');\n\nlet mercury_parser;\n\nconst resolveRelativeLink = ($, elem, attr, baseUrl) => {\n    const $elem = $(elem);\n\n    if (baseUrl) {\n        try {\n            const oldAttr = $elem.attr(attr);\n            if (oldAttr) {\n                // e.g. <video><source src=\"https://example.com\"></video> should leave <video> unchanged\n                $elem.attr(attr, new URL(oldAttr, baseUrl).href);\n            }\n        } catch (e) {\n            // no-empty\n        }\n    }\n};\n\nmodule.exports = async (ctx, next) => {\n    await next();\n\n    if (!ctx.state.data && !ctx._matchedRoute) {\n        // Given that the official demo has a cache TTL of 2h, a \"wrong path\" page will be cached by CloudFlare for\n        // 200h (8.33d).\n        // What makes it worse is that the documentation contains status badges to detect the availability of routes,\n        // but the documentation is updated more timely than the official demo, so the every example path of every\n        // new route will probably have a \"wrong path\" page cached for at least 200h soon after accepted. That is to\n        // say, the example paths of a new route will probably be unavailable on the public demo in the first 200h\n        // after accepted.\n        // As a conclusion, the next 3 lines has been commented out. (exactly the same behavior as any internal error)\n        // ctx.set({\n        //     'Cache-Control': `public, max-age=${config.cache.routeExpire * 100}`,\n        // });\n        throw Error('wrong path');\n    }\n\n    if (ctx.state.data) {\n        if ((!ctx.state.data.item || ctx.state.data.item.length === 0) && !ctx.state.data.allowEmpty) {\n            throw Error('this route is empty, please check the original site or <a href=\"https://github.com/DIYgod/RSSHub/issues/new/choose\">create an issue</a>');\n        }\n\n        // fix allowEmpty\n        ctx.state.data.item = ctx.state.data.item || [];\n\n        // decode HTML entities\n        ctx.state.data.title && (ctx.state.data.title = entities.decodeXML(ctx.state.data.title + ''));\n        ctx.state.data.description && (ctx.state.data.description = entities.decodeXML(ctx.state.data.description + ''));\n\n        // sort items\n        if (ctx.query.sorted !== 'false') {\n            ctx.state.data.item = ctx.state.data.item.sort((a, b) => +new Date(b.pubDate || 0) - +new Date(a.pubDate || 0));\n        }\n\n        const handleItem = (item) => {\n            item.title && (item.title = entities.decodeXML(item.title + ''));\n\n            // handle pubDate\n            if (item.pubDate) {\n                item.pubDate = new Date(item.pubDate).toUTCString();\n            }\n\n            // handle link\n            if (item.link) {\n                let baseUrl = ctx.state.data.link;\n                if (baseUrl && !baseUrl.match(/^https?:\\/\\//)) {\n                    if (baseUrl.match(/^\\/\\//)) {\n                        baseUrl = 'http:' + baseUrl;\n                    } else {\n                        baseUrl = 'http://' + baseUrl;\n                    }\n                }\n\n                item.link = new URL(item.link, baseUrl).href;\n            }\n\n            // handle description\n            if (item.description) {\n                const $ = cheerio.load(item.description);\n                let baseUrl = item.link || ctx.state.data.link;\n\n                if (baseUrl && !baseUrl.match(/^https?:\\/\\//)) {\n                    if (baseUrl.match(/^\\/\\//)) {\n                        baseUrl = 'http:' + baseUrl;\n                    } else {\n                        baseUrl = 'http://' + baseUrl;\n                    }\n                }\n\n                $('script').remove();\n\n                $('img').each((_, ele) => {\n                    const $ele = $(ele);\n\n                    // fix lazyload\n                    if (!$ele.attr('src')) {\n                        const lazySrc = $ele.attr('data-src') || $ele.attr('data-original');\n                        if (lazySrc) {\n                            $ele.attr('src', lazySrc);\n                        } else {\n                            for (const key in ele.attribs) {\n                                const value = ele.attribs[key].trim();\n                                if (['.gif', '.png', '.jpg', '.webp'].some((suffix) => value.includes(suffix))) {\n                                    $ele.attr('src', value);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    // redundant attributes\n                    ['onclick', 'onerror', 'onload'].forEach((e) => {\n                        $ele.removeAttr(e);\n                    });\n                });\n\n                // resolve relative link & fix referrer policy\n                // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy\n                // https://www.w3schools.com/tags/att_href.asp\n                $('a, area').each((_, elem) => {\n                    resolveRelativeLink($, elem, 'href', baseUrl);\n                    // $(elem).attr('rel', 'noreferrer');  // currently no such a need\n                });\n                // https://www.w3schools.com/tags/att_src.asp\n                $('img, video, audio, source, iframe, embed, track').each((_, elem) => {\n                    resolveRelativeLink($, elem, 'src', baseUrl);\n                });\n                $('video[poster]').each((_, elem) => {\n                    resolveRelativeLink($, elem, 'poster', baseUrl);\n                });\n                $('img, iframe').each((_, elem) => {\n                    $(elem).attr('referrerpolicy', 'no-referrer');\n                });\n\n                item.description = $('body').html() + '' + (config.suffix || '');\n\n                if (item._extra?.links && $('.rsshub-quote').length) {\n                    item._extra?.links?.map((e) => {\n                        e.content_html = $.html($('.rsshub-quote'));\n                        return e;\n                    });\n                }\n            }\n            return item;\n        };\n\n        ctx.state.data.item = await Promise.all(ctx.state.data.item.map(handleItem));\n\n        if (ctx.query) {\n            // limit\n            if (ctx.query.limit) {\n                ctx.state.data.item = ctx.state.data.item.slice(0, parseInt(ctx.query.limit));\n            }\n\n            // filter\n            const makeRegex = (string) => {\n                // default: case_senstivie = true\n                const engine = config.feature.filter_regex_engine;\n                if (ctx.query.filter_case_sensitive === 'false') {\n                    switch (engine) {\n                        case 'regexp':\n                            return new RegExp(string, 'i');\n                        case 're2':\n                            return new RE2(string, 'i');\n                        default:\n                            throw Error(`Invalid Engine Value: ${engine}, please check your config.`);\n                    }\n                } else {\n                    switch (engine) {\n                        case 'regexp':\n                            return new RegExp(string);\n                        case 're2':\n                            return new RE2(string);\n                        default:\n                            throw Error(`Invalid Engine Value: ${engine}, please check your config.`);\n                    }\n                }\n            };\n\n            if (ctx.query.filter) {\n                ctx.state.data.item = ctx.state.data.item.filter((item) => {\n                    const title = item.title || '';\n                    const description = item.description || title;\n                    const author = item.author || '';\n                    const category = item.category ? (Array.isArray(item.category) ? item.category : [item.category]) : [];\n                    const isFilter =\n                        title.match(makeRegex(ctx.query.filter)) || description.match(makeRegex(ctx.query.filter)) || author.match(makeRegex(ctx.query.filter)) || category.some((c) => c.match(makeRegex(ctx.query.filter)));\n                    return isFilter;\n                });\n            }\n\n            // filterfilter_title/description/author/category\n            if (!ctx.query.filter && (ctx.query.filter_title || ctx.query.filter_description || ctx.query.filter_author || ctx.query.filter_category)) {\n                ctx.state.data.item = ctx.state.data.item.filter((item) => {\n                    const title = item.title || '';\n                    const description = item.description || title;\n                    const author = item.author || '';\n                    const category = item.category ? (Array.isArray(item.category) ? item.category : [item.category]) : [];\n                    let isFilter = true;\n                    ctx.query.filter_title && (isFilter = title.match(makeRegex(ctx.query.filter_title)));\n                    ctx.query.filter_description && (isFilter = isFilter && description.match(makeRegex(ctx.query.filter_description)));\n                    ctx.query.filter_author && (isFilter = isFilter && author.match(makeRegex(ctx.query.filter_author)));\n                    ctx.query.filter_category && (isFilter = isFilter && category.some((c) => c.match(makeRegex(ctx.query.filter_category))));\n                    return isFilter;\n                });\n            }\n\n            if (ctx.query.filterout || ctx.query.filterout_title || ctx.query.filterout_description || ctx.query.filterout_author || ctx.query.filterout_category) {\n                if (ctx.query.filterout) {\n                    ctx.query.filterout_title = ctx.query.filterout;\n                    ctx.query.filterout_description = ctx.query.filterout;\n                }\n                ctx.state.data.item = ctx.state.data.item.filter((item) => {\n                    const title = item.title;\n                    const description = item.description || title;\n                    const author = item.author || '';\n                    const category = item.category ? (Array.isArray(item.category) ? item.category : [item.category]) : [];\n                    let isFilter = true;\n                    ctx.query.filterout_title && (isFilter = !title.match(makeRegex(ctx.query.filterout_title)));\n                    ctx.query.filterout_description && (isFilter = isFilter && !description.match(makeRegex(ctx.query.filterout_description)));\n                    ctx.query.filterout_author && (isFilter = isFilter && !author.match(makeRegex(ctx.query.filterout_author)));\n                    ctx.query.filterout_category && (isFilter = isFilter && !category.some((c) => c.match(makeRegex(ctx.query.filterout_category))));\n                    return isFilter;\n                });\n            }\n\n            if (ctx.query.filter_time) {\n                const now = Date.now();\n                ctx.state.data.item = ctx.state.data.item.filter(({ pubDate }) => {\n                    let isFilter = true;\n                    try {\n                        isFilter = !pubDate || now - new Date(pubDate).getTime() <= parseInt(ctx.query.filter_time) * 1000;\n                    } catch (err) {\n                        // no-empty\n                    }\n                    return isFilter;\n                });\n            }\n\n            // telegram instant view\n            if (ctx.query.tgiv) {\n                ctx.state.data.item.map((item) => {\n                    const encodedlink = encodeURIComponent(item.link);\n                    item.link = `https://t.me/iv?url=${encodedlink}&rhash=${ctx.query.tgiv}`;\n                    return item;\n                });\n            }\n\n            // fulltext\n            if (ctx.query.mode && ctx.query.mode.toLowerCase() === 'fulltext') {\n                const tasks = ctx.state.data.item.map(async (item) => {\n                    const { link, author, description } = item;\n                    const parsed_result = await ctx.cache.tryGet(`mercury-cache-${link}`, async () => {\n                        // if parser failed, return default description and not report error\n                        try {\n                            mercury_parser = mercury_parser || require('@postlight/parser');\n\n                            const { data: res } = await got(link);\n                            const $ = cheerio.load(res);\n                            const result = await mercury_parser.parse(link, {\n                                html: $.html(),\n                            });\n                            return result;\n                        } catch (e) {\n                            // no-empty\n                        }\n                    });\n\n                    item.author = author || (parsed_result ? parsed_result.author : '');\n                    item.description = parsed_result && parsed_result.content.length > 40 ? entities.decodeXML(parsed_result.content) : description;\n                });\n                await Promise.all(tasks);\n            }\n\n            // scihub\n            if (ctx.query.scihub) {\n                ctx.state.data.item.map((item) => {\n                    item.link = item.doi ? `${config.scihub.host}${item.doi}` : `${config.scihub.host}${item.link}`;\n                    return item;\n                });\n            }\n\n            // opencc\n            if (ctx.query.opencc) {\n                ctx.state.data.item.forEach((item) => {\n                    item.title = simplecc(item.title ?? item.link, ctx.query.opencc);\n                    item.description = simplecc(item.description ?? item.title ?? item.link, ctx.query.opencc);\n                });\n            }\n\n            // brief\n            if (ctx.query.brief) {\n                const num = /[1-9]\\d{2,}/;\n                if (num.test(ctx.query.brief)) {\n                    ctx.query.brief = parseInt(ctx.query.brief);\n                    ctx.state.data.item.forEach((item) => {\n                        let text;\n                        if (item.description) {\n                            text = item.description.replace(/<\\/?[^>]+(>|$)/g, '');\n                        }\n                        if (text && text.length) {\n                            if (text.length > ctx.query.brief) {\n                                item.description = `<p>${text.substring(0, ctx.query.brief)}</p>`;\n                            } else {\n                                item.description = `<p>${text}</p>`;\n                            }\n                        }\n                    });\n                } else {\n                    throw Error(`Invalid parameter <code>brief=${ctx.query.brief}</code>. Please check the doc https://docs.rsshub.app/parameter.html#shu-chu-jian-xun`);\n                }\n            }\n\n            // some parameters are processed in `anti-hotlink.js`\n        }\n    }\n};\n", "output": {"vulnerability_count": 12, "vulnerabilities": [{"description": "User controlled data in a `$(...)` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 11}, {"description": "User controlled data in a jQuery's `.html(...)` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 145}, {"description": "JQuery's `html` function is susceptible to Cross Site Scripting (XSS) attacks. If you're just passing text, consider `text` instead. Otherwise, use a function that escapes HTML such as edX's `HtmlUtils.setHtml()`.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 145}, {"description": "RegExp() called with a `string` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 168}, {"description": "RegExp() called with a `string` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 177}, {"description": "`isFilter` is assigned twice; the first assignment is useless", "risk": "Medium", "conceptual_fix": "Not provided", "line": 205}, {"description": "`isFilter` is assigned twice; the first assignment is useless", "risk": "Medium", "conceptual_fix": "Not provided", "line": 224}, {"description": "User data flows into the host portion of this manually-constructed HTML. This can introduce a Cross-Site-Scripting (XSS) vulnerability if this comes from user-provided input. Consider using a sanitization library such as DOMPurify to sanitize the HTML within.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 309}, {"description": "This template literal looks like HTML and has interpolated variables. These variables are not HTML-encoded by default. If the variables contain HTML tags, these may be interpreted by the browser, resulting in cross-site scripting (XSS).", "risk": "Medium", "conceptual_fix": "Not provided", "line": 309}, {"description": "This template literal looks like HTML and has interpolated variables. These variables are not HTML-encoded by default. If the variables contain HTML tags, these may be interpreted by the browser, resulting in cross-site scripting (XSS).", "risk": "Medium", "conceptual_fix": "Not provided", "line": 311}, {"description": "User data flows into the host portion of this manually-constructed HTML. This can introduce a Cross-Site-Scripting (XSS) vulnerability if this comes from user-provided input. Consider using a sanitization library such as DOMPurify to sanitize the HTML within.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 316}, {"description": "This template literal looks like HTML and has interpolated variables. These variables are not HTML-encoded by default. If the variables contain HTML tags, these may be interpreted by the browser, resulting in cross-site scripting (XSS).", "risk": "Medium", "conceptual_fix": "Not provided", "line": 316}]}}
{"CVE": "CVE-2023-27489", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "# pylint: disable=wildcard-import, unused-wildcard-import\n\"\"\"\n    Django settings for devel env.\n\"\"\"\n\nimport os\n\nfrom .common import *  # noqa: F403\n\n# Debug settings\nDEBUG = True\n\n# Database settings\nDATABASES = {\n    \"default\": {\n        \"ENGINE\": \"django.db.backends.sqlite3\",\n        \"NAME\": str(TEMP_DIR / \"kiwi.devel.sqlite\"),  # noqa: F405\n        \"USER\": \"root\",\n        \"PASSWORD\": \"\",\n        \"HOST\": \"\",\n        \"PORT\": \"\",\n    }\n}\n\n\nCACHES = {\n    \"default\": {\n        \"BACKEND\": \"django.core.cache.backends.dummy.DummyCache\",\n    }\n}\n# django-debug-toolbar settings\n\nMIDDLEWARE += [  # noqa: F405\n    \"debug_toolbar.middleware.DebugToolbarMiddleware\",\n    \"tcms.core.middleware.ExtraHeadersMiddleware\",\n]\n\nINSTALLED_APPS += [\"debug_toolbar\"]  # noqa: F405\n\nMEDIA_ROOT = os.path.join(TCMS_ROOT_PATH, \"..\", \"uploads\")  # noqa: F405\n\n# Needed by django.template.context_processors.debug:\n# See:\n# http://docs.djangoproject.com/en/dev/ref/templates/api/#django-template-context-processors-debug\nINTERNAL_IPS = (\"127.0.0.1\",)\n\nSTATICFILES_STORAGE = \"tcms.tests.storage.RaiseWhenFileNotFound\"\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2023-27592", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "// Copyright 2017 Frdric Guillot. All rights reserved.\n// Use of this source code is governed by the Apache 2.0\n// license that can be found in the LICENSE file.\n\npackage ui // import \"miniflux.app/ui\"\n\nimport (\n\t\"crypto/hmac\"\n\t\"crypto/sha256\"\n\t\"encoding/base64\"\n\t\"errors\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"miniflux.app/config\"\n\t\"miniflux.app/crypto\"\n\t\"miniflux.app/http/request\"\n\t\"miniflux.app/http/response\"\n\t\"miniflux.app/http/response/html\"\n\t\"miniflux.app/logger\"\n)\n\nfunc (h *handler) mediaProxy(w http.ResponseWriter, r *http.Request) {\n\t// If we receive a \"If-None-Match\" header, we assume the media is already stored in browser cache.\n\tif r.Header.Get(\"If-None-Match\") != \"\" {\n\t\tw.WriteHeader(http.StatusNotModified)\n\t\treturn\n\t}\n\n\tencodedDigest := request.RouteStringParam(r, \"encodedDigest\")\n\tencodedURL := request.RouteStringParam(r, \"encodedURL\")\n\tif encodedURL == \"\" {\n\t\thtml.BadRequest(w, r, errors.New(\"No URL provided\"))\n\t\treturn\n\t}\n\n\tdecodedDigest, err := base64.URLEncoding.DecodeString(encodedDigest)\n\tif err != nil {\n\t\thtml.BadRequest(w, r, errors.New(\"Unable to decode this Digest\"))\n\t\treturn\n\t}\n\n\tdecodedURL, err := base64.URLEncoding.DecodeString(encodedURL)\n\tif err != nil {\n\t\thtml.BadRequest(w, r, errors.New(\"Unable to decode this URL\"))\n\t\treturn\n\t}\n\n\tmac := hmac.New(sha256.New, config.Opts.ProxyPrivateKey())\n\tmac.Write(decodedURL)\n\texpectedMAC := mac.Sum(nil)\n\n\tif !hmac.Equal(decodedDigest, expectedMAC) {\n\t\thtml.Forbidden(w, r)\n\t\treturn\n\t}\n\n\tmediaURL := string(decodedURL)\n\tlogger.Debug(`[Proxy] Fetching %q`, mediaURL)\n\n\treq, err := http.NewRequest(\"GET\", mediaURL, nil)\n\tif err != nil {\n\t\thtml.ServerError(w, r, err)\n\t\treturn\n\t}\n\n\t// Note: User-Agent HTTP header is omitted to avoid being blocked by bot protection mechanisms.\n\treq.Header.Add(\"Connection\", \"close\")\n\n\tforwardedRequestHeader := []string{\"Range\", \"Accept\", \"Accept-Encoding\"}\n\tfor _, requestHeaderName := range forwardedRequestHeader {\n\t\tif r.Header.Get(requestHeaderName) != \"\" {\n\t\t\treq.Header.Add(requestHeaderName, r.Header.Get(requestHeaderName))\n\t\t}\n\t}\n\n\tclt := &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tIdleConnTimeout: time.Duration(config.Opts.ProxyHTTPClientTimeout()) * time.Second,\n\t\t},\n\t\tTimeout: time.Duration(config.Opts.ProxyHTTPClientTimeout()) * time.Second,\n\t}\n\n\tresp, err := clt.Do(req)\n\tif err != nil {\n\t\thtml.ServerError(w, r, err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode == http.StatusRequestedRangeNotSatisfiable {\n\t\tlogger.Error(`[Proxy] Status Code is %d for URL %q`, resp.StatusCode, mediaURL)\n\t\thtml.RequestedRangeNotSatisfiable(w, r, resp.Header.Get(\"Content-Range\"))\n\t\treturn\n\t}\n\tif resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusPartialContent {\n\t\tlogger.Error(`[Proxy] Status Code is %d for URL %q`, resp.StatusCode, mediaURL)\n\t\thtml.NotFound(w, r)\n\t\treturn\n\t}\n\n\tetag := crypto.HashFromBytes(decodedURL)\n\n\tresponse.New(w, r).WithCaching(etag, 72*time.Hour, func(b *response.Builder) {\n\t\tb.WithStatus(resp.StatusCode)\n\t\tb.WithHeader(\"Content-Security-Policy\", `default-src 'self'`)\n\t\tb.WithHeader(\"Content-Type\", resp.Header.Get(\"Content-Type\"))\n\t\tforwardedResponseHeader := []string{\"Content-Encoding\", \"Content-Type\", \"Content-Length\", \"Accept-Ranges\", \"Content-Range\"}\n\t\tfor _, responseHeaderName := range forwardedResponseHeader {\n\t\t\tif resp.Header.Get(responseHeaderName) != \"\" {\n\t\t\t\tb.WithHeader(responseHeaderName, resp.Header.Get(responseHeaderName))\n\t\t\t}\n\t\t}\n\t\tb.WithBody(resp.Body)\n\t\tb.WithoutCompression()\n\t\tb.Write()\n\t})\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2023-29202", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.rendering.internal.macro.rss;\n\nimport java.io.StringReader;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Singleton;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.xwiki.bridge.SkinAccessBridge;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.context.Execution;\nimport org.xwiki.rendering.block.Block;\nimport org.xwiki.rendering.block.GroupBlock;\nimport org.xwiki.rendering.block.ImageBlock;\nimport org.xwiki.rendering.block.LinkBlock;\nimport org.xwiki.rendering.block.ParagraphBlock;\nimport org.xwiki.rendering.block.RawBlock;\nimport org.xwiki.rendering.listener.reference.ResourceReference;\nimport org.xwiki.rendering.listener.reference.ResourceType;\nimport org.xwiki.rendering.macro.MacroExecutionException;\nimport org.xwiki.rendering.macro.box.AbstractBoxMacro;\nimport org.xwiki.rendering.macro.descriptor.DefaultContentDescriptor;\nimport org.xwiki.rendering.macro.rss.RssMacroParameters;\nimport org.xwiki.rendering.parser.ParseException;\nimport org.xwiki.rendering.parser.Parser;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.transformation.MacroTransformationContext;\n\nimport com.sun.syndication.feed.synd.SyndEntry;\nimport com.sun.syndication.feed.synd.SyndFeed;\n\n/**\n * Macro that output latest feed entries from a RSS feed.\n * \n * @version $Id$\n * @since 1.8RC1\n */\n@Component\n@Named(\"rss\")\n@Singleton\npublic class RssMacro extends AbstractBoxMacro<RssMacroParameters>\n{\n    /**\n     * The name of the CSS class attribute.\n     */\n    private static final String CLASS_ATTRIBUTE = \"class\";\n\n    private static final String FEED_CLASS_VALUE = \"rssfeed\";\n\n    private static final String FEED_PROPERTY = \"RssMacro.feed\";\n\n    /**\n     * The description of the macro.\n     */\n    private static final String DESCRIPTION = \"Output latest feed entries from a RSS feed.\";\n\n    /**\n     * The relative skin path of the feed icon to be displayed in the channel title.\n     */\n    private static final String FEED_ICON_RESOURCE_PATH = \"icons/silk/feed.png\";\n\n    /**\n     * Used to get the RSS icon.\n     */\n    @Inject\n    private SkinAccessBridge skinAccessBridge;\n\n    /**\n     * Needed to parse the ordinary text.\n     */\n    @Inject\n    @Named(\"plain/1.0\")\n    private Parser plainTextParser;\n\n    /**\n     * Needed to keep the feed information.\n     */\n    @Inject\n    private Execution execution;\n\n    /**\n     * Create a Feed object from a feed specified as a URL.\n     */\n    private RomeFeedFactory romeFeedFactory = new DefaultRomeFeedFactory();\n\n    /**\n     * Create and initialize the descriptor of the macro.\n     */\n    public RssMacro()\n    {\n        super(\"RSS\", DESCRIPTION, new DefaultContentDescriptor(DESCRIPTION, false), RssMacroParameters.class);\n        setDefaultCategories(Set.of(DEFAULT_CATEGORY_CONTENT));\n    }\n\n    @Override\n    public boolean supportsInlineMode()\n    {\n        return false;\n    }\n\n    /**\n     * Allow to save the current processed feed in the context, to be able to retrieve without concurrency issue.\n     * @param feed the feed to save in the current context.\n     */\n    private void setFeed(SyndFeed feed)\n    {\n        this.execution.getContext().setProperty(FEED_PROPERTY, feed);\n    }\n\n    /**\n     * Retrieve the feed of the current context.\n     * @return the feed that is being processed in the macro.\n     */\n    private SyndFeed getFeed()\n    {\n        return (SyndFeed) this.execution.getContext().getProperty(FEED_PROPERTY);\n    }\n\n    /**\n     * Remove the feed information from the current context.\n     */\n    private void removeContextFeed()\n    {\n        this.execution.getContext().removeProperty(FEED_PROPERTY);\n    }\n\n    @Override\n    protected ResourceReference getImageReference(RssMacroParameters parameters, String content,\n        MacroTransformationContext context)\n    {\n        if (parameters.isImage() && getFeed().getImage() != null) {\n            return new ResourceReference(getFeed().getImage().getUrl(), ResourceType.URL);\n        } else {\n            return super.getImageReference(parameters, content, context);\n        }\n    }\n\n    @Override\n    protected List<? extends Block> getBlockTitle(RssMacroParameters parameters, String content,\n        MacroTransformationContext context)\n    {\n        List<? extends Block> blockTitle = super.getBlockTitle(parameters, content, context);\n\n        if (blockTitle == null) {\n            return generateBoxTitle(\"rsschanneltitle\", getFeed());\n        } else {\n            return blockTitle;\n        }\n    }\n\n    @Override\n    protected String getClassProperty()\n    {\n        return super.getClassProperty() + ' ' + FEED_CLASS_VALUE;\n    }\n\n    @Override\n    public List<Block> execute(RssMacroParameters parameters, String content, MacroTransformationContext context)\n        throws MacroExecutionException\n    {\n        List<Block> result;\n        SyndFeed feed = this.romeFeedFactory.createFeed(parameters);\n\n        // we save the feed in the current context to be able to retrieve it\n        // we avoid to put it in a class field, to avoid concurrent exceptions\n        this.setFeed(feed);\n\n        if (parameters.isDecoration()) {\n            result = super.execute(parameters, content == null ? StringUtils.EMPTY : content, context);\n        } else {\n            result = Arrays.<Block>asList(new GroupBlock(Collections.singletonMap(CLASS_ATTRIBUTE, FEED_CLASS_VALUE)));\n        }\n\n        generateEntries(result.get(0), feed, parameters);\n\n        // clean the context\n        this.removeContextFeed();\n        return result;\n    }\n\n    @Override\n    protected List<Block> parseContent(RssMacroParameters parameters, String content,\n        MacroTransformationContext context) throws MacroExecutionException\n    {\n        return this.getMacroContentParser().parse(content, context, false, context.isInline()).getChildren();\n    }\n\n    /**\n     * Renders the RSS's title.\n     * \n     * @param cssClass the CSS sheet\n     * @param feed the RSS feed data\n     * @return the list of blocks making the RSS Box title\n     */\n    private List< ? extends Block> generateBoxTitle(String cssClass, SyndFeed feed)\n    {\n        List<Block> titleBlocks;\n\n        if (feed.getLink() == null) {\n            titleBlocks = parsePlainText(feed.getTitle());\n        } else {\n            // Title link.\n            ResourceReference titleResourceReference = new ResourceReference(feed.getLink(), ResourceType.URL);\n\n            // Title text link.\n            Block titleTextLinkBlock = new LinkBlock(parsePlainText(feed.getTitle()), titleResourceReference, true);\n\n            // Rss icon.\n            String imagePath = this.skinAccessBridge.getSkinFile(FEED_ICON_RESOURCE_PATH);\n            ImageBlock imageBlock = new ImageBlock(new ResourceReference(imagePath, ResourceType.URL), false);\n\n            // Title rss icon link.\n            Block titleImageLinkBlock = new LinkBlock(Arrays.<Block> asList(imageBlock), titleResourceReference, true);\n\n            titleBlocks = Arrays.<Block> asList(titleTextLinkBlock, titleImageLinkBlock);\n        }\n        ParagraphBlock titleBlock = new ParagraphBlock(titleBlocks);\n        titleBlock.setParameter(CLASS_ATTRIBUTE, cssClass);\n\n        return Collections.singletonList(titleBlock);\n    }\n\n    /**\n     * Renders the given RSS's entries.\n     * \n     * @param parentBlock the parent Block to which the output is going to be added\n     * @param feed the RSS Channel we retrieved via the Feed URL\n     * @param parameters our parameter helper object\n     * @throws MacroExecutionException if the content cannot be rendered\n     */\n    private void generateEntries(Block parentBlock, SyndFeed feed, RssMacroParameters parameters)\n        throws MacroExecutionException\n    {\n        int maxElements = parameters.getCount();\n        int count = 0;\n\n        for (Object item : feed.getEntries()) {\n            ++count;\n            if (count > maxElements) {\n                break;\n            }\n            SyndEntry entry = (SyndEntry) item;\n\n            ResourceReference titleResourceReference = new ResourceReference(entry.getLink(), ResourceType.URL);\n            Block titleBlock = new LinkBlock(parsePlainText(entry.getTitle()), titleResourceReference, true);\n            ParagraphBlock paragraphTitleBlock = new ParagraphBlock(Collections.singletonList(titleBlock));\n            paragraphTitleBlock.setParameter(CLASS_ATTRIBUTE, \"rssitemtitle\");\n            parentBlock.addChild(paragraphTitleBlock);\n\n            if (parameters.isContent() && entry.getDescription() != null) {\n                // We are wrapping the feed entry content in a HTML macro, not considering what the declared content\n                // is, because some feed will declare text while they actually contain HTML.\n                // See http://stuffthathappens.com/blog/2007/10/29/i-hate-rss/\n                // A case where doing this might hurt is if a feed declares \"text\" and has any XML inside it does\n                // not want to be interpreted as such, but displayed as is instead. But this certainly is too rare\n                // compared to mis-formed feeds that say text while they want to say HTML.\n                Block html = new RawBlock(entry.getDescription().getValue(), Syntax.XHTML_1_0);\n                parentBlock.addChild(new GroupBlock(Arrays.asList(html), Collections.singletonMap(CLASS_ATTRIBUTE,\n                    \"rssitemdescription\")));\n            }\n        }\n    }\n\n    /**\n     * @param romeFeedFactory a custom implementation to use instead of the default, useful for tests\n     */\n    protected void setFeedFactory(RomeFeedFactory romeFeedFactory)\n    {\n        this.romeFeedFactory = romeFeedFactory;\n    }\n\n    /**\n     * Convenience method to not have to handle exceptions in several places.\n     * \n     * @param content the content to parse as plain text\n     * @return the parsed Blocks\n     * @since 2.0M3\n     */\n    private List<Block> parsePlainText(String content)\n    {\n        if (StringUtils.isEmpty(content)) {\n            return Collections.emptyList();\n        }\n\n        try {\n            return this.plainTextParser.parse(new StringReader(content)).getChildren().get(0).getChildren();\n        } catch (ParseException e) {\n            // This shouldn't happen since the parser cannot throw an exception since the source is a memory\n            // String.\n            throw new RuntimeException(\"Failed to parse [\" + content + \"] as plain text\", e);\n        }\n    }\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2023-29207", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "## ---------------------------------------------------------------------------\n## See the NOTICE file distributed with this work for additional\n## information regarding copyright ownership.\n##\n## This is free software; you can redistribute it and/or modify it\n## under the terms of the GNU Lesser General Public License as\n## published by the Free Software Foundation; either version 2.1 of\n## the License, or (at your option) any later version.\n##\n## This software is distributed in the hope that it will be useful,\n## but WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n## Lesser General Public License for more details.\n##\n## You should have received a copy of the GNU Lesser General Public\n## License along with this software; if not, write to the Free\n## Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n## 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n## ---------------------------------------------------------------------------\n###############################################################\n## Contains various standard Velocity macros automatically\n## loaded and usable everywhere (in Velocity).\n## \n## Note that if you modify that file you will need to restart.\n###############################################################\n##\n## #template(\"name.vm\")\n## Searches for the given velocity template and interprets it.\n## Only the velocity parser is executed on the file.\n## The template is searched in the following locations, in this order:\n## - as a property of the XWikiSkins object attached to the current skin document\n## - as an attachment to the current skin document\n## - as a file in the directory corresponding to the current skin\n## - the above 3 locations corresponding to the base skin\n## - the above 3 locations corresponding to the default skin\n## - as a file in the /templates/ directory\n##\n#macro(template $tname)\n$xwiki.parseTemplate($tname)\n#end\n##\n##\n## #renderTemplate(\"name.vm\")\n## Searches for the given velocity template and renders it.\n## The template is searched in the following locations, in this order:\n## - as a property of the XWikiSkins object attached to the current skin document\n## - as an attachment to the current skin document\n## - as a file in the directory corresponding to the current skin\n## - the above 3 locations corresponding to the base skin\n## - the above 3 locations corresponding to the default skin\n## - as a file in the /templates/ directory\n##\n#macro(renderTemplate $tname )\n$xwiki.renderTemplate($tname)\n#end\n##\n##\n## #includeTopic(\"Space.Document\")\n## Includes another fully rendered document inside the current response.\n## The topic is interpreted and rendered exactly as if it were viewed in a separate response,\n## meaning that the $doc variable will point to the included document. The resulting string is\n## wrapped with {pre}...{/pre}, in order to prevent double-rendering.\n## The platform prevents recursive includes.\n## This macro is useful for creating composite documents from smaller parts, or the other way around,\n## splitting a large document into smaller distinct chunks which can be edited in parallel.\n##\n#macro(includeTopic $topic)\n$xwiki.includeTopic($topic)\n#end\n##\n##\n## #includeMacros(\"Space.Document\")\n## Includes the content of another document as velocity macros. Because of the way the velocity\n## engine works, trying to place macros in another document and including it with another method\n## will not have the expected result. Other than making the macros available, it works just as\n## #includeForm($topic)\n##\n#macro(includeMacros $topic)\n$xwiki.includeForm($topic)\n#end\n##\n##\n## #includeForm(\"Space.Document\")\n## Includes another fully rendered document inside the current response.\n## The included content is interpreted and rendered in the current context, meaning that $doc will\n## point to the current document (the includer), and not the included one. The resulting string is\n## wrapped with {pre}...{/pre}, in order to prevent double-rendering.\n## The platform prevents recursive includes.\n## This macro is the core of the document-template-sheet functionality of XWiki, where a document\n## has an XObject attached to it, its content consists of the \"#includeForm('Some.Sheet')\" statement,\n## and the sheet works just as if it were actually inside the document's content.\n##\n#macro(includeForm $topic)\n$xwiki.includeForm($topic)\n#end\n##\n##\n## #includeInContext(\"Some.Document\")\n## Alias for #includeForm\n##\n#macro(includeInContext $topic)\n$xwiki.includeForm($topic)\n#end\n##\n##\n## #includeServlet(\"/xwiki/bin/view/Some/Document?params\")\n## Invokes on the server another servlet corresponding to the passed URL, and returns the output.\n## This is done using standard servlet mechanisms (javax.servlet.RequestDispatcher#include).\n##\n#macro(includeServlet $url)\n<!-- including $url -->\n$xwiki.invokeServletAndReturnAsString($url)\n<!-- included $url -->\n#end\n##\n##\n##\n##\n## #skype(\"skypeId\")\n## Displays the status for the given Skype id\n##\n## @Deprecated\n#macro(skype $id)\n<a href=\"skype:${id}?call\"><img width=\"182\" height=\"44\" src=\"http://mystatus.skype.com/bigclassic/${id}\" style=\"border: none;\"></a>\n#end\n##\n##\n## #yahoo(\"yahooId\")\n## Displays the status for the given Yahoo! id\n##\n## @Deprecated\n#macro(yahoo $id)\n<img border=\"0\" src=\"http://opi.yahoo.com/online?u=${id}&amp;m=g&amp;t=1\" alt=\"yahoo $id\" />\n#end\n## #sign(\"XWiki.Username\")\n## Displays a \"signature\", a link to the user's profile page.\n##\n#macro(sign $username)\n#if($username.indexOf(\".\")==-1)\n#set($username = \"XWiki.${username}\")\n#end\n#if($xwiki.exists(\"$username\"))\n$xwiki.getUserName(\"$username\")\n#else\n$xwiki.getUserName(\"xwiki:${username}\")\n#end\n#end\n\n#macro(includeHelp $pagename)\n  #if($xwiki.exists(\"xwiki:XWiki.${pagename}\"))\n    $xwiki.includeForm(\"xwiki:XWiki.${pagename}\",false)\n  #else\n    #if($xwiki.exists(\"XWiki.${pagename}\"))\n      $xwiki.includeForm(\"XWiki.${pagename}\",false)\n    #end\n  #end\n#end\n\n#macro(toc $pinit $pmax $pnumbered)\n#set($init = $pinit)\n#set($max = $pmax)\n#set($numbered = $pnumbered)\n #set ($int = 0)\n #set ($boolean = false)\n #if ($init == \"\")\n  #set ($init = 2)\n #else\n  #set ($init = $int.valueOf($init))\n #end\n #if ($max == \"\")\n  #set ($max = 6)\n #else\n  #set ($max = $int.valueOf($max))\n #end\n #if ($numbered == \"\")\n  #set ($numbered = false)\n #else\n  #set ($numbered = $boolean.valueOf($numbered))\n #end\n #set ($tocData = ${tdoc.getTOC($init, $max, $numbered)})\n #set ($xcontext.tocData = $tocData)\n #set ($lastLevel = $init - 1)\n #set ($depth = 0)\n #set ($openeditem = true)\n<div class=\"toc\">\n #foreach ($tocEntry in $tocData.entrySet())\n  #set ($level = $tocEntry.value.level)\n  #if ($level > $lastLevel)\n   #set ($to = $lastLevel + 1)\n   #set ($iter = [$level .. $to])\n   #foreach ($n in $iter)\n    #if($openeditem)\n      #set($openeditem = false)\n    #else\n<li>\n    #end\n<ul class=\"tocLevel\">\n    #set ($depth = $depth + 1)\n   #end\n  #elseif ($level < $lastLevel)\n   #set ($to = $level + 1)\n   #set ($iter = [$lastLevel .. $to])\n</li>\n   #foreach ($n in $iter)\n</ul>\n</li>\n    #set ($depth = $depth - 1)\n   #end\n  #else\n</li>\n  #end\n <li class=\"tocEntry\"><a href=\"#$tocEntry.key\">$!tocEntry.value.numbering #evaluate($tocEntry.value.text)</a>\n  #set ($lastLevel = $level)\n  #set($openeditem = true)\n #end\n #if ($depth > 0)\n  #set ($levels = [1 .. $depth])\n  #foreach($level in $levels)\n </li>\n</ul>#end\n #end\n</div>\n#end\n\n\n###\n###    Separator\n###\n### Insert a span containing a |\n###\n#macro(sep)\n<span class=\"separator\"> | </span>\n#end\n\n\n#**\n * Displays the user avatar and name, linked to the user profile page.\n *\n * @param arg could be either a string, a reference or a list of them\n * @param options various configuration options; default values are {\n *   showAlias: false, // whether to show the user alias or not\n *   useInlineHTML: false, // whether to use in-line HTML elements to display the user or not\n *   wrapAvatar: false // whether to wrap the avatar image with a span or not\n * }\n *#\n#macro (displayUser $arg $options)\n  #if ($stringtool.isEmpty($arg))\n    #set ($arg = \"XWiki.XWikiGuest\")\n  #end\n  #set ($isList = $arg.iterator())\n  #if ($isList)\n    #set ($usersList = $arg)\n  #else\n    #set ($usersList = [$arg])\n  #end\n  #set ($macro.options = {\n    'showAlias': false,\n    'useInlineHTML': false,\n    'wrapAvatar': false\n  })\n  #if ($options.entrySet())\n    #set ($discard = $macro.options.putAll($options))\n  #end\n  #set ($usersTag = 'ul')\n  #set ($userTag = 'li')\n  #if ($macro.options.useInlineHTML)\n    #set ($usersTag = 'span')\n    #set ($userTag = 'span')\n  #elseif (!$isList)\n    #set ($userTag = 'div')\n  #end\n  #set ($types = $collectiontool.set)\n  #set ($output = [])\n  #foreach ($user in $usersList)\n    ## Since we accept both a String or an EntityReference as input, we first check if we have an Entity Reference\n    ## to a Document and if not then we resolve the String to convert it to a Document Reference.\n    #set ($userReference = $user.extractReference('DOCUMENT'))\n    #if (!$userReference)\n      #set ($userReference = $services.model.resolveDocument($user, 'user/current'))\n    #end\n    #set ($userAlias = $userReference.name)\n    #if ($userAlias == $services.model.getEntityReference('DOCUMENT', 'default'))\n      #set ($userAlias = $userReference.lastSpaceReference.name)\n    #end\n    #set ($userDocument = $xwiki.getDocument($userReference))\n    #if ($userDocument.getObject('XWiki.XWikiGroups'))\n      #set ($type = 'group')\n      #set ($userName = $userDocument.plainTitle)\n      #if (\"$!userName\" == '')\n        #set ($userName = $userAlias)\n      #end\n    #else\n      #set ($type = 'user')\n      #set ($userName = $xwiki.getPlainUserName($userReference))\n    #end\n    #set ($discard = $types.add(\"${type}s\"))\n    #set ($userAliasDisplay = '')\n    #if ($macro.options.showAlias && $userAlias != $userName)\n      #set ($userAliasDisplay = \"<span class=\"\"${type}-alias\"\">\" + $escapetool.xml($userAlias) + '</span>')\n    #end\n    #set ($escapedUserName = $escapetool.xml($userName))\n    #getUserAvatarURL($userReference $avatarURL 120)\n    #set ($avatarWrapperStart = '')\n    #set ($avatarWrapperEnd = '')\n    #if ($macro.options.wrapAvatar)\n      #set ($avatarWrapperStart = \"<span class=\"\"${type}-avatar-wrapper\"\">\")\n      #set ($avatarWrapperEnd = '</span>')\n    #end\n    ## We avoid the whitespace because the users are displayed as inline blocks.\n    #set ($discard = $output.addAll([\n      \"<$userTag class=\"\"$type\"\" data-reference=\"\"$escapetool.xml($userReference)\"\">\",\n        $avatarWrapperStart,\n          \"<img class=\"\"${type}-avatar\"\" src=\"\"$escapetool.xml($avatarURL.url)\"\" alt=\"\"$escapedUserName\"\" />\",\n        $avatarWrapperEnd,\n        \"<a class=\"\"${type}-name\"\" href=\"\"$escapetool.xml($xwiki.getURL($userReference))\"\">$escapedUserName</a>\",\n        $userAliasDisplay,\n      \"</$userTag>\"\n    ]))\n  #end\n  #if ($isList && $output.size() > 0)\n    #set ($discard = $output.add(0, \"<$usersTag class=\"\"$stringtool.join($types, ' ')\"\">\"))\n    #set ($discard = $output.add(\"</$usersTag>\"))\n  #end\n  $stringtool.join($output, '')\n#end\n\n#**\n * Displays the group avatar and name, linked to the group profile page.\n *\n * @param arg could be either a string, a reference or a list of them\n * @param options various configuration options; default values are {\n *   showAlias: false, // whether to show the group alias or not\n *   useInlineHTML: false, // whether to use in-line HTML elements to display the group or not\n *   wrapAvatar: false // whether to wrap the avatar image with a span or not\n * }\n *#\n#macro (displayGroup $arg $options)\n  #displayUser($arg $options)\n#end\n\n\n###\n###    useravatar\n###\n### Display the avatar of a user or a group, or a default image if the user/group has no avatar\n###\n### @param username The name of the user or group whose avatar will be displayed\n###\n#macro(getUserAvatarURL $userName $return $size)\n  #set ($specified = false)\n  #set ($profileDoc = $xwiki.getDocument($userName))\n  #if ($profileDoc.getObject('XWiki.XWikiGroups'))\n    #set ($url = $xwiki.getSkinFile('icons/xwiki/noavatargroup.png', true))\n  #else\n    #set ($url = $xwiki.getSkinFile('icons/xwiki/noavatar.png', true))\n  #end\n  #if ($profileDoc && !$profileDoc.isNew() && $profileDoc.attachmentList.size() > 0)\n    #set ($profileObj = $profileDoc.getObject('XWiki.XWikiUsers', 0))\n    #set ($avatarFileName = $profileObj.getProperty('avatar').value)\n    #if (\"$!avatarFileName\" != '')\n      #set ($avatarAttachment = $profileDoc.getAttachment($avatarFileName))\n    #elseif ($profileDoc.getObject('XWiki.XWikiGroups'))\n      ## Look for the first image attachment.\n      #foreach ($attachment in $profileDoc.attachmentList)\n        #if ($attachment.isImage())\n          #set ($avatarAttachment = $attachment)\n          #break\n        #end\n      #end\n    #else\n      ## This ensures that $avatarAttachment is always set before the following \"if\" is called, preventing a previous\n      ## call to this macro from leaking...\n      #set ($avatarAttachment = $NULL)\n    #end\n    #if ($avatarAttachment && $avatarAttachment.isImage())\n      #set ($queryString = '')\n      #if ($size > 0)\n        #set ($queryString = \"width=$size&height=$size&keepAspectRatio=true\")\n      #end\n      #set ($url = $profileDoc.getAttachmentURL($avatarAttachment.filename, 'download', $queryString))\n      #set ($specified = true)\n    #end\n  #end\n  #set ($return = $NULL)\n  #setVariable (\"$return\" {'url': $url, 'specified': $specified})\n#end\n#macro(resizedUserAvatar $username $size)\n  #if(!$picturelist)\n    #set($picturelist = {})\n  #end\n  #if(!$picturelist.containsKey(\"${username}--${size}\"))\n    #getUserAvatarURL($username $avatarURL $size)\n    #if ($avatarURL.specified)\n      #set ($picture = \"<img src='\")\n      #set ($picture = $picture.concat($escapetool.xml($avatarURL.url)))\n      #set ($picture = $picture.concat(\"' alt='\"))\n      #set ($picture = $picture.concat(${xwiki.getUserName($username, false)}))\n      #set ($picture = $picture.concat(\"' title='\"))\n      #set ($picture = $picture.concat(${xwiki.getUserName($username, false)}))\n      #set ($picture = $picture.concat(\"'/>\"))\n    #else\n      #set ($picture = \"<img class='avatar avatar_${escapetool.xml(${size})}' src='\")\n      #set ($picture = $picture.concat($avatarURL.url))\n      #set ($picture = $picture.concat(\"' alt='${xwiki.getUserName($username, false)}' title='${xwiki.getUserName($username, false)}'/>\"))\n    #end\n    #set ($discard = $!picturelist.put(\"${username}--${size}\", $picture))\n  #end\n  $picturelist.get(\"${username}--${size}\")##\n#end\n#macro(largeUserAvatar $username)\n  #resizedUserAvatar($username 120)\n#end\n#macro(mediumUserAvatar $username)\n  #resizedUserAvatar($username 50)\n#end\n#macro(smallUserAvatar $username)\n  #resizedUserAvatar($username 30)\n#end\n###\n###    useravatar\n###\n### Display the avatar of a user (HTML is returned), or a standard image if the user has no avatar\n###\n### @param username The name of the user whose avatar will be displayed\n###\n#macro(useravatar $username)\n  #resizedUserAvatar($username 0)\n#end\n\n###\n###    mimetypeimg\n###\n### Display an icon according to the mimetype\n###\n### @param mime The reported mimetype of the file\n### @param fname The name of the file\n###\n#macro(mimetypeimg $mime $fname)\n  #set($idx = $fname.lastIndexOf('.'))\n  #set($idx = $idx + 1)\n  #if(($idx != 0) && ($idx != -1))\n    #set($ext = $fname.substring($idx))\n  #else\n    #set($ext = '')\n  #end\n  ## Map mimetypes to their corresponding icons\n  #if(!$mimetypeMap)\n    #set($mimetypeMap = {})\n    ## images\n    #set($discard = $mimetypeMap.put('image/svg+xml',                      ['vector', 'svg']))\n    #set($discard = $mimetypeMap.put('application/svg+xml',                ['vector', 'svg']))\n    #set($discard = $mimetypeMap.put('image/svg',                          ['vector', 'svg']))\n    #set($discard = $mimetypeMap.put('image/svg+xml',                      ['vector', 'svg']))\n    #set($discard = $mimetypeMap.put('image/',                             ['image', 'image']))\n    ## text\n    #set($discard = $mimetypeMap.put('text/html',                          ['file-code', 'html']))\n    #set($discard = $mimetypeMap.put('text/css',                           ['file-code', 'css']))\n    #set($discard = $mimetypeMap.put('text/',                              ['file-text', 'text']))\n    ## documents\n    #set($discard = $mimetypeMap.put('application/xml',                    ['file-code', 'xml']))\n    #set($discard = $mimetypeMap.put('application/pdf',                    ['file-pdf', 'pdf']))\n    #set($discard = $mimetypeMap.put('application/postscript',             ['file-pdf', 'ps']))\n    #set($discard = $mimetypeMap.put('application/msword',                 ['file-word', 'document']))\n    #set($discard = $mimetypeMap.put('application/powerpoint',             ['file-powerpoint', 'presentation']))\n    #set($discard = $mimetypeMap.put('application/vnd.ms-powerpoint',      ['file-powerpoint', 'presentation']))\n    #set($discard = $mimetypeMap.put('application/vnd.oasis.opendocument', ['file', 'office']))\n    #set($discard = $mimetypeMap.put('application/x-shockwave-flash',      ['film', 'flash']))\n    ## archives\n    #set($discard = $mimetypeMap.put('application/x-tar',                  ['file-archive', 'tar']))\n    #set($discard = $mimetypeMap.put('application/x-gzip',                 ['file-archive', 'gz']))\n    #set($discard = $mimetypeMap.put('application/x-gtar',                 ['file-archive', 'gz']))\n    #set($discard = $mimetypeMap.put('application/zip',                    ['file-archive', 'zip']))\n    #set($discard = $mimetypeMap.put('application/java-archive',           ['coffee', 'jar']))\n    #set($discard = $mimetypeMap.put('audio/',                             ['music', 'audio']))\n    #set($discard = $mimetypeMap.put('video/',                             ['film', 'video']))\n  #end\n  #if(!$extensionMap)\n    ## Map extensions to their corresponding icons\n    #set($extensionMap = {})\n    ## media\n    #set($discard = $extensionMap.put('ogg',      ['music', 'audio']))\n    #set($discard = $extensionMap.put('flac',     ['music', 'audio']))\n    #set($discard = $extensionMap.put('ogv',      ['film', 'video']))\n    #set($discard = $extensionMap.put('mk',       ['film', 'video']))\n    #set($discard = $extensionMap.put('avi',      ['film', 'video']))\n    #set($discard = $extensionMap.put('divx',     ['film', 'video']))\n    #set($discard = $extensionMap.put('mov',      ['film', 'video']))\n    #set($discard = $extensionMap.put('flv',      ['film', 'flash']))\n    #set($discard = $extensionMap.put('fla',      ['film', 'flash']))\n    #set($discard = $extensionMap.put('swf',      ['film', 'flash']))\n    ## office\n    #set($discard = $extensionMap.put('ppt',      ['file-powerpoint', 'presentation']))\n    #set($discard = $extensionMap.put('odp',      ['file-powerpoint', 'presentation']))\n    #set($discard = $extensionMap.put('doc',      ['file-word', 'document']))\n    #set($discard = $extensionMap.put('odf',      ['file', 'document']))\n    #set($discard = $extensionMap.put('ods',      ['file-excel', 'spreadsheet']))\n    #set($discard = $extensionMap.put('xls',      ['file-excel', 'spreadsheet']))\n    #set($discard = $extensionMap.put('odt',      ['file-word', 'odt']))\n    #set($discard = $extensionMap.put('sxw',      ['file-word', 'office']))\n    #set($discard = $extensionMap.put('stw',      ['file-word', 'office']))\n    ## archives\n    #set($discard = $extensionMap.put('bz',       ['file-archive', 'bz']))\n    #set($discard = $extensionMap.put('bz2',      ['file-archive', 'bz']))\n    #set($discard = $extensionMap.put('tbz',      ['file-archive', 'bz']))\n    #set($discard = $extensionMap.put('gz',       ['file-archive', 'gz']))\n    #set($discard = $extensionMap.put('tgz',      ['file-archive', 'gz']))\n    #set($discard = $extensionMap.put('rar',      ['file-archive', 'rar']))\n    #set($discard = $extensionMap.put('7z',       ['file-archive', 'zip']))\n    ## development\n    #set($discard = $extensionMap.put('sql',      ['database', 'sql']))\n    #set($discard = $extensionMap.put('php',      ['file-code', 'php']))\n    #set($discard = $extensionMap.put('c',        ['file-code', 'c']))\n    #set($discard = $extensionMap.put('cpp',      ['file-code', 'cpp']))\n    #set($discard = $extensionMap.put('c++',      ['file-code', 'cpp']))\n    #set($discard = $extensionMap.put('cs',       ['file-code', 'cs']))\n    #set($discard = $extensionMap.put('h',        ['file-code', 'h']))\n    #set($discard = $extensionMap.put('ruby',     ['file-code', 'ruby']))\n    #set($discard = $extensionMap.put('java',     ['coffee', 'java']))\n    #set($discard = $extensionMap.put('js',       ['file-code', 'js']))\n    #set($discard = $extensionMap.put('csproj',   ['file-code', 'vs']))\n    #set($discard = $extensionMap.put('sln',      ['file-code', 'vs']))\n    #set($discard = $extensionMap.put('res',      ['file-code', 'vs']))\n    ## data\n    #set($discard = $extensionMap.put('ics',      ['calendar', 'calendar']))\n    #set($discard = $extensionMap.put('eml',      ['email', 'email']))\n    #set($discard = $extensionMap.put('vcf',      ['vcard', 'vcard']))\n    #set($discard = $extensionMap.put('vcard',    ['vcard', 'vcard']))\n    ## executables\n    #set($discard = $extensionMap.put('exe',      ['cog', 'exe']))\n    #set($discard = $extensionMap.put('bat',      ['terminal', 'script']))\n    #set($discard = $extensionMap.put('sh',       ['terminal', 'script']))\n  #end\n  #if($mimetypeMap.containsKey($mime))\n    #set ($image = $mimetypeMap.get($mime).get(0))\n    #set ($text = $mimetypeMap.get($mime).get(1))\n  #elseif ($extensionMap.containsKey($ext))\n    #set ($image = $extensionMap.get($ext).get(0))\n    #set ($text = $extensionMap.get($ext).get(1))\n  #else\n    #set ($mimetypePrefix = $mime.indexOf('/'))\n    #set ($mimetypePrefix = $mimetypePrefix + 1)\n    #set ($mimetypePrefix = $mime.substring(0, $mimetypePrefix))\n    #if ($mimetypeMap.containsKey($mimetypePrefix))\n      #set ($image = $mimetypeMap.get($mimetypePrefix).get(0))\n      #set ($text = $mimetypeMap.get($mimetypePrefix).get(1))\n    #else\n      #set ($image = 'attach')\n      #set ($text = 'attachment')\n    #end\n  #end\n  <span title=\"${services.localization.render(\"core.viewers.attachments.mime.${text}\")}\">$!services.icon.renderHTML($image)</span>\n#end\n###\n###    packName\n###\n### Display a shorter version of a string\n###\n### @param name The processed string\n###\n#macro(packName $name)\n#if(!$maxnamelength)\n#set($maxnamelength = 25)\n#end\n#set($idx = $name.lastIndexOf(\".\"))\n#if(($idx != 0) && ($idx != -1))\n#set($ext = $name.substring($idx))\n#else\n#set($ext = \"\")\n#set($idx = $name.length())\n#end\n#set($fname = $name.substring(0, $idx))\n#if($fname.length() > $maxnamelength)$fname.substring(0, $maxnamelength)~$ext#else$name#end\n#end\n\n#macro(xwikiobjectfield $fielddoc $fieldname $fieldtext $action)\n<div class=\"xmblabel\">$fieldtext</div>\n<div class=\"xmbfield\">\n#if($fieldname!=\"\")\n$fielddoc.display($fieldname, $action)\n#end\n</div>\n#end\n\n##\n## Formats a date according to the ISO8601 standard\n##\n#macro(formatdateISO $date)\n#set($tz = $xwiki.formatDate($date, \"Z\"))\n#set($tz = \"${tz.substring(0, 3)}:${tz.substring(3)}\")\n$xwiki.formatDate($date, \"yyyy-MM-dd\")T$xwiki.formatDate($date, \"HH:mm:ss\")$tz#end\n\n##\n## Formats a username like a fn (hCard microformat)\n##\n#macro(userfn $username)\n#set($fn = $xwiki.getUserName($username))\n#if($fn.indexOf(\"<a\") >= 0)\n#set($fn = $fn.replaceAll(\"<a\", '<a class=\"url fn\"'))\n#else\n#set($fn = \"<span class='fn'>$fn</span>\")\n#end\n$fn\n#end\n\n###\n###\n### Macros for \"foot notes\"\n###\n### TODO:\n###       Make Radeox macros\n###       Support in wysiwyg\n###\n###\n#macro(footnote $text)\n#if(!$page_footnotes)\n#set($page_footnotes = [])\n#set($footnote_group_id = 1)\n#end\n#set($discard = $page_footnotes.add($text))\n#set($processedText = $text.replaceAll('[*~<>_-]', ''))\n#set($footnote_id = $page_footnotes.size())\n<sup class=\"footnoteRef\" id=\"footnoteref_${footnote_group_id}_${footnote_id}\"><a href=\"#footnote_${footnote_group_id}_${footnote_id}\" title=\"$services.localization.render('core.footnotes.gotofootnote', [${footnote_id}]): {pre}$processedText{/pre}\">$footnote_id</a></sup>#end\n##\n##\n##\n#macro(putFootnotes)\n#if($page_footnotes && ($page_footnotes.size() > 0))\n<ol class=\"footnotes\">\n#foreach($footnote in $page_footnotes)\n<li id=\"footnote_${footnote_group_id}_${foreach.count}\">\n <a class=\"footnoteBackRef\" title=\"$services.localization.render('core.footnotes.backtoref')\" href=\"#footnoteref_${footnote_group_id}_${foreach.count}\">^</a>\n  $footnote</li>\n#end\n</ol>\n#set($discard = $page_footnotes.clear())\n#set($footnote_group_id = $footnote_group_id + 1)\n#end\n#end\n##\n##  Generate navigation links for paged documents. It will use the URL parameters \"ipp\" to forward\n## the number of items per page, and \"page\" to indicate a certain page. The actual range (in items,\n## not in pages) can be computer using #preparePagedViewParams. The macro does not print anything\n## if only one page exists and $alwaysDisplay is not set to true. Does not alter any variables.\n##\n## @param itemsPerPage The number of items per page, will be forwarded in the links to other pages.\n## @param totalPages The total number of pages, starting at 1.\n## @param currentPageNumber The currently displayed page, starting at 1.\n## @param additionalQueryParams Query string fragment that should be put in the links. Should not\n##        start or end with ? or &\n## @param alwaysDisplay Force display of the links, even if there is only one page in total.\n##\n#macro(printPagedViewLinks $itemsPerPage $totalPages $currentPageNumber $additionalQueryParams $alwaysDisplay)\n  ## Only display if there are more than 1 pages or we explicitely require it.\n  #if(($totalPages > 1) || $alwaysDisplay)\n    <div class=\"pagedNavigation\">\n    #if($currentPageNumber > 1)\n      #set($currentPageNumber = $currentPageNumber - 1)\n      <span class=\"pagedLink\"><a href=\"$doc.getURL($xcontext.action, \"page=1&amp;ipp=${itemsPerPage}\")#if(\"$!additionalQueryParams\" != \"\")&amp;$additionalQueryParams#end\">$services.localization.render('web.paging.firstPage')</a></span>\n      <span class=\"pagedLink\"><a href=\"$doc.getURL($xcontext.action, \"page=${currentPageNumber}&amp;ipp=${itemsPerPage}\")#if(\"$!additionalQueryParams\" != \"\")&amp;$additionalQueryParams#end\">$services.localization.render('web.paging.previousPage')</a></span>\n      #set($currentPageNumber = $currentPageNumber + 1)\n    #else\n      <span class=\"pagedLink inactive\">$services.localization.render('web.paging.firstPage')</span>\n      <span class=\"pagedLink inactive\">$services.localization.render('web.paging.previousPage')</span>\n    #end\n    <span class=\"pagedStatus\">$services.localization.render('web.paging.pageNumberOf', [$currentPageNumber, $totalPages])</span>\n    #if($currentPageNumber < $totalPages)\n      #set($currentPageNumber = $currentPageNumber + 1)\n      <span class=\"pagedLink\"><a href=\"$doc.getURL($xcontext.action, \"page=${currentPageNumber}&amp;ipp=${itemsPerPage}\")#if(\"$!additionalQueryParams\" != \"\")&amp;$additionalQueryParams#end\">$services.localization.render('web.paging.nextPage')</a></span>\n      <span class=\"pagedLink\"><a href=\"$doc.getURL($xcontext.action, \"page=${totalPages}&amp;ipp=${itemsPerPage}\")#if(\"$!additionalQueryParams\" != \"\")&amp;$additionalQueryParams#end\">$services.localization.render('web.paging.lastPage')</a></span>\n      #set($currentPageNumber = $currentPageNumber - 1)\n    #else\n      <span class=\"pagedLink inactive\">$services.localization.render('web.paging.nextPage')</span>\n      <span class=\"pagedLink inactive\">$services.localization.render('web.paging.lastPage')</span>\n    #end\n    </div>\n  #end\n#end\n##\n##\n##  Used together with #printPagedViewLinks, computes the range of items to show and the\n## variables used by #printPagedViewLinks, $currentPageNumber, $itemsPerPage, $totalPages.\n##\n## @param totalItems The total number of items that need to be displayed.\n## @param defaultItemsPerPage The default number of items per page, if no override is found in the\n##        URL. If 0, then display all items.\n## @sets startAt The first item to display (inclusive).\n## @sets endAt The last item to display (exclusive).\n## @sets itemsPerPage The requested number of items per page.\n## @sets totalPages The total number of pages according to the requested number of items per page\n##        and total items. Starts at 1.\n## @sets currentPageNumber The current page displayed. If the requested page is not available (out\n##        of range), then it will be corrected to a valid number. Starts at 1.\n##\n#macro(preparePagedViewParams $totalItems $defaultItemsPerPage)\n  ## Reuse existing variable, in case it is manually overriden somewhere else\n  #if(!$itemsPerPage)\n    #if($request.ipp)\n      #set($itemsPerPage = $numbertool.toNumber($request.ipp).intValue())\n    #else\n      #set($itemsPerPage = $defaultItemsPerPage)\n    #end\n  #end\n  ## Page numbers start at 1 outside this macro, but for internal computations we use 0-indexed values.\n  #set($currentPageNumber = $numbertool.toNumber($request.page).intValue() - 1)\n  #if(!$currentPageNumber || $currentPageNumber < 0)\n    #set($currentPageNumber = 0)\n  #end\n  ## The first item to show. Must be >= 0.\n  #set($startAt = $itemsPerPage * $currentPageNumber)\n  #if($startAt < 0)\n    #set($startAt = 0)\n  #end\n  ## The last item to show (exclusive). Must be <= total number of items.\n  #set($endAt = $itemsPerPage * ($currentPageNumber + 1))\n  #if(($endAt > $totalItems) || ($itemsPerPage == 0))\n    #set($endAt = $totalItems)\n  #end\n  ## Never show the items after the last one... They don't exist!\n  #if($startAt >= $endAt)\n    #set($startAt = $endAt - 1)\n  #end\n  ## Compute the total number of pages.\n  #if($itemsPerPage == 0)\n    #set($totalPages = 1)\n  #else\n    #set($totalPages = ($totalItems - 1) / $itemsPerPage + 1)\n  #end\n  ## The requested page might not be available, so correct it to correspond to the displayed items.\n  #set($currentPageNumber = $startAt / $itemsPerPage + 1)\n#end\n##\n##\n## Macro to set a page break used in print, pdf and rtf mode\n##\n#macro(pagebreak)\n<p style=\"page-break-before: always;\" />\n#end\n##\n##\n## Macro to include children of a page\n##\n#set($clevel = 1)\n\n#**\n * Macro to include children at multiple levels. The children are rendered in the generated output. The number of nested levels to\n * render is defined in a global variable called \"$clevel\".\n *\n * @param $page the document whose children should be rendered; preferably a Document object, but a document name works as well\n * @param $withPageBreaks a boolean indicating whether a page break should be generated before each new child document\n *###\n#macro(includeChildren $page $withPageBreaks)\n  #if ($clevel && $clevel > 0)\n    #if (\"$!page.fullName\" == '')\n      ## Not a Document, probably a String (document name)\n      ## Make it backwards compatible with older versions of the macro\n      #set ($page = $xwiki.getDocument($page))\n    #end\n    #foreach ($childDocName in $page.children)\n      #set ($childDoc = $xwiki.getDocument($childDocName))\n      #if ($childDoc && !$blacklistedSpaces.contains($childDoc.getSpace()))\n        #if ($withPageBreaks)\n          #pagebreak()\n        #end\n        $childDoc.getRenderedContent()\n        #set ($clevel = $clevel - 1)\n        #includeChildren($childDoc $withPageBreaks)\n        #set ($clevel = $clevel + 1)\n      #end\n    #end\n  #end\n#end\n\n##\n## Macro to include linked pages at multiple levels\n#macro(includeLinks $page $withPageBreaks)\n #if($clevel && $clevel!=0)\n  #set($pageDoc = $xwiki.getDocument($page))\n  #foreach($child in $pageDoc.getLinks())\n    #set($childDocName = $child.getLink())\n    #set($childDoc = $xwiki.getDocument($childDocName))\n    #if(($childDoc)&&($childDoc.getSpace()!=\"Panels\")&&($childDoc.getSpace()!=\"XWiki\"))\n     #if($withPageBreaks)\n     #pagebreak()\n     #end\n     $childDoc.getRenderedContent()\n     #set($clevel = $xwiki.add($clevel,-1))\n     #includeLinks($childDocName $withPageBreaks)\n     #set($clevel = $xwiki.add($clevel,1))\n    #end\n  #end\n #end\n#end\n\n###\n###    Panel header\n###\n### Generate the starting html code for a panel\n###\n### @param title The panel caption title\n### @param isLarge True if the panel should be larger (default: false)\n### @param isHeaderHidden True if the header should be hidden (default: false)\n###\n#macro(panelheader $title $isLarge $isHeaderHidden)\n## Note: We pass the Panel name as an HTML class attribute so that it's possible to style the Panels selectively using\n## CSS.\n## We want to avoid showing the \"WebHome\" suffix in the generated class since we're working to remove it from the UI\n## and from the APIs. In addition it generates class names longer than they are needed. Thus for nested pages we strip\n## it. We also strip the wiki prefix to have a shorter generated class name and because they're not needed to provide\n## per-wiki styling of Panels.\n#set ($defaultDocumentName = $services.model.getEntityReference('DOCUMENT', 'default').name)\n#if ($paneldoc.documentReference.name == $defaultDocumentName)\n  #set ($serializedDocument = $services.model.serialize($paneldoc.documentReference.parent, 'compactwiki'))\n#else\n  #set ($serializedDocument = $services.model.serialize($paneldoc.documentReference, 'compactwiki'))\n#end\n##We keep only alphanumeric characters so it can be used as a CSS class.\n## For instance: \"xwiki:A.B.WebHome\" will become \"AB\"\n#set ($specialClassAttribute = $stringtool.toAlphaNumeric(\"$!serializedDocument\"))\n## We keep this class for compatibility purpose but the previous one should be used instead.\n#set ($deprecatedClassAttribute = $stringtool.toAlphaNumeric(\"$!paneldoc.documentReference.name\"))\n#if ($paneldoc.syntax.toIdString() == 'xwiki/1.0')\n<div class=\"#if ($isLarge)large #{end}panel expanded $!specialClassAttribute $!deprecatedClassAttribute\">\n<h1 class=\"xwikipaneltitle#if ($isHeaderHidden) hidden#end\">$title</h1>\n<div class=\"xwikipanelcontents\">\n#else\n(% class=\"#if ($isLarge)large#{end}panel expanded $!specialClassAttribute $!deprecatedClassAttribute\" %)(((\n{{html}}<h1 class=\"xwikipaneltitle#if ($isHeaderHidden) hidden#end\">$title</h1>{{/html}}\n(% class=\"xwikipanelcontents\" %)(((\n#end\n#end\n\n#macro(panelhiddenheader $title)\n#panelheader($title, false, true)\n#end\n\n#macro(largepanelheader $title)\n#panelheader($title, true, false)\n#end\n\n###\n###    Panel footer\n###\n### Generate the ending html code for a panel\n###\n#macro(panelfooter)\n#if ($paneldoc.syntax.toIdString() == 'xwiki/1.0')\n</div>\n</div>\n#else\n)))\n)))\n#end\n#end\n\n###\n###    Display Panel\n###\n### Extract and display the panel code from the panel object\n###\n### @Deprecated\n#macro(displaypanel $name)\n  #set ($paneldoc = $xwiki.getDocument($name))\n  #if ($paneldoc)\n    #set ($pobj = $paneldoc.getObject('Panels.PanelClass'))\n    #if ($pobj)\n      $!doc.display('content', 'view', $pobj)\n    #end\n  #end\n#end\n\n#macro(displayPropName $prop)\n#if($services.localization.render(\"${class.getName()}_${prop.name}\") == \"${class.getName()}_${prop.name}\")\n$prop.prettyName#else\n$services.localization.render($prop.name)#end\n#end\n\n###\n###    Display Panel content\n###\n###\n#macro(displaypanelcontent $doc $obj)\n$doc.display(\"content\", $obj)\n#end\n\n###\n###    Message box\n###\n#macro(xwikimessageboxstart $title $message)\n  <div class=\"centered\">\n    <fieldset class=\"xwikimessage\">\n      <legend><span>$title</span></legend>\n      #if (\"$!message\" != '')\n        <p class=\"xwikimessage\">$message</p>\n      #end\n#end\n#macro(xwikimessageboxend)\n    </fieldset>\n  </div>\n#end\n\n#macro(xwikimessagebox $title $message $urlyes $urlno $msgyes $msgno)\n#xwikimessageboxstart($title $message)\n      <div class=\"buttons\"><a href=\"$urlyes\" class=\"buttonwrapper\"><input type=\"button\" class=\"button\" value=\"$msgyes\" onclick=\"location='$urlyes'; return false;\"/></a><a href=\"$urlno\" class=\"buttonwrapper\"><input type=\"button\" class=\"button\" value=\"$msgno\" onclick=\"location='$urlno'; return false;\"/></a></div>\n#xwikimessageboxend()\n#end\n\n#macro(xwikimessageboxfield $fielddoc $fieldname $fieldtext $html)\n<div class=\"xmblabel\">$fieldtext</div>\n<div class=\"xmbfield\">\n#if($fieldname!=\"\")\n$fielddoc.display($fieldname, \"edit\")\n#end\n#if($html!=\"\")\n$html\n#end\n</div>\n#end\n\n#macro(xwikimessageboxsubmit $submittext)\n<div class=\"xmbbutton\">\n<input type=\"submit\" value=\"$submittext\" />\n</div>\n#end\n\n\n###\n###    message\n###\n\n#macro(warning $text)\n<div class=\"warningmessage\"><span class=\"messagetype\">$services.localization.render('warning'): </span>$text</div>\n#end\n\n#macro(error $text)\n<div class=\"errormessage\"><span class=\"messagetype\">$services.localization.render('error'): </span>$text</div>\n#end\n\n#macro(info $text)\n<div class=\"infomessage\">$text</div>\n#end\n\n#macro(message $text)\n<div class=\"plainmessage\">$text</div>\n#end\n\n#macro (floatingbox $text)\n<div class=\"floatinginfobox\">$text</div>\n#end\n\n#macro (startfloatingbox)\n<div class=\"floatinginfobox\">\n#end\n\n#macro (endfloatingbox)\n</div>\n#end\n\n###\n###    Display in page panels layout\n###\n###\n#macro(displayPanelLayout $nbcolumns $panelNameList)\n  <div class=\"panellayoutcontainer-${nbcolumns}col\">\n    #set($lastColumnId = ($nbcolumns - 1))\n    #foreach($colId in [0..$lastColumnId])\n      <div class=\"panellayoutcol\">\n        #foreach($panelName in $panelNameList)\n          #if($panelName && ($panelName != \"\") && (((($foreach.count - 1) + $nbcolumns) % $nbcolumns) == $colId))\n            #displaypanel($panelName)\n          #end\n        #end\n      </div>\n    #end\n  </div>\n#end\n\n#**\n * Displays a public google calendar with all buttons and displays\n * The size of the display is 800x600\n *\n * This macro displays the public part of the calendar specified. However if the visiting user is logged in in Google Calendar and has rights to the private part of the calendar then the information will be displayed.\n *\n * @param id ID of the google account to display the calendar for\n *#\n#macro(googlecal $id)\n{pre}\n<iframe src=\"http://www.google.com/calendar/embed?height=600&amp;wkst=1&amp;bgcolor=%23FFFFFF&amp;src=${id.replaceAll(\"@\",\"%40\")}&amp;color=%232952A3\" style=\" border-width:0 \" width=\"800\" height=\"600\" frameborder=\"0\" scrolling=\"no\"></iframe>\n{/pre}\n#end\n\n#**\n * Displays a public google calendar with all buttons and displays and a custom size\n *\n * @param id ID of the google account to display the calendar for\n * @param width Width of the calendar\n * @param height Height of the calendar\n *#\n#macro(googlecalsize $id $width $height)\n#if($width==\"\")\n#set($width = \"800\")\n#end\n#if($height==\"\")\n#set($height = \"600\")\n#end\n{pre}\n<iframe src=\"http://www.google.com/calendar/embed?height=${height}&amp;wkst=1&amp;bgcolor=%23FFFFFF&amp;src=${id.replaceAll(\"@\",\"%40\")}&amp;color=%232952A3\" style=\" border-width:0 \" width=\"${width}\" height=\"${height}\" frameborder=\"0\" scrolling=\"no\"></iframe>\n{/pre}\n#end\n\n#**\n * Displays a private google calendar with all buttons\n *\n * @param id ID of the google account to display the calendar for\n * @param token Private token giving access to the Calendar. This token is 32 chars long and can be retrieved in the \"Agenda Details\" when accessing your \"Private URL\" of your calendar. You should use this parameter with care as it will display all your calendar events to anybody that can access the page in which you use this macro\n *#\n#macro(googlecalprivate $id $token)\n{pre}\n<iframe src=\"http://www.google.com/calendar/embed?pvttk=${token}&amp;height=600&amp;wkst=1&amp;bgcolor=%23FFFFFF&amp;src=${id.replaceAll(\"@\",\"%40\")}&amp;color=%232952A3\" style=\" border-width:0 \" width=\"800\" height=\"600\" frameborder=\"0\" scrolling=\"no\"></iframe>\n{/pre}\n#end\n\n#**\n * Displays a private google calendar with all buttons\n *\n * @param id ID of the google account to display the calendar for\n * @param token Private token giving access to the Calendar. This token is 32 chars long and can be retrieved in the \"Agenda Details\" when accessing your \"Private URL\" of your calendar. You should use this parameter with care as it will display all your calendar events to anybody that can access the page in which you use this macro\n * @param width Width of the calendar\n * @param height Height of the calendar\n *#\n#macro(googlecalprivatesize $id $token $width $height)\n#if($width==\"\")\n#set($width = \"800\")\n#end\n#if($height==\"\")\n#set($height = \"600\")\n#end\n{pre}\n<iframe src=\"http://www.google.com/calendar/embed?pvttk=${token}&amp;height=${height}&amp;wkst=1&amp;bgcolor=%23FFFFFF&amp;src=${id.replaceAll(\"@\",\"%40\")}&amp;color=%232952A3\" style=\" border-width:0 \" width=\"${width}\" height=\"${height}\" frameborder=\"0\" scrolling=\"no\"></iframe>\n{/pre}\n#end\n\n#**\n * Displays a public or private google calendar with a wide range of settings\n * You can check the effect of these settings using the Google Calendar Embed Helper\n * http://www.google.com/calendar/embedhelper\n *\n * @param id ID of the google account to display the calendar for\n * @param token Private token giving access to the Calendar. This token is 32 chars long and can be retrieved in the \"Agenda Details\" when accessing your \"Private URL\" of your calendar. You should use this parameter with care as it will display all your calendar events to anybody that can access the page in which you use this macro\n * @param width Width of the calendar\n * @param height Height of the calendar\n * @param showTitle 0 to not show the title\n * @param showNav 0 to not show the navigation buttons allowing to switch to previous/next week or month\n * @param showDate 0 to not show the current period displayed\n * @param showPrint 0 to not show the print button\n * @param showTabs 0 to not show the tabs allowing to switch between MONTH,WEEK,AGENDA mode\n * @param showCalendars 0 to not show the calendars list drop down button\n * @param showTz Show a message saying the timezone of the dates/hours\n * @param mode Default mode to display (empty is Month display, WEEK is Week dispaly, AGENDA is the event display)\n * @param language Language to display in (en,fr,de,..)\n * @param bgcolor Background color of the calendar in the form #255455\n * @param color Color of the events in the form #234567\n * @param ctz Timezone in which to display the calendar. Leave empty for default calendar Timezone\n * @param border Border in pixels (1,2,3)\n *#\n#macro(googlecalcustom $id $token $width $height $showTitle $showNav $showDate $showPrint $showTabs $showCalendars $showTz $mode $language $bgcolor $color $ctz $border)\n#if($width==\"\")\n#set($width = \"800\")\n#end\n#if($height==\"\")\n#set($height = \"600\")\n#end\n#if($color!=\"\")\n#set($color = $color.replaceAll(\"#\",\"%23\"))\n#else\n#set($color = \"%232952A3\")\n#end\n#if($bgcolor!=\"\")\n#set($bgcolor = $bgcolor.replaceAll(\"#\",\"%23\"))\n#else\n#set($bgcolor = \"%232952A3\")\n#end\n{pre}\n<iframe src=\"//www.google.com/calendar/embed?showTitle=${showTitle}&amp;showNav=${showNav}&amp;showDate=${showDate}&amp;showPrint=${showPrint}&amp;showTabs=${showTabs}&amp;showCalendars=${showCalendars}&amp;showTz=${showTz}&amp;mode=${mode}&amp;height=${height}&amp;wkst=2&amp;hl=${language}&amp;bgcolor=${bgcolor}&amp;src=${id.replaceAll(\"@\",\"%40\")}&amp;color=${color}&amp;ctz=${ctz}\" style=\" border:solid ${border}px #777 \" width=\"${width}\" height=\"${height}\" frameborder=\"0\" scrolling=\"no\"></iframe>\n{/pre}\n#end\n#**\n * Displays a list of documents.\n * Only documents that the current user is allowed to view will be displayed.\n *\n * @param docNames list of document names.\n * @param displaySpaces true to group documents by space.\n * @param blacklistedSpaces spaces to exclude from the list.\n *#\n#macro(displayDocumentList $docNames $displaySpaces $blacklistedSpaces)\n  #set($documentList = [])\n  #foreach($docName in $docNames)\n    #if($xwiki.hasAccessLevel(\"view\", $xcontext.user, $docName))\n      #set($document = $xwiki.getDocument($docName).getTranslatedDocument())\n      #if(!$blacklistedSpaces.contains($document.getSpace()))\n        #set($discard = $documentList.add($document))\n      #end\n    #end\n  #end\n  #if($documentList.size() > 0)\n    #set($previousSpace = \"\")\n    <ul class=\"xlist\">\n      #foreach($document in $documentList)\n        #if ($document.getSpace() != $previousSpace && $displaySpaces)\n          #if($foreach.count > 1) </ul></div></li> #end ## Close previous space item if needed\n          <li class=\"xitem\">\n            <div class=\"xitemcontainer\">\n              $services.icon.renderHTML('space') $escapetool.xml($document.space)\n              <ul class=\"xlist\"> ## Open new space item\n          #set($previousSpace = $document.getSpace())\n        #end\n        <li class=\"xitem\">\n          <div class=\"xitemcontainer\">\n            $services.icon.renderHTML('page')\n            <a href=\"$document.getURL()\">$escapetool.xml($document.plainTitle)</a>\n          </div>\n        </li>\n      #end\n      #if($displaySpaces)\n        </ul></div></li> ## Close last space item\n      #end\n    </ul>\n  #end\n#end\n#**\n * Set a variable from request parameters.\n * If the parameter is not present in the request, set it to the default value.\n *\n * Note that request parameters will be cast to the type of the defaultValue.\n * Handled types: ArrayList, Boolean, Integer, Float, Long, Double.\n *\n * @param variable the variable to set.\n * @param parameterName name of the parameter to look for in the request.\n * @param defaultValue if the parameter is not set in the HTTP request, the variable is assigned this value.\n * @deprecated since Velocity 1.7 (XWiki 3.0) it is no longer possible to use macros this way.\n *     Setting $variable will not be observed outside the macro unless the actual parameter is also called $variable.\n *     Use #readVariableFromRequest instead.\n *###\n#macro(setVariableFromRequest $variable $parameterName $defaultValue)\n  ## Trick: when null, \"$variable\" will print the actual parameter name, so \"$abc\" if the macro was called with $abc as a parameter.\n  ## Use this hack to extract the actual parameter name, and use #evaluate to set it.\n  #set ($variable = $NULL)\n  #set ($varName = \"$variable\")\n  #readVariableFromRequest($varName $parameterName $defaultValue)\n#end\n##\n##\n##\n#**\n * Set a variable from request parameters.\n * If the parameter is not present in the request, set it to the default value.\n *\n * Note that request parameters will be cast to the type of the defaultValue.\n * Handled types: ArrayList, Boolean, Integer, Float, Long, Double.\n *\n * @param resultVariableName the name of the variable to set, a String; when the macro returns, a variable named that way will be created with the output value\n * @param parameterName name of the parameter to look for in the request.\n * @param defaultValue if the parameter is not set in the HTTP request, the variable is assigned this value.\n *###\n#macro(readVariableFromRequest $resultVariableName $parameterName $defaultValue)\n  ## Try to get the variable value from HTTP request.\n  #if ($defaultValue.class == 'class java.util.ArrayList')\n    #set ($result = [])\n    #foreach ($param in $request.getParameterValues($parameterName))\n      #set ($discard = $result.add($param))\n    #end\n    #if ($result.size() == 0)\n      #set ($discard = $result.addAll($defaultValue))\n    #end\n  #else\n    #set ($result = $request.getParameter(\"${parameterName}\"))\n    #if (\"$!result\" != '')\n      #if ($defaultValue.class == 'class java.lang.Boolean')\n        #set ($result = $util.parseBoolean($result))\n      #elseif ($defaultValue.class == 'class java.lang.Integer')\n        #set ($result = $numbertool.toNumber($result).intValue())\n      #elseif ($defaultValue.class == 'class java.lang.Float')\n        #set ($result = $numbertool.toNumber($result).floatValue())\n      #elseif ($defaultValue.class == 'class java.lang.Long')\n        #set ($result = $numbertool.toNumber($result).longValue())\n      #elseif ($defaultValue.class == 'class java.lang.Double')\n        #set ($result = $numbertool.toDouble($result))\n      #end\n    #end\n    #if (\"$!result\" == '')\n      #set ($result = $defaultValue)\n    #end\n  #end\n  #setVariable($resultVariableName $result)\n#end\n##\n##\n##\n#**\n * Assign a value to a variable, given by its name. The purpose of this macro is to emulate call by macro expansion,\n * which was available in velocity versions up to 1.6, but was removed in 1.7.\n *\n * @param variableName the name of the variable to set, a String; when the macro returns, a variable named that way will be created with the output value\n * @param value the value to assign\n *###\n#macro(setVariable $variableName $value)\n## Only do this if the variable name is really a valid variable name\n#if ($variableName.matches('[a-zA-Z_][a-zA-Z0-9_-]*'))\n#evaluate(\"${escapetool.h}set(${escapetool.d}${variableName}=${escapetool.d}value)\")\n#elseif ($variableName.matches('\\$[a-zA-Z_][a-zA-Z0-9_-]*'))\n#evaluate(\"${escapetool.h}set(${variableName}=${escapetool.d}value)\")\n#end\n#end\n##\n##\n##\n#**\n * Displays a submit button, i.e. an <tt>input</tt> element with <tt>type=submit</tt>.\n * For styling purposes, the button is wrapped in a span element.\n * @param name The value of the <tt>name</tt> attribute\n * @param shortcut The keyboard shortcut for this button. The value will be displayed\n *        as the title of the element. The actual shortcut is attached elsewhere, in\n *        the javascript code.\n * @param value The value of the <tt>value</tt> attribute, i.e. the text displayed on\n *        the button.\n *#\n#macro(submitButton $name $shortcut $value)\n<span class=\"buttonwrapper\"><input class=\"button\" type=\"submit\" name=\"$name\"#if($keyboardShortcutsEnabled) title=\"$shortcut\"#end value=\"$value\"/></span>\n<input type=\"hidden\" name=\"xaction\" value=\"$escapetool.xml($action)\" />\n#end\n#**\n * Displays a submit button for the editor. This macro calls submitButton,\n * composing all its parameters based on the action's identifier and the\n * identifier of the corresponding localized resources.\n * @param action The identifier of the button's action.\n * @param resourceIdentifier The key used to identify the localized resources.\n *#\n#macro(editActionButton $action $resourceIdentifier)\n#submitButton(\"action_${action}\", $services.localization.render(\"core.shortcuts.edit.${resourceIdentifier}\"), $services.localization.render($resourceIdentifier))\n#end\n\n#**\n * Display a human-readable file size\n *\n * @param $size the size in bytes to display in a human readable format\n *#\n#macro(dynamicsize $sz)\n#if($sz < 1024)\n$sz bytes##\n#else\n#set($ksz = $mathtool.div($sz, 1024))\n#set($ksz = $mathtool.roundTo(1, $ksz))\n#if($ksz < 1024)\n$ksz KB##\n#else\n#set($Msz = $mathtool.div($sz, 1048576))\n#set($Msz = $mathtool.roundTo(1, $Msz))\n$Msz MB##\n#end##\n#end##\n#end\n\n#**\n * AJAX Live table that displays XWiki data.\n *\n * Example of usage, in syntax 2.0:\n * <code>\n * {{velocity}}\n * #set($columns = [ \"_avatar\", \"first_name\", \"last_name\", \"email\"])\n * #set($columnsProperties = {\n *                  \"first_name\" : { \"type\" : \"text\" , \"size\" : 10, \"link\" : \"view\"},\n *                  \"last_name\" : { \"type\" : \"text\" , \"size\" : 10, \"link\" : \"view\"},\n *                  \"email\" : { \"type\" : \"text\" , \"size\" : 20, \"link\" : \"editor\"},\n *                  \"_avatar\" : { \"type\" : \"none\" , \"size\" : 20, \"link\" : \"none\", \"html\" : \"true\", \"sortable\":false }\n *                })\n * #set($options = {  \"className\":\"XWiki.XWikiUsers\",\n *                    \"translationPrefix\" : \"platform.index.\",\n *                    \"tagCloud\" : true,\n *                    \"rowCount\": 15,\n *                    \"javascriptName\" : \"MyModule.myTable\",\n *                    \"description: \"The description of this table here\", })\n * #livetable(\"userstable\" $columns $columnsProperties $options)\n * {{/velocity}}\n * </code>\n *\n * @param divid the id of the table div\n * @param collist the column list\n * @param colprops the columns properties\n * @param options the livetable options.\n *#\n#macro (livetable $divid $collist $colprops $options)\n## Open wiki syntax wrappers.\n#if(\"$!options.outputOnlyHtml\" != 'true')\n## Do not indent:\n#if($xwiki.getCurrentContentSyntaxId() != \"xwiki/1.0\")\n\n\n## We don't clean the HTML because we control the markup and because we want to preserve the whitespace characters in\n## the attribute values (e.g. if the live table id contains whitespaces)\n{{html clean=\"false\"}}\n#else {pre} #end\n#end\n#if ($services.liveData.liveTable && $request.useLiveData == 'true')\n#livetable_liveData($divid $collist $colprops $options)\n#else\n#livetable_html($divid $collist $colprops $options)\n#end\n## Close wiki syntax wrappers. Do not modify the indentation below or it will generate unwanted paragraphs!\n#if(\"$!options.outputOnlyHtml\" != 'true')#if($xwiki.getCurrentContentSyntaxId() != \"xwiki/1.0\"){{/html}}\n\n#else{/pre}#end##\n#end## end-wrappers\n#end\n\n#macro (livetable_liveData $divid $collist $colprops $options)\n  #set ($discard = $xwiki.jsfx.use('uicomponents/widgets/liveData.js', true))\n  #set ($liveDataConfig = $services.liveData.liveTable.getConfig($divid, $collist, $colprops, $options))\n  #set ($liveDataConfigJSON = $jsontool.serialize($liveDataConfig))\n  <div class=\"liveData\" id=\"$!escapetool.xml($divid)\" data-config=\"$escapetool.xml($liveDataConfigJSON)\"></div>\n#end\n\n#macro(livetable_html $divid $collist $colprops $options)\n  ##\n  ## SX deps.\n  ##\n  #set($ok = $xwiki.jsfx.use('js/xwiki/table/livetable.js', true))\n  #set($ok = $xwiki.ssfx.use('js/xwiki/table/livetable.css', true))\n  ##\n  ## Options / defaults\n  ##\n  #if(\"$!options.translationPrefix\" != '') #set($transprefix = $options.translationPrefix) #else #set($transprefix = '') #end\n  #if(\"$!options.defaultOrder\" == 'desc') #set($defaultOrder = 'desc') #else #set($defaultOrder = 'asc') #end\n  #if(\"$!options.selectedColumn\" != '') #set($selectedColumn = $options.selectedColumn) #end\n  #if(\"$!options.tagCloud\" == '' || $options.tagCloud == false) #set($tagcloud=false) #else #set($tagcloud = true) #end\n  #set ($topfilters = $options.topFilters)\n  #set ($hasTopFilters = \"$!topfilters\" !='')\n  #if(\"$options.pageSize\" == '' || $!options.pageSize == false) #set($hasPageSize=false) #else #set($hasPageSize = true) #end\n  #set ($queryFilters = $options.queryFilters)\n  #if (!$queryFilters)\n    #set ($queryFilters = 'currentlanguage,hidden')\n  #end\n  #set($classname = \"$!options.className\")\n  ##\n  ## Columns informations\n  ##\n  #set ($dataColumns = [])\n  #set ($classParams = {})\n  #foreach($colname in $collist)\n    ## If the live table options don't specify which column to select then select the first non-special column.\n    #if(\"$!selectedColumn\" == '' && !$colname.startsWith('_'))\n      #set($selectedColumn = $colname)\n    #end\n    #if($colname != '_actions')\n      #set ($discard = $dataColumns.add($colname))\n      #set($propClassName = \"$!{colprops.get($colname).get('class')}\")\n      #if($propClassName != '')\n        #set ($discard = $classParams.put(\"${colname}_class\", $propClassName))\n      #end\n      #set ($propMatchType = \"$!colprops.get($colname).match\")\n      #if ($propMatchType != '')\n        #set ($discard = $classParams.put(\"${colname}_match\", $propMatchType))\n      #end\n    #end\n  #end\n  #if(\"$!options.url\" != '')\n    #set($dataurl = $options.url)\n  #else\n    #set ($parameters = {\n      'outputSyntax': 'plain',\n      'transprefix': $transprefix,\n      'classname': $classname,\n      'collist': $stringtool.join($dataColumns, ','),\n      'queryFilters': $queryFilters\n    })\n    #set ($discard = $parameters.putAll($classParams))\n    #set ($resultPage = $options.resultPage)\n    #if (\"$!resultPage\" == '')\n      #set ($resultPage = 'XWiki.LiveTableResults')\n    #end\n    #set ($dataurl = $xwiki.getURL($resultPage, 'get', \"$escapetool.url($parameters)&$!options.extraParams\"))\n  #end\n  ## Clone the column properties because we modify them.\n  #set ($macro.columnDescriptors = $jsontool.fromString($jsontool.serialize($colprops)))\n  #livetable_normalizeColumnDescriptors($macro.columnDescriptors $collist $transprefix)\n  #set ($macro.settings = {\n    'name': $options.javascriptName,\n    'url': $dataurl,\n    'columns': $collist,\n    'columnDescriptors': $macro.columnDescriptors,\n    'xclass': $classname,\n    'maxPages': $options.maxPages,\n    'hasPageSize': $hasPageSize,\n    'pageSizeBounds': $options.pageSizeBounds,\n    'limit': $options.rowCount,\n    'selectedTags': $options.selectedTags,\n    'hasTopFilters': $hasTopFilters,\n    'callback': $options.callback\n  })\n  ##\n  ## HTML Table\n  ##\n  #set ($htmlLiveTableId = $escapetool.xml($divid))\n<div class=\"xwiki-livetable-container\">\n  #if($tagcloud || $hasTopFilters)\n  <div class=\"tipfilters\">\n  #end\n  #if($hasTopFilters)\n  <div id=\"${htmlLiveTableId}-topfilters\" class=\"xwiki-livetable-topfilters-tip #if($tagcloud)splitted#end\">\n    <div>\n      <div class=\"xwiki-livetable-topfilters-container\">\n      $topfilters\n      </div>\n      <div class=\"tippointer\">\n        <div></div>\n      </div>\n    </div>\n  </div>\n  #end\n  #if($tagcloud)\n    #set($discard = $xwiki.ssx.use('XWiki.TagCloud'))\n    <div id=\"${htmlLiveTableId}-tagcloud\" class=\"xwiki-livetable-tagcloud-tip hidden #if($hasTopFilters)splitted#end\">\n      <div>\n        <div class=\"xwiki-livetable-tagcloud-container\">\n          <h2>$services.localization.render('platform.livetable.tagsHelp') $services.localization.render('platform.livetable.tagsHelpCancel')</h2>\n          <div class=\"xwiki-livetable-tagcloud\"></div>\n        </div>\n        <div class=\"tippointer\">\n          <div></div>\n        </div>\n      </div>\n    </div>\n  #end\n  #if($tagcloud || $hasTopFilters)\n  </div>\n  #end\n  <table id=\"${htmlLiveTableId}\" class=\"xwiki-livetable\"\n      #if(\"$!options.description\" != '') summary=\"$escapetool.xml($options.description)\"#end\n      data-settings=\"$escapetool.xml($jsontool.serialize($macro.settings))\" data-xwiki-lightbox=\"false\">\n    <tr>\n      <td class=\"xwiki-livetable-pagination\">\n        <span id=\"${htmlLiveTableId}-limits\" class=\"xwiki-livetable-limits\"></span>\n  #if($hasPageSize)\n        <span id=\"${htmlLiveTableId}-pagesize\" class=\"xwiki-livetable-pagesize\">\n            <span>$services.localization.render('platform.livetable.pagesizeLabel')</span>\n            <span class=\"xwiki-livetable-pagesize-content\" ></span>\n        </span>\n  #end\n        <span id=\"${htmlLiveTableId}-ajax-loader\" class=\"xwiki-livetable-loader hidden\">\n          <img src=\"$xwiki.getSkinFile('icons/xwiki/ajax-loader-large.gif')\" alt=\"$escapetool.xml($services.localization.render('platform.livetable.loading'))\" title=\"\" />\n        </span>\n        <span class=\"controlPagination\">\n          <a title=\"$escapetool.xml($services.localization.render('platform.livetable.paginationPagePrevTitle'))\" class=\"prevPagination\" href=\"#\"><span class=\"hidden\">$services.localization.render('platform.livetable.paginationPagePrevTitle')</span></a>\n          <a title=\"$escapetool.xml($services.localization.render('platform.livetable.paginationPageNextTitle'))\" class=\"nextPagination\" href=\"#\"><span class=\"hidden\">$services.localization.render('platform.livetable.paginationPageNextTitle')</span></a>\n        </span>\n        <span class=\"pagination\">\n          <span class=\"xwiki-livetable-pagination-text\">$services.localization.render('platform.livetable.paginationPage')</span>\n          <span class=\"xwiki-livetable-pagination-content\" ></span>\n        </span>\n      </td>\n    </tr>\n    <tr>\n      <td class=\"xwiki-livetable-display-container\">\n        <table class=\"xwiki-livetable-display\">\n          <thead class=\"xwiki-livetable-display-header\">\n            <tr>\n            #set($columnCount = 0)\n            #foreach($colname in $collist)\n              #set($colprop = $colprops.get($colname))\n              #set ($isFilterable = $colprop.filterable != false && $colname != '_actions' && $colprop.type != 'hidden')\n              #set ($isSortable = $colprop.sortable != false && $colname != '_actions' && $colprop.type != 'hidden')\n              ## Get the column's display name to use in the header.\n              #set($displayName = \"#getLivetableColumnDisplayName($colname, $colprop, $transprefix)\")\n              #set ($defaultHeaderClass = {'_actions': 'actions', '_avatar': 'avatar'})\n              #set ($discard = $colprop.putIfAbsent('headerClass', $defaultHeaderClass.get($colname)))\n              <th scope=\"col\" class=\"xwiki-livetable-display-header-text $!colprop.headerClass\n                  #if ($!colprop.type == 'hidden')hidden#end\n                  #if ($isSortable)sortable #if ($colname == $selectedColumn)selected $defaultOrder#else asc#end#end\">\n                #if($isSortable)<a rel=\"${colname}\">#end\n                #if($isFilterable)<label for=\"xwiki-livetable-${htmlLiveTableId}-filter-${foreach.count}\">#end\n                $displayName\n                #if($isFilterable)</label>#end\n                #if($isSortable)</a>#end\n                #set($columnCount = $mathtool.add($columnCount, 1))\n              </th>\n            #end\n            </tr>\n            #livetable_filters($collist $colprops $classname)\n            <tr class=\"xwiki-livetable-initial-message\">\n              <td colspan=\"${columnCount}\">\n                <div class=\"warningmessage\">$services.localization.render('platform.livetable.environmentCannotLoadTableMessage')</div>\n              </td>\n            </tr>\n          </thead>\n          <tbody id=\"${htmlLiveTableId}-display\" class=\"xwiki-livetable-display-body\"><tr><td>&nbsp;</td></tr></tbody>\n        </table>\n      </td>\n    </tr>\n    <tr>\n      <td class=\"xwiki-livetable-pagination\">\n        <span class=\"xwiki-livetable-limits\"></span>\n        <span class=\"controlPagination\">\n          <a title=\"$escapetool.xml($services.localization.render('platform.livetable.paginationPagePrevTitle'))\" class=\"prevPagination\" href=\"#\"><span class=\"hidden\">$services.localization.render('platform.livetable.paginationPagePrevTitle')</span></a>\n          <a title=\"$escapetool.xml($services.localization.render('platform.livetable.paginationPageNextTitle'))\" class=\"nextPagination\" href=\"#\"><span class=\"hidden\">$services.localization.render('platform.livetable.paginationPageNextTitle')</span></a>\n        </span>\n        <span class=\"pagination\">\n          <span class=\"xwiki-livetable-pagination-text\">$services.localization.render('platform.livetable.paginationPage')</span>\n          <span class=\"xwiki-livetable-pagination-content\" ></span>\n        </span>\n      </td>\n    </tr>\n  </table>\n  <div id=\"${htmlLiveTableId}-inaccessible-docs\" class=\"hidden\">\n    #info($services.localization.render('rightsmanager.documentrequireviewrights'))\n  </div>\n  <div id=\"${htmlLiveTableId}-computed-title-docs\" class=\"hidden\">\n    #info(\"(<span class='docTitleComputed'></span>)&nbsp;$services.localization.render('platform.livetable.docTitleComputedHint')\")\n  </div>\n</div>## xwiki-livetable-container\n#end## end-livetable-macro\n\n#macro (livetable_filters $columns $columnsProperties $xclassName)\n  <tr class=\"xwiki-livetable-display-filters\">\n    #foreach ($column in $columns)\n      #set ($columnProperties = $columnsProperties.get($column))\n      ## Note: Even though the column is hidden, we still need a (pottentially hidden) TD to generate valid HTML\n      <td class=\"xwiki-livetable-display-header-filter #if (\"$!columnProperties.type\" == 'hidden')hidden#end\">\n        #if ($columnProperties.type != 'hidden')\n          #if ($columnProperties.filterable != false && \"$!column\" != '_actions')\n            #set ($columnXClassName = $columnProperties.get('class'))\n            #set ($columnXPropertyName = $column)\n            #if (!$columnXClassName)\n              #if ($column.startsWith('doc.'))\n                #set ($columnXClassName = 'XWiki.DocumentClass')\n                #set ($columnXPropertyName = $column.substring(4))\n              #else\n                #set ($columnXClassName = $xclassName)\n              #end\n            #end\n            #set ($xclass = $xwiki.getDocument($columnXClassName).getxWikiClass())\n            #set ($xproperty = $xclass.get($columnXPropertyName))\n            #livetable_filter($column $columnProperties $xproperty)\n          #end\n        #end\n      </td>\n    #end\n  </tr>\n#end\n\n#macro (livetable_filter $column $columnProperties $xproperty)\n  #set ($filterType = $columnProperties.type)\n  #if (\"$!filterType\" == '')\n    ## Determine the filter type from the xproperty type.\n    #set ($filterTypeByXPropertyType = {\n      'Boolean': 'boolean',\n      'DBList': 'suggest',\n      'DBTreeList': 'suggest',\n      'Date': 'text',\n      'Email': 'text',\n      'Groups': 'suggest',\n      'Number': 'number',\n      'Page': 'suggest',\n      'StaticList': 'list',\n      'String': 'text',\n      'TextArea': 'text',\n      'Users': 'suggest'\n    })\n    #set ($filterType = $filterTypeByXPropertyType.get($xproperty.classType))\n    #if (\"$!filterType\" == '')\n      ## If we get here then it means the column is filterable but we could not determine the filter type. Use the text\n      ## filter in this case because it is the most generic.\n      #set ($filterType = 'text')\n    #end\n  #end\n  #set($escapedTitle = $escapetool.xml($services.localization.render('platform.livetable.filtersTitle',\n    [$services.localization.render(\"${transprefix}$column\")])))\n  #if ($filterType == 'list' || $filterType == 'multilist')\n    <select id=\"xwiki-livetable-${htmlLiveTableId}-filter-${foreach.count}\" name=\"$column\"\n      #if ($filterType == 'multilist')\n        class=\"xwiki-livetable-multilist\" multiple=\"multiple\">\n      #else\n        ><option value=\"\">$services.localization.render('platform.livetable.selectAll')</option>\n        <option disabled=\"disabled\"></option>\n      #end\n    #set ($storedValues = $xproperty.listValues)\n    #set ($displayedValues = $xproperty.mapValues)\n    #foreach ($storedValue in $storedValues)\n      #set ($l10nKey = \"${xproperty.className}_${column}_$storedValue\")\n      #set ($displayedValue = $services.localization.render($l10nKey))\n      #if ($displayedValue == $l10nKey)\n        #set ($displayedValue = $displayedValues.get($storedValue).value)\n      #end\n      <option value=\"$storedValue\">$displayedValue</option>\n    #end\n    </select>\n  #elseif ($filterType == 'boolean')\n    <select id=\"xwiki-livetable-${htmlLiveTableId}-filter-${foreach.count}\" name=\"$column\">\n      <option value=\"\">$services.localization.render('platform.livetable.selectAll')</option>\n      <option value=\"0\">$services.localization.render('no')</option>\n      <option value=\"1\">$services.localization.render('yes')</option>\n    </select>\n  #elseif ($filterType == 'text' || $filterType == 'number')\n    <input id=\"xwiki-livetable-${htmlLiveTableId}-filter-${foreach.count}\" name=\"$column\" type=\"text\"\n      #if (\"$!columnProperties.size\" != '')size=\"$!escapetool.xml($columnProperties.size)\"#end\n      title=\"$escapedTitle\"/>\n  #elseif ($filterType == 'suggest' && $xproperty)\n    #set ($discard = $xwiki.linkx.use($services.webjars.url('selectize.js', 'css/selectize.css'),\n      {'type': 'text/css', 'rel': 'stylesheet'}))\n    #set ($discard = $xwiki.ssfx.use('uicomponents/suggest/xwiki.selectize.css', true))\n    #set ($discard = $xwiki.jsfx.use('uicomponents/suggest/suggestPropertyValues.js'))\n    <select id=\"xwiki-livetable-${htmlLiveTableId}-filter-${foreach.count}\" name=\"$!escapetool.xml($column)\"\n      class=\"suggest-propertyValues\" multiple=\"multiple\" size=\"1\"\n      data-className=\"$!escapetool.xml($xproperty.className)\" data-propertyName=\"$!escapetool.xml($xproperty.name)\"\n      title=\"$escapedTitle\">\n    </select>\n  #end\n#end\n\n#**\n * Internal macro - Determine the name to be displayed in a livetable's column header. Strategy is as follows :\n * - If defined, the 'displayName' passed as a column option wins.\n * - If not, and if a i18n prefix has been passed, we use the localization tool with the prefix + the column name.\n * - Finally, we fall back on the column name.\n *\n * @param colname the column name\n * @param colprop the column properties map\n * @param transprefix the translations prefix to use\n *\n * @internal\n *#\n##\n#macro(getLivetableColumnDisplayName $colname $colprop $transprefix)\n  #if(\"$!colprop.displayName\" != '')\n    #set($displayName = $colprop.displayName)##\n  #elseif($transprefix != '')\n    #set($displayName = $services.localization.render(\"${transprefix}${colname}\"))##\n  #else\n    #set($displayName = $colname)##\n  #end\n$displayName##\n#end\n\n#macro (livetable_normalizeColumnDescriptors $columnDescriptors $colList $transPrefix)\n  ## Make sure the columns containing HTML are formatted in HTML indeed\n  #set ($htmlColumnKeys = ['doc.location'])\n  #foreach($htmlColumnKey in $htmlColumnKeys)\n    #if ($colList.contains($htmlColumnKey))\n      #set ($htmlColumnProps = $columnDescriptors[$htmlColumnKey])\n      #if (!$htmlColumnProps)\n        #set ($htmlColumnProps = {})\n        #set ($columnDescriptors[$htmlColumnKey] = $htmlColumnProps)\n      #end\n      #if ($htmlColumnProps.html == $NULL)\n        #set ($htmlColumnProps.html = true)\n      #end\n    #end\n  #end\n  ## Translate the column descriptor.\n  #foreach ($entry in $columnDescriptors.entrySet())\n    #if (\"$!entry.value.displayName\" == '' && \"$!transPrefix\" != '')\n      #set ($entry.value.displayName = $services.localization.render(\"${transPrefix}$entry.key\"))\n    #end\n  #end\n  #livetable_normalizeActionsDescriptor($columnDescriptors $transPrefix)\n#end\n\n#macro (livetable_normalizeActionsDescriptor $columnDescriptors $transPrefix)\n  #set ($actionsDescriptor = $columnDescriptors.get('_actions'))\n  #if ($actionsDescriptor)\n    #foreach ($action in $actionsDescriptor.actions)\n      ## If the action is specified as a string then only the action id is specified.\n      #if ($action.equals(\"$!action\"))\n        ## Note that 'labels' and 'actionCallbacks' are deprecated.\n        #set ($action = {\n          'id': $action,\n          'label': $actionsDescriptor.labels.get($action),\n          'async': $actionsDescriptor.ajaxActions.get($action),\n          'callback': $actionsDescriptor.actionCallbacks.get($action)\n        })\n        #set ($discard = $actionsDescriptor.actions.set($foreach.index, $action))\n      #end\n      #if (\"$!action.label\" == '')\n        #if (\"$!transPrefix\" != '' && $services.localization.get(\"${transPrefix}_actions.$action.id\"))\n          #set ($action.label = $services.localization.render(\"${transPrefix}_actions.$action.id\"))\n        #elseif ($services.localization.get(\"platform.livetable._actions.$action.id\"))\n          #set ($action.label = $services.localization.render(\"platform.livetable._actions.$action.id\"))\n        #else\n          #set ($action.label = $action.id)\n        #end\n      #end\n      #if (\"$!action.icon\" == '')\n        #set ($defaultActionIcons = {\n          'rename': 'move',\n          'delete': 'cross',\n          'restore': 'refresh',\n          'undelete': 'refresh',\n          'rights': 'lock',\n          'edit': 'pencil',\n          'view': 'eye'\n        })\n        #set ($action.icon = $defaultActionIcons.getOrDefault($action.id, $action.id))\n      #end\n      #set ($action.icon = \"$!services.icon.renderHTML($action.icon)\")\n    #end\n  #end\n#end\n\n#**\n * Internal macro - Remove the obfuscated results (i.e., non-viewable rows) from the map when the total number of \n * returned rows is larger or equal to the total number of counted rows.\n *\n * @param map the response map returned to the user. This map is expected to have a totalrows and returnedrows fields\n *            with numeric values and a rows field containing a arrow of objects containing a doc_viewable boolean\n *            field   \n *\n * @internal\n * @since 13.9RC1\n * @since 13.4.4\n * @since 12.10.11\n *#\n##\n#macro (livetable_filterObfuscated $map)\n  ## When the total number of rows is not bigger than the limit, we remove the obfuscated results from the response since\n  ## this has no impact on the pagination.\n  #set ($rows = $map.get('rows'))\n  #set ($offset = 0)\n  #if($map.get('offset'))\n    #set ($offset = $mathtool.sub($map.get('offset'), 1))\n  #end\n  #if ($map.get('totalrows') <= $map.get('returnedrows'))\n    #set ($filteredRows = [])\n    #foreach ($row in $rows)\n      #if($row['doc_viewable'])\n        #set ($discard = $filteredRows.add($row))\n      #end\n    #end\n    ## The offset needs to be taken into account when returning the total number of pages otherwise, client-side can\n    ## consider that previsouly returned results have been removed (e.g., in case of page size change).\n    #set($discard = $map.put('totalrows', $mathtool.add($filteredRows.size(), $offset)))\n    #set($discard = $map.put('returnedrows', $filteredRows.size()))\n  #else\n    #set ($filteredRows = $rows)\n  #end\n  #set ($discard = $map.put('rows', $filteredRows))\n#end\n\n#**\n * Modifies the passed where clause of the query (and its parameters) to add a \"location\" filter.\n *\n * To be used when the passed whereParams parameter is either of type Map or of type List but the whereSQL query is\n * using the \"?\" syntax for specifying parameters. Should always be used instead of #addLivetableLocationFilter which\n * is buggy when called several times (it'll add the same HQL binding name every time it's called!\n * See https://jira.xwiki.org/browse/XWIKI-17463).\n *\n * @param whereQL existing where clause to augment\n * @param whereParams existing query params to augment\n * @param locationValue if not empty then filters pages matching the passed values, with the \"/\" character acting as\n *        a wildcard (e.g. passing \"Blog/Intro\" will match \"Blog.BlogIntroduction\")\n * @param filterWebHome if true then treat \"WebHome\" as a normal input string like any other (defaults to false)\n * @param customWhereQL if defined then use that query instead of computing it ourselves. In this case the filterWebHome\n *        and locationValue parameters are ignored\n * @internal\n * @since 12.5\n *#\n#macro(filterLocation $whereQL $whereParams $locationValue $hqlLocationBindingName $filterWebHome $customWhereQL)\n  #if (\"$!locationValue\" != '')\n    ## Location is a special case, that we need to handle separatly.\n    ## It is actually not a real field, but a special request on doc.fullName, more user-friendly.\n    #set ($locationFilterValue = $locationValue)\n    ## Note: the \"_\", \"[\", and the \"%\" characters have special meanings in standard SQL servers (they behave as\n    ## wildcards). However, it is not what the user expects (e.g. https://jira.xwiki.org/browse/XWIKI-12608).\n    ## As a consequence, we must escape these characters.\n    ## See http://www.jguru.com/faq/view.jsp?EID=8881 to understand why we use the special clause 'escape' below.\n    ## Since we use '!' for the escaping, we also double existing ones.\n    #set ($locationFilterValue = $locationFilterValue.replaceAll('([\\[%_!])', '!$1'))\n    ## Because the user might filter with \"/\" as separator we replace that by \"%\", because it could be \".\"\n    ## (the space separator) or \"/\" (as it is in the document name).\n    ## In addition, using \"%\" (any sequence of character) instead of \"_\" (any single character) gives the ability\n    ## to filter on different levels:\n    ##   e.g. filtering on \"Blog/Intro\" will return \"Blog.BlogIntroduction\".\n    #set ($locationFilterValue = $locationFilterValue.replaceAll('/', '%.%'))\n    #if (\"$!customWhereQL\" != '')\n      #set ($internalWhereQL = \"${whereQL} $customWhereQL\")\n    #else\n      #if ($whereParams.entrySet())\n        #set ($discard = $whereParams.put($hqlLocationBindingName, \"%${locationFilterValue}%\"))\n      #else\n        #set ($discard = $whereParams.add(\"%${locationFilterValue}%\"))\n      #end\n      #if ($filterWebHome == true)\n        #if ($whereParams.entrySet())\n          #set ($matchNestedDocument = \"(doc.name = 'WebHome' AND LOWER(doc.space) LIKE LOWER(:$hqlLocationBindingName) ESCAPE '!')\")\n          #set ($matchTerminalDocument = \"(doc.name <> 'WebHome' AND LOWER(doc.fullName) LIKE LOWER(:$hqlLocationBindingName) ESCAPE '!')\")\n          #set ($internalWhereQL = \"${whereQL} AND ($matchNestedDocument OR $matchTerminalDocument)\")\n        #else\n          #set ($matchNestedDocument = \"(doc.name = 'WebHome' AND LOWER(doc.space) LIKE LOWER(?) ESCAPE '!')\")\n          #set ($matchTerminalDocument = \"(doc.name <> 'WebHome' AND LOWER(doc.fullName) LIKE LOWER(?) ESCAPE '!')\")\n          #set ($internalWhereQL = \"${whereQL} AND ($matchNestedDocument OR $matchTerminalDocument)\")\n          #set ($discard = $whereParams.add(\"%${locationFilterValue}%\"))\n        #end\n      #else\n        #if ($whereParams.entrySet())\n          #set ($internalWhereQL = \"${whereQL} AND LOWER(doc.fullName) LIKE LOWER(:$hqlLocationBindingName) ESCAPE '!'\")\n        #else\n          #set ($internalWhereQL = \"${whereQL} AND LOWER(doc.fullName) LIKE LOWER(?) ESCAPE '!'\")\n        #end\n      #end\n    #end\n    #set ($whereQL = $NULL)\n    #setVariable(\"$whereQL\", $internalWhereQL)\n  #end\n#end\n##\n##\n#**\n * Modifies the passed where clause of the query (and its parameters) to add a \"location\" filter.\n *\n * To be used when the passed whereParams parameter is either of type Map or of type List but the whereSQL query is\n * using the \"?\" syntax for specifying parameters.\n *\n * @param whereQL existing where clause to augment\n * @param whereParams existing query params to augment\n * @param locationValue if not empty then filters pages matching the passed values, with the \"/\" character acting as\n *        a wildcard (e.g. passing \"Blog/Intro\" will match \"Blog.BlogIntroduction\")\n * @param filterWebHome if true then treat \"WebHome\" as a normal input string like any other (defaults to false)\n * @param customWhereQL if defined then use that query instead of computing it ourselves. In this case the filterWebHome\n *        and locationValue parameters are ignored\n * @internal\n * @deprecated starting with 12.5 use #filterLocation since this macro is buggy when called several times\n *#\n#macro(addLivetableLocationFilter $whereQL $whereParams $locationValue $filterWebHome $customWhereQL)\n  #if (\"$!locationValue\" != '')\n    ## Location is a special case, that we need to handle separatly.\n    ## It is actually not a real field, but a special request on doc.fullName, more user-friendly.\n    #set ($locationFilterValue = $locationValue)\n    ## Note: the \"_\", \"[\", and the \"%\" characters have special meanings in standard SQL servers (they behave as\n    ## wildcards). However, it is not what the user expects (e.g. https://jira.xwiki.org/browse/XWIKI-12608).\n    ## As a consequence, we must escape these characters.\n    ## See http://www.jguru.com/faq/view.jsp?EID=8881 to understand why we use the special clause 'escape' above.\n    ## Since we use '!' for the escaping, we also double existing ones.\n    #set ($locationFilterValue = $locationFilterValue.replaceAll('([\\[%_!])', '!$1'))\n    ## Because the user might filter with \"/\" as separator we replace that by \"%\", because it could be \".\"\n    ## (the space separator) or \"/\" (as it is in the document name).\n    ## In addition, using \"%\" (any sequence of character) instead of \"_\" (any single character) gives the ability\n    ## to filter on different levels:\n    ##   e.g. filtering on \"Blog/Intro\" will return \"Blog.BlogIntroduction\".\n    #set ($locationFilterValue = $locationFilterValue.replaceAll('/', '%.%'))\n    #if (\"$!customWhereQL\" != '')\n      #set ($internalWhereQL = \"${whereQL} $customWhereQL\")\n    #else\n      #if ($whereParams.entrySet())\n        #set ($discard = $whereParams.put('locationFilterValue', \"%${locationFilterValue}%\"))\n      #else\n        #set ($discard = $whereParams.add(\"%${locationFilterValue}%\"))\n      #end\n      #if ($filterWebHome == true)\n        #if ($whereParams.entrySet())\n          #set ($matchNestedDocument = \"(doc.name = 'WebHome' AND LOWER(doc.space) LIKE LOWER(:locationFilterValue) ESCAPE '!')\")\n          #set ($matchTerminalDocument = \"(doc.name <> 'WebHome' AND LOWER(doc.fullName) LIKE LOWER(:locationFilterValue) ESCAPE '!')\")\n          #set ($internalWhereQL = \"${whereQL} AND ($matchNestedDocument OR $matchTerminalDocument)\")\n        #else\n          #set ($matchNestedDocument = \"(doc.name = 'WebHome' AND LOWER(doc.space) LIKE LOWER(?) ESCAPE '!')\")\n          #set ($matchTerminalDocument = \"(doc.name <> 'WebHome' AND LOWER(doc.fullName) LIKE LOWER(?) ESCAPE '!')\")\n          #set ($internalWhereQL = \"${whereQL} AND ($matchNestedDocument OR $matchTerminalDocument)\")\n          #set ($discard = $whereParams.add(\"%${locationFilterValue}%\"))\n        #end\n      #else\n        #if ($whereParams.entrySet())\n          #set ($internalWhereQL = \"${whereQL} AND LOWER(doc.fullName) LIKE LOWER(:locationFilterValue) ESCAPE '!'\")\n        #else\n          #set ($internalWhereQL = \"${whereQL} AND LOWER(doc.fullName) LIKE LOWER(?) ESCAPE '!'\")\n        #end\n      #end\n    #end\n    #set ($whereQL = $NULL)\n    #setVariable(\"$whereQL\", $internalWhereQL)\n #end\n#end\n##\n##\n#**\n * Modifies the passed where clause of the query (and its parameters) to add a \"location\" filter.\n *\n * To be used when the passed whereParams parameter is of type List and the whereSQL query is using the \"?N\" syntax\n * for specifying parameters.\n *\n * @param whereQL existing where clause to augment\n * @param whereParams existing query params to augment\n * @param locationValue if not empty then filters pages matching the passed values, with the \"/\" character acting as\n *        a wildcard (e.g. passing \"Blog/Intro\" will match \"Blog.BlogIntroduction\")\n * @param filterWebHome if true then treat \"WebHome\" as a normal input string like any other (defaults to false)\n * @param customWhereQL if defined then use that query instead of computing it ourselves. In this case the filterWebHome\n *        and locationValue parameters are ignored\n * @internal\n * @since 11.6\n *#\n#macro(addLocationFilter $whereQL $whereParams $locationValue $filterWebHome $customWhereQL)\n  #if (\"$!locationValue\" != '')\n    ## Location is a special case, that we need to handle separatly.\n    ## It is actually not a real field, but a special request on doc.fullName, more user-friendly.\n    #set ($locationFilterValue = $locationValue)\n    ## Note: the \"_\", \"[\", and the \"%\" characters have special meanings in standard SQL servers (they behave as\n    ## wildcards). However, it is not what the user expects (e.g. https://jira.xwiki.org/browse/XWIKI-12608).\n    ## As a consequence, we must escape these characters.\n    ## See http://www.jguru.com/faq/view.jsp?EID=8881 to understand why we use the special clause 'escape' above.\n    ## Since we use '!' for the escaping, we also double existing ones.\n    #set ($locationFilterValue = $locationFilterValue.replaceAll('([\\[%_!])', '!$1'))\n    ## Because the user might filter with \"/\" as separator we replace that by \"%\", because it could be \".\"\n    ## (the space separator) or \"/\" (as it is in the document name).\n    ## In addition, using \"%\" (any sequence of character) instead of \"_\" (any single character) gives the ability\n    ## to filter on different levels:\n    ##   e.g. filtering on \"Blog/Intro\" will return \"Blog.BlogIntroduction\".\n    #set ($locationFilterValue = $locationFilterValue.replaceAll('/', '%.%'))\n    #if (\"$!customWhereQL\" != '')\n      #set ($internalWhereQL = \"${whereQL} $customWhereQL\")\n    #else\n      #set ($discard = $whereParams.add(\"%${locationFilterValue}%\"))\n      #if ($filterWebHome == true)\n        #set ($matchNestedDocument = \"(doc.name = 'WebHome' AND LOWER(doc.space) LIKE LOWER(?${whereParams.size()}) ESCAPE '!')\")\n        #set ($matchTerminalDocument = \"(doc.name <> 'WebHome' AND LOWER(doc.fullName) LIKE LOWER(?${whereParams.size()}) ESCAPE '!')\")\n        #set ($internalWhereQL = \"${whereQL} AND ($matchNestedDocument OR $matchTerminalDocument)\")\n      #else\n        #set ($internalWhereQL = \"${whereQL} AND LOWER(doc.fullName) LIKE LOWER(?${whereParams.size()}) ESCAPE '!'\")\n      #end\n    #end\n    #set ($whereQL = $NULL)\n    #setVariable(\"$whereQL\", $internalWhereQL)\n #end\n#end\n##\n##\n#**\n * Pagination 2.0\n *\n * Displays a generic pagination widget for browsing a collection of items.\n * The macro is responsible for displaying browsing links, and does not involve the actual display of the browsed items.\n *\n * @param parameters A map of parameters:\n * <dl>\n *   <dt>url</dt>\n *   <dd>The base url of the document displaying the collection.</dd>\n *   <dd>Default: $doc.getURL('view')</dd>\n *   <dt>totalItems</dt>\n *   <dd>The total number number of items in the collection.</dd>\n *   <dd>Default: none, this parameter is mandatory.</dd>\n *   <dt>defaultItemsPerPage</dt>\n *   <dd>The number of items per page. This value is overwritten by the request parameter \"perPage\", if it exists and\n *       has a valid positive integer value.</dd>\n *   <dd>Default: 20</dd>\n *   <dt>position</dt>\n *   <dd>The placement of the pagination widget. Supported values: \"top\", \"bottom\". The bottom widget only displays\n *       pages, while the top widget also provides a information about the item range on the current page.</dd>\n *   <dd>Default: top</dd>\n *   <dt>itemParamName</dt>\n *   <dd>The name of the request parameter for the index of the first displayed item.</dd>\n *   <dd>Default: firstIndex</dd>\n *   <dt>itemsPerPageParamName</dt>\n *   <dd>The name of the request parameter for the number of items displayed on a page.</dd>\n *   <dd>Default: perPage</dd>\n *   <dt>noSx</dt>\n *   <dd>Do not force to use the pagination Skin Extension</dd>\n *   <dd>Default: false</dd>\n *   <dt>hash</dt>\n *   <dd>An optional URL hash to be appended to all pagination links generated by this macro.</dd>\n *   <dd>Default: none</dd>\n * </dl>\n *#\n#macro(pagination $parameters)\n  #if(!$parameters.noSx)\n  $xwiki.ssfx.use('uicomponents/pagination/pagination.css', true)##\n  #end\n  #if(\"$!{parameters.url}\" == '')\n    #set($parameters.url = $doc.getURL('view'))\n  #end\n  #if(!$parameters.url.contains('?'))\n    #set($parameters.url = \"${parameters.url}?\")\n  #end\n  #if($parameters.position != 'bottom')\n    #set($parameters.position = 'top')\n  #end\n  #paginationPrepareParams($parameters)\n  #paginationDisplay($parameters)\n#end\n#**\n * Pagination : request parameters preparation\n *\n * Used internally by the pagination macro. Retrieves pagination parameter values from the request:\n * \"firstIndex\" = the index of the first displayed item; \"perPage\" = number of items per page\n *\n * @see #pagination\n * @internal\n *#\n#macro(paginationPrepareParams $parameters)\n  ## Setting some defaults\n  #if(\"$!{parameters.itemParamName}\" == '')\n    #set($parameters.itemParamName = 'firstIndex')\n  #end\n  #if(\"$!{parameters.itemsPerPageParamName}\" == '')\n    #set($parameters.itemsPerPageParamName = 'perPage')\n  #end\n  ## Adding the hash sign to the hash parameter if it is not present already\n  #if(\"$!{parameters.hash}\" != '' && !$parameters.hash.startsWith($escapetool.H))\n    #set($parameters.hash = \"${escapetool.H}${parameters.hash}\")\n  #end\n  ## Get starting item number from request\n  #set ($parameters.firstItem = \"$!{request.get($parameters.itemParamName)}\")\n  #set ($parameters.firstItem = $numbertool.toNumber($parameters.firstItem).intValue())\n  #if (!$parameters.firstItem)\n    #set ($parameters.firstItem = 0)\n  #end\n  ## Get number of items per page from request\n  #if (!$parameters.defaultItemsPerPage || $numbertool.toNumber($parameters.defaultItemsPerPage).intValue() <= 0)\n    #set ($parameters.defaultItemsPerPage = 20)\n  #end\n  #set ($parameters.itemsPerPage = \"$!{request.get($parameters.itemsPerPageParamName)}\")\n  #set ($parameters.itemsPerPage = $numbertool.toNumber($parameters.itemsPerPage).intValue())\n  #if (!$parameters.itemsPerPage || $parameters.itemsPerPage <= 0)\n    #set ($parameters.itemsPerPage = $parameters.defaultItemsPerPage)\n  #end\n#end\n#**\n * Pagination : display the pagination widget after all parameters have been computed\n *\n * Used internally by the pagination macro.\n *\n * @see #pagination\n * @internal\n *#\n#macro(paginationDisplay $parameters)\n  #set($parameters.pageCount = ($parameters.totalItems + $parameters.itemsPerPage - 1) / $parameters.itemsPerPage)\n  #if($parameters.firstItem >= $parameters.totalItems)\n    #set($parameters.firstItem = ($parameters.pageCount - 1) * $parameters.itemsPerPage)\n  #elseif($parameters.firstItem < 0)\n    #set($parameters.firstItem = 0)\n  #end\n  #set($parameters.crtPage = $parameters.firstItem / $parameters.itemsPerPage)\n  ## Make firstItem a multiple of itemsPerPage\n  #set($parameters.firstItem = $parameters.crtPage * $parameters.itemsPerPage)\n  #set($parameters.lastPage = $parameters.pageCount - 1)\n  <div class=\"paginationFilter\">\n    #if($parameters.position == 'top')\n      #paginationResultsRange($parameters)\n    #end\n    #if($parameters.totalItems > 0)\n      #if($parameters.controlsAround == true)\n        #paginationControlLeft($parameters)\n        #paginationPages($parameters)\n        #paginationControlRight($parameters)\n      #else\n        #paginationControl($parameters)\n        #paginationPages($parameters)\n      #end\n    #end\n  </div>\n#end\n#**\n * Pagination : display links for browsing pages\n *\n * Used internally by the pagination macro.\n *\n * @see #pagination\n * @internal\n *#\n#macro(paginationPages $parameters)\n## $url $crtPage $itemsPerPage $lastPage $pageCount $itemParamName $itemsPerPageParamName)\n  #set($contextLeft  = 4)\n  #set($contextRight = 4)\n  #set($contextWidth = $contextLeft + 1 + $contextRight)\n  #if($parameters.pageCount <= $contextWidth)\n    #set($contextFirstPage = 0)\n    #set($contextLastPage = $parameters.pageCount - 1)\n  #else\n    #set($contextFirstPage = $parameters.crtPage - $contextLeft)\n    #set($contextLastPage = $parameters.crtPage + $contextRight)\n    #if($contextFirstPage < 0)\n      #set($contextFirstPage = 0)\n    #end\n    #if($contextLastPage >= $parameters.pageCount)\n      #set($contextLastPage = $parameters.pageCount - 1)\n    #end\n    #if($contextLastPage < $contextWidth)\n      #set($contextLastPage = $contextWidth - 1)\n    #end\n    #if($contextFirstPage > $parameters.pageCount - $contextWidth)\n      #set($contextFirstPage = $parameters.pageCount - $contextWidth)\n    #end\n  #end\n  <span class=\"pagination\">$services.localization.render('platform.livetable.paginationPage')\n  #if($contextFirstPage != 0)\n    #paginationPageLink(0 $parameters)\n  #end\n  #if($contextFirstPage > 1) ... #end\n  #foreach ($i in [$contextFirstPage .. $contextLastPage])\n    #paginationPageLink($i $parameters)\n  #end\n  #if($parameters.lastPage - $contextLastPage > 1) ... #end\n  #if($contextLastPage != $parameters.lastPage)\n    #paginationPageLink($parameters.lastPage $parameters)\n  #end\n  </span>\n#end\n#**\n * Pagination : display the link to a certain page (indicated by $pageNumber)\n *\n * Used internally by the pagination macro.\n *\n * @see #pagination\n * @internal\n *#\n#macro(paginationPageLink $pageNumber $parameters)\n  #set($firstItem = $pageNumber * $parameters.itemsPerPage)\n  #set($displayedPageNumber = $pageNumber + 1)\n  #if($pageNumber == $parameters.crtPage)\n  <span class=\"currentPage\">$displayedPageNumber</span>\n  #else\n    <a href=\"${parameters.url}&amp;${parameters.itemParamName}=${firstItem}#if($parameters.itemsPerPage != $parameters.defaultItemsPerPage)&amp;${parameters.itemsPerPageParamName}=${parameters.itemsPerPage}#end$!{parameters.hash}\" title=\"$services.localization.render('platform.livetable.paginationPageTitle', [$displayedPageNumber])\">$displayedPageNumber</a>\n  #end\n#end\n#**\n * Pagination : display prev / next links\n *\n * Used internally by the pagination macro.\n *\n * @see #pagination\n * @internal\n *#\n#macro(paginationControl $parameters)\n  <span class=\"controlPagination\">\n  #paginationControlLeft($parameters)\n  #paginationControlRight($parameters)\n  </span>\n#end\n#**\n * Pagination : display prev link\n *\n * Used internally by the pagination macro.\n *\n * @see #pagination\n * @internal\n *#\n#macro(paginationControlLeft $parameters)\n  #if($parameters.crtPage > 0)\n    #set($prevPage = $parameters.crtPage - 1)\n    #set($firstItem = $prevPage * $parameters.itemsPerPage)\n    <a href=\"${parameters.url}&amp;${parameters.itemParamName}=${firstItem}#if($parameters.itemsPerPage != $parameters.defaultItemsPerPage)&amp;${parameters.itemsPerPageParamName}=${parameters.itemsPerPage}#end$!{parameters.hash}\" title=\"$services.localization.render('platform.livetable.paginationPagePrevTitle')\" class=\"prevPagination\">$services.localization.render('platform.livetable.paginationPagePrevious')</a>\n  #else\n    <span class=\"noPrevPagination\"> </span>\n  #end\n#end\n#**\n * Pagination : display next link\n *\n * Used internally by the pagination macro.\n *\n * @see #pagination\n * @internal\n *#\n#macro(paginationControlRight $parameters)\n  #if($parameters.crtPage < $parameters.lastPage)\n    #set($nextPage = $parameters.crtPage + 1)\n    #set($firstItem = $nextPage * $parameters.itemsPerPage)\n    <a href=\"${parameters.url}&amp;${parameters.itemParamName}=${firstItem}#if($parameters.itemsPerPage != $parameters.defaultItemsPerPage)&amp;${parameters.itemsPerPageParamName}=${parameters.itemsPerPage}#end$!{parameters.hash}\" title=\"$services.localization.render('platform.livetable.paginationPageNextTitle')\" class=\"nextPagination\">$services.localization.render('platform.livetable.paginationPageNext')</a>\n  #else\n    <span class=\"noNextPagination\"> </span>\n  #end\n#end\n#**\n * Pagination : message informing the user which items are being displayed on the current page (Results i - j of N)\n *\n * Used internally by the pagination macro.\n *\n * @see #pagination\n * @internal\n *#\n#macro(paginationResultsRange $parameters)\n  #set($from = $parameters.firstItem + 1)\n  #set($to =   $parameters.firstItem + $parameters.itemsPerPage)\n  #if ($to > $parameters.totalItems)\n    #set($to = $parameters.totalItems)\n  #end\n  <span class=\"resultsNo\">\n  #if($parameters.totalItems == 0)\n    <span class='currentResultsNo'>$services.localization.render('platform.livetable.paginationResultsNone')</span>\n  #elseif($parameters.totalItems == 1)\n    <span class='currentResultsNo'>$services.localization.render('platform.livetable.paginationResultsOne')</span>\n  #elseif($from == $parameters.totalItems)\n    $services.localization.render('platform.livetable.paginationResultsSingle', [$from, $parameters.totalItems])\n  #else\n    $services.localization.render('platform.livetable.paginationResultsMany', [$from, $to, $parameters.totalItems])\n  #end\n  </span>\n#end\n\n#**\n * Generates a vertical menu from an object describing the categories\n *\n * Expected format of the object:\n * menu = vector of items\n * item = map with the following fields:\n *        'id'       : mandatory\n *        'name'     : the text displayed for the corresponding menu item;\n *                     optional, defaults to\n *                     $services.localization.render(\"$!{translationPrefix}${item.id}\")\n *        'url'      : the \"action\" of the menu item; optional, defaults to #\n *        'cssClass' : a specific css class for the menu item for custom\n *                     styling; optional, defaults to ''\n *        'children' : vector of items, allowing to recursively define submenus\n *\n * @param $menu the menu object, in the format described above\n * @param $options a map of options, where the following entries are currently used:\n *        'translationPrefix' :  the translation prefix added to the id of each\n *                     item, in order to generate the name; ignored for items whose\n *                     name is specified\n *        'crtItemId': identifier of the current menu item (for differential styling)\n *        'cssClass' : specific css class for this menu\n *#\n#macro(verticalNavigation $menu $options)\n(% class=\"vertical-menu $!{options.cssClass}\" %)(((\n  #foreach ($item in $menu)\n    #verticalNavigationItem($item '*' $options)\n  #end\n)))\n#end\n\n#**\n * Generates a vertical menu item from an object (a map)\n *\n * Expected format:\n * item = map with the following fields:\n *        'id'       : mandatory\n *        'name'     : the text displayed for the corresponding menu item;\n *                     optional, defaults to\n *                     $services.localization.render(\"$!{translationPrefix}${item.id}\")\n *        'url'      : the \"action\" of the menu item; optional\n *        'cssClass' : a specific css class for the menu item for custom\n *                     styling; optional, defaults to ''\n *        'children' : vector of items, allowing to recursively define submenus\n *\n * @param $item the menu item object, in the format described above\n * @param $level the current level of the item, of the form '\\*+'; the number of\n *        stars indicates the depth of the item in the menu\n * @param $options a map of options, where the following entries are currently used:\n *        'translationPrefix' :  the translation prefix added to the id of each\n *                     item, in order to generate the name; ignored for items whose\n *                     name is specified\n *        'crtItemId': identifier of the current menu item (for differential styling)\n *#\n#macro(verticalNavigationItem $item $level $options)\n  #set ($class = \"$!{item.cssClass}\")\n  #set ($hasChildren = ($item.children && $item.children.size() > 0))\n  #if ($hasChildren)\n    #set ($class = \"$class group\")\n  #end\n  #if ($options.crtItemId == $item.id)\n    #set ($class = \"$class current\")\n    #if ($hasChildren)\n      #set ($class = \"$class current-group\")\n    #end\n  #end\n  #set ($class = $class.trim())\n  #set ($name = \"$!{item.name}\")\n  #if ($name == '')\n    #set ($name = $services.localization.render(\"$!{options.translationPrefix}${item.id}\"))\n  #end\n  $level (% id=\"vertical-menu-${item.id}\" class=\"${class}\" %){{html}}<a #if (\"$!{item.url}\" != '')href=\"$item.url\"#{end}>$name</a>{{/html}}\n  #if ($hasChildren)\n    #set ($children = [])\n    #sortCollectionOfMapsByField($item.children, 'order', 99999, 'asc', $children)\n    #foreach ($child in $children)\n      #verticalNavigationItem($child $level.concat('*') $options)\n    #end\n  #end\n#end\n\n#**\n * Sort a collection containing maps by a field.\n *\n *\n * @param $collection - List - Collection to sort.\n *\n * @param $field - String - Name of the field of the map to sort on.\n *\n * @param $defaultValue - Any - The default value for the sort if one of the elements has a NULL field\n *\n * @param $order - String - Must be 'asc' for ascending, or 'desc' for descending\n *\n * @param $outList - List - The returns from this macro will be put in this list, passing the list as a parameter\n *                          a safety measure because macros can't return values.\n *#\n#macro (sortCollectionOfMapsByField $collection $field $defaultValue $order $outputList)\n  ## If an element has a null field, $collectiontool.sort() won't return anything.\n  ## To avoid this situation, we create a new list that contains the elements with a default field if it is missing\n  #set ($newList = [])\n  #foreach ($element in $collection)\n    #if (\"$!element.get($field)\" == '')\n      #set ($elementCopy = {})\n      #set ($discard = $elementCopy.putAll($element))\n      #set ($discard = $elementCopy.put($field, $defaultValue))\n      #set ($discard = $newList.add($elementCopy))\n    #else\n      #set ($discard = $newList.add($element))\n    #end\n  #end\n  #set ($discard = $outputList.addAll($collectiontool.sort($newList, \"${field}:${order}\")))\n#end\n\n#**\n * Sets a gradient-based styling for CSS backgrounds\n *\n *\n * @param $icon the path to an additional icon image\n * @param $gradientData a map of gradients, where the following entries are currently used:\n *        'angle' :  an angle of direction for the gradient\n *        'colors':  a list of maps of color-stops for the gradient, where the following entries are currently used: \n *                'color'    : color value\n *                'position' : stop position for the color (between 0% and 100% or a lenght)\n *#\n#macro (css3_backgroundIconAndLinearGradient $icon $gradientData)\n  ## Older color themes don't have values defined for the gradients, so we'll use a simple background-color instead\n  #set ($validColors = 0)\n  #set ($validColor = '')\n  #foreach ($colorEntry in $gradientData.colors)\n    #if (\"$!{colorEntry.color}\" != '')\n      #set ($validColors = $validColors + 1)\n      #set ($validColor = $colorEntry.color)\n    #end\n  #end\n  #if ($validColors <= 1)\n    #if (\"$!{icon}\" != '')\n      background-image: ${icon};\n    #end\n    #if (\"$!{validColor}\" != '')\n      background-color: ${validColor};\n    #end\n    #break($macro)\n  #end\n  #set ($colors = '')\n  #set ($position = '')\n  #if ($gradientData.angle)\n    #if ($stringtool.indexOfAny($gradientData.angle, 'top', 'right', 'bottom', 'left') != -1)\n      #set ($position = \"to $!{gradientData.angle}\")\n    #else\n      #set ($position = \"$!{gradientData.angle}\")\n    #end\n  #elseif ($gradientData.to)\n    #set ($position = \"to $!{gradientData.to}\")\n  #end\n  #foreach ($colorEntry in $gradientData.colors)\n    #set ($colors = \"$!{colors}, $!{colorEntry.color} $!{colorEntry.position}\")\n  #end\n  #if (\"$!{colors}\" != '' && \"$!{position}\" == '')\n    #set ($colors = $colors.substring(2))\n  #end\n  background-image:#if (\"$!{icon}\" != '') $icon,#end linear-gradient($!{position}$!{colors});\n#end\n##\n##\n##\n#macro (css3_backgroundLinearGradient $gradientData)\n  #css3_backgroundIconAndLinearGradient ('' $gradientData)\n#end\n\n#**\n * Macro that adds the prefixes for box-sizing CSS property that alters the default CSS box model used to calculate widths and heights of elements\n *\n *\n * @param $value should take the following values: content-box | padding-box | border-box\n *#\n#macro (css3_boxSizing $value)\n  #if (\"$!{value}\" != '')\n    #set ($browserVariants = ['-moz-', ''])\n    #foreach ($bvar in $browserVariants)\n      ${bvar}box-sizing: $value;\n    #end\n  #end\n#end\n\n#**\n * Macro for text-shadow CSS property that adds shadows to text\n *\n *\n * @param $offsetX shadow's horizontal offset value from the text\n * @param $offsetY shadow's vertical offset value from the text\n * @param $blurRadius the blur radius value of the text-shadow\n * @param $color the color of the text-shadow\n *#\n#macro (css_textShadow $offsetX $offsetY $blurRadius $color)\n  ## In order to ensure consistency across browsers and also to accommodate old ColorThemes that might not have gradientColor defined, we test the existence of $color param\n  #if ((\"$!{offsetX}\" != '') && (\"$!{offsetY}\" != '') && (\"$!{color}\" != ''))\n    text-shadow: ${offsetX} ${offsetY} ${blurRadius} ${color};\n  #end\n#end\n\n#**\n * Transforms the given string to an XML name by filtering all the characters that are not allowed in an XML name. If\n * the given string contains only invalid characters then the result is the empty string.\n *\n * @param $string the string to be transformed to an XML name\n *#\n#macro(toXMLName $string)\n## Keep only Unicode letters and digits plus the hyphen and the underscore characters.\n#set($string = $string.replaceAll('[^\\p{L}\\p{N}_\\-]+', ''))\n## Make sure the string doesn't start with a number or the hyphen character.\n#set($string = $string.replaceAll('^[\\p{N}\\-]+', ''))\n$string##\n#end\n\n#**\n * Pulls all the JavaScript and CSS resources needed by pickers.\n *#\n#macro (picker_import)\n  #set ($discard = $xwiki.linkx.use($services.webjars.url('selectize.js', 'css/selectize.bootstrap3.css'),\n    {'type': 'text/css', 'rel': 'stylesheet'}))\n  #set ($discard = $xwiki.ssfx.use('uicomponents/suggest/xwiki.selectize.css', true))\n#end\n\n#**\n * Pulls all the JavaScript and CSS resources needed by the user and group picker.\n *#\n#macro (userPicker_import)\n  #picker_import\n  #set ($discard = $xwiki.jsfx.use('uicomponents/suggest/suggestUsersAndGroups.js'))\n#end\n\n#macro (userPicker_input $multiSelect $parameters)\n  #if ($multiSelect)\n    #set ($discard = $parameters.put('multiple', 'multiple'))\n  #end\n  #set ($discard = $parameters.putIfAbsent('data-userScope', \"$!services.wiki.user.userScope\"))\n  #suggestInput($parameters)\n#end\n\n#macro (userPicker $multiSelect $parameters)\n  #userPicker_import\n  #set ($discard = $parameters.put('class', \"$!parameters.get('class') suggest-users\"))\n  #userPicker_input($multiSelect $parameters)\n#end\n\n#macro (groupPicker $multiSelect $parameters)\n  #userPicker_import\n  #set ($discard = $parameters.put('class', \"$!parameters.get('class') suggest-groups\"))\n  #userPicker_input($multiSelect $parameters)\n#end\n\n\n#**\n* Pulls all the JavaScript and CSS resources needed by the page picker.\n*#\n#macro (pagePicker_import)\n  #picker_import\n  #set ($discard = $xwiki.jsfx.use('uicomponents/suggest/suggestPages.js',\n    {'forceSkinAction': true, 'language': $xcontext.locale}))\n#end\n\n#macro (pagePicker $parameters)\n  #pagePicker_import\n  #if (\"$!parameters\" == \"\")\n    #set ($parameters = {})\n  #end\n  #set ($discard = $parameters.put('class', \"$!parameters.get('class') suggest-pages\"))\n  #suggestInput($parameters)\n#end\n\n#**\n* Pulls all the JavaScript and CSS resources needed by the attachment picker.\n*#\n#macro (attachmentPicker_import)\n  #picker_import\n  #set ($discard = $xwiki.jsfx.use('uicomponents/suggest/suggestAttachments.js'))\n  ## Pull the resources required by the configured icon set in order to display attachment icons.\n  #set ($discard = $services.icon.use())\n#end\n\n#macro (attachmentPicker $parameters)\n  #attachmentPicker_import\n  #if (\"$!parameters\" == \"\")\n    #set ($parameters = {})\n  #end\n  #set ($discard = $parameters.put('class', \"$!parameters.get('class') suggest-attachments\"))\n  #suggestInput($parameters)\n#end\n\n#**\n * Displays the given title (i.e. the title of the sheet) if the condition is true. Otherwise displays the title of the\n * current document (i.e. the document the sheet is applied to). If the condition is not specified then it checks if the\n * current document is a sheet by looking for an object of type 'XWiki.SheetDescriptorClass'. You can pass a traslation\n * key for the sheet title. This macro makes sure the document title is not displayed recursively.\n *\n * @param $title the sheet title, you can pass a translation key\n * @param $condition optional condition, whether to display the sheet title or the document title\n *#\n#macro (sheetTitle $title $condition)\n## NOTE: Don't format the code because spaces are preserved in document title.\n#if (!$condition && \"$!condition\" == '')##\n## Undefined condition. Use the default condition.\n#set ($condition = $doc.getObject('XWiki.SheetDescriptorClass'))\n#elseif ($condition.getClass().getName() == 'java.lang.String')##\n## The condition is the name of an xclass. Display the sheet title if the current document doesn't have such an object.\n#set ($condition = !$doc.getObject($condition))\n#end##\n##\n#if ($condition)##\n## Display the sheet title.\n$services.localization.render($title)##\n##\n#elseif (!$sheetTitle_displayingDocumentTitle)##\n## Display the document title without going through the sheet and preventing recursion.\n#set ($sheetTitle_displayingDocumentTitle = true)\n$services.display.title($doc, {\n  'displayerHint': 'default',\n  'outputSyntaxId': 'plain/1.0'\n})##\n#set ($sheetTitle_displayingDocumentTitle = false)\n##\n#else##\nRecursive title display detected!##\n#end##\n#end\n\n#**\n * Outputs the skin extension hooks, for both Stylesheet and JavaScript extensions. This is useful when the HTML response\n * of an AJAX request needs to pull some CSS and JavaScript resources. The code that makes the AJAX request should move\n * the 'includes' (i.e. the link and script tags) to the head of the HTML page after receiving the HTML response.\n *#\n#macro (skinExtensionHooks)\n  #styleSheetExtensionHooks\n  #javaScriptExtensionHooks\n#end\n\n#**\n * Hook for inserting CSS skin extensions.\n *#\n#macro (styleSheetExtensionHooks)\n  ## - Skin JAR extension hook. Placed first to allow other skin extensions to override it.\n  <!-- com.xpn.xwiki.plugin.skinx.CssResourceSkinExtensionPlugin -->\n  ## - Skin file extension hook.\n  <!-- com.xpn.xwiki.plugin.skinx.CssSkinFileExtensionPlugin -->\n  ## - Skin extension hook, placed at the last to be able to override previous css rules with a Skin Extension Object\n  <!-- com.xpn.xwiki.plugin.skinx.CssSkinExtensionPlugin -->\n#end\n\n#**\n * Hooks for inserting JavaScript skin extensions.\n *#\n#macro (javaScriptExtensionHooks)\n  ## - Skin JAR extension hook. Placed first to allow other skin extensions to override it.\n  <!-- com.xpn.xwiki.plugin.skinx.JsResourceSkinExtensionPlugin -->\n  ## - Skin file extension hook.\n  <!-- com.xpn.xwiki.plugin.skinx.JsSkinFileExtensionPlugin -->\n  ## - Skin extension hook\n  <!-- com.xpn.xwiki.plugin.skinx.JsSkinExtensionPlugin -->\n#end\n\n###\n### Displays an exception.\n###\n### @param title the message to display to the user\n### @param exception the exception to display when the user clicks on the message\n#macro(displayException $title $exception)\n<div class=\"xwikirenderingerror\" title=\"Click to get more details about the error\" style=\"cursor: pointer;\">\n  $title\n</div>\n<div class=\"xwikirenderingerrordescription hidden\">\n  <pre>$escapetool.xml($exceptiontool.getStackTrace($exception))</pre>\n</div>\n#end\n\n###\n### Generically display exceptions that have not been handled at the right level and have now bubbled up to the UI.\n###\n### This is a convenience macro, see #displayException.\n###\n### @param exception The exception to format for displaying\n#macro(displayUnhandledException $exception)\n  #set ($sentence1 = 'Unexpected error.')\n  #set ($sentence2 = 'Contact your administrator or <a href=\"https://jira.xwiki.org\">report the issue</a>.')\n  #set ($sentence3 = 'Click this box to get technical details.')\n  #displayException(\"${sentence1} ${sentence2} ${sentence3}\", $exception)\n#end\n\n###\n### Display a rich select input (with icon, description, etc...)\n###\n###\n### @param $fieldName name of the input field\n### @param $options an array of maps describing a category of options, which contains an array of options\n### @param $defaultValue the default value to use\n### @param $firstIsDefaultIfDefaultNull if defaultValue is null, select the first option\n### @param $cssClass class to add to the div (could be 'xwiki-select-small', 'xwiki-select-medium', 'xwiki-select-tall' or any other class)\n### @param $id (optional) id to give to the widget\n### @param $enableFilter (optional) enable the filtering of the options\n###\n### Example of use:\n###\n####set($options = [\n###                   { \n###                     'name': 'Category 1',\n###                     'options': [\n###                       { 'name': 'Option 1', 'value': 'option1', 'description': 'Description of the option 1', 'icon': 'wiki', 'data': {'some-data': 'some-value'}},\n###                       { 'name': 'Option 2', 'value': 'option2', 'description': 'Description of the option 2', 'icon': 'page'}\n###                     ]\n###                   },\n###                   {\n###                     'name': 'Category 2',\n###                     'options': [\n###                       { 'name': 'Option 3', 'value': 'option3', 'description': 'Description of the option 3', 'icon': 'check'}\n###                     ]\n###                   }\n###                 ])\n### #xwikiSelect('nameOfTheField', $options, 'option1', false, 'xwiki-select-small', '', true)\n#########################################################\n#macro(xwikiSelect $fieldName $options $defaultValue $firstIsDefaultIfDefaultNull $cssClass $id $enableFilter $filterPlaceHolder)\n  ## TODO: put this in a webjar instead\n  #set ($discard = $xwiki.ssfx.use('uicomponents/widgets/select/select.css', {'forceSkinAction': true}))\n  #set ($discard = $xwiki.jsfx.use('uicomponents/widgets/select/select.js' , {'forceSkinAction': true}))\n  <div class=\"xwiki-select $!cssClass\" #if(\"$!id\" != '')id=\"$id\"#end>\n    ## Here we let a place to add a filter in the future, that is why the options are inside the following div block.\n    <p><input type=\"text\" class=\"xwiki-select-filter\" placeholder=\"$escapetool.xml($services.localization.render('web.widgets.select.filter.placeholder'))\"/></p>\n    <div class=\"xwiki-select-options\">\n      <ul>\n        #set ($count = 0)\n        #foreach ($category in $options)\n          <li class=\"xwiki-select-category\">$category.name (<span class=\"xwiki-select-category-count\">$category.options.size()</span>)\n            <ul>\n              #foreach ($option in $category.options)\n                #if (\"$!defaultValue\" == $$option.value || ($count == 0 && $firstIsDefaultIfDefaultNull && \"$!defaultValue\" == ''))\n                  #set ($checked = 'checked=\"checked\"')\n                  #set ($class = 'xwiki-select-option-selected')\n                #else\n                  #set ($checked = '')\n                  #set ($class = '')\n                #end\n                #set ($otherData = '')\n                #foreach($data in $option.data.keySet())\n                  #set ($otherData = \"$otherData data-${escapetool.xml($data)} = '$escapetool.xml($option.data.get($data))'\")\n                #end\n                <li class=\"xwiki-select-option $class\">\n                  <input type=\"radio\" name=\"$fieldName\" value=\"$escapetool.xml($option.value)\" id=\"${fieldName}_${count}\" $checked $otherData/>\n                  <span class=\"xwiki-select-option-icon\">$!services.icon.renderHTML($option.icon)</span>\n                  <div>\n                    <label for=\"${fieldName}_${count}\">$escapetool.xml($option.name)</label>\n                    #if (\"$!option.description\" != '')\n                      <p class=\"xHint\">$escapetool.xml($option.description)</p>\n                    #end\n                  </div>\n                </li>\n                #set ($count = $count + 1)\n              #end\n            </ul>\n          </li>\n        #end\n      </ul>\n    </div>\n  </div>\n#end\n\n#**\n * Used by custom property displayers that need a generic suggest input.\n *#\n#macro (xpropertySuggestInputDisplayer $field $prefix $name $value)\n  #set ($discard = $xwiki.jsfx.use('uicomponents/suggest/suggestPropertyValues.js'))\n  #set ($id = \"${prefix}${name}\")\n  #set ($freeText = $!field.getValue('freeText'))\n  #set ($parameters = {\n    'id': $id,\n    'name': $id,\n    'value': $value,\n    'class': 'suggest-propertyValues',\n    'data-className': $field.className,\n    'data-propertyName': $name\n  })\n  #if (\"$!freeText\" != '')\n    #set ($discard = $parameters.put('data-freeText', $freeText))\n  #end\n\n  #if ($field.getProperty('disabled').value == 1)\n    #set ($parameters.disabled = 'disabled')\n  #end\n  #if ($field.getProperty('multiSelect').value == 1)\n    #set ($parameters.multiple = 'multiple')\n    #set ($separators = $field.getProperty('separators').value)\n    #if (\"$!separators\" != '')\n      #set ($parameters.separators = $separators)\n    #end\n  #end\n  #suggestInput($parameters)\n#end\n\n#**\n * Utility macro to output a generic suggest input.\n *\n * @param $parameters the parameters (most of them are treated as HTML attributes)\n *#\n#macro (suggestInput $parameters $optionsDisplayerMacroName)\n  #set ($discard = $xwiki.linkx.use($services.webjars.url('selectize.js', 'css/selectize.bootstrap3.css'),\n    {'type': 'text/css', 'rel': 'stylesheet'}))\n  #set ($discard = $xwiki.ssfx.use('uicomponents/suggest/xwiki.selectize.css', true))\n  #set ($discard = $parameters.put('size', 1))\n  #set ($attributes = [])\n  ## Note: Remove placeholder since it's not valid to have it on an HTML SELECT element.\n  #set ($nonAttributes = ['value', 'separators', 'placeholder'])\n  #foreach ($entry in $parameters.entrySet())\n    #if (!$nonAttributes.contains($entry.key))\n      #if ($entry.value.equals($entry.value.toString()))\n        #set ($stringValue = $entry.value)\n      #else\n        ## Serialize non-string values as JSON.\n        #set ($stringValue = $jsontool.serialize($entry.value))\n      #end\n      #set ($discard = $attributes.add(\"$escapetool.xml($entry.key)='$!escapetool.xml($stringValue)'\"))\n    #end\n  #end\n  #if (\"$!parameters.value.size()\" != '')\n    #set ($values = $parameters.value)\n  #elseif ($parameters.multiple)\n    #set ($values = $stringtool.split($parameters.value, $parameters.getOrDefault('separators', '|,')))\n  #elseif (\"$!parameters.value\" != '')\n    #set ($values = [$parameters.value])\n  #else\n    #set ($values = [])\n  #end\n  <select $stringtool.join($attributes, ' ')>\n    #if (\"$!parameters.placeholder\" != '')\n      <option value=\"\">$escapetool.xml($parameters.placeholder)</option>\n    #end\n    #if (\"$!optionsDisplayerMacroName\" != '')\n      #evaluate(\"${escapetool.h}${optionsDisplayerMacroName}(${escapetool.d}values)\")\n    #else\n      #foreach ($selectedValue in $values)\n        <option value=\"$!escapetool.xml($selectedValue)\" selected=\"selected\">$!escapetool.xml($selectedValue)</option>\n      #end\n    #end\n  </select>\n  #if ($parameters.multiple)\n    ## We need a hidden input with an empty value to be able to clear the selected values when no value is selected.\n    <input type=\"hidden\" name=\"$!escapetool.xml($parameters.name)\" />\n  #end\n#end\n\n#**\n * Serializes the given data as JSON and writes the result on the HTTP response, setting the proper content type and\n * length.\n *\n * @param $data the data to be written as JSON on the HTTP response\n *#\n#macro (jsonResponse $data)\n  #set ($json = $jsontool.serialize($data))\n  ## We write the output directly to the HTTP response in order to avoid going through the Rendering which executes\n  ## transformations that could break the JSON (e.g. the icon transformation). Another option would be to specify which\n  ## Rendering Transformations to execute in the query string (XWIKI-13167).\n  #set ($discard = $response.setContentType('application/json'))\n  ## Make sure the Character Encoding response header matches the character encoding used to write the response and\n  ## compute its length.\n  #set ($characterEncoding = 'utf-8')\n  #set ($discard = $response.setCharacterEncoding($characterEncoding))\n  #set ($discard = $response.writer.write($json))\n  ## The content length is measured in bytes and one character can use more than one byte.\n  #set ($discard = $response.setContentLength($json.getBytes($characterEncoding).size()))\n  ## Make sure the entire content is send back to the client.\n  #set ($discard = $response.flushBuffer())\n  ## Make sure XWiki doesn't write any more content to the response.\n  #set ($discard = $xcontext.setFinished(true))\n#end\n\n#macro (classPicker $parameters)\n  #classPicker_import\n  #if (\"$!parameters\" == \"\")\n    #set ($parameters = {})\n  #end\n  #set ($discard = $parameters.put('class', \"$!parameters.get('class') xwiki-selectize suggest-classes\"))\n  #suggestInput($parameters 'classPicker_displayOptions')\n#end\n\n#macro (classPicker_import)\n  #picker_import\n  #set ($discard = $xwiki.jsfx.use('uicomponents/suggest/xwiki.selectize.js', true))\n#end\n\n#macro (classPicker_displayOptions $selectedValues)\n  #set ($selectedClassReferences = $collectiontool.set)\n  #foreach ($selectedValue in $selectedValues)\n    #set ($discard = $selectedClassReferences.add($services.model.resolveDocument($selectedValue)))\n  #end\n  #set ($optionGroups = $collectiontool.orderedMap)\n  #classPicker_getOptionGroups($optionGroups $selectedClassReferences)\n  #classPicker_displayOptionGroups($optionGroups $selectedClassReferences)\n#end\n\n#macro (classPicker_getOptionGroups $optionGroups $selectedClassReferences)\n  #set ($classReferences = $collectiontool.set)\n  ## Make sure the selected classes are listed as options.\n  #set ($discard = $classReferences.addAll($selectedClassReferences))\n  #foreach ($className in $xwiki.classList)\n    #set ($classReference = $services.model.resolveDocument($className))\n    #if ($services.security.authorization.hasAccess('view', $classReference))\n      #set ($discard = $classReferences.add($classReference))\n    #end\n  #end\n  #set ($classReferenceTree = $services.model.toTree($classReferences))\n  #classPicker_addOptionGroups($classReferenceTree $optionGroups)\n#end\n\n#**\n * Flatten the class reference tree into a list of class reference groups.\n *#\n#macro (classPicker_addOptionGroups $parentNode $optionGroups)\n  ## Look for direct child class nodes and create an option group.\n  #set ($classNodes = $parentNode.getChildren($doc.documentReference.type))\n  #if ($classNodes.size() > 0)\n    #set ($classReferences = [])\n    #foreach ($classNode in $classNodes)\n      #set ($discard = $classReferences.add($classNode.reference))\n    #end\n    #set ($discard = $optionGroups.put($parentNode.reference, $classReferences))\n  #end\n  #foreach ($childNode in $parentNode.children)\n    #if ($childNode.children.size() > 0)\n      #classPicker_addOptionGroups($childNode $optionGroups)\n    #end\n  #end\n#end\n\n#macro (classPicker_displayOptionGroups $optionGroups $selectedClassReferences)\n  #foreach ($entry in $optionGroups.entrySet())\n    ## Use the location as group label.\n    #set ($path = [])\n    #set ($referenceChain = $entry.key.reversedReferenceChain)\n    ## Skip the wiki reference because classes are local.\n    #foreach ($reference in $referenceChain.subList(1, $referenceChain.size()))\n      #set ($discard = $path.add($reference.name))\n    #end\n    <optgroup label=\"$escapetool.xml($stringtool.join($path, ' / '))\">\n      #foreach ($classReference in $entry.value)\n        #set ($optionData = {\n          'url': $xwiki.getURL($classReference)\n        })\n        <option value=\"$escapetool.xml($services.model.serialize($classReference, 'local'))\"\n            #if ($selectedClassReferences.contains($classReference))selected=\"selected\"#end\n            data-data=\"$escapetool.xml($jsontool.serialize($optionData))\">\n          ## We display the class title instead of the class name because classes can be defined in nested (WebHome)\n          ## documents. We could also display the last space name but then we would need an option group for the top\n          ## level classes and a label for this group that doesn't confuse the users.\n          #set ($classDoc = $xwiki.getDocument($classReference))\n          $escapetool.xml($classDoc.plainTitle)\n        </option>\n      #end\n    </optgroup>\n  #end\n#end\n\n#macro (dateTimePicker_input $parameters)\n  #set ($discard = $parameters.putIfAbsent('class', 'datetime'))\n  #set ($discard = $parameters.putIfAbsent('data-timestamp', $parameters.value.time))\n  #set ($discard = $parameters.putIfAbsent('data-locale', $services.localization.currentLocale))\n  #if (\"$!parameters.get('data-format')\" != '' && \"$!parameters.value.time\" != '')\n    #set ($parameters.value = $datetool.format($parameters.get('data-format'), $parameters.value,\n      $services.localization.currentLocale))\n  #end\n  #if (\"$!parameters.disabled\" == 'true')\n    #set ($parameters.disabled = 'disabled')\n  #else\n    #set ($discard = $parameters.remove('disabled'))\n  #end\n  <input type=\"text\"\n    #foreach ($parameter in $parameters.entrySet())\n      $escapetool.xml($parameter.key)=\"$!escapetool.xml($parameter.value)\"\n    #end\n  />\n#end\n\n#macro (dateTimePicker $parameters)\n  #dateTimePicker_import\n  #dateTimePicker_input($parameters)\n#end\n\n#macro (colorPicker_input $parameters)\n  #set ($discard = $parameters.putIfAbsent('class', 'color-picker type-color'))\n  #if (\"$!parameters.disabled\" == 'true')\n    #set ($parameters.disabled = 'disabled')\n  #else\n    #set ($discard = $parameters.remove('disabled'))\n  #end\n  <input type=\"text\"\n    #foreach ($parameter in $parameters.entrySet())\n      $escapetool.xml($parameter.key)=\"$!escapetool.xml($parameter.value)\"\n    #end\n  />\n#end\n\n#macro (colorPicker $parameters)\n  #colorPicker_import\n  #colorPicker_input($parameters)\n#end\n\n#**\n * Returns the editor that should be used to edit the current document by default (if no other editor is specified).\n * This macro is called both in view mode (to determine the in-place editor to load) and in edit mode (to determine the\n * classical editor to use).\n *#\n#macro (getDefaultDocumentEditor $return)\n  ## Determine the sheets using the default document translation because objects are accessible only from the default\n  ## translation.\n  #if (!$services.sheet.getSheets($doc, $xcontext.action).isEmpty())\n    #set ($defaultDocumentEditor = 'inline')\n  #elseif ($xwiki.editorPreference == 'wysiwyg' && $services.wysiwyg.isSyntaxSupported($tdoc.syntax.toIdString()))\n    #set ($defaultDocumentEditor = 'wysiwyg')\n  #else\n    #set ($defaultDocumentEditor = 'wiki')\n  #end\n  #set ($return = $NULL)\n  #setVariable (\"$return\" $defaultDocumentEditor)\n#end\n\n#macro (displayUserLink $userReference)\n  #if ($userReference.class.simpleName == \"DocumentUserReference\")\n    #set ($docReference = $userReference.reference)\n    #set ($props = $services.user.getProperties($userReference))\n    #if (\"$!props.firstName\" == \"\" || \"$!props.lastName\" == \"\")\n      #set ($displayName = $docReference.name)\n    #else\n      #set ($displayName = \"$props.firstName $props.lastName\")\n    #end\n  #else\n    #set ($docReference = $userReference)\n    #set ($displayName = $docReference.name)\n  #end\n  <div class=\"user\" data-reference=\"$escapetool.xml($docReference)\">\n    <span class=\"user-avatar-wrapper\">\n      #getUserAvatarURL($docReference $avatarURL 120)\n      <img class=\"user-avatar\" src=\"$escapetool.xml($avatarURL.url)\" />\n    </span>\n    <a href=\"$xwiki.getURL($docReference)\">$escapetool.xml($docReference.name)</a>\n  </div>\n#end\n\n##\n## Parse the provided filterValue according to its match type and assign the resulting start/end dates to the dateRange\n## map.\n## First, if a after or before matchType is provided, a '/' is added respectivelly at the end or at the beguinning of  \n## filterValue.\n## Then, we first start by trying to split filterValue using a '/', and parse the two substring as ISO 8601 dates.\n## If none of the substring conforms to the ISO 8601 date format, a second try is done by splitting using '-', and \n## the two substrings are parsed as timestamps.\n##\n## @since 14.0RC1\n## @since 13.10.2\n## @since 13.4.6\n##\n#macro (parseDateRange $matchType $filterValue $dateRange)\n  ## Transform the filter value into a date range if needed.\n  #if ($matchType == 'after')\n    #set ($dateRangeString = \"$filterValue/\")\n  #elseif ($matchType == 'before')\n    #set ($dateRangeString = \"/$filterValue\")\n  #else\n    ## Between start and end date.\n    #set ($dateRangeString = $filterValue)\n  #end\n  ## Try to parse as ISO 8601 time interval (see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals)\n  #set ($parts = $dateRangeString.split('/', -1))\n  #if ($parts.size() == 2)\n    #set ($dateRange.start = $datetool.toDate('iso_tz', $parts[0]))\n    #set ($dateRange.end = $datetool.toDate('iso_tz', $parts[1]))\n  #end\n  #if (!$dateRange.start && !$dateRange.end)\n    ## Try to parse as timestamp range. Note that this doesn't handle well negative timestamps.\n    #set ($parts = $dateRangeString.split('-', -1))\n    #if ($parts.size() == 2)\n      #set ($dateRange.start = $datetool.toDate($numbertool.toNumber($parts[0])))\n      #set ($dateRange.end = $datetool.toDate($numbertool.toNumber($parts[1])))\n    #end\n  #end\n#end\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2023-29528", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.xml.internal.html;\n\nimport java.io.Reader;\nimport java.util.Arrays;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Singleton;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.htmlcleaner.CleanerProperties;\nimport org.htmlcleaner.DoctypeToken;\nimport org.htmlcleaner.HtmlCleaner;\nimport org.htmlcleaner.TagNode;\nimport org.htmlcleaner.TagTransformation;\nimport org.htmlcleaner.TrimAttributeTagTransformation;\nimport org.htmlcleaner.XWikiDOMSerializer;\nimport org.w3c.dom.Document;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.context.Execution;\nimport org.xwiki.context.ExecutionContext;\nimport org.xwiki.xml.html.HTMLCleaner;\nimport org.xwiki.xml.html.HTMLCleanerConfiguration;\nimport org.xwiki.xml.html.HTMLConstants;\nimport org.xwiki.xml.html.filter.HTMLFilter;\n\n/**\n * Default implementation for {@link org.xwiki.xml.html.HTMLCleaner} using the <a href=\"HTML Cleaner\n * framework>http://htmlcleaner.sourceforge.net/</a>.\n *\n * @version $Id$\n * @since 1.6M1\n */\n@Component\n@Singleton\npublic class DefaultHTMLCleaner implements HTMLCleaner\n{\n    /**\n     * {@link HTMLFilter} for filtering html lists.\n     */\n    @Inject\n    @Named(\"list\")\n    private HTMLFilter listFilter;\n\n    /**\n     * {@link HTMLFilter} for filtering html lists.\n     */\n    @Inject\n    @Named(\"listitem\")\n    private HTMLFilter listItemFilter;\n\n    /**\n     * {@link HTMLFilter} for filtering HTML font elements.\n     */\n    @Inject\n    @Named(\"font\")\n    private HTMLFilter fontFilter;\n\n    /**\n     * {@link HTMLFilter} for wrapping invalid body elements with paragraphs.\n     */\n    @Inject\n    @Named(\"body\")\n    private HTMLFilter bodyFilter;\n\n    /**\n     * {@link HTMLFilter} for filtering HTML attributes that are used by many different elements and for which we cannot\n     * write simple transformations like in {@link #getDefaultCleanerTransformations(HTMLCleanerConfiguration)}.\n     */\n    @Inject\n    @Named(\"attribute\")\n    private HTMLFilter attributeFilter;\n\n    /**\n     * {@link HTMLFilter} for filtering HTML links.\n     */\n    @Inject\n    @Named(\"link\")\n    private HTMLFilter linkFilter;\n\n    /**\n     * Remove control characters.\n     */\n    @Inject\n    @Named(\"controlcharacters\")\n    // TODO: remove when upgrading to HTMLClener 2.23\n    private HTMLFilter controlFilter;\n\n    @Inject\n    @Named(\"sanitizer\")\n    private HTMLFilter sanitizerFilter;\n\n    @Inject\n    private Execution execution;\n\n    @Inject\n    private XWikiHTML5TagProvider html5TagInfoProvider;\n\n    @Override\n    public Document clean(Reader originalHtmlContent)\n    {\n        return clean(originalHtmlContent, getDefaultConfiguration());\n    }\n\n    private DocumentBuilder getAvailableDocumentBuilder() throws ParserConfigurationException\n    {\n        ExecutionContext econtext = this.execution.getContext();\n\n        if (econtext != null) {\n            DocumentBuilder documentBuilder = (DocumentBuilder) econtext.getProperty(DocumentBuilder.class.getName());\n\n            if (documentBuilder == null) {\n                documentBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n                econtext.setProperty(DocumentBuilder.class.getName(), documentBuilder);\n            }\n\n            return documentBuilder;\n        }\n\n        return DocumentBuilderFactory.newInstance().newDocumentBuilder();\n    }\n\n    @Override\n    public Document clean(Reader originalHtmlContent, HTMLCleanerConfiguration configuration)\n    {\n        Document result;\n\n        // Note: Instantiation of an HtmlCleaner object is cheap so there's no need to cache an instance of it,\n        // especially since this makes it extra safe with regards to multithreading (even though HTML Cleaner is\n        // already supposed to be thread safe).\n        CleanerProperties cleanerProperties = getDefaultCleanerProperties(configuration);\n        HtmlCleaner cleaner;\n        if (isHTML5(configuration)) {\n            // Use our custom provider to fix bugs, should be checked on each upgrade if still necessary.\n            cleaner = new HtmlCleaner(this.html5TagInfoProvider, cleanerProperties);\n        }  else {\n            cleaner = new HtmlCleaner(cleanerProperties);\n        }\n\n        TagNode cleanedNode;\n        try {\n            cleanedNode = cleaner.clean(originalHtmlContent);\n        } catch (Exception e) {\n            // This shouldn't happen since we're not doing any IO... I consider this a flaw in the design of HTML\n            // Cleaner.\n            throw new RuntimeException(\"Unhandled error when cleaning HTML\", e);\n        }\n\n        try {\n            // Ideally we would use SF's HTMLCleaner DomSerializer but there are outstanding issues with it, so we're\n            // using a custom XWikiDOMSerializer (see its javadoc for more details).\n            // Replace by the following when fixed:\n            //   result = new DomSerializer(cleanerProperties, false).createDOM(cleanedNode);\n\n            if (isHTML5(configuration)) {\n                cleanedNode.setDocType(new DoctypeToken(HTMLConstants.TAG_HTML, null, null, null));\n            } else {\n                cleanedNode.setDocType(\n                    new DoctypeToken(HTMLConstants.TAG_HTML, \"PUBLIC\", \"-//W3C//DTD XHTML 1.0 Strict//EN\",\n                        \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"));\n            }\n            result =\n                new XWikiDOMSerializer(cleanerProperties).createDOM(getAvailableDocumentBuilder(), cleanedNode);\n        } catch (ParserConfigurationException ex) {\n            throw new RuntimeException(\"Error while serializing TagNode into w3c dom.\", ex);\n        }\n\n        // Finally apply filters.\n        for (HTMLFilter filter : configuration.getFilters()) {\n            filter.filter(result, configuration.getParameters());\n        }\n\n        return result;\n    }\n\n    @Override\n    public HTMLCleanerConfiguration getDefaultConfiguration()\n    {\n        HTMLCleanerConfiguration configuration = new DefaultHTMLCleanerConfiguration();\n        configuration.setFilters(Arrays.asList(\n            this.controlFilter,\n            this.bodyFilter,\n            this.listItemFilter,\n            this.listFilter,\n            this.fontFilter,\n            this.attributeFilter,\n            this.linkFilter,\n            this.sanitizerFilter));\n        return configuration;\n    }\n\n    /**\n     * @param configuration the configuration to use for the cleaning\n     * @return the default {@link CleanerProperties} to be used for cleaning.\n     */\n    private CleanerProperties getDefaultCleanerProperties(HTMLCleanerConfiguration configuration)\n    {\n        CleanerProperties defaultProperties = new CleanerProperties();\n        defaultProperties.setOmitUnknownTags(true);\n\n        // HTML Cleaner uses the compact notation by default but we don't want that since:\n        // - it's more work and not required since not compact notation is valid XHTML\n        // - expanded elements can also be rendered fine in browsers that only support HTML.\n        defaultProperties.setUseEmptyElementTags(false);\n\n        // Wrap script and style content in CDATA blocks\n        defaultProperties.setUseCdataForScriptAndStyle(true);\n\n        // We need this for example to ignore CDATA sections not inside script or style elements.\n        defaultProperties.setIgnoreQuestAndExclam(true);\n\n        // Remove CDATA outside of script and style since according to the spec it has no effect there.\n        defaultProperties.setOmitCdataOutsideScriptAndStyle(true);\n\n        // If the caller has defined NAMESPACE_AWARE configuration property then use it, otherwise use our default.\n        String param = configuration.getParameters().get(HTMLCleanerConfiguration.NAMESPACES_AWARE);\n        boolean namespacesAware = (param == null) || Boolean.parseBoolean(param);\n        defaultProperties.setNamespacesAware(namespacesAware);\n\n        // Set Cleaner transformations\n        defaultProperties.setCleanerTransformations(getDefaultCleanerTransformations(configuration));\n\n        // Don't convert special HTML entities (i.e. &ocirc;, &permil;, &times;) with unicode characters they represent.\n        defaultProperties.setTranslateSpecialEntities(false);\n\n        // Use character references rather than entity references if needed (for instance if you need to parse the\n        // output as XML)\n        param = configuration.getParameters().get(HTMLCleanerConfiguration.USE_CHARACTER_REFERENCES);\n        boolean useCharacterReferences = (param != null) && Boolean.parseBoolean(param);\n        defaultProperties.setTransResCharsToNCR(useCharacterReferences);\n\n        // Sets the HTML version from the configuration (by default 4).\n        defaultProperties.setHtmlVersion(getHTMLVersion(configuration));\n\n        // We trim values by default for all attributes but the input value attribute.\n        // The only way to currently do that is to switch off this flag, and to create a dedicated TagTransformation.\n        // See TrimAttributeCleanerTransformation for more information.\n        defaultProperties.setTrimAttributeValues(false);\n\n        // This flag should be set to true once https://sourceforge.net/p/htmlcleaner/bugs/221/ is fixed.\n        defaultProperties.setRecognizeUnicodeChars(false);\n\n        param = configuration.getParameters().get(HTMLCleanerConfiguration.TRANSLATE_SPECIAL_ENTITIES);\n        boolean translateSpecialEntities = (param != null) && Boolean.parseBoolean(param);\n        defaultProperties.setTranslateSpecialEntities(translateSpecialEntities);\n\n        defaultProperties.setDeserializeEntities(true);\n\n        return defaultProperties;\n    }\n\n    /**\n     * @param configuration The cleaner configuration.\n     * @return the default cleaning transformations to perform on tags, in addition to the base transformations done by\n     *         HTML Cleaner\n     */\n    private TrimAttributeCleanerTransformations getDefaultCleanerTransformations(HTMLCleanerConfiguration configuration)\n    {\n        TrimAttributeCleanerTransformations defaultTransformations = new TrimAttributeCleanerTransformations();\n\n        TagTransformation tt;\n\n        // note that we do not care here to use a TrimAttributeTagTransformation, since the attributes are not preserved\n        if (!isHTML5(configuration)) {\n            // These tags are not obsolete in HTML5.\n            tt = new TagTransformation(HTMLConstants.TAG_B, HTMLConstants.TAG_STRONG, false);\n            defaultTransformations.addTransformation(tt);\n\n            tt = new TagTransformation(HTMLConstants.TAG_I, HTMLConstants.TAG_EM, false);\n            defaultTransformations.addTransformation(tt);\n\n            tt = new TagTransformation(HTMLConstants.TAG_U, HTMLConstants.TAG_INS, false);\n            defaultTransformations.addTransformation(tt);\n\n            tt = new TagTransformation(HTMLConstants.TAG_S, HTMLConstants.TAG_DEL, false);\n            defaultTransformations.addTransformation(tt);\n        }\n\n        tt = new TagTransformation(HTMLConstants.TAG_STRIKE, HTMLConstants.TAG_DEL, false);\n        defaultTransformations.addTransformation(tt);\n\n        tt = new TagTransformation(HTMLConstants.TAG_CENTER, HTMLConstants.TAG_P, false);\n        tt.addAttributeTransformation(HTMLConstants.ATTRIBUTE_STYLE, \"text-align:center\");\n        defaultTransformations.addTransformation(tt);\n\n        if (isHTML5(configuration)) {\n            // Font tags are removed before the filters are applied in HTML5, we thus need a transformation here.\n            defaultTransformations.addTransformation(new FontTagTransformation());\n\n            // The tt-tag is obsolete in HTML5\n            tt = new TrimAttributeTagTransformation(HTMLConstants.TAG_TT, HTMLConstants.TAG_SPAN);\n            tt.addAttributeTransformation(HTMLConstants.ATTRIBUTE_CLASS, \"${class} monospace\");\n            defaultTransformations.addTransformation(tt);\n        }\n\n        String restricted = configuration.getParameters().get(HTMLCleanerConfiguration.RESTRICTED);\n        if (\"true\".equalsIgnoreCase(restricted)) {\n\n            tt = new TagTransformation(HTMLConstants.TAG_SCRIPT, HTMLConstants.TAG_PRE, false);\n            defaultTransformations.addTransformation(tt);\n\n            tt = new TagTransformation(HTMLConstants.TAG_STYLE, HTMLConstants.TAG_PRE, false);\n            defaultTransformations.addTransformation(tt);\n        }\n\n        return defaultTransformations;\n    }\n\n    /**\n     * @param configuration The configuration to parse.\n     * @return If the configuration specifies HTML 5 as version.\n     */\n    private boolean isHTML5(HTMLCleanerConfiguration configuration)\n    {\n        return getHTMLVersion(configuration) == 5;\n    }\n\n    /**\n     * @param configuration The configuration to parse.\n     * @return The HTML version specified in the configuration.\n     */\n    private int getHTMLVersion(HTMLCleanerConfiguration configuration)\n    {\n        String param = configuration.getParameters().get(HTMLCleanerConfiguration.HTML_VERSION);\n        int htmlVersion = 4;\n        if (\"5\".equals(param)) {\n            htmlVersion = 5;\n        }\n        return htmlVersion;\n    }\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2023-30177", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "<?php\n/**\n * @link https://craftcms.com/\n * @copyright Copyright (c) Pixel & Tonic, Inc.\n * @license https://craftcms.github.io/license/\n */\n\nnamespace craft\\elements;\n\nuse Craft;\nuse craft\\base\\Element;\nuse craft\\base\\Field;\nuse craft\\base\\LocalVolumeInterface;\nuse craft\\base\\VolumeInterface;\nuse craft\\db\\Query;\nuse craft\\db\\Table;\nuse craft\\elements\\actions\\CopyReferenceTag;\nuse craft\\elements\\actions\\CopyUrl;\nuse craft\\elements\\actions\\DeleteAssets;\nuse craft\\elements\\actions\\DownloadAssetFile;\nuse craft\\elements\\actions\\Edit;\nuse craft\\elements\\actions\\EditImage;\nuse craft\\elements\\actions\\PreviewAsset;\nuse craft\\elements\\actions\\RenameFile;\nuse craft\\elements\\actions\\ReplaceFile;\nuse craft\\elements\\db\\AssetQuery;\nuse craft\\elements\\db\\ElementQueryInterface;\nuse craft\\errors\\AssetException;\nuse craft\\errors\\AssetTransformException;\nuse craft\\errors\\FileException;\nuse craft\\errors\\VolumeObjectNotFoundException;\nuse craft\\events\\AssetEvent;\nuse craft\\helpers\\ArrayHelper;\nuse craft\\helpers\\Assets;\nuse craft\\helpers\\Cp;\nuse craft\\helpers\\Db;\nuse craft\\helpers\\ElementHelper;\nuse craft\\helpers\\FileHelper;\nuse craft\\helpers\\Html;\nuse craft\\helpers\\Image;\nuse craft\\helpers\\StringHelper;\nuse craft\\helpers\\Template;\nuse craft\\helpers\\UrlHelper;\nuse craft\\models\\AssetTransform;\nuse craft\\models\\VolumeFolder;\nuse craft\\records\\Asset as AssetRecord;\nuse craft\\validators\\AssetLocationValidator;\nuse craft\\validators\\DateTimeValidator;\nuse craft\\validators\\StringValidator;\nuse craft\\volumes\\Temp;\nuse DateTime;\nuse Twig\\Markup;\nuse yii\\base\\ErrorHandler;\nuse yii\\base\\Exception;\nuse yii\\base\\InvalidArgumentException;\nuse yii\\base\\InvalidCallException;\nuse yii\\base\\InvalidConfigException;\nuse yii\\base\\NotSupportedException;\nuse yii\\base\\UnknownPropertyException;\n\n/**\n * Asset represents an asset element.\n *\n * @property int|float|null $height the image height\n * @property int|float|null $width the image width\n * @property int|null $volumeId the volume ID\n * @property string|array|null $focalPoint the focal point represented as an array with `x` and `y` keys, or null if it's not an image\n * @property-read Markup|null $img an `<img>` tag based on this asset\n * @property-read VolumeFolder $folder the assets volume folder\n * @property-read VolumeInterface $volume the assets volume\n * @property-read bool $hasFocalPoint whether a user-defined focal point is set on the asset\n * @property-read string $extension the file extension\n * @property-read string $path the asset's path in the volume\n * @property-read string|null $mimeType the files MIME type, if it can be determined\n * @author Pixel & Tonic, Inc. <support@pixelandtonic.com>\n * @since 3.0.0\n */\nclass Asset extends Element\n{\n    // Events\n    // -------------------------------------------------------------------------\n\n    /**\n     * @event AssetEvent The event that is triggered before an asset is uploaded to volume.\n     */\n    const EVENT_BEFORE_HANDLE_FILE = 'beforeHandleFile';\n\n    // Location error codes\n    // -------------------------------------------------------------------------\n\n    const ERROR_DISALLOWED_EXTENSION = 'disallowed_extension';\n    const ERROR_FILENAME_CONFLICT = 'filename_conflict';\n\n    // Validation scenarios\n    // -------------------------------------------------------------------------\n\n    /**\n     * Validation scenario that should be used when the asset is only getting *moved*; not renamed.\n     *\n     * @since 3.7.1\n     */\n    const SCENARIO_MOVE = 'move';\n    const SCENARIO_FILEOPS = 'fileOperations';\n    const SCENARIO_INDEX = 'index';\n    const SCENARIO_CREATE = 'create';\n    const SCENARIO_REPLACE = 'replace';\n\n    // File kinds\n    // -------------------------------------------------------------------------\n\n    const KIND_ACCESS = 'access';\n    const KIND_AUDIO = 'audio';\n    /**\n     * @since 3.6.0\n     */\n    const KIND_CAPTIONS_SUBTITLES = 'captionsSubtitles';\n    const KIND_COMPRESSED = 'compressed';\n    const KIND_EXCEL = 'excel';\n    /**\n     * @deprecated in 3.7.0\n     */\n    const KIND_FLASH = 'flash';\n    const KIND_HTML = 'html';\n    const KIND_ILLUSTRATOR = 'illustrator';\n    const KIND_IMAGE = 'image';\n    const KIND_JAVASCRIPT = 'javascript';\n    const KIND_JSON = 'json';\n    const KIND_PDF = 'pdf';\n    const KIND_PHOTOSHOP = 'photoshop';\n    const KIND_PHP = 'php';\n    const KIND_POWERPOINT = 'powerpoint';\n    const KIND_TEXT = 'text';\n    const KIND_VIDEO = 'video';\n    const KIND_WORD = 'word';\n    const KIND_XML = 'xml';\n    const KIND_UNKNOWN = 'unknown';\n\n    /**\n     * @inheritdoc\n     */\n    public static function displayName(): string\n    {\n        return Craft::t('app', 'Asset');\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public static function lowerDisplayName(): string\n    {\n        return Craft::t('app', 'asset');\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public static function pluralDisplayName(): string\n    {\n        return Craft::t('app', 'Assets');\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public static function pluralLowerDisplayName(): string\n    {\n        return Craft::t('app', 'assets');\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public static function refHandle()\n    {\n        return 'asset';\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public static function hasContent(): bool\n    {\n        return true;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public static function hasTitles(): bool\n    {\n        return true;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public static function isLocalized(): bool\n    {\n        return true;\n    }\n\n    /**\n     * @inheritdoc\n     * @return AssetQuery The newly created [[AssetQuery]] instance.\n     */\n    public static function find(): ElementQueryInterface\n    {\n        return new AssetQuery(static::class);\n    }\n\n    /**\n     * @inheritdoc\n     * @since 3.4.0\n     */\n    public static function eagerLoadingMap(array $sourceElements, string $handle)\n    {\n        if ($handle === 'uploader') {\n            // Get the source element IDs\n            $sourceElementIds = ArrayHelper::getColumn($sourceElements, 'id');\n\n            $map = (new Query())\n                ->select(['id as source', 'uploaderId as target'])\n                ->from([Table::ASSETS])\n                ->where(['and', ['id' => $sourceElementIds], ['not', ['uploaderId' => null]]])\n                ->all();\n\n            return [\n                'elementType' => User::class,\n                'map' => $map,\n            ];\n        }\n\n        return parent::eagerLoadingMap($sourceElements, $handle);\n    }\n\n    /**\n     * @inheritdoc\n     * @since 3.4.0\n     */\n    public function setEagerLoadedElements(string $handle, array $elements)\n    {\n        if ($handle === 'uploader') {\n            $uploader = $elements[0] ?? null;\n            $this->setUploader($uploader);\n        } else {\n            parent::setEagerLoadedElements($handle, $elements);\n        }\n    }\n\n    /**\n     * @inheritdoc\n     * @since 3.3.0\n     */\n    public static function gqlTypeNameByContext($context): string\n    {\n        return $context->handle . '_Asset';\n    }\n\n    /**\n     * @inheritdoc\n     * @since 3.3.0\n     */\n    public static function gqlScopesByContext($context): array\n    {\n        return ['volumes.' . $context->uid];\n    }\n\n    /**\n     * @inheritdoc\n     * @since 3.5.0\n     */\n    public static function gqlMutationNameByContext($context): string\n    {\n        /** @var VolumeInterface $context */\n        return 'save_' . $context->handle . '_Asset';\n    }\n\n    /**\n     * @inheritdoc\n     */\n    protected static function defineSources(string $context = null): array\n    {\n        $volumes = Craft::$app->getVolumes();\n\n        if ($context === 'index') {\n            $sourceIds = $volumes->getViewableVolumeIds();\n        } else {\n            $sourceIds = $volumes->getAllVolumeIds();\n        }\n\n        $additionalCriteria = $context === 'settings' ? ['parentId' => ':empty:'] : [];\n\n        $tree = Craft::$app->getAssets()->getFolderTreeByVolumeIds($sourceIds, $additionalCriteria);\n\n        $sourceList = self::_assembleSourceList($tree, $context !== 'settings', Craft::$app->getUser()->getIdentity());\n\n        // Add the Temporary Uploads location, if that's not set to a real volume\n        if (\n            $context !== 'settings' &&\n            !Craft::$app->getRequest()->getIsConsoleRequest() &&\n            !Craft::$app->getProjectConfig()->get('assets.tempVolumeUid')\n        ) {\n            $temporaryUploadFolder = Craft::$app->getAssets()->getUserTemporaryUploadFolder();\n            $temporaryUploadFolder->name = Craft::t('app', 'Temporary Uploads');\n            $sourceList[] = self::_assembleSourceInfoForFolder($temporaryUploadFolder);\n        }\n\n        return $sourceList;\n    }\n\n    /**\n     * @inheritdoc\n     * @since 3.5.0\n     */\n    protected static function defineFieldLayouts(string $source): array\n    {\n        $fieldLayouts = [];\n        if (\n            preg_match('/^folder:(.+)$/', $source, $matches) &&\n            ($folder = Craft::$app->getAssets()->getFolderByUid($matches[1])) &&\n            $fieldLayout = $folder->getVolume()->getFieldLayout()\n        ) {\n            $fieldLayouts[] = $fieldLayout;\n        }\n        return $fieldLayouts;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    protected static function defineActions(string $source = null): array\n    {\n        $actions = [];\n\n        // Only match the first folder ID - ignore nested folders\n        if (\n            preg_match('/^folder:([a-z0-9\\-]+)/', $source, $matches) &&\n            $folder = Craft::$app->getAssets()->getFolderByUid($matches[1])\n        ) {\n            $volume = $folder->getVolume();\n            $isTemp = $volume instanceof Temp;\n\n            $actions[] = [\n                'type' => PreviewAsset::class,\n                'label' => Craft::t('app', 'Preview file'),\n            ];\n\n            // Download\n            $actions[] = DownloadAssetFile::class;\n\n            // Edit\n            $actions[] = [\n                'type' => Edit::class,\n                'label' => Craft::t('app', 'Edit asset'),\n            ];\n\n            $userSession = Craft::$app->getUser();\n            if ($isTemp || $userSession->checkPermission(\"replaceFilesInVolume:$volume->uid\")) {\n                // Rename/Replace File\n                $actions[] = RenameFile::class;\n                $actions[] = ReplaceFile::class;\n            }\n\n            // Copy URL\n            if ($volume->hasUrls) {\n                $actions[] = CopyUrl::class;\n            }\n\n            // Copy Reference Tag\n            $actions[] = [\n                'type' => CopyReferenceTag::class,\n                'elementType' => static::class,\n            ];\n\n            // Edit Image\n            if ($isTemp || $userSession->checkPermission(\"editImagesInVolume:$volume->uid\")) {\n                $actions[] = EditImage::class;\n            }\n\n            // Delete\n            if ($isTemp || $userSession->checkPermission(\"deleteFilesAndFoldersInVolume:$volume->uid\")) {\n                $actions[] = DeleteAssets::class;\n            }\n        }\n\n        return $actions;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    protected static function defineSearchableAttributes(): array\n    {\n        return ['filename', 'extension', 'kind'];\n    }\n\n    /**\n     * @inheritdoc\n     */\n    protected static function defineSortOptions(): array\n    {\n        return [\n            'title' => Craft::t('app', 'Title'),\n            'filename' => Craft::t('app', 'Filename'),\n            'size' => Craft::t('app', 'File Size'),\n            [\n                'label' => Craft::t('app', 'File Modification Date'),\n                'orderBy' => 'dateModified',\n                'defaultDir' => 'desc',\n            ],\n            [\n                'label' => Craft::t('app', 'Date Uploaded'),\n                'orderBy' => 'elements.dateCreated',\n                'attribute' => 'dateCreated',\n                'defaultDir' => 'desc',\n            ],\n            [\n                'label' => Craft::t('app', 'Date Updated'),\n                'orderBy' => 'elements.dateUpdated',\n                'attribute' => 'dateUpdated',\n                'defaultDir' => 'desc',\n            ],\n            [\n                'label' => Craft::t('app', 'ID'),\n                'orderBy' => 'elements.id',\n                'attribute' => 'id',\n            ],\n        ];\n    }\n\n    /**\n     * @inheritdoc\n     */\n    protected static function defineTableAttributes(): array\n    {\n        $attributes = [\n            'title' => ['label' => Craft::t('app', 'Asset')],\n            'filename' => ['label' => Craft::t('app', 'Filename')],\n            'size' => ['label' => Craft::t('app', 'File Size')],\n            'kind' => ['label' => Craft::t('app', 'File Kind')],\n            'imageSize' => ['label' => Craft::t('app', 'Dimensions')],\n            'width' => ['label' => Craft::t('app', 'Image Width')],\n            'height' => ['label' => Craft::t('app', 'Image Height')],\n            'link' => ['label' => Craft::t('app', 'Link'), 'icon' => 'world'],\n            'id' => ['label' => Craft::t('app', 'ID')],\n            'uid' => ['label' => Craft::t('app', 'UID')],\n            'dateModified' => ['label' => Craft::t('app', 'File Modified Date')],\n            'dateCreated' => ['label' => Craft::t('app', 'Date Uploaded')],\n            'dateUpdated' => ['label' => Craft::t('app', 'Date Updated')],\n            'uploader' => ['label' => Craft::t('app', 'Uploaded By')],\n        ];\n\n        // Hide Author from Craft Solo\n        if (Craft::$app->getEdition() !== Craft::Pro) {\n            unset($attributes['uploader']);\n        }\n\n        return $attributes;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    protected static function defineDefaultTableAttributes(string $source): array\n    {\n        return [\n            'filename',\n            'size',\n            'dateModified',\n            'uploader',\n            'link',\n        ];\n    }\n\n    /**\n     * @inheritdoc\n     */\n    protected static function prepElementQueryForTableAttribute(ElementQueryInterface $elementQuery, string $attribute)\n    {\n        if ($attribute === 'uploader') {\n            $elementQuery->andWith('uploader');\n        } else {\n            parent::prepElementQueryForTableAttribute($elementQuery, $attribute);\n        }\n    }\n\n    /**\n     * Transforms an asset folder tree into a source list.\n     *\n     * @param array $folders\n     * @param bool $includeNestedFolders\n     * @param User|null $user\n     * @return array\n     */\n    private static function _assembleSourceList(array $folders, bool $includeNestedFolders = true, User $user = null): array\n    {\n        $sources = [];\n\n        foreach ($folders as $folder) {\n            $sources[] = self::_assembleSourceInfoForFolder($folder, $includeNestedFolders, $user);\n        }\n\n        return $sources;\n    }\n\n    /**\n     * Transforms an VolumeFolderModel into a source info array.\n     *\n     * @param VolumeFolder $folder\n     * @param bool $includeNestedFolders\n     * @param User|null $user\n     * @return array\n     */\n    private static function _assembleSourceInfoForFolder(VolumeFolder $folder, bool $includeNestedFolders = true, User $user = null): array\n    {\n        $volume = $folder->getVolume();\n\n        if ($volume instanceof Temp) {\n            $volumeHandle = 'temp';\n        } elseif (!$folder->parentId) {\n            $volumeHandle = $volume->handle ?? false;\n        } else {\n            $volumeHandle = false;\n        }\n\n        $userSession = Craft::$app->getUser();\n        $canUpload = $userSession->checkPermission(\"saveAssetInVolume:$volume->uid\");\n        $canMoveTo = $canUpload && $userSession->checkPermission(\"deleteFilesAndFoldersInVolume:$volume->uid\");\n        $canMovePeerFilesTo = (\n            $canMoveTo &&\n            $userSession->checkPermission(\"editPeerFilesInVolume:$volume->uid\") &&\n            $userSession->checkPermission(\"deletePeerFilesInVolume:$volume->uid\")\n        );\n\n        $source = [\n            'key' => 'folder:' . $folder->uid,\n            'label' => $folder->parentId ? $folder->name : Craft::t('site', $folder->name),\n            'hasThumbs' => true,\n            'criteria' => ['folderId' => $folder->id],\n            'defaultSort' => ['dateCreated', 'desc'],\n            'data' => [\n                'volume-handle' => $volumeHandle,\n                'folder-id' => $folder->id,\n                'can-upload' => $folder->volumeId === null || $canUpload,\n                'can-move-to' => $canMoveTo,\n                'can-move-peer-files-to' => $canMovePeerFilesTo,\n            ],\n        ];\n\n        if ($user) {\n            if (!$user->can(\"viewPeerFilesInVolume:$volume->uid\")) {\n                $source['criteria']['uploaderId'] = $user->id;\n            }\n        }\n\n        if ($includeNestedFolders) {\n            $source['nested'] = self::_assembleSourceList($folder->getChildren(), true, $user);\n        }\n\n        return $source;\n    }\n\n    /**\n     * @var int|null Folder ID\n     */\n    public $folderId;\n\n    /**\n     * @var int|null The ID of the user who first added this asset (if known)\n     */\n    public $uploaderId;\n\n    /**\n     * @var string|null Folder path\n     */\n    public $folderPath;\n\n    /**\n     * @var string|null Filename\n     * @todo rename to private $_basename w/ getter & setter in 4.0; and getFilename() should not include the extension (to be like PATHINFO_FILENAME). We can add a getBasename() for getting the whole thing.\n     */\n    public $filename;\n\n    /**\n     * @var string|null Kind\n     */\n    public $kind;\n\n    /**\n     * @var int|null Size\n     */\n    public $size;\n\n    /**\n     * @var bool|null Whether the file was kept around when the asset was deleted\n     */\n    public $keptFile;\n\n    /**\n     * @var \\DateTime|null Date modified\n     */\n    public $dateModified;\n\n    /**\n     * @var string|null New file location\n     */\n    public $newLocation;\n\n    /**\n     * @var string|null Location error code\n     * @see AssetLocationValidator::validateAttribute()\n     */\n    public $locationError;\n\n    /**\n     * @var string|null New filename\n     */\n    public $newFilename;\n\n    /**\n     * @var int|null New folder id\n     */\n    public $newFolderId;\n\n    /**\n     * @var string|null The temp file path\n     */\n    public $tempFilePath;\n\n    /**\n     * @var bool Whether Asset should avoid filename conflicts when saved.\n     */\n    public $avoidFilenameConflicts = false;\n\n    /**\n     * @var string|null The suggested filename in case of a conflict.\n     */\n    public $suggestedFilename;\n\n    /**\n     * @var string|null The filename that was used that caused a conflict.\n     */\n    public $conflictingFilename;\n\n    /**\n     * @var bool Whether the asset was deleted along with its volume\n     * @see beforeDelete()\n     */\n    public $deletedWithVolume = false;\n\n    /**\n     * @var bool Whether the associated file should be preserved if the asset record is deleted.\n     * @see beforeDelete()\n     * @see afterDelete()\n     */\n    public $keepFileOnDelete = false;\n\n    /**\n     * @var int|null Volume ID\n     */\n    private $_volumeId;\n\n    /**\n     * @var int|float|null Width\n     */\n    private $_width;\n\n    /**\n     * @var int|float|null Height\n     */\n    private $_height;\n\n    /**\n     * @var array|null Focal point\n     */\n    private $_focalPoint;\n\n    /**\n     * @var AssetTransform|null\n     */\n    private $_transform;\n\n    /**\n     * @var string\n     */\n    private $_transformSource = '';\n\n    /**\n     * @var VolumeInterface|null\n     */\n    private $_volume;\n\n    /**\n     * @var User|null\n     */\n    private $_uploader;\n\n    /**\n     * @var int|null\n     */\n    private $_oldVolumeId;\n\n    /**\n     * @inheritdoc\n     */\n    public function __toString()\n    {\n        try {\n            if ($this->_transform !== null && ($url = (string)$this->getUrl())) {\n                return $url;\n            }\n            return parent::__toString();\n        } catch (\\Exception $e) {\n            ErrorHandler::convertExceptionToError($e);\n        }\n    }\n\n    /**\n     * Checks if a property is set.\n     *\n     * This method will check if $name is one of the following:\n     * - a magic property supported by [[Element::__isset()]]\n     * - an image transform handle\n     *\n     * @param string $name The property name\n     * @return bool Whether the property is set\n     */\n    public function __isset($name): bool\n    {\n        return (\n            parent::__isset($name) ||\n            strncmp($name, 'transform:', 10) === 0 ||\n            Craft::$app->getAssetTransforms()->getTransformByHandle($name)\n        );\n    }\n\n    /**\n     * Returns a property value.\n     *\n     * This method will check if $name is one of the following:\n     * - a magic property supported by [[Element::__get()]]\n     * - an image transform handle\n     *\n     * @param string $name The property name\n     * @return mixed The property value\n     * @throws UnknownPropertyException if the property is not defined\n     * @throws InvalidCallException if the property is write-only.\n     */\n    public function __get($name)\n    {\n        if (strncmp($name, 'transform:', 10) === 0) {\n            return $this->copyWithTransform(substr($name, 10));\n        }\n\n        try {\n            return parent::__get($name);\n        } catch (UnknownPropertyException $e) {\n            // Is $name a transform handle?\n            if (($transform = Craft::$app->getAssetTransforms()->getTransformByHandle($name)) !== null) {\n                return $this->copyWithTransform($transform);\n            }\n\n            throw $e;\n        }\n    }\n\n    /**\n     * @inheritdoc\n     * @since 3.5.0\n     */\n    public function init()\n    {\n        parent::init();\n        $this->_oldVolumeId = $this->_volumeId;\n    }\n\n    /**\n     * Returns the volumes ID.\n     *\n     * @return int|null\n     */\n    public function getVolumeId()\n    {\n        return (int)$this->_volumeId ?: null;\n    }\n\n    /**\n     * Sets the volumes ID.\n     *\n     * @param int|null $id\n     */\n    public function setVolumeId(int $id = null)\n    {\n        if ($id !== $this->getVolumeId()) {\n            $this->_volumeId = $id;\n            $this->_volume = null;\n        }\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public function datetimeAttributes(): array\n    {\n        $attributes = parent::datetimeAttributes();\n        $attributes[] = 'dateModified';\n        return $attributes;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    protected function defineRules(): array\n    {\n        $rules = parent::defineRules();\n\n        $rules[] = [['title'], StringValidator::class, 'max' => 255, 'disallowMb4' => true, 'on' => [self::SCENARIO_CREATE]];\n        $rules[] = [['volumeId', 'folderId', 'width', 'height', 'size'], 'number', 'integerOnly' => true];\n        $rules[] = [['dateModified'], DateTimeValidator::class];\n        $rules[] = [['filename', 'kind'], 'required'];\n        $rules[] = [['kind'], 'string', 'max' => 50];\n        $rules[] = [['newLocation'], 'required', 'on' => [self::SCENARIO_CREATE, self::SCENARIO_MOVE, self::SCENARIO_FILEOPS]];\n        $rules[] = [['tempFilePath'], 'required', 'on' => [self::SCENARIO_CREATE, self::SCENARIO_REPLACE]];\n\n        // Validate the extension unless all we're doing is moving the file\n        $rules[] = [\n            ['newLocation'],\n            AssetLocationValidator::class,\n            'avoidFilenameConflicts' => $this->avoidFilenameConflicts,\n            'except' => [self::SCENARIO_MOVE],\n        ];\n        $rules[] = [\n            ['newLocation'],\n            AssetLocationValidator::class,\n            'avoidFilenameConflicts' => $this->avoidFilenameConflicts,\n            'allowedExtensions' => '*',\n            'on' => [self::SCENARIO_MOVE],\n        ];\n\n        return $rules;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public function scenarios()\n    {\n        $scenarios = parent::scenarios();\n        $scenarios[self::SCENARIO_INDEX] = [];\n\n        return $scenarios;\n    }\n\n    /**\n     * @inheritdoc\n     * @since 3.5.0\n     */\n    public function getCacheTags(): array\n    {\n        $tags = [\n            \"volume:$this->_volumeId\",\n        ];\n\n        // Did the volume just change?\n        if ($this->_volumeId != $this->_oldVolumeId) {\n            $tags[] = \"volume:$this->_oldVolumeId\";\n        }\n\n        return $tags;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    protected function isEditable(): bool\n    {\n        $volume = $this->getVolume();\n        $userSession = Craft::$app->getUser();\n        $isUploader = $this->uploaderId && $this->uploaderId == $userSession->getId();\n\n        if ($isUploader) {\n            return $userSession->checkPermission(\"saveAssetInVolume:$volume->uid\");\n        }\n\n        return $userSession->checkPermission(\"editPeerFilesInVolume:$volume->uid\");\n    }\n\n    /**\n     * @inheritdoc\n     * @since 3.5.15\n     */\n    protected function isDeletable(): bool\n    {\n        $volume = $this->getVolume();\n\n        if ($volume instanceof Temp) {\n            return true;\n        }\n\n        $userSession = Craft::$app->getUser();\n        return (\n            $userSession->checkPermission(\"deleteFilesAndFoldersInVolume:$volume->uid\") &&\n            ($userSession->getId() == $this->uploaderId || $userSession->checkPermission(\"deletePeerFilesInVolume:$volume->uid\"))\n        );\n    }\n\n    /**\n     * @inheritdoc\n     * ---\n     * ```php\n     * $url = $asset->cpEditUrl;\n     * ```\n     * ```twig{2}\n     * {% if asset.isEditable %}\n     *   <a href=\"{{ asset.cpEditUrl }}\">Edit</a>\n     * {% endif %}\n     * ```\n     * @since 3.4.0\n     */\n    protected function cpEditUrl(): ?string\n    {\n        $volume = $this->getVolume();\n        if ($volume instanceof Temp) {\n            return null;\n        }\n\n        $filename = $this->getFilename(false);\n        $path = \"assets/edit/$this->id-$filename\";\n\n        $params = [];\n        if (Craft::$app->getIsMultiSite()) {\n            $params['site'] = $this->getSite()->handle;\n        }\n\n        return UrlHelper::cpUrl($path, $params);\n    }\n\n    /**\n     * Returns an `<img>` tag based on this asset.\n     *\n     * @param mixed $transform The transform to use when generating the html.\n     * @param string[]|null $sizes The widths/x-descriptors that should be used for the `srcset` attribute\n     * (see [[getSrcset()]] for example syntaxes)\n     * @return Markup|null\n     * @throws InvalidArgumentException\n     */\n    public function getImg($transform = null, array $sizes = null)\n    {\n        if ($this->kind !== self::KIND_IMAGE) {\n            return null;\n        }\n\n        $volume = $this->getVolume();\n\n        if (!$volume->hasUrls) {\n            return null;\n        }\n\n        if ($transform) {\n            $oldTransform = $this->_transform;\n            $this->setTransform($transform);\n        }\n\n        $img = Html::tag('img', '', [\n            'src' => $this->getUrl(),\n            'width' => $this->getWidth(),\n            'height' => $this->getHeight(),\n            'srcset' => $sizes ? $this->getSrcset($sizes) : false,\n            'alt' => $this->title,\n        ]);\n\n        if (isset($oldTransform)) {\n            $this->setTransform($oldTransform);\n        }\n\n        return Template::raw($img);\n    }\n\n    /**\n     * Returns a `srcset` attribute value based on the given widths or x-descriptors.\n     *\n     * For example, if you pass `['100w', '200w']`, you will get:\n     *\n     * ```\n     * image-url@100w.ext 100w,\n     * image-url@200w.ext 200w\n     * ```\n     *\n     * If you pass x-descriptors, it will be assumed that the images current width is the `1x` width.\n     * So if you pass `['1x', '2x']` on an image with a 100px-wide transform applied, you will get:\n     *\n     * ```\n     * image-url@100w.ext,\n     * image-url@200w.ext 2x\n     * ```\n     *\n     * @param string[] $sizes\n     * @param AssetTransform|string|array|null $transform A transform handle or configuration that should be applied to the image\n     * @return string|false The `srcset` attribute value, or `false` if it cant be determined\n     * @throws InvalidArgumentException\n     * @since 3.5.0\n     */\n    public function getSrcset(array $sizes, $transform = null)\n    {\n        $urls = $this->getUrlsBySize($sizes, $transform);\n\n        if (empty($urls)) {\n            return false;\n        }\n\n        $srcset = [];\n\n        foreach ($urls as $size => $url) {\n            if ($size === '1x') {\n                $srcset[] = $url;\n            } else {\n                $srcset[] = \"$url $size\";\n            }\n        }\n\n        return implode(', ', $srcset);\n    }\n\n    /**\n     * Returns an array of image transform URLs based on the given widths or x-descriptors.\n     *\n     * For example, if you pass `['100w', '200w']`, you will get:\n     *\n     * ```php\n     * [\n     *     '100w' => 'image-url@100w.ext',\n     *     '200w' => 'image-url@200w.ext'\n     * ]\n     * ```\n     *\n     * If you pass x-descriptors, it will be assumed that the images current width is the indented 1x width.\n     * So if you pass `['1x', '2x']` on an image with a 100px-wide transform applied, you will get:\n     *\n     * ```php\n     * [\n     *     '1x' => 'image-url@100w.ext',\n     *     '2x' => 'image-url@200w.ext'\n     * ]\n     * ```\n     *\n     * @param string[] $sizes\n     * @param AssetTransform|string|array|null $transform A transform handle or configuration that should be applied to the image\n     * @return array\n     * @since 3.7.16\n     */\n    public function getUrlsBySize(array $sizes, $transform = null): array\n    {\n        if ($this->kind !== self::KIND_IMAGE) {\n            return [];\n        }\n\n        $urls = [];\n\n        if (\n            ($transform !== null || $this->_transform) &&\n            Image::canManipulateAsImage($this->getExtension())\n        ) {\n            $transform = Craft::$app->getAssetTransforms()->normalizeTransform($transform ?? $this->_transform);\n        } else {\n            $transform = null;\n        }\n\n        [$currentWidth, $currentHeight] = $this->_dimensions($transform);\n\n        if (!$currentWidth || !$currentHeight) {\n            return [];\n        }\n\n        foreach ($sizes as $size) {\n            if ($size === '1x') {\n                $urls[$size] = $this->getUrl($transform);\n                continue;\n            }\n\n            [$value, $unit] = Assets::parseSrcsetSize($size);\n\n            $sizeTransform = $transform ? $transform->toArray([\n                'format',\n                'height',\n                'interlace',\n                'mode',\n                'position',\n                'quality',\n                'width',\n            ]) : [];\n\n            if ($unit === 'w') {\n                $sizeTransform['width'] = (int)$value;\n            } else {\n                $sizeTransform['width'] = (int)ceil($currentWidth * $value);\n            }\n\n            // Only set the height if the current transform has a height set on it\n            if ($transform && $transform->height) {\n                if ($unit === 'w') {\n                    $sizeTransform['height'] = (int)ceil($currentHeight * $sizeTransform['width'] / $currentWidth);\n                } else {\n                    $sizeTransform['height'] = (int)ceil($currentHeight * $value);\n                }\n            }\n\n            $urls[\"$value$unit\"] = $this->getUrl($sizeTransform);\n        }\n\n        return $urls;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public function getIsTitleTranslatable(): bool\n    {\n        return ($this->getVolume()->titleTranslationMethod !== Field::TRANSLATION_METHOD_NONE);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public function getTitleTranslationDescription()\n    {\n        return ElementHelper::translationDescription($this->getVolume()->titleTranslationMethod);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public function getTitleTranslationKey(): string\n    {\n        $type = $this->getVolume();\n        return ElementHelper::translationKey($this, $type->titleTranslationMethod, $type->titleTranslationKeyFormat);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public function getFieldLayout()\n    {\n        if (($fieldLayout = parent::getFieldLayout()) !== null) {\n            return $fieldLayout;\n        }\n\n        $volume = $this->getVolume();\n        return $volume->getFieldLayout();\n    }\n\n    /**\n     * Returns the assets volume folder.\n     *\n     * @return VolumeFolder\n     * @throws InvalidConfigException if [[folderId]] is missing or invalid\n     */\n    public function getFolder(): VolumeFolder\n    {\n        if ($this->folderId === null) {\n            throw new InvalidConfigException('Asset is missing its folder ID');\n        }\n\n        if (($folder = Craft::$app->getAssets()->getFolderById($this->folderId)) === null) {\n            throw new InvalidConfigException('Invalid folder ID: ' . $this->folderId);\n        }\n\n        return $folder;\n    }\n\n    /**\n     * Returns the assets volume.\n     *\n     * @return VolumeInterface\n     * @throws InvalidConfigException if [[volumeId]] is missing or invalid\n     */\n    public function getVolume(): VolumeInterface\n    {\n        if ($this->_volume !== null) {\n            return $this->_volume;\n        }\n\n        if ($this->_volumeId === null) {\n            return new Temp();\n        }\n\n        if (($volume = Craft::$app->getVolumes()->getVolumeById($this->_volumeId)) === null) {\n            throw new InvalidConfigException('Invalid volume ID: ' . $this->_volumeId);\n        }\n\n        return $this->_volume = $volume;\n    }\n\n    /**\n     * Returns the user that uploaded the asset, if known.\n     *\n     * @return User|null\n     * @since 3.4.0\n     */\n    public function getUploader()\n    {\n        if ($this->_uploader !== null) {\n            return $this->_uploader;\n        }\n\n        if ($this->uploaderId === null) {\n            return null;\n        }\n\n        if (($this->_uploader = Craft::$app->getUsers()->getUserById($this->uploaderId)) === null) {\n            // The uploader is probably soft-deleted. Just pretend no uploader is set\n            return null;\n        }\n\n        return $this->_uploader;\n    }\n\n    /**\n     * Sets the asset's uploader.\n     *\n     * @param User|null $uploader\n     * @since 3.4.0\n     */\n    public function setUploader(User $uploader = null)\n    {\n        $this->_uploader = $uploader;\n    }\n\n    /**\n     * Sets the transform.\n     *\n     * @param AssetTransform|string|array|null $transform A transform handle or configuration that should be applied to the image\n     * @return Asset\n     * @throws AssetTransformException if $transform is an invalid transform handle\n     */\n    public function setTransform($transform): Asset\n    {\n        $this->_transform = Craft::$app->getAssetTransforms()->normalizeTransform($transform);\n\n        return $this;\n    }\n\n    /**\n     * Returns the elements full URL.\n     *\n     * @param string|array|null $transform A transform handle or configuration that should be applied to the\n     * image If an array is passed, it can optionally include a `transform` key that defines a base transform\n     * which the rest of the settings should be applied to.\n     * @param bool|null $generateNow Whether the transformed image should be generated immediately if it doesnt exist. If `null`, it will be left\n     * up to the `generateTransformsBeforePageLoad` config setting.\n     * @return string|null\n     * @throws InvalidConfigException\n     */\n    public function getUrl($transform = null, bool $generateNow = null)\n    {\n        $volume = $this->getVolume();\n\n        if (!$volume->hasUrls || !$this->folderId) {\n            return null;\n        }\n\n        $mimeType = $this->getMimeType();\n        $generalConfig = Craft::$app->getConfig()->getGeneral();\n\n        if (\n            ($mimeType === 'image/gif' && !$generalConfig->transformGifs) ||\n            ($mimeType === 'image/svg+xml' && !$generalConfig->transformSvgs)\n        ) {\n            return Assets::generateUrl($volume, $this);\n        }\n\n        // Normalize empty transform values\n        $transform = $transform ?: null;\n\n        if (is_array($transform)) {\n            if (isset($transform['width'])) {\n                $transform['width'] = round((float)$transform['width']);\n            }\n            if (isset($transform['height'])) {\n                $transform['height'] = round((float)$transform['height']);\n            }\n            $assetTransformsService = Craft::$app->getAssetTransforms();\n            $transform = $assetTransformsService->normalizeTransform($transform);\n        }\n\n        if ($transform === null && $this->_transform !== null) {\n            $transform = $this->_transform;\n        }\n\n        try {\n            return Craft::$app->getAssets()->getAssetUrl($this, $transform, $generateNow);\n        } catch (VolumeObjectNotFoundException $e) {\n            Craft::error(\"Could not determine asset's URL ($this->id): {$e->getMessage()}\");\n            Craft::$app->getErrorHandler()->logException($e);\n            return UrlHelper::actionUrl('not-found', null, null, false);\n        }\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public function getThumbUrl(int $size)\n    {\n        if ($this->getWidth() && $this->getHeight()) {\n            [$width, $height] = Assets::scaledDimensions($this->getWidth(), $this->getHeight(), $size, $size);\n        } else {\n            $width = $height = $size;\n        }\n\n        return Craft::$app->getAssets()->getThumbUrl($this, $width, $height, false);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public function getHasCheckeredThumb(): bool\n    {\n        return in_array(strtolower($this->getExtension()), ['png', 'gif', 'svg'], true);\n    }\n\n    /**\n     * Returns preview thumb image HTML.\n     *\n     * @param int $width\n     * @param int $height\n     * @return string\n     * @throws NotSupportedException if the asset can't have a thumbnail, and $fallbackToIcon is `false`\n     * @since 3.4.0\n     */\n    public function getPreviewThumbImg(int $width, int $height): string\n    {\n        $assetsService = Craft::$app->getAssets();\n        $srcsets = [];\n        [$width, $height] = Assets::scaledDimensions($this->getWidth() ?? 0, $this->getHeight() ?? 0, $width, $height);\n        $thumbSizes = [\n            [$width, $height],\n            [$width * 2, $height * 2],\n        ];\n        foreach ($thumbSizes as [$width, $height]) {\n            $thumbUrl = $assetsService->getThumbUrl($this, $width, $height, false, false);\n            $srcsets[] = $thumbUrl . ' ' . $width . 'w';\n        }\n\n        return Html::tag('img', '', [\n            'sizes' => \"{$thumbSizes[0][0]}px\",\n            'srcset' => implode(', ', $srcsets),\n            'alt' => $this->title,\n        ]);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public function getPreviewTargets(): array\n    {\n        return [];\n    }\n\n    /**\n     * Returns the file name, with or without the extension.\n     *\n     * @param bool $withExtension\n     * @return string\n     */\n    public function getFilename(bool $withExtension = true): string\n    {\n        if ($withExtension) {\n            return $this->filename;\n        }\n        return pathinfo($this->filename, PATHINFO_FILENAME);\n    }\n\n    /**\n     * Returns the file extension.\n     *\n     * @return string\n     */\n    public function getExtension(): string\n    {\n        return pathinfo($this->filename, PATHINFO_EXTENSION);\n    }\n\n    /**\n     * Returns the files MIME type, if it can be determined.\n     *\n     * @return string|null\n     */\n    public function getMimeType()\n    {\n        // todo: maybe we should be passing this off to volume types\n        // so Local volumes can call FileHelper::getMimeType() (uses magic file instead of ext)\n        return FileHelper::getMimeTypeByExtension($this->filename);\n    }\n\n    /**\n     * Returns the image height.\n     *\n     * @param AssetTransform|string|array|null $transform A transform handle or configuration that should be applied to the image\n     * @return int|float|null\n     */\n\n    public function getHeight($transform = null)\n    {\n        return $this->_dimensions($transform)[1];\n    }\n\n    /**\n     * Sets the image height.\n     *\n     * @param int|float|null $height the image height\n     */\n    public function setHeight($height)\n    {\n        $this->_height = $height;\n    }\n\n    /**\n     * Returns the image width.\n     *\n     * @param AssetTransform|string|array|null $transform A transform handle or configuration that should be applied to the image\n     * @return int|float|null\n     */\n    public function getWidth($transform = null)\n    {\n        return $this->_dimensions($transform)[0];\n    }\n\n    /**\n     * Sets the image width.\n     *\n     * @param int|float|null $width the image width\n     */\n    public function setWidth($width)\n    {\n        $this->_width = $width;\n    }\n\n    /**\n     * Returns the formatted file size, if known.\n     *\n     * @param int|null $decimals the number of digits after the decimal point\n     * @param bool $short whether the size should be returned in short form (kB instead of kilobytes)\n     * @return string|null\n     * @since 3.4.0\n     */\n    public function getFormattedSize(int $decimals = null, bool $short = true)\n    {\n        if ($this->size === null) {\n            return null;\n        }\n        if ($short) {\n            return Craft::$app->getFormatter()->asShortSize($this->size, $decimals);\n        }\n        return Craft::$app->getFormatter()->asSize($this->size, $decimals);\n    }\n\n    /**\n     * Returns the formatted file size in bytes, if known.\n     *\n     * @param bool $short whether the size should be returned in short form (B instead of bytes)\n     * @return string|null\n     * @since 3.4.0\n     */\n    public function getFormattedSizeInBytes(bool $short = true)\n    {\n        $params = [\n            'n' => $this->size,\n            'nFormatted' => Craft::$app->getFormatter()->asDecimal($this->size),\n        ];\n        if ($short) {\n            return Craft::t('yii', '{nFormatted} B', $params);\n        }\n        return Craft::t('yii', '{nFormatted} {n, plural, =1{byte} other{bytes}}', $params);\n    }\n\n    /**\n     * Returns the image dimensions.\n     *\n     * @return string|null\n     * @since 3.4.0\n     */\n    public function getDimensions()\n    {\n        $width = $this->getWidth();\n        $height = $this->getHeight();\n        if (!$width || !$height) {\n            return null;\n        }\n        return \"{$width}{$height}\";\n    }\n\n    /**\n     * @return string\n     */\n    public function getTransformSource(): string\n    {\n        if (!$this->_transformSource) {\n            Craft::$app->getAssetTransforms()->getLocalImageSource($this);\n        }\n\n        return $this->_transformSource;\n    }\n\n    /**\n     * Set a source to use for transforms for this Assets File.\n     *\n     * @param string $uri\n     */\n    public function setTransformSource(string $uri)\n    {\n        $this->_transformSource = $uri;\n    }\n\n    /**\n     * Returns the asset's path in the volume.\n     *\n     * @param string|null $filename Filename to use. If not specified, the asset's filename will be used.\n     * @return string\n     * @deprecated in 3.0.0-RC12\n     */\n    public function getUri(string $filename = null): string\n    {\n        Craft::$app->getDeprecator()->log(self::class . '::getUri()', '`' . self::class . '::getUri()` has been deprecated. Use `getPath()` instead.');\n\n        return $this->getPath($filename);\n    }\n\n    /**\n     * Returns the asset's path in the volume.\n     *\n     * @param string|null $filename Filename to use. If not specified, the asset's filename will be used.\n     * @return string\n     */\n    public function getPath(string $filename = null): string\n    {\n        return $this->folderPath . ($filename ?: $this->filename);\n    }\n\n    /**\n     * Return the path where the source for this Asset's transforms should be.\n     *\n     * @return string\n     */\n    public function getImageTransformSourcePath(): string\n    {\n        $volume = $this->getVolume();\n\n        if ($volume instanceof LocalVolumeInterface) {\n            return FileHelper::normalizePath($volume->getRootPath() . DIRECTORY_SEPARATOR . $this->getPath());\n        }\n\n        return Craft::$app->getPath()->getAssetSourcesPath() . DIRECTORY_SEPARATOR . $this->id . '.' . $this->getExtension();\n    }\n\n    /**\n     * Get a temporary copy of the actual file.\n     *\n     * @return string\n     */\n    public function getCopyOfFile(): string\n    {\n        $tempFilename = uniqid(pathinfo($this->filename, PATHINFO_FILENAME), true) . '.' . $this->getExtension();\n        $tempPath = Craft::$app->getPath()->getTempPath() . DIRECTORY_SEPARATOR . $tempFilename;\n        $this->getVolume()->saveFileLocally($this->getPath(), $tempPath);\n\n        return $tempPath;\n    }\n\n    /**\n     * Returns a stream of the actual file.\n     *\n     * @return resource\n     * @throws InvalidConfigException if [[volumeId]] is missing or invalid\n     * @throws AssetException if a stream could not be created\n     */\n    public function getStream()\n    {\n        return $this->getVolume()->getFileStream($this->getPath());\n    }\n\n    /**\n     * Returns the files contents.\n     *\n     * @return string\n     * @throws InvalidConfigException if [[volumeId]] is missing or invalid\n     * @throws AssetException if a stream could not be created\n     * @since 3.0.6\n     */\n    public function getContents(): string\n    {\n        return stream_get_contents($this->getStream());\n    }\n\n    /**\n     * Generates a base64-encoded [data URL](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs) for the asset.\n     *\n     * @return string\n     * @throws InvalidConfigException if [[volumeId]] is missing or invalid\n     * @throws AssetException if a stream could not be created\n     * @since 3.5.13\n     */\n    public function getDataUrl(): string\n    {\n        return Html::dataUrlFromString($this->getContents(), $this->getMimeType());\n    }\n\n    /**\n     * Return whether the Asset has a URL.\n     *\n     * @return bool\n     * @deprecated in 3.0.0-RC12. Use getVolume()->hasUrls instead.\n     */\n    public function getHasUrls(): bool\n    {\n        Craft::$app->getDeprecator()->log(self::class . '::getHasUrls()', '`' . self::class . '::getHasUrls()` has been deprecated. Use `getVolume()->hasUrls` instead.');\n\n        $volume = $this->getVolume();\n        return $volume && $volume->hasUrls;\n    }\n\n    /**\n     * Returns whether this asset can be edited by the image editor.\n     *\n     * @return bool\n     */\n    public function getSupportsImageEditor(): bool\n    {\n        $ext = $this->getExtension();\n        return (strcasecmp($ext, 'svg') !== 0 && Image::canManipulateAsImage($ext));\n    }\n\n    /**\n     * Returns whether this asset can be previewed.\n     *\n     * @return bool\n     * @deprecated in 3.4.0. Use [[\\craft\\services\\Assets::getAssetPreviewHandler]] instead.\n     */\n    public function getSupportsPreview(): bool\n    {\n        Craft::$app->getDeprecator()->log(self::class . '::getSupportsPreview()', '`' . self::class . '::getSupportsPreview()` has been deprecated. Use `craft\\services\\Assets::getAssetPreview()` instead.');\n\n        return \\in_array($this->kind, [self::KIND_IMAGE, self::KIND_HTML, self::KIND_JAVASCRIPT, self::KIND_JSON], true);\n    }\n\n    /**\n     * Returns whether a user-defined focal point is set on the asset.\n     *\n     * @return bool\n     */\n    public function getHasFocalPoint(): bool\n    {\n        return $this->_focalPoint !== null;\n    }\n\n    /**\n     * Returns the focal point represented as an array with `x` and `y` keys, or null if it's not an image.\n     *\n     * @param bool $asCss whether the value should be returned in CSS syntax (\"50% 25%\") instead\n     * @return array|string|null\n     */\n    public function getFocalPoint(bool $asCss = false)\n    {\n        if (!in_array($this->kind, [self::KIND_IMAGE, self::KIND_VIDEO], true)) {\n            return null;\n        }\n\n        $focal = $this->_focalPoint ?? ['x' => 0.5, 'y' => 0.5];\n\n        if ($asCss) {\n            return ($focal['x'] * 100) . '% ' . ($focal['y'] * 100) . '%';\n        }\n\n        return $focal;\n    }\n\n    /**\n     * Sets the asset's focal point.\n     *\n     * @param $value string|array|null\n     * @throws \\InvalidArgumentException if $value is invalid\n     */\n    public function setFocalPoint($value)\n    {\n        if (is_array($value)) {\n            if (!isset($value['x'], $value['y'])) {\n                throw new \\InvalidArgumentException('$value should be a string or array with \\'x\\' and \\'y\\' keys.');\n            }\n            $value = [\n                'x' => (float)$value['x'],\n                'y' => (float)$value['y'],\n            ];\n        } elseif ($value !== null) {\n            $focal = explode(';', $value);\n            if (count($focal) !== 2) {\n                throw new \\InvalidArgumentException('$value should be a string or array with \\'x\\' and \\'y\\' keys.');\n            }\n            $value = [\n                'x' => (float)$focal[0],\n                'y' => (float)$focal[1],\n            ];\n        }\n\n        if ($value !== null && (\n            $value['x'] < 0 ||\n            $value['x'] > 1 ||\n            $value['y'] < 0 ||\n            $value['y'] > 1\n        )) {\n            $value = null;\n        }\n\n        $this->_focalPoint = $value;\n    }\n\n    // Indexes, etc.\n    // -------------------------------------------------------------------------\n\n    /**\n     * @inheritdoc\n     */\n    protected function tableAttributeHtml(string $attribute): string\n    {\n        switch ($attribute) {\n            case 'uploader':\n                $uploader = $this->getUploader();\n                return $uploader ? Cp::elementHtml($uploader) : '';\n\n            case 'filename':\n                return Html::tag('span', Html::encode($this->filename), [\n                    'class' => 'break-word',\n                ]);\n\n            case 'kind':\n                return Assets::getFileKindLabel($this->kind);\n\n            case 'size':\n                if ($this->size === null) {\n                    return '';\n                }\n                return Html::tag('span', $this->getFormattedSize(0), [\n                    'title' => $this->getFormattedSizeInBytes(false),\n                ]);\n\n            case 'imageSize':\n                return $this->getDimensions() ?? '';\n\n            case 'width':\n            case 'height':\n                $size = $this->$attribute;\n                return ($size ? $size . 'px' : '');\n        }\n\n        return parent::tableAttributeHtml($attribute);\n    }\n\n    /**\n     * Returns the HTML for asset previews.\n     *\n     * @return string\n     * @throws InvalidConfigException\n     */\n    public function getPreviewHtml(): string\n    {\n        $html = '';\n\n        // See if we can show a thumbnail\n        try {\n            // Is the image editable, and is the user allowed to edit?\n            $userSession = Craft::$app->getUser();\n\n            $volume = $this->getVolume();\n            $previewable = Craft::$app->getAssets()->getAssetPreviewHandler($this) !== null;\n            $editable = (\n                $this->getSupportsImageEditor() &&\n                $userSession->checkPermission(\"editImagesInVolume:$volume->uid\") &&\n                ($userSession->getId() == $this->uploaderId || $userSession->checkPermission(\"editPeerImagesInVolume:$volume->uid\"))\n            );\n\n            $html = Html::tag('div',\n                Html::tag('div', $this->getPreviewThumbImg(350, 190), [\n                    'class' => 'preview-thumb',\n                ]) .\n                Html::tag(\n                    'div',\n                    ($previewable ? Html::tag('button', Craft::t('app', 'Preview'), ['class' => 'btn preview-btn', 'id' => 'preview-btn', 'type' => 'button']) : '') .\n                    ($editable ? Html::tag('button', Craft::t('app', 'Edit'), ['class' => 'btn edit-btn', 'id' => 'edit-btn', 'type' => 'button']) : ''),\n                    ['class' => 'buttons']\n                ),\n                [\n                    'class' => array_filter([\n                        'preview-thumb-container',\n                        $this->getHasCheckeredThumb() ? 'checkered' : null,\n                    ]),\n                ]\n            );\n        } catch (NotSupportedException $e) {\n            // NBD\n        }\n\n        return $html;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public function getSidebarHtml(): string\n    {\n        $components = [\n\n            // Omit preview button on sidebar of slideouts\n            $this->getPreviewHtml(false),\n\n            parent::getSidebarHtml(),\n        ];\n\n        return implode(\"\\n\", $components);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public function getEditorHtml(): string\n    {\n        if (!$this->fieldLayoutId) {\n            $this->fieldLayoutId = Craft::$app->getRequest()->getBodyParam('defaultFieldLayoutId');\n        }\n\n        return parent::getEditorHtml();\n    }\n\n    /**\n     * @inheritdoc\n     */\n    protected function metaFieldsHtml(): string\n    {\n        return implode('', [\n            Cp::textFieldHtml([\n                'label' => Craft::t('app', 'Filename'),\n                'id' => 'newFilename',\n                'name' => 'newFilename',\n                'value' => $this->filename,\n                'errors' => $this->getErrors('newLocation'),\n                'first' => true,\n                'required' => true,\n                'class' => ['text', 'filename'],\n            ]),\n            parent::metaFieldsHtml(),\n        ]);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    protected function metadata(): array\n    {\n        $volume = $this->getVolume();\n\n        return [\n            Craft::t('app', 'Location') => function() use ($volume) {\n                $loc = [Craft::t('site', $volume->name)];\n                if ($this->folderPath) {\n                    array_push($loc, ...ArrayHelper::filterEmptyStringsFromArray(explode('/', $this->folderPath)));\n                }\n                return implode('  ', $loc);\n            },\n            Craft::t('app', 'File size') => function() {\n                $size = $this->getFormattedSize(0);\n                if (!$size) {\n                    return false;\n                }\n                $inBytes = $this->getFormattedSizeInBytes(false);\n                return Html::tag('div', $size, [\n                    'title' => $inBytes,\n                    'aria' => [\n                        'label' => $inBytes,\n                    ],\n                ]);\n            },\n            Craft::t('app', 'Uploaded by') => function() {\n                $uploader = $this->getUploader();\n                return $uploader ? Cp::elementHtml($uploader) : false;\n            },\n            Craft::t('app', 'Dimensions') => $this->getDimensions() ?: false,\n        ];\n    }\n\n    /**\n     * @inheritdoc\n     * @since 3.3.0\n     */\n    public function getGqlTypeName(): string\n    {\n        return static::gqlTypeNameByContext($this->getVolume());\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public function attributes()\n    {\n        $names = parent::attributes();\n        $names[] = 'extension';\n        $names[] = 'filename';\n        $names[] = 'focalPoint';\n        $names[] = 'hasFocalPoint';\n        $names[] = 'height';\n        $names[] = 'mimeType';\n        $names[] = 'path';\n        $names[] = 'volumeId';\n        $names[] = 'width';\n        return $names;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public function extraFields()\n    {\n        $names = parent::extraFields();\n        $names[] = 'folder';\n        $names[] = 'volume';\n        return $names;\n    }\n\n    /**\n     * Returns a copy of the asset with the given transform applied to it.\n     *\n     * @param AssetTransform|string|array|null $transform The transform handle or configuration that should be applied to the image\n     * @return Asset\n     * @throws AssetTransformException if $transform is an invalid transform handle\n     */\n    public function copyWithTransform($transform): Asset\n    {\n        $model = clone $this;\n        $model->setFieldValues($this->getFieldValues());\n        $model->setTransform($transform);\n\n        return $model;\n    }\n\n    // Events\n    // -------------------------------------------------------------------------\n\n    /**\n     * @inheritdoc\n     */\n    public function beforeSave(bool $isNew): bool\n    {\n        // newFolderId/newFilename => newLocation.\n        if ($this->newFilename === '') {\n            $this->newFilename = null;\n        }\n        if ($this->newFolderId !== null || $this->newFilename !== null) {\n            $folderId = $this->newFolderId ?: $this->folderId;\n            $filename = $this->newFilename ?? $this->filename;\n            $this->newLocation = \"{folder:$folderId}$filename\";\n            $this->newFolderId = $this->newFilename = null;\n        }\n\n        // Get the (new?) folder ID\n        if ($this->newLocation !== null) {\n            [$folderId] = Assets::parseFileLocation($this->newLocation);\n        } else {\n            $folderId = $this->folderId;\n        }\n\n        // Fire a 'beforeHandleFile' event if we're going to be doing any file operations in afterSave()\n        if (\n            ($this->newLocation !== null || $this->tempFilePath !== null) &&\n            $this->hasEventHandlers(self::EVENT_BEFORE_HANDLE_FILE)\n        ) {\n            $this->trigger(self::EVENT_BEFORE_HANDLE_FILE, new AssetEvent([\n                'asset' => $this,\n                'isNew' => !$this->id,\n            ]));\n        }\n\n        // Set the kind based on filename, if not set already\n        if ($this->kind === null && $this->filename !== null) {\n            $this->kind = Assets::getFileKindByExtension($this->filename);\n        }\n\n        // Give it a default title based on the file name, if it doesn't have a title yet\n        if (!$this->id && !$this->title) {\n            $this->title = Assets::filename2Title(pathinfo($this->filename, PATHINFO_FILENAME));\n        }\n\n        // Set the field layout\n        $volume = Craft::$app->getAssets()->getFolderById($folderId)->getVolume();\n\n        if (!$volume instanceof Temp) {\n            $this->fieldLayoutId = $volume->fieldLayoutId;\n        }\n\n        return parent::beforeSave($isNew);\n    }\n\n    /**\n     * @inheritdoc\n     * @throws Exception if the asset isn't new but doesn't have a row in the `assets` table for some reason\n     */\n    public function afterSave(bool $isNew)\n    {\n        if (!$this->propagating) {\n            $isCpRequest = Craft::$app->getRequest()->getIsCpRequest();\n            $sanitizeCpImageUploads = Craft::$app->getConfig()->getGeneral()->sanitizeCpImageUploads;\n\n            if (\n                \\in_array($this->getScenario(), [self::SCENARIO_REPLACE, self::SCENARIO_CREATE], true) &&\n                Assets::getFileKindByExtension($this->tempFilePath) === static::KIND_IMAGE &&\n                !($isCpRequest && !$sanitizeCpImageUploads)\n            ) {\n                Image::cleanImageByPath($this->tempFilePath);\n            }\n\n            // Relocate the file?\n            if ($this->newLocation !== null || $this->tempFilePath !== null) {\n                $this->_relocateFile();\n            }\n\n            // Get the asset record\n            if (!$isNew) {\n                $record = AssetRecord::findOne($this->id);\n\n                if (!$record) {\n                    throw new Exception('Invalid asset ID: ' . $this->id);\n                }\n            } else {\n                $record = new AssetRecord();\n                $record->id = (int)$this->id;\n            }\n\n            $record->filename = $this->filename;\n            $record->volumeId = $this->getVolumeId();\n            $record->folderId = (int)$this->folderId;\n            $record->uploaderId = (int)$this->uploaderId ?: null;\n            $record->kind = $this->kind;\n            $record->size = (int)$this->size ?: null;\n            $record->width = (int)$this->_width ?: null;\n            $record->height = (int)$this->_height ?: null;\n            $record->dateModified = $this->dateModified;\n\n            if ($this->getHasFocalPoint()) {\n                $focal = $this->getFocalPoint();\n                $record->focalPoint = number_format($focal['x'], 4) . ';' . number_format($focal['y'], 4);\n            } else {\n                $record->focalPoint = null;\n            }\n\n            $record->save(false);\n        }\n\n        parent::afterSave($isNew);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public function beforeDelete(): bool\n    {\n        if (!parent::beforeDelete()) {\n            return false;\n        }\n\n        // Update the asset record\n        Db::update(Table::ASSETS, [\n            'deletedWithVolume' => $this->deletedWithVolume,\n            'keptFile' => $this->keepFileOnDelete,\n        ], [\n            'id' => $this->id,\n        ], [], false);\n\n        return true;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public function afterDelete()\n    {\n        if (!$this->keepFileOnDelete) {\n            $this->getVolume()->deleteFile($this->getPath());\n        }\n\n        Craft::$app->getAssetTransforms()->deleteAllTransformData($this);\n        parent::afterDelete();\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public function beforeRestore(): bool\n    {\n        // Only allow the asset to be restored if the file was kept on delete\n        return $this->keptFile && parent::beforeRestore();\n    }\n\n    /**\n     * @inheritdoc\n     */\n    protected function htmlAttributes(string $context): array\n    {\n        $attributes = [\n            'data-kind' => $this->kind,\n        ];\n\n        if ($this->kind === self::KIND_IMAGE) {\n            $attributes['data-image-width'] = $this->getWidth();\n            $attributes['data-image-height'] = $this->getHeight();\n        }\n\n        $volume = $this->getVolume();\n        $userSession = Craft::$app->getUser();\n        $imageEditable = $context === 'index' && $this->getSupportsImageEditor();\n\n        if ($volume instanceof Temp || $userSession->getId() == $this->uploaderId) {\n            $attributes['data-own-file'] = null;\n            $movable = $replaceable = true;\n        } else {\n            $attributes['data-peer-file'] = null;\n            $movable = (\n                $userSession->checkPermission(\"editPeerFilesInVolume:$volume->uid\") &&\n                $userSession->checkPermission(\"deletePeerFilesInVolume:$volume->uid\")\n            );\n            $replaceable = $userSession->checkPermission(\"replacePeerFilesInVolume:$volume->uid\");\n            $imageEditable = (\n                $imageEditable &&\n                ($userSession->checkPermission(\"editPeerImagesInVolume:$volume->uid\"))\n            );\n        }\n\n        if ($movable) {\n            $attributes['data-movable'] = null;\n        }\n\n        if ($replaceable) {\n            $attributes['data-replaceable'] = null;\n        }\n\n        if ($imageEditable) {\n            $attributes['data-editable-image'] = null;\n        }\n\n        return $attributes;\n    }\n\n    /**\n     * Returns whether the current user can move/rename the asset.\n     *\n     * @return bool\n     */\n    private function _isMovable(): bool\n    {\n        $userSession = Craft::$app->getUser();\n        if ($userSession->getId() == $this->uploaderId) {\n            return true;\n        }\n\n        $volume = $this->getVolume();\n        return (\n            $userSession->checkPermission(\"editPeerFilesInVolume:$volume->uid\") &&\n            $userSession->checkPermission(\"deletePeerFilesInVolume:$volume->uid\")\n        );\n    }\n\n    /**\n     * Returns the width and height of the image.\n     *\n     * @param AssetTransform|string|array|null $transform\n     * @return array\n     */\n    private function _dimensions($transform = null): array\n    {\n        if (!in_array($this->kind, [self::KIND_IMAGE, self::KIND_VIDEO], true)) {\n            return [null, null];\n        }\n\n        if (!$this->_width || !$this->_height) {\n            if (\n                $this->kind === self::KIND_IMAGE &&\n                $this->getScenario() !== self::SCENARIO_CREATE\n            ) {\n                Craft::warning(\"Asset $this->id is missing its width or height\", __METHOD__);\n            }\n\n            return [null, null];\n        }\n\n        $transform = $transform ?? $this->_transform;\n\n        if ($transform === null || !Image::canManipulateAsImage($this->getExtension())) {\n            return [$this->_width, $this->_height];\n        }\n\n        $transform = Craft::$app->getAssetTransforms()->normalizeTransform($transform);\n\n        return Image::targetDimensions(\n            $this->_width,\n            $this->_height,\n            $transform->width,\n            $transform->height,\n            $transform->mode\n        );\n    }\n\n    /**\n     * Relocates the file after the element has been saved.\n     *\n     * @throws FileException if the file is being moved but cannot be read\n     */\n    private function _relocateFile()\n    {\n        $assetsService = Craft::$app->getAssets();\n\n        // Get the (new?) folder ID & filename\n        if ($this->newLocation !== null) {\n            [$folderId, $filename] = Assets::parseFileLocation($this->newLocation);\n        } else {\n            $folderId = $this->folderId;\n            $filename = $this->filename;\n        }\n\n        $hasNewFolder = $folderId != $this->folderId;\n\n        $tempPath = null;\n\n        $oldFolder = $this->folderId ? $assetsService->getFolderById($this->folderId) : null;\n        $oldVolume = $oldFolder ? $oldFolder->getVolume() : null;\n\n        $newFolder = $hasNewFolder ? $assetsService->getFolderById($folderId) : $oldFolder;\n        $newVolume = $hasNewFolder ? $newFolder->getVolume() : $oldVolume;\n\n        $oldPath = $this->folderId ? $this->getPath() : null;\n        $newPath = ($newFolder->path ? rtrim($newFolder->path, '/') . '/' : '') . $filename;\n\n        // Is this just a simple move/rename within the same volume?\n        if ($this->tempFilePath === null && $oldFolder !== null && $oldFolder->volumeId == $newFolder->volumeId) {\n            $oldVolume->renameFile($oldPath, $newPath);\n        } else {\n            // Get the temp path\n            if ($this->tempFilePath !== null) {\n                if (!$this->_validateTempFilePath()) {\n                    Craft::warning(\"Prevented saving $this->tempFilePath as an asset. It must be located within a temp directory or the project root (excluding system directories).\");\n                    throw new FileException(Craft::t('app', \"There was an error relocating the file.\"));\n                }\n\n                $tempPath = $this->tempFilePath;\n            } else {\n                $tempFilename = uniqid(pathinfo($filename, PATHINFO_FILENAME), true) . '.' . pathinfo($filename, PATHINFO_EXTENSION);\n                $tempPath = Craft::$app->getPath()->getTempPath() . DIRECTORY_SEPARATOR . $tempFilename;\n                $oldVolume->saveFileLocally($oldPath, $tempPath);\n            }\n\n            // Try to open a file stream\n            if (($stream = fopen($tempPath, 'rb')) === false) {\n                if (file_exists($tempPath)) {\n                    FileHelper::unlink($tempPath);\n                }\n                throw new FileException(Craft::t('app', 'Could not open file for streaming at {path}', ['path' => $tempPath]));\n            }\n\n            if ($this->folderId) {\n                // Delete the old file\n                $oldVolume->deleteFile($oldPath);\n            }\n\n            // Upload the file to the new location\n            $newVolume->createFileByStream($newPath, $stream, [\n                'mimetype' => FileHelper::getMimeType($tempPath),\n            ]);\n\n            // Rackspace will disconnect the stream automatically\n            if (is_resource($stream)) {\n                fclose($stream);\n            }\n        }\n\n        if ($this->folderId) {\n            // Nuke the transforms\n            Craft::$app->getAssetTransforms()->deleteAllTransformData($this);\n        }\n\n        // Update file properties\n        $this->setVolumeId($newFolder->volumeId);\n        $this->folderId = $folderId;\n        $this->folderPath = $newFolder->path;\n        $this->filename = $filename;\n        $this->_volume = $newVolume;\n\n        // If there was a new file involved, update file data.\n        if ($tempPath && file_exists($tempPath)) {\n            $this->kind = Assets::getFileKindByExtension($filename);\n\n            if ($this->kind === self::KIND_IMAGE) {\n                [$this->_width, $this->_height] = Image::imageSize($tempPath);\n            } else {\n                $this->_width = null;\n                $this->_height = null;\n            }\n\n            $this->size = filesize($tempPath);\n            $this->dateModified = new DateTime('@' . filemtime($tempPath));\n\n            // Delete the temp file\n            FileHelper::unlink($tempPath);\n        }\n\n        // Clear out the temp location properties\n        $this->newLocation = null;\n        $this->tempFilePath = null;\n    }\n\n    /**\n     * Validates that the temp file path exists and is someplace safe.\n     *\n     * @return bool\n     */\n    private function _validateTempFilePath(): bool\n    {\n        $tempFilePath = realpath($this->tempFilePath);\n\n        if ($tempFilePath === false || !is_file($tempFilePath)) {\n            return false;\n        }\n\n        $tempFilePath = FileHelper::normalizePath($tempFilePath);\n\n        // Make sure it's within a known temp path, the project root, or storage/ folder\n        $pathService = Craft::$app->getPath();\n        $allowedRoots = [\n            [$pathService->getTempPath(), true],\n            [$pathService->getTempAssetUploadsPath(), true],\n            [sys_get_temp_dir(), true],\n            [Craft::getAlias('@root', false), false],\n            [Craft::getAlias('@storage', false), false],\n        ];\n\n        $inAllowedRoot = false;\n        foreach ($allowedRoots as [$root, $isTempDir]) {\n            $root = $this->_normalizeTempPath($root);\n            if ($root !== false && StringHelper::startsWith($tempFilePath, $root)) {\n                // If this is a known temp dir, were good here\n                if ($isTempDir) {\n                    return true;\n                }\n                $inAllowedRoot = true;\n                break;\n            }\n        }\n        if (!$inAllowedRoot) {\n            return false;\n        }\n\n        // Make sure it's *not* within a system directory though\n        $systemDirs = $pathService->getSystemPaths();\n        $systemDirs = array_map([$this, '_normalizeTempPath'], $systemDirs);\n        $systemDirs = array_filter($systemDirs, function($value) {\n            return ($value !== false);\n        });\n\n        foreach ($systemDirs as $dir) {\n            if (StringHelper::startsWith($tempFilePath, $dir)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns a normalized temp path or false, if realpath fails.\n     *\n     * @param string|false $path\n     * @return false|string\n     */\n    private function _normalizeTempPath($path)\n    {\n        if (!$path || !($path = realpath($path))) {\n            return false;\n        }\n\n        return FileHelper::normalizePath($path) . DIRECTORY_SEPARATOR;\n    }\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2023-30852", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\AdminBundle\\Controller\\Admin\\Asset;\n\nuse Pimcore\\Bundle\\AdminBundle\\Controller\\Admin\\ElementControllerBase;\nuse Pimcore\\Bundle\\AdminBundle\\Controller\\Traits\\AdminStyleTrait;\nuse Pimcore\\Bundle\\AdminBundle\\Controller\\Traits\\ApplySchedulerDataTrait;\nuse Pimcore\\Bundle\\AdminBundle\\Helper\\GridHelperService;\nuse Pimcore\\Bundle\\AdminBundle\\Security\\CsrfProtectionHandler;\nuse Pimcore\\Config;\nuse Pimcore\\Controller\\KernelControllerEventInterface;\nuse Pimcore\\Controller\\Traits\\ElementEditLockHelperTrait;\nuse Pimcore\\Db\\Helper;\nuse Pimcore\\Event\\Admin\\ElementAdminStyleEvent;\nuse Pimcore\\Event\\AdminEvents;\nuse Pimcore\\Event\\AssetEvents;\nuse Pimcore\\Event\\Model\\Asset\\ResolveUploadTargetEvent;\nuse Pimcore\\File;\nuse Pimcore\\Loader\\ImplementationLoader\\Exception\\UnsupportedException;\nuse Pimcore\\Logger;\nuse Pimcore\\Messenger\\AssetPreviewImageMessage;\nuse Pimcore\\Model;\nuse Pimcore\\Model\\Asset;\nuse Pimcore\\Model\\DataObject\\ClassDefinition\\Data\\ManyToManyRelation;\nuse Pimcore\\Model\\DataObject\\Concrete;\nuse Pimcore\\Model\\Element;\nuse Pimcore\\Model\\Element\\ValidationException;\nuse Pimcore\\Model\\Metadata;\nuse Pimcore\\Model\\Schedule\\Task;\nuse Pimcore\\Tool;\nuse Symfony\\Component\\EventDispatcher\\GenericEvent;\nuse Symfony\\Component\\HttpFoundation\\BinaryFileResponse;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\ResponseHeaderBag;\nuse Symfony\\Component\\HttpFoundation\\Session\\Attribute\\AttributeBagInterface;\nuse Symfony\\Component\\HttpFoundation\\StreamedResponse;\nuse Symfony\\Component\\HttpKernel\\Event\\ControllerEvent;\nuse Symfony\\Component\\Mime\\MimeTypes;\nuse Symfony\\Component\\Process\\Process;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Symfony\\Contracts\\EventDispatcher\\EventDispatcherInterface;\n\n/**\n * @Route(\"/asset\")\n *\n * @internal\n */\nclass AssetController extends ElementControllerBase implements KernelControllerEventInterface\n{\n    use AdminStyleTrait;\n    use ElementEditLockHelperTrait;\n    use ApplySchedulerDataTrait;\n\n    /**\n     * @var Asset\\Service\n     */\n    protected $_assetService;\n\n    /**\n     * @Route(\"/tree-get-root\", name=\"pimcore_admin_asset_treegetroot\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function treeGetRootAction(Request $request)\n    {\n        return parent::treeGetRootAction($request);\n    }\n\n    /**\n     * @Route(\"/delete-info\", name=\"pimcore_admin_asset_deleteinfo\", methods={\"GET\"})\n     *\n     * @param Request $request\n     * @param EventDispatcherInterface $eventDispatcher\n     *\n     * @return JsonResponse\n     */\n    public function deleteInfoAction(Request $request, EventDispatcherInterface $eventDispatcher)\n    {\n        return parent::deleteInfoAction($request, $eventDispatcher);\n    }\n\n    /**\n     * @Route(\"/get-data-by-id\", name=\"pimcore_admin_asset_getdatabyid\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getDataByIdAction(Request $request, EventDispatcherInterface $eventDispatcher)\n    {\n        $assetId = (int)$request->get('id');\n        $type = (string)$request->get('type');\n\n        $asset = Asset::getById($assetId);\n        if (!$asset instanceof Asset) {\n            return $this->adminJson(['success' => false, 'message' => \"asset doesn't exist\"]);\n        }\n\n        // check for lock on non-folder items only.\n        if ($type !== 'folder' && ($asset->isAllowed('publish') || $asset->isAllowed('delete'))) {\n            if (Element\\Editlock::isLocked($assetId, 'asset')) {\n                return $this->getEditLockResponse($assetId, 'asset');\n            }\n\n            Element\\Editlock::lock($request->get('id'), 'asset');\n        }\n\n        $asset = clone $asset;\n        $asset->setParent(null);\n\n        $asset->setStream(null);\n        $data = $asset->getObjectVars();\n        $data['locked'] = $asset->isLocked();\n\n        if ($asset instanceof Asset\\Text) {\n            if ($asset->getFileSize() < 2000000) {\n                // it doesn't make sense to show a preview for files bigger than 2MB\n                $data['data'] = \\ForceUTF8\\Encoding::toUTF8($asset->getData());\n            } else {\n                $data['data'] = false;\n            }\n        } elseif ($asset instanceof Asset\\Document) {\n            $data['pdfPreviewAvailable'] = (bool)$this->getDocumentPreviewPdf($asset);\n        } elseif ($asset instanceof Asset\\Video) {\n            $videoInfo = [];\n\n            if (\\Pimcore\\Video::isAvailable()) {\n                $config = Asset\\Video\\Thumbnail\\Config::getPreviewConfig();\n                $thumbnail = $asset->getThumbnail($config, ['mp4']);\n                if ($thumbnail) {\n                    if ($thumbnail['status'] == 'finished') {\n                        $videoInfo['previewUrl'] = $thumbnail['formats']['mp4'];\n                        $videoInfo['width'] = $asset->getWidth();\n                        $videoInfo['height'] = $asset->getHeight();\n\n                        $metaData = $asset->getSphericalMetaData();\n                        if (isset($metaData['ProjectionType']) && strtolower($metaData['ProjectionType']) == 'equirectangular') {\n                            $videoInfo['isVrVideo'] = true;\n                        }\n                    }\n                }\n            }\n\n            $data['videoInfo'] = $videoInfo;\n        } elseif ($asset instanceof Asset\\Image) {\n            $imageInfo = [];\n\n            $previewUrl = $this->generateUrl('pimcore_admin_asset_getimagethumbnail', [\n                'id' => $asset->getId(),\n                'treepreview' => true,\n                '_dc' => time(),\n            ]);\n\n            if ($asset->isAnimated()) {\n                $previewUrl = $this->generateUrl('pimcore_admin_asset_getasset', [\n                    'id' => $asset->getId(),\n                    '_dc' => time(),\n                ]);\n            }\n\n            $imageInfo['previewUrl'] = $previewUrl;\n\n            if ($asset->getWidth() && $asset->getHeight()) {\n                $imageInfo['dimensions'] = [];\n                $imageInfo['dimensions']['width'] = $asset->getWidth();\n                $imageInfo['dimensions']['height'] = $asset->getHeight();\n            }\n\n            $imageInfo['exiftoolAvailable'] = (bool)\\Pimcore\\Tool\\Console::getExecutable('exiftool');\n\n            if (!$asset->getEmbeddedMetaData(false)) {\n                $asset->getEmbeddedMetaData(true, false); // read Exif, IPTC and XPM like in the old days ...\n            }\n\n            $data['imageInfo'] = $imageInfo;\n        }\n\n        $predefinedMetaData = Metadata\\Predefined\\Listing::getByTargetType('asset', [$asset->getType()]);\n        $predefinedMetaDataGroups = [];\n        /** @var Metadata\\Predefined $item */\n        foreach ($predefinedMetaData as $item) {\n            if ($item->getGroup()) {\n                $predefinedMetaDataGroups[$item->getGroup()] = true;\n            }\n        }\n        $data['predefinedMetaDataGroups'] = array_keys($predefinedMetaDataGroups);\n        $data['properties'] = Element\\Service::minimizePropertiesForEditmode($asset->getProperties());\n        $data['metadata'] = Asset\\Service::expandMetadataForEditmode($asset->getMetadata());\n        $data['versionDate'] = $asset->getModificationDate();\n        $data['filesizeFormatted'] = $asset->getFileSize(true);\n        $data['filesize'] = $asset->getFileSize();\n        $data['fileExtension'] = File::getFileExtension($asset->getFilename());\n        $data['idPath'] = Element\\Service::getIdPath($asset);\n        $data['userPermissions'] = $asset->getUserPermissions($this->getAdminUser());\n        $frontendPath = $asset->getFrontendFullPath();\n        $data['url'] = preg_match('/^http(s)?:\\\\/\\\\/.+/', $frontendPath) ?\n            $frontendPath :\n            $request->getSchemeAndHttpHost() . $frontendPath;\n\n        $data['scheduledTasks'] = array_map(\n            static function (Task $task) {\n                return $task->getObjectVars();\n            },\n            $asset->getScheduledTasks()\n        );\n\n        $this->addAdminStyle($asset, ElementAdminStyleEvent::CONTEXT_EDITOR, $data);\n\n        $data['php'] = [\n            'classes' => array_merge([get_class($asset)], array_values(class_parents($asset))),\n            'interfaces' => array_values(class_implements($asset)),\n        ];\n\n        $event = new GenericEvent($this, [\n            'data' => $data,\n            'asset' => $asset,\n        ]);\n        $eventDispatcher->dispatch($event, AdminEvents::ASSET_GET_PRE_SEND_DATA);\n        $data = $event->getArgument('data');\n\n        if ($asset->isAllowed('view')) {\n            return $this->adminJson($data);\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @Route(\"/tree-get-childs-by-id\", name=\"pimcore_admin_asset_treegetchildsbyid\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function treeGetChildsByIdAction(Request $request, EventDispatcherInterface $eventDispatcher)\n    {\n        $allParams = array_merge($request->request->all(), $request->query->all());\n\n        $assets = [];\n        $cv = false;\n        $asset = Asset::getById($allParams['node']);\n\n        $filter = $request->get('filter');\n        $limit = (int)$allParams['limit'];\n        if (!is_null($filter)) {\n            if (substr($filter, -1) != '*') {\n                $filter .= '*';\n            }\n            $filter = str_replace('*', '%', $filter);\n\n            $limit = 100;\n            $offset = 0;\n        } elseif (!$allParams['limit']) {\n            $limit = 100000000;\n        }\n\n        $offset = isset($allParams['start']) ? (int)$allParams['start'] : 0;\n\n        $filteredTotalCount = 0;\n\n        if ($asset->hasChildren()) {\n            if ($allParams['view']) {\n                $cv = \\Pimcore\\Model\\Element\\Service::getCustomViewById($allParams['view']);\n            }\n\n            // get assets\n            $childrenList = new Asset\\Listing();\n            $childrenList->addConditionParam('parentId = ?', [$asset->getId()]);\n            $childrenList->filterAccessibleByUser($this->getAdminUser(), $asset);\n\n            if (!is_null($filter)) {\n                $childrenList->addConditionParam('CAST(assets.filename AS CHAR CHARACTER SET utf8) COLLATE utf8_general_ci LIKE ?', [$filter]);\n            }\n\n            $childrenList->setLimit($limit);\n            $childrenList->setOffset($offset);\n            $childrenList->setOrderKey(\"FIELD(assets.type, 'folder') DESC, CAST(assets.filename AS CHAR CHARACTER SET utf8) COLLATE utf8_general_ci ASC\", false);\n\n            \\Pimcore\\Model\\Element\\Service::addTreeFilterJoins($cv, $childrenList);\n\n            $beforeListLoadEvent = new GenericEvent($this, [\n                'list' => $childrenList,\n                'context' => $allParams,\n            ]);\n            $eventDispatcher->dispatch($beforeListLoadEvent, AdminEvents::ASSET_LIST_BEFORE_LIST_LOAD);\n            /** @var Asset\\Listing $childrenList */\n            $childrenList = $beforeListLoadEvent->getArgument('list');\n\n            $children = $childrenList->load();\n\n            $filteredTotalCount = $childrenList->getTotalCount();\n\n            foreach ($children as $childAsset) {\n                $assetTreeNode = $this->getTreeNodeConfig($childAsset);\n                if ($assetTreeNode['permissions']['list'] == 1) {\n                    $assets[] = $assetTreeNode;\n                }\n            }\n        }\n\n        //Hook for modifying return value - e.g. for changing permissions based on asset data\n        $event = new GenericEvent($this, [\n            'assets' => $assets,\n        ]);\n        $eventDispatcher->dispatch($event, AdminEvents::ASSET_TREE_GET_CHILDREN_BY_ID_PRE_SEND_DATA);\n        $assets = $event->getArgument('assets');\n\n        if ($allParams['limit']) {\n            return $this->adminJson([\n                'offset' => $offset,\n                'limit' => $limit,\n                'total' => $asset->getChildAmount($this->getAdminUser()),\n                'overflow' => !is_null($filter) && ($filteredTotalCount > $limit),\n                'nodes' => $assets,\n                'filter' => $request->get('filter') ? $request->get('filter') : '',\n                'inSearch' => (int)$request->get('inSearch'),\n            ]);\n        } else {\n            return $this->adminJson($assets);\n        }\n    }\n\n    /**\n     * @Route(\"/add-asset\", name=\"pimcore_admin_asset_addasset\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param Config $config\n     *\n     * @return JsonResponse\n     */\n    public function addAssetAction(Request $request, Config $config)\n    {\n        try {\n            $res = $this->addAsset($request, $config);\n\n            $response = [\n                'success' => $res['success'],\n            ];\n\n            if ($res['success']) {\n                $response['asset'] = [\n                    'id' => $res['asset']->getId(),\n                    'path' => $res['asset']->getFullPath(),\n                    'type' => $res['asset']->getType(),\n                ];\n            }\n\n            return $this->adminJson($response);\n        } catch (\\Exception $e) {\n            return $this->adminJson([\n                'success' => false,\n                'message' => $e->getMessage(),\n            ]);\n        }\n    }\n\n    /**\n     * @Route(\"/add-asset-compatibility\", name=\"pimcore_admin_asset_addassetcompatibility\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param Config $config\n     *\n     * @return JsonResponse\n     */\n    public function addAssetCompatibilityAction(Request $request, Config $config)\n    {\n        try {\n            // this is a special action for the compatibility mode upload (without flash)\n            $res = $this->addAsset($request, $config);\n\n            $response = $this->adminJson([\n                'success' => $res['success'],\n                'msg' => $res['success'] ? 'Success' : 'Error',\n                'id' => $res['asset'] ? $res['asset']->getId() : null,\n                'fullpath' => $res['asset'] ? $res['asset']->getRealFullPath() : null,\n                'type' => $res['asset'] ? $res['asset']->getType() : null,\n            ]);\n            $response->headers->set('Content-Type', 'text/html');\n\n            return $response;\n        } catch (\\Exception $e) {\n            return $this->adminJson([\n                'success' => false,\n                'message' => $e->getMessage(),\n            ]);\n        }\n    }\n\n    /**\n     * @Route(\"/exists\", name=\"pimcore_admin_asset_exists\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function existsAction(Request $request)\n    {\n        $parentAsset = \\Pimcore\\Model\\Asset::getById((int)$request->get('parentId'));\n\n        return new JsonResponse([\n            'exists' => Asset\\Service::pathExists($parentAsset->getRealFullPath().'/'.$request->get('filename')),\n        ]);\n    }\n\n    /**\n     * @param Request $request\n     * @param Config $config\n     *\n     * @return array\n     *\n     * @throws \\Exception\n     */\n    protected function addAsset(Request $request, Config $config)\n    {\n        $defaultUploadPath = $config['assets']['default_upload_path'] ?? '/';\n\n        if (array_key_exists('Filedata', $_FILES)) {\n            $filename = $_FILES['Filedata']['name'];\n            $sourcePath = $_FILES['Filedata']['tmp_name'];\n        } elseif ($request->get('type') == 'base64') {\n            $filename = $request->get('filename');\n            $sourcePath = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/upload-base64' . uniqid() . '.tmp';\n            $data = preg_replace('@^data:[^,]+;base64,@', '', $request->get('data'));\n            File::put($sourcePath, base64_decode($data));\n        } else {\n            throw new \\Exception('The filename of the asset is empty');\n        }\n\n        $parentId = $request->get('parentId');\n        $parentPath = $request->get('parentPath');\n\n        if ($request->get('dir') && $request->get('parentId')) {\n            // this is for uploading folders with Drag&Drop\n            // param \"dir\" contains the relative path of the file\n            $parent = Asset::getById((int) $request->get('parentId'));\n            $dir = $request->get('dir');\n            if (strpos($dir, '..') !== false) {\n                throw new \\Exception('not allowed');\n            }\n\n            $newPath = $parent->getRealFullPath() . '/' . trim($dir, '/ ');\n\n            $maxRetries = 5;\n            $newParent = null;\n            for ($retries = 0; $retries < $maxRetries; $retries++) {\n                try {\n                    $newParent = Asset\\Service::createFolderByPath($newPath);\n\n                    break;\n                } catch (\\Exception $e) {\n                    if ($retries < ($maxRetries - 1)) {\n                        $waitTime = rand(100000, 900000); // microseconds\n                        usleep($waitTime); // wait specified time until we restart the transaction\n                    } else {\n                        // if the transaction still fail after $maxRetries retries, we throw out the exception\n                        throw $e;\n                    }\n                }\n            }\n            if ($newParent) {\n                $parentId = $newParent->getId();\n            }\n        } elseif (!$request->get('parentId') && $parentPath) {\n            $parent = Asset::getByPath($parentPath);\n            if ($parent instanceof Asset\\Folder) {\n                $parentId = $parent->getId();\n            }\n        }\n\n        $filename = Element\\Service::getValidKey($filename, 'asset');\n        if (empty($filename)) {\n            throw new \\Exception('The filename of the asset is empty');\n        }\n\n        $context = $request->get('context');\n        if ($context) {\n            $context = json_decode($context, true);\n            $context = $context ?: [];\n\n            $this->validateManyToManyRelationAssetType($context, $filename, $sourcePath);\n\n            $event = new ResolveUploadTargetEvent($parentId, $filename, $context);\n            \\Pimcore::getEventDispatcher()->dispatch($event, AssetEvents::RESOLVE_UPLOAD_TARGET);\n            $filename = Element\\Service::getValidKey($event->getFilename(), 'asset');\n            $parentId = $event->getParentId();\n        }\n\n        if (!$parentId) {\n            $parentId = Asset\\Service::createFolderByPath($defaultUploadPath)->getId();\n        }\n\n        $parentAsset = Asset::getById((int)$parentId);\n\n        if (!$request->get('allowOverwrite')) {\n            // check for duplicate filename\n            $filename = $this->getSafeFilename($parentAsset->getRealFullPath(), $filename);\n        }\n\n        if (!$parentAsset->isAllowed('create')) {\n            throw $this->createAccessDeniedHttpException(\n                'Missing the permission to create new assets in the folder: ' . $parentAsset->getRealFullPath()\n            );\n        }\n\n        if (is_file($sourcePath) && filesize($sourcePath) < 1) {\n            throw new \\Exception('File is empty!');\n        } elseif (!is_file($sourcePath)) {\n            throw new \\Exception('Something went wrong, please check upload_max_filesize and post_max_size in your php.ini as well as the write permissions of your temporary directories.');\n        }\n\n        // check if there is a requested type and if matches the asset type of the uploaded file\n        $uploadAssetType = $request->get('uploadAssetType');\n        if ($uploadAssetType) {\n            $mimetype = MimeTypes::getDefault()->guessMimeType($sourcePath);\n            $assetType = Asset::getTypeFromMimeMapping($mimetype, $filename);\n\n            if ($uploadAssetType !== $assetType) {\n                throw new \\Exception(\"Mime type $mimetype does not match with asset type: $uploadAssetType\");\n            }\n        }\n\n        if ($request->get('allowOverwrite') && Asset\\Service::pathExists($parentAsset->getRealFullPath().'/'.$filename)) {\n            $asset = Asset::getByPath($parentAsset->getRealFullPath().'/'.$filename);\n            $asset->setStream(fopen($sourcePath, 'rb', false, File::getContext()));\n            $asset->save();\n        } else {\n            $asset = Asset::create($parentId, [\n                'filename' => $filename,\n                'sourcePath' => $sourcePath,\n                'userOwner' => $this->getAdminUser()->getId(),\n                'userModification' => $this->getAdminUser()->getId(),\n            ]);\n        }\n\n        @unlink($sourcePath);\n\n        return [\n            'success' => true,\n            'asset' => $asset,\n        ];\n    }\n\n    /**\n     * @param string $targetPath\n     * @param string $filename\n     *\n     * @return string\n     */\n    protected function getSafeFilename($targetPath, $filename)\n    {\n        $pathinfo = pathinfo($filename);\n        $originalFilename = $pathinfo['filename'];\n        $originalFileextension = empty($pathinfo['extension']) ? '' : '.' . $pathinfo['extension'];\n        $count = 1;\n\n        if ($targetPath == '/') {\n            $targetPath = '';\n        }\n\n        while (true) {\n            if (Asset\\Service::pathExists($targetPath . '/' . $filename)) {\n                $filename = $originalFilename . '_' . $count . $originalFileextension;\n                $count++;\n            } else {\n                return $filename;\n            }\n        }\n    }\n\n    /**\n     * @Route(\"/replace-asset\", name=\"pimcore_admin_asset_replaceasset\", methods={\"POST\", \"PUT\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function replaceAssetAction(Request $request)\n    {\n        $asset = Asset::getById((int) $request->get('id'));\n\n        $newFilename = Element\\Service::getValidKey($_FILES['Filedata']['name'], 'asset');\n        $mimetype = MimeTypes::getDefault()->guessMimeType($_FILES['Filedata']['tmp_name']);\n        $newType = Asset::getTypeFromMimeMapping($mimetype, $newFilename);\n\n        if ($newType != $asset->getType()) {\n            return $this->adminJson([\n                'success' => false,\n                'message' => sprintf($this->trans('asset_type_change_not_allowed', [], 'admin'), $asset->getType(), $newType),\n            ]);\n        }\n\n        $stream = fopen($_FILES['Filedata']['tmp_name'], 'r+');\n        $asset->setStream($stream);\n        $asset->setCustomSetting('thumbnails', null);\n        $asset->setUserModification($this->getAdminUser()->getId());\n\n        $newFileExt = File::getFileExtension($newFilename);\n        $currentFileExt = File::getFileExtension($asset->getFilename());\n        if ($newFileExt != $currentFileExt) {\n            $newFilename = preg_replace('/\\.' . $currentFileExt . '$/i', '.' . $newFileExt, $asset->getFilename());\n            $newFilename = Element\\Service::getSafeCopyName($newFilename, $asset->getParent());\n            $asset->setFilename($newFilename);\n        }\n\n        if ($asset->isAllowed('publish')) {\n            $asset->save();\n\n            $response = $this->adminJson([\n                'id' => $asset->getId(),\n                'path' => $asset->getRealFullPath(),\n                'success' => true,\n            ]);\n\n            // set content-type to text/html, otherwise (when application/json is sent) chrome will complain in\n            // Ext.form.Action.Submit and mark the submission as failed\n            $response->headers->set('Content-Type', 'text/html');\n\n            return $response;\n        } else {\n            throw new \\Exception('missing permission');\n        }\n    }\n\n    /**\n     * @Route(\"/add-folder\", name=\"pimcore_admin_asset_addfolder\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function addFolderAction(Request $request)\n    {\n        $success = false;\n        $parentAsset = Asset::getById((int)$request->get('parentId'));\n        $equalAsset = Asset::getByPath($parentAsset->getRealFullPath() . '/' . $request->get('name'));\n\n        if ($parentAsset->isAllowed('create')) {\n            if (!$equalAsset) {\n                $asset = Asset::create($request->get('parentId'), [\n                    'filename' => $request->get('name'),\n                    'type' => 'folder',\n                    'userOwner' => $this->getAdminUser()->getId(),\n                    'userModification' => $this->getAdminUser()->getId(),\n                ]);\n                $success = true;\n            }\n        } else {\n            Logger::debug('prevented creating asset because of missing permissions');\n        }\n\n        return $this->adminJson(['success' => $success]);\n    }\n\n    /**\n     * @Route(\"/delete\", name=\"pimcore_admin_asset_delete\", methods={\"DELETE\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function deleteAction(Request $request)\n    {\n        $type = $request->get('type');\n\n        if ($type === 'childs') {\n            trigger_deprecation(\n                'pimcore/pimcore',\n                '10.4',\n                'Type childs is deprecated. Use children instead'\n            );\n            $type = 'children';\n        }\n        if ($type === 'children') {\n            $parentAsset = Asset::getById((int) $request->get('id'));\n\n            $list = new Asset\\Listing();\n            $list->setCondition('path LIKE ?', [Helper::escapeLike($parentAsset->getRealFullPath()) . '/%']);\n            $list->setLimit((int)$request->get('amount'));\n            $list->setOrderKey('LENGTH(path)', false);\n            $list->setOrder('DESC');\n\n            $deletedItems = [];\n            foreach ($list as $asset) {\n                $deletedItems[$asset->getId()] = $asset->getRealFullPath();\n                if ($asset->isAllowed('delete') && !$asset->isLocked()) {\n                    $asset->delete();\n                }\n            }\n\n            return $this->adminJson(['success' => true, 'deleted' => $deletedItems]);\n        }\n        if ($request->get('id')) {\n            $asset = Asset::getById((int) $request->get('id'));\n            if ($asset && $asset->isAllowed('delete')) {\n                if ($asset->isLocked()) {\n                    return $this->adminJson([\n                        'success' => false,\n                        'message' => 'prevented deleting asset, because it is locked: ID: ' . $asset->getId(),\n                    ]);\n                }\n\n                $asset->delete();\n\n                return $this->adminJson(['success' => true]);\n            }\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @param Asset $element\n     *\n     * @return array\n     */\n    protected function getTreeNodeConfig($element)\n    {\n        $asset = $element;\n\n        $permissions =  $asset->getUserPermissions($this->getAdminUser());\n\n        $tmpAsset = [\n            'id' => $asset->getId(),\n            'key' => $element->getKey(),\n            'text' => htmlspecialchars($asset->getFilename()),\n            'type' => $asset->getType(),\n            'path' => $asset->getRealFullPath(),\n            'basePath' => $asset->getRealPath(),\n            'locked' => $asset->isLocked(),\n            'lockOwner' => $asset->getLocked() ? true : false,\n            'elementType' => 'asset',\n            'permissions' => [\n                'remove' => $permissions['delete'],\n                'settings' => $permissions['settings'],\n                'rename' => $permissions['rename'],\n                'publish' => $permissions['publish'],\n                'view' => $permissions['view'],\n                'list' => $permissions['list'],\n            ],\n        ];\n\n        $hasChildren = $asset->getDao()->hasChildren($this->getAdminUser());\n\n        // set type specific settings\n        if ($asset instanceof Asset\\Folder) {\n            $tmpAsset['leaf'] = false;\n            $tmpAsset['expanded'] = !$hasChildren;\n            $tmpAsset['loaded'] = !$hasChildren;\n            $tmpAsset['permissions']['create'] = $permissions['create'];\n            $tmpAsset['thumbnail'] = $this->getThumbnailUrl($asset, ['origin' => 'treeNode']);\n        } else {\n            $tmpAsset['leaf'] = true;\n            $tmpAsset['expandable'] = false;\n            $tmpAsset['expanded'] = false;\n        }\n\n        $this->addAdminStyle($asset, ElementAdminStyleEvent::CONTEXT_TREE, $tmpAsset);\n\n        if ($asset instanceof Asset\\Image) {\n            try {\n                $tmpAsset['thumbnail'] = $this->getThumbnailUrl($asset, ['origin' => 'treeNode']);\n\n                // we need the dimensions for the wysiwyg editors, so that they can resize the image immediately\n                if ($asset->getCustomSetting('imageDimensionsCalculated')) {\n                    $tmpAsset['imageWidth'] = $asset->getCustomSetting('imageWidth');\n                    $tmpAsset['imageHeight'] = $asset->getCustomSetting('imageHeight');\n                }\n            } catch (\\Exception $e) {\n                Logger::debug('Cannot get dimensions of image, seems to be broken.');\n            }\n        } elseif ($asset->getType() == 'video') {\n            try {\n                if (\\Pimcore\\Video::isAvailable()) {\n                    $tmpAsset['thumbnail'] = $this->getThumbnailUrl($asset, ['origin' => 'treeNode']);\n                }\n            } catch (\\Exception $e) {\n                Logger::debug('Cannot get dimensions of video, seems to be broken.');\n            }\n        } elseif ($asset->getType() == 'document') {\n            try {\n                // add the PDF check here, otherwise the preview layer in admin is shown without content\n                if (\\Pimcore\\Document::isAvailable() && \\Pimcore\\Document::isFileTypeSupported($asset->getFilename())) {\n                    $tmpAsset['thumbnail'] = $this->getThumbnailUrl($asset, ['origin' => 'treeNode']);\n                }\n            } catch (\\Exception $e) {\n                Logger::debug('Cannot get dimensions of video, seems to be broken.');\n            }\n        }\n\n        $tmpAsset['cls'] = '';\n        if ($asset->isLocked()) {\n            $tmpAsset['cls'] .= 'pimcore_treenode_locked ';\n        }\n        if ($asset->getLocked()) {\n            $tmpAsset['cls'] .= 'pimcore_treenode_lockOwner ';\n        }\n\n        return $tmpAsset;\n    }\n\n    /**\n     * @param Asset $asset\n     * @param array $params\n     *\n     * @return null|string\n     */\n    protected function getThumbnailUrl(Asset $asset, array $params = [])\n    {\n        $defaults = [\n            'id' => $asset->getId(),\n            'treepreview' => true,\n            '_dc' => $asset->getModificationDate(),\n        ];\n\n        $params = array_merge($defaults, $params);\n\n        if ($asset instanceof Asset\\Image) {\n            return $this->generateUrl('pimcore_admin_asset_getimagethumbnail', $params);\n        }\n\n        if ($asset instanceof Asset\\Folder) {\n            return $this->generateUrl('pimcore_admin_asset_getfolderthumbnail', $params);\n        }\n\n        if ($asset instanceof Asset\\Video && \\Pimcore\\Video::isAvailable()) {\n            return $this->generateUrl('pimcore_admin_asset_getvideothumbnail', $params);\n        }\n\n        if ($asset instanceof Asset\\Document && \\Pimcore\\Document::isAvailable() && $asset->getPageCount()) {\n            return $this->generateUrl('pimcore_admin_asset_getdocumentthumbnail', $params);\n        }\n\n        if ($asset instanceof Asset\\Audio) {\n            return '/bundles/pimcoreadmin/img/flat-color-icons/speaker.svg';\n        }\n\n        if ($asset instanceof Asset) {\n            return '/bundles/pimcoreadmin/img/filetype-not-supported.svg';\n        }\n    }\n\n    /**\n     * @Route(\"/update\", name=\"pimcore_admin_asset_update\", methods={\"PUT\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function updateAction(Request $request)\n    {\n        $success = false;\n        $allowUpdate = true;\n\n        $updateData = array_merge($request->request->all(), $request->query->all());\n\n        $asset = Asset::getById((int) $request->get('id'));\n        if ($asset->isAllowed('settings')) {\n            $asset->setUserModification($this->getAdminUser()->getId());\n\n            // if the position is changed the path must be changed || also from the children\n            if ($parentId = $request->get('parentId')) {\n                $parentAsset = Asset::getById((int) $parentId);\n\n                //check if parent is changed i.e. asset is moved\n                if ($asset->getParentId() != $parentAsset->getId()) {\n                    if (!$parentAsset->isAllowed('create')) {\n                        throw new \\Exception('Prevented moving asset - no create permission on new parent ');\n                    }\n\n                    $intendedPath = $parentAsset->getRealPath();\n                    $pKey = $parentAsset->getKey();\n                    if (!empty($pKey)) {\n                        $intendedPath .= $parentAsset->getKey() . '/';\n                    }\n\n                    $assetWithSamePath = Asset::getByPath($intendedPath . $asset->getKey());\n\n                    if ($assetWithSamePath != null) {\n                        $allowUpdate = false;\n                    }\n\n                    if ($asset->isLocked()) {\n                        $allowUpdate = false;\n                    }\n                }\n            }\n\n            if ($allowUpdate) {\n                if ($request->get('filename') != $asset->getFilename() && !$asset->isAllowed('rename')) {\n                    unset($updateData['filename']);\n                    Logger::debug('prevented renaming asset because of missing permissions ');\n                }\n\n                $asset->setValues($updateData);\n\n                try {\n                    $asset->save();\n                    $success = true;\n                } catch (\\Exception $e) {\n                    return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n                }\n            } else {\n                $msg = 'prevented moving asset, asset with same path+key already exists at target location or the asset is locked. ID: ' . $asset->getId();\n                Logger::debug($msg);\n\n                return $this->adminJson(['success' => $success, 'message' => $msg]);\n            }\n        } elseif ($asset->isAllowed('rename') && $request->get('filename')) {\n            //just rename\n            try {\n                $asset->setFilename($request->get('filename'));\n                $asset->save();\n                $success = true;\n            } catch (\\Exception $e) {\n                return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n            }\n        } else {\n            Logger::debug('prevented update asset because of missing permissions ');\n        }\n\n        return $this->adminJson(['success' => $success]);\n    }\n\n    /**\n     * @Route(\"/webdav{path}\", name=\"pimcore_admin_webdav\", requirements={\"path\"=\".*\"})\n     */\n    public function webdavAction()\n    {\n        $homeDir = Asset::getById(1);\n\n        try {\n            $publicDir = new Asset\\WebDAV\\Folder($homeDir);\n            $objectTree = new Asset\\WebDAV\\Tree($publicDir);\n            $server = new \\Sabre\\DAV\\Server($objectTree);\n            $server->setBaseUri($this->generateUrl('pimcore_admin_webdav', ['path' => '/']));\n\n            // lock plugin\n            /** @var \\Doctrine\\DBAL\\Driver\\PDOConnection $pdo */\n            $pdo = \\Pimcore\\Db::get()->getWrappedConnection();\n            $lockBackend = new \\Sabre\\DAV\\Locks\\Backend\\PDO($pdo);\n            $lockBackend->tableName = 'webdav_locks';\n\n            $lockPlugin = new \\Sabre\\DAV\\Locks\\Plugin($lockBackend);\n            $server->addPlugin($lockPlugin);\n\n            // browser plugin\n            $server->addPlugin(new \\Sabre\\DAV\\Browser\\Plugin());\n\n            $server->start();\n        } catch (\\Exception $e) {\n            Logger::error((string) $e);\n        }\n\n        exit;\n    }\n\n    /**\n     * @Route(\"/save\", name=\"pimcore_admin_asset_save\", methods={\"PUT\",\"POST\"})\n     *\n     * @param Request $request\n     * @param EventDispatcherInterface $eventDispatcher\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function saveAction(Request $request, EventDispatcherInterface $eventDispatcher)\n    {\n        $asset = Asset::getById((int) $request->get('id'));\n\n        if (!$asset) {\n            throw $this->createNotFoundException('Asset not found');\n        }\n\n        if ($asset->isAllowed('publish')) {\n            // metadata\n            if ($request->get('metadata')) {\n                $metadata = $this->decodeJson($request->get('metadata'));\n\n                $metadataEvent = new GenericEvent($this, [\n                    'id' => $asset->getId(),\n                    'metadata' => $metadata,\n                ]);\n                $eventDispatcher->dispatch($metadataEvent, AdminEvents::ASSET_METADATA_PRE_SET);\n\n                $metadata = $metadataEvent->getArgument('metadata');\n                $metadataValues = $metadata['values'];\n\n                $metadataValues = Asset\\Service::minimizeMetadata($metadataValues, 'editor');\n                $asset->setMetadataRaw($metadataValues);\n            }\n\n            // properties\n            if ($request->get('properties')) {\n                $properties = [];\n                $propertiesData = $this->decodeJson($request->get('properties'));\n\n                if (is_array($propertiesData)) {\n                    foreach ($propertiesData as $propertyName => $propertyData) {\n                        $value = $propertyData['data'];\n\n                        try {\n                            $property = new Model\\Property();\n                            $property->setType($propertyData['type']);\n                            $property->setName($propertyName);\n                            $property->setCtype('asset');\n                            $property->setDataFromEditmode($value);\n                            $property->setInheritable($propertyData['inheritable']);\n\n                            $properties[$propertyName] = $property;\n                        } catch (\\Exception $e) {\n                            Logger::err(\"Can't add \" . $propertyName . ' to asset ' . $asset->getRealFullPath());\n                        }\n                    }\n\n                    $asset->setProperties($properties);\n                }\n            }\n\n            $this->applySchedulerDataToElement($request, $asset);\n\n            if ($request->get('data')) {\n                $asset->setData($request->get('data'));\n            }\n\n            // image specific data\n            if ($asset instanceof Asset\\Image) {\n                if ($request->get('image')) {\n                    $imageData = $this->decodeJson($request->get('image'));\n                    if (isset($imageData['focalPoint'])) {\n                        $asset->setCustomSetting('focalPointX', $imageData['focalPoint']['x']);\n                        $asset->setCustomSetting('focalPointY', $imageData['focalPoint']['y']);\n                        $asset->removeCustomSetting('disableFocalPointDetection');\n                    }\n                } else {\n                    // wipe all data\n                    $asset->removeCustomSetting('focalPointX');\n                    $asset->removeCustomSetting('focalPointY');\n                    $asset->setCustomSetting('disableFocalPointDetection', true);\n                }\n            }\n\n            $asset->setUserModification($this->getAdminUser()->getId());\n            if ($request->get('task') === 'session') {\n                // save to session only\n                Asset\\Service::saveElementToSession($asset);\n            } else {\n                $asset->save();\n            }\n\n            $treeData = $this->getTreeNodeConfig($asset);\n\n            return $this->adminJson([\n                'success' => true,\n                'data' => [\n                    'versionDate' => $asset->getModificationDate(),\n                    'versionCount' => $asset->getVersionCount(),\n                ],\n                'treeData' => $treeData,\n            ]);\n        } else {\n            throw $this->createAccessDeniedHttpException();\n        }\n    }\n\n    /**\n     * @Route(\"/publish-version\", name=\"pimcore_admin_asset_publishversion\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function publishVersionAction(Request $request)\n    {\n        $id = (int)$request->get('id');\n        $version = Model\\Version::getById($id);\n        $asset = $version?->loadData();\n\n        if (!$asset) {\n            throw $this->createNotFoundException('Version with id [' . $id . \"] doesn't exist\");\n        }\n\n        $currentAsset = Asset::getById($asset->getId());\n        if ($currentAsset->isAllowed('publish')) {\n            try {\n                $asset->setUserModification($this->getAdminUser()->getId());\n                $asset->save();\n\n                $treeData = $this->getTreeNodeConfig($asset);\n\n                return $this->adminJson(['success' => true, 'treeData' => $treeData]);\n            } catch (\\Exception $e) {\n                return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n            }\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @Route(\"/show-version\", name=\"pimcore_admin_asset_showversion\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function showVersionAction(Request $request)\n    {\n        $id = (int)$request->get('id');\n        $version = Model\\Version::getById($id);\n        $asset = $version?->loadData();\n        if (!$asset) {\n            throw $this->createNotFoundException('Version with id [' . $id . \"] doesn't exist\");\n        }\n\n        if (!$asset->isAllowed('versions')) {\n            throw $this->createAccessDeniedHttpException('Permission denied, version id [' . $id . ']');\n        }\n\n        $loader = \\Pimcore::getContainer()->get('pimcore.implementation_loader.asset.metadata.data');\n\n        return $this->render(\n            '@PimcoreAdmin/Admin/Asset/showVersion' . ucfirst($asset->getType()) . '.html.twig',\n            [\n                'asset' => $asset,\n                'loader' => $loader,\n            ]\n        );\n    }\n\n    /**\n     * @Route(\"/download\", name=\"pimcore_admin_asset_download\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return StreamedResponse\n     */\n    public function downloadAction(Request $request)\n    {\n        $asset = Asset::getById((int) $request->get('id'));\n\n        if (!$asset) {\n            throw $this->createNotFoundException('Asset not found');\n        }\n\n        if (!$asset->isAllowed('view')) {\n            throw $this->createAccessDeniedException('not allowed to view asset');\n        }\n\n        $stream = $asset->getStream();\n\n        if (!is_resource($stream)) {\n            throw $this->createNotFoundException('Unable to get resource for asset ' . $asset->getId());\n        }\n\n        return new StreamedResponse(function () use ($stream) {\n            fpassthru($stream);\n        }, 200, [\n            'Content-Type' => $asset->getMimeType(),\n            'Content-Disposition' => sprintf('attachment; filename=\"%s\"', $asset->getFilename()),\n            'Content-Length' => $asset->getFileSize(),\n        ]);\n    }\n\n    /**\n     * @Route(\"/download-image-thumbnail\", name=\"pimcore_admin_asset_downloadimagethumbnail\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return BinaryFileResponse\n     */\n    public function downloadImageThumbnailAction(Request $request)\n    {\n        $image = Asset\\Image::getById((int) $request->get('id'));\n\n        if (!$image) {\n            throw $this->createNotFoundException('Asset not found');\n        }\n\n        if (!$image->isAllowed('view')) {\n            throw $this->createAccessDeniedException('not allowed to view thumbnail');\n        }\n\n        $config = null;\n        $thumbnail = null;\n        $thumbnailName = $request->get('thumbnail');\n        $thumbnailFile = null;\n        $deleteThumbnail = true;\n\n        if ($request->get('config')) {\n            $config = $this->decodeJson($request->get('config'));\n        } elseif ($request->get('type')) {\n            $predefined = [\n                'web' => [\n                    'resize_mode' => 'scaleByWidth',\n                    'width' => 3500,\n                    'dpi' => 72,\n                    'format' => 'JPEG',\n                    'quality' => 85,\n                ],\n                'print' => [\n                    'resize_mode' => 'scaleByWidth',\n                    'width' => 6000,\n                    'dpi' => 300,\n                    'format' => 'JPEG',\n                    'quality' => 95,\n                ],\n                'office' => [\n                    'resize_mode' => 'scaleByWidth',\n                    'width' => 1190,\n                    'dpi' => 144,\n                    'format' => 'JPEG',\n                    'quality' => 90,\n                ],\n            ];\n\n            $config = $predefined[$request->get('type')];\n        } elseif ($thumbnailName) {\n            $thumbnail = $image->getThumbnail($thumbnailName);\n            $deleteThumbnail = false;\n        }\n\n        if ($config) {\n            $thumbnailConfig = new Asset\\Image\\Thumbnail\\Config();\n            $thumbnailConfig->setName('pimcore-download-' . $image->getId() . '-' . md5($request->get('config')));\n\n            if ($config['resize_mode'] == 'scaleByWidth') {\n                $thumbnailConfig->addItem('scaleByWidth', [\n                    'width' => $config['width'],\n                ]);\n            } elseif ($config['resize_mode'] == 'scaleByHeight') {\n                $thumbnailConfig->addItem('scaleByHeight', [\n                    'height' => $config['height'],\n                ]);\n            } else {\n                $thumbnailConfig->addItem('resize', [\n                    'width' => $config['width'],\n                    'height' => $config['height'],\n                ]);\n            }\n\n            $thumbnailConfig->setQuality($config['quality']);\n            $thumbnailConfig->setFormat($config['format']);\n            $thumbnailConfig->setRasterizeSVG(true);\n\n            if ($thumbnailConfig->getFormat() == 'JPEG') {\n                $thumbnailConfig->setPreserveMetaData(true);\n\n                if (empty($config['quality'])) {\n                    $thumbnailConfig->setPreserveColor(true);\n                }\n            }\n\n            $thumbnail = $image->getThumbnail($thumbnailConfig);\n            $thumbnailFile = $thumbnail->getLocalFile();\n\n            $exiftool = \\Pimcore\\Tool\\Console::getExecutable('exiftool');\n            if ($thumbnailConfig->getFormat() == 'JPEG' && $exiftool && isset($config['dpi']) && $config['dpi']) {\n                $process = new Process([$exiftool, '-overwrite_original', '-xresolution=' . (int)$config['dpi'], '-yresolution=' . (int)$config['dpi'], '-resolutionunit=inches', $thumbnailFile]);\n                $process->run();\n            }\n        }\n\n        if ($thumbnail) {\n            $thumbnailFile = $thumbnailFile ?: $thumbnail->getLocalFile();\n\n            $downloadFilename = preg_replace(\n                '/\\.' . preg_quote(File::getFileExtension($image->getFilename())) . '$/i',\n                '.' . $thumbnail->getFileExtension(),\n                $image->getFilename()\n            );\n            $downloadFilename = strtolower($downloadFilename);\n\n            clearstatcache();\n\n            $response = new BinaryFileResponse($thumbnailFile);\n            $response->headers->set('Content-Type', $thumbnail->getMimeType());\n            $response->setContentDisposition(ResponseHeaderBag::DISPOSITION_ATTACHMENT, $downloadFilename);\n            $this->addThumbnailCacheHeaders($response);\n            $response->deleteFileAfterSend($deleteThumbnail);\n\n            return $response;\n        }\n\n        throw $this->createNotFoundException('Thumbnail not found');\n    }\n\n    /**\n     * @Route(\"/get-asset\", name=\"pimcore_admin_asset_getasset\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return StreamedResponse\n     */\n    public function getAssetAction(Request $request)\n    {\n        $image = Asset::getById((int)$request->get('id'));\n\n        if (!$image) {\n            throw $this->createNotFoundException('Asset not found');\n        }\n\n        if (!$image->isAllowed('view')) {\n            throw $this->createAccessDeniedException('not allowed to view asset');\n        }\n\n        $stream = $image->getStream();\n\n        if (!is_resource($stream)) {\n            throw $this->createNotFoundException('Unable to get resource for asset ' . $image->getId());\n        }\n\n        $response = new StreamedResponse(function () use ($stream) {\n            fpassthru($stream);\n        }, 200, [\n            'Content-Type' => $image->getMimeType(),\n            'Access-Control-Allow-Origin' => '*',\n        ]);\n        $this->addThumbnailCacheHeaders($response);\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/get-image-thumbnail\", name=\"pimcore_admin_asset_getimagethumbnail\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return StreamedResponse|JsonResponse|BinaryFileResponse\n     */\n    public function getImageThumbnailAction(Request $request)\n    {\n        $fileinfo = $request->get('fileinfo');\n        $image = Asset\\Image::getById((int)$request->get('id'));\n\n        if (!$image) {\n            throw $this->createNotFoundException('Asset not found');\n        }\n\n        if (!$image->isAllowed('view')) {\n            throw $this->createAccessDeniedException('not allowed to view thumbnail');\n        }\n\n        $thumbnailConfig = null;\n\n        if ($request->get('thumbnail')) {\n            $thumbnailConfig = $image->getThumbnailConfig($request->get('thumbnail'));\n        }\n        if (!$thumbnailConfig) {\n            if ($request->get('config')) {\n                $thumbnailConfig = $image->getThumbnailConfig($this->decodeJson($request->get('config')));\n            } else {\n                $thumbnailConfig = $image->getThumbnailConfig(array_merge($request->request->all(), $request->query->all()));\n            }\n        } else {\n            // no high-res images in admin mode (editmode)\n            // this is mostly because of the document's image editable, which doesn't know anything about the thumbnail\n            // configuration, so the dimensions would be incorrect (double the size)\n            $thumbnailConfig->setHighResolution(1);\n        }\n\n        $format = strtolower($thumbnailConfig->getFormat());\n        if ($format == 'source' || $format == 'print') {\n            $thumbnailConfig->setFormat('PNG');\n            $thumbnailConfig->setRasterizeSVG(true);\n        }\n\n        if ($request->get('treepreview')) {\n            $thumbnailConfig = Asset\\Image\\Thumbnail\\Config::getPreviewConfig();\n            if ($request->get('origin') === 'treeNode' && !$image->getThumbnail($thumbnailConfig)->exists()) {\n                \\Pimcore::getContainer()->get('messenger.bus.pimcore-core')->dispatch(\n                    new AssetPreviewImageMessage($image->getId())\n                );\n\n                throw $this->createNotFoundException(sprintf('Tree preview thumbnail not available for asset %s', $image->getId()));\n            }\n        }\n\n        $cropPercent = $request->get('cropPercent');\n        if ($cropPercent && filter_var($cropPercent, FILTER_VALIDATE_BOOLEAN)) {\n            $thumbnailConfig->addItemAt(0, 'cropPercent', [\n                'width' => $request->get('cropWidth'),\n                'height' => $request->get('cropHeight'),\n                'y' => $request->get('cropTop'),\n                'x' => $request->get('cropLeft'),\n            ]);\n\n            $hash = md5(Tool\\Serialize::serialize(array_merge($request->request->all(), $request->query->all())));\n            $thumbnailConfig->setName($thumbnailConfig->getName() . '_auto_' . $hash);\n        }\n\n        $thumbnail = $image->getThumbnail($thumbnailConfig);\n\n        if ($fileinfo) {\n            return $this->adminJson([\n                'width' => $thumbnail->getWidth(),\n                'height' => $thumbnail->getHeight(), ]);\n        }\n\n        $stream = $thumbnail->getStream();\n\n        if (!$stream) {\n            return new BinaryFileResponse(PIMCORE_PATH . '/bundles/AdminBundle/Resources/public/img/filetype-not-supported.svg');\n        }\n\n        $response = new StreamedResponse(function () use ($stream) {\n            fpassthru($stream);\n        }, 200, [\n            'Content-Type' => $thumbnail->getMimeType(),\n            'Access-Control-Allow-Origin', '*',\n        ]);\n\n        $this->addThumbnailCacheHeaders($response);\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/get-folder-thumbnail\", name=\"pimcore_admin_asset_getfolderthumbnail\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return StreamedResponse\n     */\n    public function getFolderThumbnailAction(Request $request)\n    {\n        $folder = null;\n\n        if ($request->get('id')) {\n            $folder = Asset\\Folder::getById((int)$request->get('id'));\n            if ($folder instanceof  Asset\\Folder) {\n                if (!$folder->isAllowed('view')) {\n                    throw $this->createAccessDeniedException('not allowed to view thumbnail');\n                }\n\n                $stream = $folder->getPreviewImage();\n                if (!$stream) {\n                    throw $this->createNotFoundException(sprintf('Tree preview thumbnail not available for asset %s', $folder->getId()));\n                } else {\n                    $response = new StreamedResponse(function () use ($stream) {\n                        fpassthru($stream);\n                    }, 200, [\n                        'Content-Type' => 'image/jpg',\n                    ]);\n                }\n\n                $this->addThumbnailCacheHeaders($response);\n\n                return $response;\n            }\n        }\n\n        throw $this->createNotFoundException('could not load asset folder');\n    }\n\n    /**\n     * @Route(\"/get-video-thumbnail\", name=\"pimcore_admin_asset_getvideothumbnail\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return StreamedResponse\n     */\n    public function getVideoThumbnailAction(Request $request)\n    {\n        $video = null;\n\n        if ($request->get('id')) {\n            $video = Asset\\Video::getById((int)$request->get('id'));\n        } elseif ($request->get('path')) {\n            $video = Asset\\Video::getByPath($request->get('path'));\n        }\n\n        if (!$video) {\n            throw $this->createNotFoundException('could not load video asset');\n        }\n\n        if (!$video->isAllowed('view')) {\n            throw $this->createAccessDeniedException('not allowed to view thumbnail');\n        }\n\n        $thumbnail = array_merge($request->request->all(), $request->query->all());\n\n        if ($request->get('treepreview')) {\n            $thumbnail = Asset\\Image\\Thumbnail\\Config::getPreviewConfig();\n        }\n\n        $time = null;\n        if (is_numeric($request->get('time'))) {\n            $time = (int)$request->get('time');\n        }\n\n        if ($request->get('settime')) {\n            $video->removeCustomSetting('image_thumbnail_asset');\n            $video->setCustomSetting('image_thumbnail_time', $time);\n            $video->save();\n        }\n\n        $image = null;\n        if ($request->get('image')) {\n            $image = Asset\\Image::getById((int)$request->get('image'));\n        }\n\n        if ($request->get('setimage') && $image) {\n            $video->removeCustomSetting('image_thumbnail_time');\n            $video->setCustomSetting('image_thumbnail_asset', $image->getId());\n            $video->save();\n        }\n\n        $thumb = $video->getImageThumbnail($thumbnail, $time, $image);\n\n        if ($request->get('origin') === 'treeNode' && !$thumb->exists()) {\n            \\Pimcore::getContainer()->get('messenger.bus.pimcore-core')->dispatch(\n                new AssetPreviewImageMessage($video->getId())\n            );\n\n            throw $this->createNotFoundException(sprintf('Tree preview thumbnail not available for asset %s', $video->getId()));\n        }\n\n        $stream = $thumb->getStream();\n        if (!$stream) {\n            throw $this->createNotFoundException('Unable to get video thumbnail for video ' . $video->getId());\n        }\n\n        $response = new StreamedResponse(function () use ($stream) {\n            fpassthru($stream);\n        }, 200, [\n            'Content-Type' => 'image/' . $thumb->getFileExtension(),\n        ]);\n\n        $this->addThumbnailCacheHeaders($response);\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/get-document-thumbnail\", name=\"pimcore_admin_asset_getdocumentthumbnail\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return StreamedResponse|BinaryFileResponse\n     */\n    public function getDocumentThumbnailAction(Request $request)\n    {\n        $document = Asset\\Document::getById((int)$request->get('id'));\n\n        if (!$document) {\n            throw $this->createNotFoundException('could not load document asset');\n        }\n\n        if (!$document->isAllowed('view')) {\n            throw $this->createAccessDeniedException('not allowed to view thumbnail');\n        }\n\n        $thumbnail = Asset\\Image\\Thumbnail\\Config::getByAutoDetect(array_merge($request->request->all(), $request->query->all()));\n\n        $format = strtolower($thumbnail->getFormat());\n        if ($format == 'source') {\n            $thumbnail->setFormat('jpeg'); // default format for documents is JPEG not PNG (=too big)\n        }\n\n        if ($request->get('treepreview')) {\n            $thumbnail = Asset\\Image\\Thumbnail\\Config::getPreviewConfig();\n        }\n\n        $page = 1;\n        if (is_numeric($request->get('page'))) {\n            $page = (int)$request->get('page');\n        }\n\n        $thumb = $document->getImageThumbnail($thumbnail, $page);\n\n        if ($request->get('origin') === 'treeNode' && !$thumb->exists()) {\n            \\Pimcore::getContainer()->get('messenger.bus.pimcore-core')->dispatch(\n                new AssetPreviewImageMessage($document->getId())\n            );\n\n            throw $this->createNotFoundException(sprintf('Tree preview thumbnail not available for asset %s', $document->getId()));\n        }\n\n        $stream = $thumb->getStream();\n        if ($stream) {\n            $response = new StreamedResponse(function () use ($stream) {\n                fpassthru($stream);\n            }, 200, [\n                'Content-Type' => 'image/' . $thumb->getFileExtension(),\n            ]);\n        } else {\n            $response = new BinaryFileResponse(PIMCORE_PATH . '/bundles/AdminBundle/Resources/public/img/filetype-not-supported.svg');\n        }\n\n        $this->addThumbnailCacheHeaders($response);\n\n        return $response;\n    }\n\n    /**\n     * @param Response $response\n     */\n    protected function addThumbnailCacheHeaders(Response $response)\n    {\n        $lifetime = 300;\n        $date = new \\DateTime('now');\n        $date->add(new \\DateInterval('PT' . $lifetime . 'S'));\n\n        $response->setMaxAge($lifetime);\n        $response->setPublic();\n        $response->setExpires($date);\n        $response->headers->set('Pragma', '');\n    }\n\n    /**\n     * @Route(\"/get-preview-document\", name=\"pimcore_admin_asset_getpreviewdocument\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return StreamedResponse\n     */\n    public function getPreviewDocumentAction(Request $request)\n    {\n        $asset = Asset\\Document::getById((int) $request->get('id'));\n\n        if (!$asset) {\n            throw $this->createNotFoundException('could not load document asset');\n        }\n\n        if ($asset->isAllowed('view')) {\n            $stream = $this->getDocumentPreviewPdf($asset);\n            if ($stream) {\n                return new StreamedResponse(function () use ($stream) {\n                    fpassthru($stream);\n                }, 200, [\n                    'Content-Type' => 'application/pdf',\n                ]);\n            } else {\n                throw $this->createNotFoundException('Unable to get preview for asset ' . $asset->getId());\n            }\n        } else {\n            throw $this->createAccessDeniedException('Access to asset ' . $asset->getId() . ' denied');\n        }\n    }\n\n    /**\n     * @param Asset\\Document $asset\n     *\n     * @return resource|null\n     */\n    protected function getDocumentPreviewPdf(Asset\\Document $asset)\n    {\n        $stream = null;\n\n        if ($asset->getMimeType() == 'application/pdf') {\n            $stream = $asset->getStream();\n        }\n\n        if (!$stream && $asset->getPageCount() && \\Pimcore\\Document::isAvailable() && \\Pimcore\\Document::isFileTypeSupported($asset->getFilename())) {\n            try {\n                $document = \\Pimcore\\Document::getInstance();\n                $stream = $document->getPdf($asset);\n            } catch (\\Exception $e) {\n                // nothing to do\n            }\n        }\n\n        return $stream;\n    }\n\n    /**\n     * @Route(\"/get-preview-video\", name=\"pimcore_admin_asset_getpreviewvideo\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function getPreviewVideoAction(Request $request)\n    {\n        $asset = Asset\\Video::getById((int) $request->get('id'));\n\n        if (!$asset) {\n            throw $this->createNotFoundException('could not load video asset');\n        }\n\n        if (!$asset->isAllowed('view')) {\n            throw $this->createAccessDeniedException('not allowed to preview');\n        }\n\n        $previewData = ['asset' => $asset];\n        $config = Asset\\Video\\Thumbnail\\Config::getPreviewConfig();\n        $thumbnail = $asset->getThumbnail($config, ['mp4']);\n\n        if ($thumbnail) {\n            $previewData['asset'] = $asset;\n            $previewData['thumbnail'] = $thumbnail;\n\n            if ($thumbnail['status'] == 'finished') {\n                return $this->render(\n                    '@PimcoreAdmin/Admin/Asset/getPreviewVideoDisplay.html.twig',\n                    $previewData\n                );\n            } else {\n                return $this->render(\n                    '@PimcoreAdmin/Admin/Asset/getPreviewVideoError.html.twig',\n                    $previewData\n                );\n            }\n        } else {\n            return $this->render(\n                '@PimcoreAdmin/Admin/Asset/getPreviewVideoError.html.twig',\n                $previewData\n            );\n        }\n    }\n\n    /**\n     * @Route(\"/serve-video-preview\", name=\"pimcore_admin_asset_servevideopreview\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return StreamedResponse\n     */\n    public function serveVideoPreviewAction(Request $request)\n    {\n        $asset = Asset\\Video::getById((int) $request->get('id'));\n\n        if (!$asset) {\n            throw $this->createNotFoundException('could not load video asset');\n        }\n\n        if (!$asset->isAllowed('view')) {\n            throw $this->createAccessDeniedException('not allowed to preview');\n        }\n\n        $config = Asset\\Video\\Thumbnail\\Config::getPreviewConfig();\n        $thumbnail = $asset->getThumbnail($config, ['mp4']);\n        $storagePath = $asset->getRealPath() . '/' . preg_replace('@^' . preg_quote($asset->getPath(), '@') . '@', '', urldecode($thumbnail['formats']['mp4']));\n\n        $storage = Tool\\Storage::get('thumbnail');\n        if ($storage->fileExists($storagePath)) {\n            $fs = $storage->fileSize($storagePath);\n            $stream = $storage->readStream($storagePath);\n\n            return new StreamedResponse(function () use ($stream) {\n                fpassthru($stream);\n            }, 200, [\n                'Content-Type' => 'video/mp4',\n                'Content-Length' => $fs,\n                'Accept-Ranges' => 'bytes',\n            ]);\n        } else {\n            throw $this->createNotFoundException('Video thumbnail not found');\n        }\n    }\n\n    /**\n     * @Route(\"/image-editor\", name=\"pimcore_admin_asset_imageeditor\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function imageEditorAction(Request $request)\n    {\n        $asset = Asset::getById((int) $request->get('id'));\n\n        if (!$asset->isAllowed('view')) {\n            throw $this->createAccessDeniedException('Not allowed to preview');\n        }\n\n        return $this->render(\n            '@PimcoreAdmin/Admin/Asset/imageEditor.html.twig',\n            ['asset' => $asset]\n        );\n    }\n\n    /**\n     * @Route(\"/image-editor-save\", name=\"pimcore_admin_asset_imageeditorsave\", methods={\"PUT\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function imageEditorSaveAction(Request $request)\n    {\n        $asset = Asset::getById((int) $request->get('id'));\n\n        if (!$asset) {\n            throw $this->createNotFoundException('Asset not found');\n        }\n\n        if (!$asset->isAllowed('publish')) {\n            throw $this->createAccessDeniedException('not allowed to publish');\n        }\n\n        $data = $request->get('dataUri');\n        $data = substr($data, strpos($data, ','));\n        $data = base64_decode($data);\n        $asset->setData($data);\n        $asset->setUserModification($this->getAdminUser()->getId());\n        $asset->save();\n\n        return $this->adminJson(['success' => true]);\n    }\n\n    /**\n     * @Route(\"/get-folder-content-preview\", name=\"pimcore_admin_asset_getfoldercontentpreview\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getFolderContentPreviewAction(Request $request, EventDispatcherInterface $eventDispatcher)\n    {\n        $allParams = array_merge($request->request->all(), $request->query->all());\n\n        $filterPrepareEvent = new GenericEvent($this, [\n            'requestParams' => $allParams,\n        ]);\n        $eventDispatcher->dispatch($filterPrepareEvent, AdminEvents::ASSET_LIST_BEFORE_FILTER_PREPARE);\n\n        $allParams = $filterPrepareEvent->getArgument('requestParams');\n\n        $folder = Asset::getById($allParams['id']);\n\n        $start = 0;\n        $limit = 10;\n\n        if ($allParams['limit']) {\n            $limit = $allParams['limit'];\n        }\n        if ($allParams['start']) {\n            $start = $allParams['start'];\n        }\n\n        $conditionFilters = [];\n        $list = new Asset\\Listing();\n        $conditionFilters[] = 'path LIKE ' . ($folder->getRealFullPath() == '/' ? \"'/%'\" : $list->quote(Helper::escapeLike($folder->getRealFullPath()) . '/%')) . \" AND type != 'folder'\";\n\n        if (!$this->getAdminUser()->isAdmin()) {\n            $userIds = $this->getAdminUser()->getRoles();\n            $userIds[] = $this->getAdminUser()->getId();\n            $conditionFilters[] = ' (\n                                                    (select list from users_workspaces_asset where userId in (' . implode(',', $userIds) . ') and LOCATE(CONCAT(path, filename),cpath)=1  ORDER BY LENGTH(cpath) DESC LIMIT 1)=1\n                                                    OR\n                                                    (select list from users_workspaces_asset where userId in (' . implode(',', $userIds) . ') and LOCATE(cpath,CONCAT(path, filename))=1  ORDER BY LENGTH(cpath) DESC LIMIT 1)=1\n                                                 )';\n        }\n\n        $condition = implode(' AND ', $conditionFilters);\n\n        $list->setCondition($condition);\n        $list->setLimit($limit);\n        $list->setOffset($start);\n        $list->setOrderKey('CAST(filename AS CHAR CHARACTER SET utf8) COLLATE utf8_general_ci ASC', false);\n\n        $beforeListLoadEvent = new GenericEvent($this, [\n            'list' => $list,\n            'context' => $allParams,\n        ]);\n        $eventDispatcher->dispatch($beforeListLoadEvent, AdminEvents::ASSET_LIST_BEFORE_LIST_LOAD);\n        /** @var Asset\\Listing $list */\n        $list = $beforeListLoadEvent->getArgument('list');\n\n        $list->load();\n\n        $assets = [];\n\n        foreach ($list as $asset) {\n            $filenameDisplay = $asset->getFilename();\n            if (strlen($filenameDisplay) > 32) {\n                $filenameDisplay = substr($filenameDisplay, 0, 25) . '...' . \\Pimcore\\File::getFileExtension($filenameDisplay);\n            }\n\n            // Like for treeGetChildsByIdAction, so we respect isAllowed method which can be extended (object DI) for custom permissions, so relying only users_workspaces_asset is insufficient and could lead security breach\n            if ($asset->isAllowed('list')) {\n                $assets[] = [\n                    'id' => $asset->getId(),\n                    'type' => $asset->getType(),\n                    'filename' => $asset->getFilename(),\n                    'filenameDisplay' => htmlspecialchars($filenameDisplay),\n                    'url' => $this->getThumbnailUrl($asset),\n                    'idPath' => $data['idPath'] = Element\\Service::getIdPath($asset),\n                ];\n            }\n        }\n\n        // We need to temporary use data key to be compatible with the ASSET_LIST_AFTER_LIST_LOAD global event\n        $result = ['data' => $assets, 'success' => true, 'total' => $list->getTotalCount()];\n\n        $afterListLoadEvent = new GenericEvent($this, [\n            'list' => $result,\n            'context' => $allParams,\n        ]);\n        $eventDispatcher->dispatch($afterListLoadEvent, AdminEvents::ASSET_LIST_AFTER_LIST_LOAD);\n        $result = $afterListLoadEvent->getArgument('list');\n\n        // Here we revert to assets key\n        return $this->adminJson(['assets' => $result['data'], 'success' => $result['success'], 'total' => $result['total']]);\n    }\n\n    /**\n     * @Route(\"/copy-info\", name=\"pimcore_admin_asset_copyinfo\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function copyInfoAction(Request $request)\n    {\n        $transactionId = time();\n        $pasteJobs = [];\n\n        Tool\\Session::useSession(function (AttributeBagInterface $session) use ($transactionId) {\n            $session->set((string) $transactionId, []);\n        }, 'pimcore_copy');\n\n        if ($request->get('type') == 'recursive') {\n            $asset = Asset::getById((int) $request->get('sourceId'));\n\n            if (!$asset) {\n                throw $this->createNotFoundException('Source not found');\n            }\n\n            // first of all the new parent\n            $pasteJobs[] = [[\n                'url' => $this->generateUrl('pimcore_admin_asset_copy'),\n                'method' => 'POST',\n                'params' => [\n                    'sourceId' => $request->get('sourceId'),\n                    'targetId' => $request->get('targetId'),\n                    'type' => 'child',\n                    'transactionId' => $transactionId,\n                    'saveParentId' => true,\n                ],\n            ]];\n\n            if ($asset->hasChildren()) {\n                // get amount of children\n                $list = new Asset\\Listing();\n                $list->setCondition('path LIKE ?', [$list->escapeLike($asset->getRealFullPath()) . '/%']);\n                $list->setOrderKey('LENGTH(path)', false);\n                $list->setOrder('ASC');\n                $childIds = $list->loadIdList();\n\n                if (count($childIds) > 0) {\n                    foreach ($childIds as $id) {\n                        $pasteJobs[] = [[\n                            'url' => $this->generateUrl('pimcore_admin_asset_copy'),\n                            'method' => 'POST',\n                            'params' => [\n                                'sourceId' => $id,\n                                'targetParentId' => $request->get('targetId'),\n                                'sourceParentId' => $request->get('sourceId'),\n                                'type' => 'child',\n                                'transactionId' => $transactionId,\n                            ],\n                        ]];\n                    }\n                }\n            }\n        } elseif ($request->get('type') == 'child' || $request->get('type') == 'replace') {\n            // the object itself is the last one\n            $pasteJobs[] = [[\n                'url' => $this->generateUrl('pimcore_admin_asset_copy'),\n                'method' => 'POST',\n                'params' => [\n                    'sourceId' => $request->get('sourceId'),\n                    'targetId' => $request->get('targetId'),\n                    'type' => $request->get('type'),\n                    'transactionId' => $transactionId,\n                ],\n            ]];\n        }\n\n        return $this->adminJson([\n            'pastejobs' => $pasteJobs,\n        ]);\n    }\n\n    /**\n     * @Route(\"/copy\", name=\"pimcore_admin_asset_copy\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function copyAction(Request $request)\n    {\n        $success = false;\n        $sourceId = (int)$request->get('sourceId');\n        $source = Asset::getById($sourceId);\n\n        $session = Tool\\Session::get('pimcore_copy');\n        $sessionBag = $session->get($request->get('transactionId'));\n\n        $targetId = (int)$request->get('targetId');\n        if ($request->get('targetParentId')) {\n            $sourceParent = Asset::getById((int) $request->get('sourceParentId'));\n\n            // this is because the key can get the prefix \"_copy\" if the target does already exists\n            if ($sessionBag['parentId']) {\n                $targetParent = Asset::getById($sessionBag['parentId']);\n            } else {\n                $targetParent = Asset::getById((int) $request->get('targetParentId'));\n            }\n\n            $targetPath = preg_replace('@^' . $sourceParent->getRealFullPath() . '@', $targetParent . '/', $source->getRealPath());\n            $target = Asset::getByPath($targetPath);\n        } else {\n            $target = Asset::getById($targetId);\n        }\n\n        if (!$target) {\n            throw $this->createNotFoundException('Target not found');\n        }\n\n        if ($target->isAllowed('create')) {\n            $source = Asset::getById($sourceId);\n            if ($source != null) {\n                if ($request->get('type') == 'child') {\n                    $newAsset = $this->_assetService->copyAsChild($target, $source);\n\n                    // this is because the key can get the prefix \"_copy\" if the target does already exists\n                    if ($request->get('saveParentId')) {\n                        $sessionBag['parentId'] = $newAsset->getId();\n                    }\n                } elseif ($request->get('type') == 'replace') {\n                    $this->_assetService->copyContents($target, $source);\n                }\n\n                $session->set($request->get('transactionId'), $sessionBag);\n                Tool\\Session::writeClose();\n\n                $success = true;\n            } else {\n                Logger::debug('prevended copy/paste because asset with same path+key already exists in this location');\n            }\n        } else {\n            Logger::error('could not execute copy/paste because of missing permissions on target [ ' . $targetId . ' ]');\n\n            throw $this->createAccessDeniedHttpException();\n        }\n\n        Tool\\Session::writeClose();\n\n        return $this->adminJson(['success' => $success]);\n    }\n\n    /**\n     * @Route(\"/download-as-zip-jobs\", name=\"pimcore_admin_asset_downloadaszipjobs\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function downloadAsZipJobsAction(Request $request)\n    {\n        $jobId = uniqid();\n        $filesPerJob = 5;\n        $jobs = [];\n        $asset = Asset::getById((int) $request->get('id'));\n\n        if (!$asset) {\n            throw $this->createNotFoundException('Asset not found');\n        }\n\n        if ($asset->isAllowed('view')) {\n            $parentPath = $asset->getRealFullPath();\n            if ($asset->getId() == 1) {\n                $parentPath = '';\n            }\n\n            $db = \\Pimcore\\Db::get();\n            $conditionFilters = [];\n            $selectedIds = explode(',', $request->get('selectedIds', ''));\n            $quotedSelectedIds = [];\n            foreach ($selectedIds as $selectedId) {\n                if ($selectedId) {\n                    $quotedSelectedIds[] = $db->quote($selectedId);\n                }\n            }\n            if (!empty($quotedSelectedIds)) {\n                //add a condition if id numbers are specified\n                $conditionFilters[] = 'id IN (' . implode(',', $quotedSelectedIds) . ')';\n            }\n            $conditionFilters[] = 'path LIKE ' . $db->quote(Helper::escapeLike($parentPath) . '/%') . ' AND type != ' . $db->quote('folder');\n            if (!$this->getAdminUser()->isAdmin()) {\n                $userIds = $this->getAdminUser()->getRoles();\n                $userIds[] = $this->getAdminUser()->getId();\n                $conditionFilters[] = ' (\n                                                    (select list from users_workspaces_asset where userId in (' . implode(',', $userIds) . ') and LOCATE(CONCAT(path, filename),cpath)=1  ORDER BY LENGTH(cpath) DESC LIMIT 1)=1\n                                                    OR\n                                                    (select list from users_workspaces_asset where userId in (' . implode(',', $userIds) . ') and LOCATE(cpath,CONCAT(path, filename))=1  ORDER BY LENGTH(cpath) DESC LIMIT 1)=1\n                                                 )';\n            }\n\n            $condition = implode(' AND ', $conditionFilters);\n\n            $assetList = new Asset\\Listing();\n            $assetList->setCondition($condition);\n            $assetList->setOrderKey('LENGTH(path)', false);\n            $assetList->setOrder('ASC');\n\n            for ($i = 0; $i < ceil($assetList->getTotalCount() / $filesPerJob); $i++) {\n                $jobs[] = [[\n                    'url' => $this->generateUrl('pimcore_admin_asset_downloadaszipaddfiles'),\n                    'method' => 'GET',\n                    'params' => [\n                        'id' => $asset->getId(),\n                        'selectedIds' => implode(',', $selectedIds),\n                        'offset' => $i * $filesPerJob,\n                        'limit' => $filesPerJob,\n                        'jobId' => $jobId,\n                    ],\n                ]];\n            }\n        }\n\n        return $this->adminJson([\n            'success' => true,\n            'jobs' => $jobs,\n            'jobId' => $jobId,\n        ]);\n    }\n\n    /**\n     * @Route(\"/download-as-zip-add-files\", name=\"pimcore_admin_asset_downloadaszipaddfiles\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function downloadAsZipAddFilesAction(Request $request)\n    {\n        $zipFile = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/download-zip-' . $request->get('jobId') . '.zip';\n        $asset = Asset::getById((int) $request->get('id'));\n        $success = false;\n\n        if (!$asset) {\n            throw $this->createNotFoundException('Asset not found');\n        }\n\n        if ($asset->isAllowed('view')) {\n            $zip = new \\ZipArchive();\n            if (!is_file($zipFile)) {\n                $zipState = $zip->open($zipFile, \\ZipArchive::CREATE);\n            } else {\n                $zipState = $zip->open($zipFile);\n            }\n\n            if ($zipState === true) {\n                $parentPath = $asset->getRealFullPath();\n                if ($asset->getId() == 1) {\n                    $parentPath = '';\n                }\n\n                $db = \\Pimcore\\Db::get();\n                $conditionFilters = [];\n\n                $selectedIds = $request->get('selectedIds', []);\n\n                if (!empty($selectedIds)) {\n                    $selectedIds = explode(',', $selectedIds);\n                    //add a condition if id numbers are specified\n                    $conditionFilters[] = 'id IN (' . implode(',', $selectedIds) . ')';\n                }\n                $conditionFilters[] = \"type != 'folder' AND path LIKE \" . $db->quote(Helper::escapeLike($parentPath) . '/%');\n                if (!$this->getAdminUser()->isAdmin()) {\n                    $userIds = $this->getAdminUser()->getRoles();\n                    $userIds[] = $this->getAdminUser()->getId();\n                    $conditionFilters[] = ' (\n                                                    (select list from users_workspaces_asset where userId in (' . implode(',', $userIds) . ') and LOCATE(CONCAT(path, filename),cpath)=1  ORDER BY LENGTH(cpath) DESC LIMIT 1)=1\n                                                    OR\n                                                    (select list from users_workspaces_asset where userId in (' . implode(',', $userIds) . ') and LOCATE(cpath,CONCAT(path, filename))=1  ORDER BY LENGTH(cpath) DESC LIMIT 1)=1\n                                                 )';\n                }\n\n                $condition = implode(' AND ', $conditionFilters);\n\n                $assetList = new Asset\\Listing();\n                $assetList->setCondition($condition);\n                $assetList->setOrderKey('LENGTH(path) ASC, id ASC', false);\n                $assetList->setOffset((int)$request->get('offset'));\n                $assetList->setLimit((int)$request->get('limit'));\n\n                foreach ($assetList as $a) {\n                    if ($a->isAllowed('view')) {\n                        if (!$a instanceof Asset\\Folder) {\n                            // add the file with the relative path to the parent directory\n                            $zip->addFile($a->getLocalFile(), preg_replace('@^' . preg_quote($asset->getRealPath(), '@') . '@i', '', $a->getRealFullPath()));\n                        }\n                    }\n                }\n\n                $zip->close();\n                $success = true;\n            }\n        }\n\n        return $this->adminJson([\n            'success' => $success,\n        ]);\n    }\n\n    /**\n     * @Route(\"/download-as-zip\", name=\"pimcore_admin_asset_downloadaszip\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return BinaryFileResponse\n     * Download all assets contained in the folder with parameter id as ZIP file.\n     * The suggested filename is either [folder name].zip or assets.zip for the root folder.\n     */\n    public function downloadAsZipAction(Request $request)\n    {\n        $asset = Asset::getById((int) $request->get('id'));\n        if (!$asset) {\n            throw $this->createNotFoundException('Asset not found');\n        }\n        $zipFile = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/download-zip-' . $request->get('jobId') . '.zip';\n        $suggestedFilename = $asset->getFilename();\n        if (empty($suggestedFilename)) {\n            $suggestedFilename = 'assets';\n        }\n\n        $response = new BinaryFileResponse($zipFile);\n        $response->headers->set('Content-Type', 'application/zip');\n        $response->setContentDisposition(ResponseHeaderBag::DISPOSITION_ATTACHMENT, $suggestedFilename . '.zip');\n        $response->deleteFileAfterSend(true);\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/import-zip\", name=\"pimcore_admin_asset_importzip\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function importZipAction(Request $request)\n    {\n        $jobId = uniqid();\n        $filesPerJob = 5;\n        $jobs = [];\n        $asset = Asset::getById((int) $request->get('parentId'));\n\n        if (!is_file($_FILES['Filedata']['tmp_name'])) {\n            return $this->adminJson([\n                'success' => false,\n                'message' => 'Something went wrong, please check upload_max_filesize and post_max_size in your php.ini as well as the write permissions on the file system',\n            ]);\n        }\n\n        if (!$asset) {\n            throw $this->createNotFoundException('Parent asset not found');\n        }\n\n        if (!$asset->isAllowed('create')) {\n            throw $this->createAccessDeniedException('not allowed to create');\n        }\n\n        $zipFile = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/' . $jobId . '.zip';\n\n        copy($_FILES['Filedata']['tmp_name'], $zipFile);\n\n        $zip = new \\ZipArchive;\n        $retCode = $zip->open($zipFile);\n        if ($retCode === true) {\n            $jobAmount = ceil($zip->numFiles / $filesPerJob);\n            for ($i = 0; $i < $jobAmount; $i++) {\n                $jobs[] = [[\n                    'url' => $this->generateUrl('pimcore_admin_asset_importzipfiles'),\n                    'method' => 'POST',\n                    'params' => [\n                        'parentId' => $asset->getId(),\n                        'offset' => $i * $filesPerJob,\n                        'limit' => $filesPerJob,\n                        'jobId' => $jobId,\n                        'last' => (($i + 1) >= $jobAmount) ? 'true' : '',\n                    ],\n                ]];\n            }\n            $zip->close();\n\n            // here we have to use this method and not the JSON action helper ($this->_helper->json()) because this will add\n            // Content-Type: application/json which fires a download window in most browsers, because this is a normal POST\n            // request and not XHR where the content-type doesn't matter\n            $responseJson = $this->encodeJson([\n                'success' => true,\n                'jobs' => $jobs,\n                'jobId' => $jobId,\n            ]);\n\n            return new Response($responseJson);\n        } else {\n            return $this->adminJson([\n                'success' => false,\n                'message' => $this->trans('could_not_open_zip_file'),\n            ]);\n        }\n    }\n\n    /**\n     * @Route(\"/import-zip-files\", name=\"pimcore_admin_asset_importzipfiles\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function importZipFilesAction(Request $request)\n    {\n        $jobId = $request->get('jobId');\n        $limit = (int)$request->get('limit');\n        $offset = (int)$request->get('offset');\n        $importAsset = Asset::getById((int) $request->get('parentId'));\n        $zipFile = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/' . $jobId . '.zip';\n        $tmpDir = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/zip-import';\n\n        if (!is_dir($tmpDir)) {\n            File::mkdir($tmpDir, 0777, true);\n        }\n\n        $zip = new \\ZipArchive;\n        if ($zip->open($zipFile) === true) {\n            for ($i = $offset; $i < ($offset + $limit); $i++) {\n                $path = $zip->getNameIndex($i);\n\n                if (str_starts_with($path, '__MACOSX/') || str_ends_with($path, '/Thumbs.db')) {\n                    continue;\n                }\n\n                if ($path !== false) {\n                    if ($zip->extractTo($tmpDir . '/', $path)) {\n                        $tmpFile = $tmpDir . '/' . preg_replace('@^/@', '', $path);\n\n                        $filename = Element\\Service::getValidKey(basename($path), 'asset');\n\n                        $relativePath = '';\n                        if (dirname($path) != '.') {\n                            $relativePath = dirname($path);\n                        }\n\n                        $parentPath = $importAsset->getRealFullPath() . '/' . preg_replace('@^/@', '', $relativePath);\n                        $parent = Asset\\Service::createFolderByPath($parentPath);\n\n                        // check for duplicate filename\n                        $filename = $this->getSafeFilename($parent->getRealFullPath(), $filename);\n\n                        if ($parent->isAllowed('create')) {\n                            $asset = Asset::create($parent->getId(), [\n                                'filename' => $filename,\n                                'sourcePath' => $tmpFile,\n                                'userOwner' => $this->getAdminUser()->getId(),\n                                'userModification' => $this->getAdminUser()->getId(),\n                            ]);\n\n                            @unlink($tmpFile);\n                        } else {\n                            Logger::debug('prevented creating asset because of missing permissions');\n                        }\n                    }\n                }\n            }\n            $zip->close();\n        }\n\n        if ($request->get('last')) {\n            unlink($zipFile);\n        }\n\n        return $this->adminJson([\n            'success' => true,\n        ]);\n    }\n\n    /**\n     * @Route(\"/import-server\", name=\"pimcore_admin_asset_importserver\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function importServerAction(Request $request)\n    {\n        $success = true;\n        $filesPerJob = 5;\n        $jobs = [];\n        $importDirectory = str_replace('/fileexplorer', PIMCORE_PROJECT_ROOT, $request->get('serverPath'));\n        if (preg_match('@^' . preg_quote(PIMCORE_PROJECT_ROOT, '@') . '@', $importDirectory) && is_dir($importDirectory)) {\n            $this->checkForPharStreamWrapper($importDirectory);\n            $files = rscandir($importDirectory . '/');\n            $count = count($files);\n            $jobFiles = [];\n\n            for ($i = 0; $i < $count; $i++) {\n                if (is_dir($files[$i])) {\n                    continue;\n                }\n\n                $jobFiles[] = preg_replace('@^' . preg_quote($importDirectory, '@') . '@', '', $files[$i]);\n\n                if (count($jobFiles) >= $filesPerJob || $i >= ($count - 1)) {\n                    $relativeImportDirectory = preg_replace('@^' . preg_quote(PIMCORE_PROJECT_ROOT, '@') . '@', '', $importDirectory);\n                    $jobs[] = [[\n                        'url' => $this->generateUrl('pimcore_admin_asset_importserverfiles'),\n                        'method' => 'POST',\n                        'params' => [\n                            'parentId' => $request->get('parentId'),\n                            'serverPath' => $relativeImportDirectory,\n                            'files' => implode('::', $jobFiles),\n                        ],\n                    ]];\n                    $jobFiles = [];\n                }\n            }\n        }\n\n        return $this->adminJson([\n            'success' => $success,\n            'jobs' => $jobs,\n        ]);\n    }\n\n    /**\n     * @Route(\"/import-server-files\", name=\"pimcore_admin_asset_importserverfiles\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function importServerFilesAction(Request $request)\n    {\n        $assetFolder = Asset::getById((int) $request->get('parentId'));\n        if (!$assetFolder) {\n            throw $this->createNotFoundException('Parent asset not found');\n        }\n\n        $serverPath = realpath(PIMCORE_PROJECT_ROOT . $request->get('serverPath'));\n        $serverPath = PIMCORE_PROJECT_ROOT . $request->get('serverPath');\n        }\n\n        $files = explode('::', $request->get('files'));\n\n        foreach ($files as $file) {\n            $absolutePath = $serverPath . $file;\n            $this->checkForPharStreamWrapper($absolutePath);\n            if (is_file($absolutePath)) {\n                $relFolderPath = str_replace('\\\\', '/', dirname($file));\n                $folder = Asset\\Service::createFolderByPath($assetFolder->getRealFullPath() . $relFolderPath);\n                $filename = basename($file);\n\n                // check for duplicate filename\n                $filename = Element\\Service::getValidKey($filename, 'asset');\n                $filename = $this->getSafeFilename($folder->getRealFullPath(), $filename);\n\n                if ($assetFolder->isAllowed('create')) {\n                    $asset = Asset::create($folder->getId(), [\n                        'filename' => $filename,\n                        'sourcePath' => $absolutePath,\n                        'userOwner' => $this->getAdminUser()->getId(),\n                        'userModification' => $this->getAdminUser()->getId(),\n                    ]);\n                } else {\n                    Logger::debug('prevented creating asset because of missing permissions ');\n                }\n            }\n        }\n\n        return $this->adminJson([\n            'success' => true,\n        ]);\n    }\n\n    protected function checkForPharStreamWrapper($path)\n    {\n        if (stripos($path, 'phar://') !== false) {\n            throw $this->createAccessDeniedException('Using PHAR files is not allowed!');\n        }\n    }\n\n    /**\n     * @Route(\"/import-url\", name=\"pimcore_admin_asset_importurl\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function importUrlAction(Request $request)\n    {\n        $success = true;\n\n        $data = Tool::getHttpData($request->get('url'));\n        $filename = basename($request->get('url'));\n        $parentId = $request->get('id');\n        $parentAsset = Asset::getById((int)$parentId);\n\n        if (!$parentAsset) {\n            throw $this->createNotFoundException('Parent asset not found');\n        }\n\n        $filename = Element\\Service::getValidKey($filename, 'asset');\n        $filename = $this->getSafeFilename($parentAsset->getRealFullPath(), $filename);\n\n        if (empty($filename)) {\n            throw new \\Exception('The filename of the asset is empty');\n        }\n\n        // check for duplicate filename\n        $filename = $this->getSafeFilename($parentAsset->getRealFullPath(), $filename);\n\n        if ($parentAsset->isAllowed('create')) {\n            $asset = Asset::create($parentId, [\n                'filename' => $filename,\n                'data' => $data,\n                'userOwner' => $this->getAdminUser()->getId(),\n                'userModification' => $this->getAdminUser()->getId(),\n            ]);\n            $success = true;\n        } else {\n            Logger::debug('prevented creating asset because of missing permissions');\n        }\n\n        return $this->adminJson(['success' => $success]);\n    }\n\n    /**\n     * @Route(\"/clear-thumbnail\", name=\"pimcore_admin_asset_clearthumbnail\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function clearThumbnailAction(Request $request)\n    {\n        $success = false;\n\n        if ($asset = Asset::getById((int) $request->get('id'))) {\n            if (method_exists($asset, 'clearThumbnails')) {\n                if (!$asset->isAllowed('publish')) {\n                    throw $this->createAccessDeniedException('not allowed to publish');\n                }\n\n                $asset->clearThumbnails(true); // force clear\n                $asset->save();\n\n                $success = true;\n            }\n        }\n\n        return $this->adminJson(['success' => $success]);\n    }\n\n    /**\n     * @Route(\"/grid-proxy\", name=\"pimcore_admin_asset_gridproxy\", methods={\"GET\", \"POST\", \"PUT\"})\n     *\n     * @param Request $request\n     * @param EventDispatcherInterface $eventDispatcher\n     * @param GridHelperService $gridHelperService\n     * @param CsrfProtectionHandler $csrfProtection\n     *\n     * @return JsonResponse\n     */\n    public function gridProxyAction(Request $request, EventDispatcherInterface $eventDispatcher, GridHelperService $gridHelperService, CsrfProtectionHandler $csrfProtection)\n    {\n        $allParams = array_merge($request->request->all(), $request->query->all());\n\n        $filterPrepareEvent = new GenericEvent($this, [\n            'requestParams' => $allParams,\n        ]);\n        $language = $request->get('language') != 'default' ? $request->get('language') : null;\n\n        $eventDispatcher->dispatch($filterPrepareEvent, AdminEvents::ASSET_LIST_BEFORE_FILTER_PREPARE);\n\n        $allParams = $filterPrepareEvent->getArgument('requestParams');\n\n        $loader = \\Pimcore::getContainer()->get('pimcore.implementation_loader.asset.metadata.data');\n\n        if (isset($allParams['data']) && $allParams['data']) {\n            $csrfProtection->checkCsrfToken($request);\n            if ($allParams['xaction'] == 'update') {\n                try {\n                    $data = $this->decodeJson($allParams['data']);\n\n                    $updateEvent = new GenericEvent($this, [\n                        'data' => $data,\n                        'processed' => false,\n                    ]);\n\n                    $eventDispatcher->dispatch($updateEvent, AdminEvents::ASSET_LIST_BEFORE_UPDATE);\n\n                    $processed = $updateEvent->getArgument('processed');\n\n                    if ($processed) {\n                        // update already processed by event handler\n                        return $this->adminJson(['success' => true]);\n                    }\n\n                    $data = $updateEvent->getArgument('data');\n\n                    // save\n                    $asset = Asset::getById($data['id']);\n\n                    if (!$asset) {\n                        throw $this->createNotFoundException('Asset not found');\n                    }\n\n                    if (!$asset->isAllowed('publish')) {\n                        throw $this->createAccessDeniedException(\"Permission denied. You don't have the rights to save this asset.\");\n                    }\n\n                    $metadata = $asset->getMetadata(null, null, false, true);\n                    $dirty = false;\n\n                    unset($data['id']);\n                    foreach ($data as $key => $value) {\n                        $fieldDef = explode('~', $key);\n                        $key = $fieldDef[0];\n                        if (isset($fieldDef[1])) {\n                            $language = ($fieldDef[1] == 'none' ? '' : $fieldDef[1]);\n                        }\n\n                        foreach ($metadata as $idx => &$em) {\n                            if ($em['name'] == $key && $em['language'] == $language) {\n                                try {\n                                    $dataImpl = $loader->build($em['type']);\n                                    $value = $dataImpl->getDataFromListfolderGrid($value, $em);\n                                } catch (UnsupportedException $le) {\n                                    Logger::error('could not resolve metadata implementation for ' . $em['type']);\n                                }\n\n                                $em['data'] = $value;\n                                $dirty = true;\n\n                                break;\n                            }\n                        }\n\n                        if (!$dirty) {\n                            $defaulMetadata = ['title', 'alt', 'copyright'];\n                            if (in_array($key, $defaulMetadata)) {\n                                $newEm = [\n                                    'name' => $key,\n                                    'language' => $language,\n                                    'type' => 'input',\n                                    'data' => $value,\n                                ];\n\n                                try {\n                                    $dataImpl = $loader->build($newEm['type']);\n                                    $newEm['data'] = $dataImpl->getDataFromListfolderGrid($value, $newEm);\n                                } catch (UnsupportedException $le) {\n                                    Logger::error('could not resolve metadata implementation for ' . $newEm['type']);\n                                }\n\n                                $metadata[] = $newEm;\n\n                                $dirty = true;\n                            } else {\n                                $predefined = Model\\Metadata\\Predefined::getByName($key);\n                                if ($predefined && (empty($predefined->getTargetSubtype())\n                                        || $predefined->getTargetSubtype() == $asset->getType())) {\n                                    $newEm = [\n                                        'name' => $key,\n                                        'language' => $language,\n                                        'type' => $predefined->getType(),\n                                        'data' => $value,\n                                    ];\n\n                                    try {\n                                        $dataImpl = $loader->build($newEm['type']);\n                                        $newEm['data'] = $dataImpl->getDataFromListfolderGrid($value, $newEm);\n                                    } catch (UnsupportedException $le) {\n                                        Logger::error('could not resolve metadata implementation for ' . $newEm['type']);\n                                    }\n\n                                    $metadata[] = $newEm;\n                                    $dirty = true;\n                                }\n                            }\n                        }\n                    }\n\n                    if ($dirty) {\n                        // $metadata = Asset\\Service::minimizeMetadata($metadata, \"grid\");\n                        $asset->setMetadataRaw($metadata);\n                        $asset->save();\n\n                        return $this->adminJson(['success' => true]);\n                    }\n\n                    return $this->adminJson(['success' => false, 'message' => 'something went wrong.']);\n                } catch (\\Exception $e) {\n                    return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n                }\n            }\n        } else {\n            $list = $gridHelperService->prepareAssetListingForGrid($allParams, $this->getAdminUser());\n\n            $beforeListLoadEvent = new GenericEvent($this, [\n                'list' => $list,\n                'context' => $allParams,\n            ]);\n            $eventDispatcher->dispatch($beforeListLoadEvent, AdminEvents::ASSET_LIST_BEFORE_LIST_LOAD);\n            /** @var Asset\\Listing $list */\n            $list = $beforeListLoadEvent->getArgument('list');\n\n            $list->load();\n\n            $assets = [];\n            foreach ($list->getAssets() as $index => $asset) {\n                // Like for treeGetChildsByIdAction, so we respect isAllowed method which can be extended (object DI) for custom permissions, so relying only users_workspaces_asset is insufficient and could lead security breach\n                if ($asset->isAllowed('list')) {\n                    $a = Asset\\Service::gridAssetData($asset, $allParams['fields'], $allParams['language'] ?? '');\n                    $assets[] = $a;\n                }\n            }\n\n            $result = ['data' => $assets, 'success' => true, 'total' => $list->getTotalCount()];\n\n            $afterListLoadEvent = new GenericEvent($this, [\n                'list' => $result,\n                'context' => $allParams,\n            ]);\n            $eventDispatcher->dispatch($afterListLoadEvent, AdminEvents::ASSET_LIST_AFTER_LIST_LOAD);\n            $result = $afterListLoadEvent->getArgument('list');\n\n            return $this->adminJson($result);\n        }\n\n        return $this->adminJson(['success' => false]);\n    }\n\n    /**\n     * @Route(\"/get-text\", name=\"pimcore_admin_asset_gettext\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getTextAction(Request $request)\n    {\n        $asset = Asset::getById((int) $request->get('id'));\n\n        if (!$asset) {\n            throw $this->createNotFoundException('Asset not found');\n        }\n\n        if (!$asset->isAllowed('view')) {\n            throw $this->createAccessDeniedException('not allowed to view');\n        }\n\n        $page = $request->get('page');\n        $text = null;\n        if ($asset instanceof Asset\\Document) {\n            $text = $asset->getText($page);\n        }\n\n        return $this->adminJson(['success' => 'true', 'text' => $text]);\n    }\n\n    /**\n     * @Route(\"/detect-image-features\", name=\"pimcore_admin_asset_detectimagefeatures\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function detectImageFeaturesAction(Request $request)\n    {\n        $asset = Asset\\Image::getById((int)$request->get('id'));\n        if (!$asset instanceof Asset) {\n            return $this->adminJson(['success' => false, 'message' => \"asset doesn't exist\"]);\n        }\n\n        if ($asset->isAllowed('publish')) {\n            $asset->detectFaces();\n            $asset->removeCustomSetting('disableImageFeatureAutoDetection');\n            $asset->save();\n\n            return $this->adminJson(['success' => true]);\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @Route(\"/delete-image-features\", name=\"pimcore_admin_asset_deleteimagefeatures\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function deleteImageFeaturesAction(Request $request)\n    {\n        $asset = Asset::getById((int)$request->get('id'));\n        if (!$asset instanceof Asset) {\n            return $this->adminJson(['success' => false, 'message' => \"asset doesn't exist\"]);\n        }\n\n        if ($asset->isAllowed('publish')) {\n            $asset->removeCustomSetting('faceCoordinates');\n            $asset->setCustomSetting('disableImageFeatureAutoDetection', true);\n            $asset->save();\n\n            return $this->adminJson(['success' => true]);\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @param ControllerEvent $event\n     */\n    public function onKernelControllerEvent(ControllerEvent $event)\n    {\n        if (!$event->isMainRequest()) {\n            return;\n        }\n\n        $this->checkActionPermission($event, 'assets', [\n            'getImageThumbnailAction', 'getVideoThumbnailAction', 'getDocumentThumbnailAction',\n        ]);\n\n        $this->_assetService = new Asset\\Service($this->getAdminUser());\n    }\n\n    /**\n     * @throws ValidationException\n     */\n    private function validateManyToManyRelationAssetType(array $context, string $filename, string $sourcePath): void\n    {\n        if (isset($context['containerType'], $context['objectId'], $context['fieldname'])\n            && 'object' === $context['containerType']\n            && $object = Concrete::getById($context['objectId'])\n        ) {\n            $fieldDefinition = $object->getClass()?->getFieldDefinition($context['fieldname']);\n            if (!$fieldDefinition instanceof ManyToManyRelation) {\n                return;\n            }\n\n            $mimeType = MimeTypes::getDefault()->guessMimeType($sourcePath);\n            $type = Asset::getTypeFromMimeMapping($mimeType, $filename);\n\n            $allowedAssetTypes = $fieldDefinition->getAssetTypes();\n            $allowedAssetTypes = array_column($allowedAssetTypes, 'assetTypes');\n\n            if (\n                !(\n                    $fieldDefinition->getAssetsAllowed()\n                    && ($allowedAssetTypes === [] || in_array($type, $allowedAssetTypes, true))\n                )\n            ) {\n                throw new ValidationException(sprintf('Invalid relation in field `%s` [type: %s]', $context['fieldname'], $type));\n            }\n        }\n    }\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2023-31779", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "const commentReactionSchema = new SimpleSchema({\n  reactionCodepoint: { type: String, optional: false },\n  userIds: { type: [String], defaultValue: [] }\n});\n\nCardCommentReactions = new Mongo.Collection('card_comment_reactions');\n\n/**\n * All reactions of a card comment\n */\nCardCommentReactions.attachSchema(\n  new SimpleSchema({\n    boardId: {\n      /**\n       * the board ID\n       */\n      type: String,\n      optional: false\n    },\n    cardId: {\n      /**\n       * the card ID\n       */\n      type: String,\n      optional: false\n    },\n    cardCommentId: {\n      /**\n       * the card comment ID\n       */\n      type: String,\n      optional: false\n    },\n    reactions: {\n      type: [commentReactionSchema],\n      defaultValue: []\n    }\n  }),\n);\n\nCardCommentReactions.allow({\n  insert(userId, doc) {\n    return allowIsBoardMember(userId, Boards.findOne(doc.boardId));\n  },\n  update(userId, doc) {\n    return allowIsBoardMember(userId, Boards.findOne(doc.boardId));\n  },\n  remove(userId, doc) {\n    return allowIsBoardMember(userId, Boards.findOne(doc.boardId));\n  },\n  fetch: ['boardId'],\n});\n\n\nif (Meteor.isServer) {\n  Meteor.startup(() => {\n    CardCommentReactions._collection.createIndex({ cardCommentId: 1 }, { unique: true });\n  });\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2023-32071", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "## ---------------------------------------------------------------------------\n## See the NOTICE file distributed with this work for additional\n## information regarding copyright ownership.\n##\n## This is free software; you can redistribute it and/or modify it\n## under the terms of the GNU Lesser General Public License as\n## published by the Free Software Foundation; either version 2.1 of\n## the License, or (at your option) any later version.\n##\n## This software is distributed in the hope that it will be useful,\n## but WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n## Lesser General Public License for more details.\n##\n## You should have received a copy of the GNU Lesser General Public\n## License along with this software; if not, write to the Free\n## Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n## 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n## ---------------------------------------------------------------------------\n## ---------------------------------------------------------------------------\n## If the Document to which XARs will be attached to doesn't exist, then\n## create it.\n## Note that the upload action could automatically create it but we want to\n## control the creation so that we can set the parent and thus not make it\n## orphaned + we set a save comment and make it a minor edit.\n## ---------------------------------------------------------------------------\n#set($importDoc = $xwiki.getDocument('XWiki.XWikiPreferences'))\n#if($importDoc.isNew())\n  $importDoc.setParent('XWiki.WebHome')\n  $importDoc.save(\"Creating document to which to attach XAR files to import\", true)\n#end\n## ---------------------------------------------------------------------------\n#if($request.xredirect)\n  #set($redirect = $request.xredirect)\n#else\n  #set($redirect = $xwiki.relativeRequestURL)\n#end\n#if(!$redirect)\n  #set($redirect = $importDoc.getURL('import', 'section=Import'))\n#end\n## ---------------------------------------------------------------------------\n## Import the documents from the selected XAR.\n## ---------------------------------------------------------------------------\n#if(\"$!{request.action}\" == 'import')\n<p class=\"legend\">$escapetool.xml($services.localization.render('import')) #if(\"$!{request.withversions}\" == '1')\n  $escapetool.xml($services.localization.render('export_addhistory'))#end</p>\n#template(\"imported.vm\")\n## ---------------------------------------------------------------------------\n## Browse the XARs and let the user select a XAR and the list of documents\n## to import from that XAR.\n## ---------------------------------------------------------------------------\n#else\n  #set($baseQueryString = \"editor=$!{request.editor}&amp;section=$!{request.section}\")\n  $xwiki.jsfx.use('js/xwiki/importer/import.js', true)##\n  $xwiki.ssfx.use('js/xwiki/importer/import.css', true)##\n  $xwiki.jsfx.use('uicomponents/widgets/upload.js', {'forceSkinAction': true, 'language': ${xcontext.locale}})##\n  $xwiki.ssfx.use('uicomponents/widgets/upload.css', true)##\n  <div id=\"import\" class=\"row\">\n    <div id=\"packagelist\" class=\"col-xs-12 col-sm-6 col-md-6\">\n      <div class=\"legend\">\n        $escapetool.xml($services.localization.render('core.importer.uploadPackage'))\n      </div>\n      ## Let the user upload XAR files.\n      <form action=\"$doc.getURL('upload')\" enctype=\"multipart/form-data\" method=\"post\" id=\"AddAttachment\">\n        <div>\n          ## CSRF prevention\n          <input type=\"hidden\" name=\"form_token\" value=\"$!escapetool.xml($services.csrf.getToken())\" />\n          <input type=\"hidden\" name=\"xredirect\" value=\"$!{escapetool.xml($redirect)}\" />\n          <fieldset id=\"attachform\">\n            ## Temporarily disabled, until we fix attachment name handling\n            ## <div><label id=\"xwikiuploadnamelabel\" for=\"xwikiuploadname\">$services.localization.render('core.viewers.attachments.upload.filename')</label></div>\n            <div><input id=\"xwikiuploadname\" type=\"hidden\" name=\"filename\" value=\"\" /></div>\n            <div class=\"package-upload\">\n              <label for=\"xwikiuploadfile\" class=\"hidden\">\n                $escapetool.xml($services.localization.render('core.viewers.attachments.upload.file'))\n              </label>\n              <input id=\"xwikiuploadfile\" type=\"file\" name=\"filepath\" class=\"uploadFileInput noitems\"\n                     data-max-file-size=\"$!escapetool.xml($xwiki.getSpacePreference('upload_maxsize'))\"/>\n              <span class=\"buttonwrapper\">\n                <input type=\"submit\" value=\"Upload\" class=\"button\"/>\n              </span>\n            </div>\n          </fieldset>\n        </div>\n      </form>\n    <div class=\"legend\">\n      $escapetool.xml($services.localization.render('core.importer.availablePackages'))\n    </div>\n    <div id=\"packagelistcontainer\">\n      #template('packagelist.vm')\n    </div> ## packagelistcontainer\n    </div> ##packagelist\n    <div id=\"packagecontainer\" class=\"col-xs-12 col-sm-6 col-md-6\">\n      #if(\"$!request.file\" != '')\n        ##\n        ## If we get here, it means javascript is not activated on the user's browser (otherwise the attachment link\n        ## click would have been intercepted). We display a basic UI (list of checkboxes) to chose which documents in the archive to import.\n        ##\n        #set($attach = $doc.getAttachment($request.file))\n        #if($attach)\n          #set($package = $services.xar.getXarPackage($attach.contentInputStream, true))\n          #if(!$package)\n            #error(\"There was an error reading the file ${escapetool.xml(${request.file})}. $!xcontext.import_error\")\n          #else\n          <div class=\"legend\">\n            $escapetool.xml($services.localization.render('core.importer.availableDocuments'))\n          </div>\n          <div id=\"packageDescription\">\n            <div class=\"packageinfos\">\n              <div>\n                <span class=\"label\">\n                  $escapetool.xml($services.localization.render('core.importer.package'))\n                </span>\n                <span class=\"filename\">$escapetool.xml($attach.filename)</span>\n              </div>\n              #if(\"$!package.packageName\" != '')\n              <div>\n                <span class=\"label\">\n                  $escapetool.xml($services.localization.render('core.importer.package.description'))\n                </span>\n                <span class=\"name\">$escapetool.xml($package.packageName)</span>\n              </div>\n              #end\n              #if(\"$!package.packageVersion\" != '')\n              <div>\n                <span class=\"label\">\n                  $escapetool.xml($services.localization.render('core.importer.package.version'))\n                </span>\n                <span class=\"version\">$escapetool.xml($package.packageVersion)</span>\n              </div>\n              #end\n              #if(\"$!package.packageAuthor\" != '')\n              <div>\n                <span class=\"label\">\n                  $escapetool.xml($services.localization.render('core.importer.package.author'))\n                </span>\n                <span class=\"author\">$escapetool.xml($package.packageAuthor)</span>\n              </div>\n              #end\n              #if(\"$!package.packageLicense\" != '')\n              <div>\n                <span class=\"label\">\n                  $escapetool.xml($services.localization.render('core.importer.package.licence'))\n                </span>\n                <span class=\"licence\">$escapetool.xml($package.packageLicense)</span>\n              </div>\n              #end\n            </div>\n            <form action=\"$!escapetool.xml($importaction)\" method=\"post\" class=\"static-importer\">\n              <div>\n                ## CSRF prevention\n                <input type=\"hidden\" name=\"form_token\" value=\"$!escapetool.xml($services.csrf.token)\" />\n                <input type=\"hidden\" name=\"action\" value=\"import\" />\n                <input type=\"hidden\" name=\"name\" value=\"$!{escapetool.xml($request.file)}\" />\n                <div id=\"package\">\n                  <ul class=\"xlist package\">\n                    <li>\n                      ## This hidden input ensures that if no page is selected, the 'pages' parameter is still passed, thus skipping all the documents in the xar\n                      <input type='hidden' name='pages' value=''/>\n                    </li>\n                    ## List each page in the package\n                    #macro(displayPageNode $pageNode)\n                      #set($document = $pageNode.reference.name)\n                      ## List each locale of the current document\n                      #foreach($locale in $pageNode.locales)\n                      <li class=\"xitem xhighlight pages\">\n                        <div class=\"xitemcontainer xpagecontainer\">\n                          <span class=\"checkbox\">\n                            <input type=\"checkbox\" name=\"pages\"\n                                  value=\"${escapetool.xml($services.model.serialize($locale, 'local'))}#if(\"$!locale.locale\" != ''):${locale.locale}#end\" checked />\n                          </span>\n                          <span class=\"documentName\">\n                            <input type=\"hidden\" name=\"$!{escapetool.xml($services.model.serialize($locale, 'local'))}:$!{escapetool.xml($locale.locale)}\" value=\"$!{escapetool.xml($locale.locale)}\" />\n                            $escapetool.xml($document) #if(\"$!locale.locale\" != '') - $locale.locale #end\n                          </span>\n                          <div class=\"clearfloats\"></div>\n                        </div>\n                      </li>\n                      #end\n                    #end\n                    #macro(displaySpaceNode $spaceNode)\n                      #set($spaceReference = $spaceNode.reference)\n                      #set($space = $spaceNode.reference.name)\n                      <li class=\"xitem xunderline\">\n                        <div class=\"xitemcontainer\">\n                        <div class=\"spacename\">$escapetool.xml($space)</div>\n                        <div class=\"clearfloats\"></div>\n                        <div class=\"pages\">\n                        <ul class=\"xlist pages\">\n                        #foreach($node in $spaceNode.children)\n                          #displayNode($node)\n                        #end\n                        </ul>\n                        </div>\n                        </div>\n                      </li>\n                    #end\n                    #macro(displayNode $node)\n                      #if ($node.children.isEmpty())\n                        #displayPageNode($node)\n                      #else\n                        #displaySpaceNode($node)\n                      #end                      \n                    #end\n                    #set ($tree = $services.model.toTree($package.entries))\n                    #foreach($node in $tree.children)\n                      #displayNode($node)\n                    #end\n                  </ul>\n                <div class=\"importOption\">\n                  <em>\n                    $escapetool.xml($services.localization.render('core.importer.whenDocumentAlreadyExists'))\n                  </em>\n                  <div class=\"historyStrategyOption\">\n                    <input type=\"radio\" name=\"historyStrategy\" value=\"add\" checked=\"checked\" />\n                    $escapetool.xml($services.localization.render('core.importer.addNewVersion'))\n                  </div>\n                  <div class=\"historyStrategyOption\">\n                    <input type=\"radio\" name=\"historyStrategy\" value=\"replace\" />\n                    $escapetool.xml($services.localization.render('core.importer.replaceDocumentHistory'))\n                  </div>\n                  <div class=\"historyStrategyOption\">\n                    <input type=\"radio\" name=\"historyStrategy\" value=\"reset\" />\n                    $escapetool.xml($services.localization.render('core.importer.resetHistory'))\n                  </div>\n                </div>\n                ## TODO: replace with a new API to introduce (impossible to safely test right on a different wiki from velocity without PR)\n                #if($xwiki.package.hasBackupPackImportRights())\n                <div class=\"importOption\">\n                  <input type=\"checkbox\" name=\"importAsBackup\" value=\"true\" #if($packager.isBackupPack())checked=\"checked\"#end/>\n                  $escapetool.xml($services.localization.render('core.importer.importAsBackup'))\n                </div>\n                #end\n                <span class=\"buttonwrapper\">\n                  <input class=\"button\" type=\"submit\" \n                         value=\"$escapetool.xml($services.localization.render('core.importer.import'))\" />\n                </span>\n              </div>\n              </div>\n            </form>\n          </div>\n          #end ## package is valid\n        #end ## attachment exists\n      #end\n    </div> ## package\n    <div class=\"clearfloats\"></div>\n  </div>\n#end\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2023-33186", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "import $ from \"jquery\";\nimport _ from \"lodash\";\nimport tippy, {delegate} from \"tippy.js\";\n\nimport render_message_inline_image_tooltip from \"../templates/message_inline_image_tooltip.hbs\";\nimport render_narrow_to_compose_recipients_tooltip from \"../templates/narrow_to_compose_recipients_tooltip.hbs\";\nimport render_tooltip_templates from \"../templates/tooltip_templates.hbs\";\n\nimport * as compose_recipient from \"./compose_recipient\";\nimport * as compose_state from \"./compose_state\";\nimport {$t} from \"./i18n\";\nimport * as message_lists from \"./message_lists\";\nimport * as narrow_state from \"./narrow_state\";\nimport * as popover_menus from \"./popover_menus\";\nimport * as reactions from \"./reactions\";\nimport * as rows from \"./rows\";\nimport * as timerender from \"./timerender\";\nimport {parse_html} from \"./ui_util\";\nimport {user_settings} from \"./user_settings\";\n\n// For tooltips without data-tippy-content, we use the HTML content of\n// a <template> whose id is given by data-tooltip-template-id.\nfunction get_tooltip_content(reference) {\n    if (\"tooltipTemplateId\" in reference.dataset) {\n        const template = document.querySelector(\n            `template#${CSS.escape(reference.dataset.tooltipTemplateId)}`,\n        );\n        return template.content.cloneNode(true);\n    }\n    return \"\";\n}\n\n// We need to store all message list instances together to destroy them in case of re-rendering.\nconst message_list_tippy_instances = new Set();\n\n// This keeps track of all the instances created and destroyed.\nconst store_message_list_instances_plugin = {\n    fn() {\n        return {\n            onCreate(instance) {\n                message_list_tippy_instances.add(instance);\n            },\n            onDestroy(instance) {\n                // To make sure the `message_list_tippy_instances` contains only instances\n                // that are present in the DOM, we need to delete instances that are destroyed\n                message_list_tippy_instances.delete(instance);\n            },\n        };\n    },\n};\n\n// To prevent the appearance of tooltips whose reference is hidden or removed from the\n// DOM during re-rendering, we need to destroy all the message list present instances,\n// and then initialize triggers of the tooltips again after re-rendering.\nexport function destroy_all_message_list_tooltips() {\n    for (const instance of message_list_tippy_instances) {\n        if (instance.reference === document.body) {\n            continue;\n        }\n        instance.destroy();\n    }\n    message_list_tippy_instances.clear();\n}\n\n// Defining observer outside ensures that at max only one observer is active at all times.\nlet observer;\nfunction hide_tooltip_if_reference_removed(\n    target_node,\n    config,\n    instance,\n    nodes_to_check_for_removal,\n) {\n    // Use MutationObserver to check for removal of nodes on which tooltips\n    // are still active.\n    if (!target_node) {\n        // The tooltip reference was removed from DOM before we reached here.\n        // In that case, we simply hide the tooltip.\n        // We have to be smart about hiding the instance, so we hide it as soon\n        // as it is displayed.\n        setTimeout(instance.hide, 0);\n        return;\n    }\n    const callback = function (mutationsList) {\n        for (const mutation of mutationsList) {\n            for (const node of nodes_to_check_for_removal) {\n                // Hide instance if reference's class changes.\n                if (mutation.type === \"attributes\" && mutation.attributeName === \"class\") {\n                    instance.hide();\n                }\n                // Hide instance if reference is in the removed node list.\n                if (Array.prototype.includes.call(mutation.removedNodes, node)) {\n                    instance.hide();\n                }\n            }\n        }\n    };\n    observer = new MutationObserver(callback);\n    observer.observe(target_node, config);\n}\n\n// We use three delay settings for tooltips. The default \"instant\"\n// version has just a tiny bit of delay to create a natural feeling\n// transition, while the \"long\" version is intended for elements where\n// we want to avoid distracting the user with the tooltip\n// unnecessarily.\nconst INSTANT_HOVER_DELAY = [100, 20];\nconst LONG_HOVER_DELAY = [750, 20];\n// EXTRA_LONG_HOVER_DELAY is for elements like the compose box send\n// button where the tooltip content is almost exactly the same as the\n// text in the button, and the tooltip exists just to advertise a\n// keyboard shortcut. For these tooltips, it's very important to avoid\n// distracting users unnecessarily.\nconst EXTRA_LONG_HOVER_DELAY = [1500, 20];\n\n// Tooltips present outside of message list table in DOM don't get\n// effected by `rerender` but since their original reference is removed,\n// their position is miscalculated and they get placed at top left of the\n// window. To avoid this, we use this wrapping function.\nfunction message_list_tooltip(target, props) {\n    delegate(\"body\", {\n        target,\n        appendTo: () => document.body,\n        plugins: [store_message_list_instances_plugin],\n        ...props,\n    });\n}\n\n// We override the defaults set by tippy library here,\n// so make sure to check this too after checking tippyjs\n// documentation for default properties.\ntippy.setDefaultProps({\n    // Tooltips shouldn't take more space than mobile widths.\n    maxWidth: 300,\n    delay: INSTANT_HOVER_DELAY,\n    placement: \"top\",\n    // Disable animations to make the tooltips feel snappy.\n    animation: false,\n    // Show tooltips on long press on touch based devices.\n    touch: [\"hold\", 750],\n    // Create the tooltip inside the parent element. This has the\n    // undesirable side effect of CSS properties of the parent elements\n    // applying to tooltips, which causes ugly clipping if the parent\n    // element has overflow rules. Even with that, we prefer to have\n    // tooltips appended to the parent so that the tooltip gets removed\n    // if the parent is hidden / removed from DOM; which is not the case\n    // with appending it to `body` which has side effect of tooltips\n    // sticking around due to browser not communicating to tippy that\n    // the element has been removed without having a Mutation Observer.\n    appendTo: \"parent\",\n    // To add a text tooltip, override this by setting data-tippy-content.\n    // To add an HTML tooltip, set data-tooltip-template-id to the id of a <template>.\n    // Or, override this with a function returning string (text) or DocumentFragment (HTML).\n    content: get_tooltip_content,\n});\n\nexport function initialize() {\n    $(\"#tooltip-templates-container\").html(render_tooltip_templates());\n\n    // Our default tooltip configuration. For this, one simply needs to:\n    // * Set `class=\"tippy-zulip-tooltip\"` on an element for enable this.\n    // * Set `data-tippy-content=\"{{t 'Tooltip content' }}\"`, often\n    //   replacing a `title` attribute on an element that had both.\n    // * Set placement; we typically use `data-tippy-placement=\"top\"`.\n    delegate(\"body\", {\n        target: \".tippy-zulip-tooltip\",\n    });\n\n    // variant of tippy-zulip-tooltip above having delay=LONG_HOVER_DELAY,\n    // default placement=\"top\" with fallback placement=\"bottom\",\n    // and appended to body\n    delegate(\"body\", {\n        target: \".tippy-zulip-delayed-tooltip\",\n        // Disable trigger on focus, to avoid displaying on-click.\n        trigger: \"mouseenter\",\n        delay: LONG_HOVER_DELAY,\n        appendTo: () => document.body,\n        popperOptions: {\n            modifiers: [\n                {\n                    name: \"flip\",\n                    options: {\n                        fallbackPlacements: \"bottom\",\n                    },\n                },\n            ],\n        },\n    });\n\n    message_list_tooltip(\".tippy-narrow-tooltip\", {\n        delay: LONG_HOVER_DELAY,\n        onCreate(instance) {\n            const content = instance.props.content + $(\"#narrow-hotkey-tooltip-template\").html();\n            instance.setContent(parse_html(content));\n        },\n    });\n\n    delegate(\"body\", {\n        target: \".toggle-subscription-tooltip\",\n        delay: EXTRA_LONG_HOVER_DELAY,\n        appendTo: () => document.body,\n        placement: \"bottom\",\n    });\n\n    delegate(\"body\", {\n        target: \".tippy-left-sidebar-tooltip\",\n        placement: \"right\",\n        delay: EXTRA_LONG_HOVER_DELAY,\n        appendTo: () => document.body,\n        popperOptions: {\n            modifiers: [\n                {\n                    name: \"flip\",\n                    options: {\n                        fallbackPlacements: \"bottom\",\n                    },\n                },\n            ],\n        },\n    });\n\n    // Variant of .tippy-left-sidebar-tooltip configuration. Since\n    // this element doesn't have an always visible label, and\n    // thus hovering it is a way to find out what it does, give\n    // it the faster LONG_HOVER_DELAY.\n    delegate(\"body\", {\n        target: \"#show_all_private_messages\",\n        placement: \"right\",\n        delay: LONG_HOVER_DELAY,\n        appendTo: () => document.body,\n        popperOptions: {\n            modifiers: [\n                {\n                    name: \"flip\",\n                    options: {\n                        fallbackPlacements: \"bottom\",\n                    },\n                },\n            ],\n        },\n    });\n\n    // The below definitions are for specific tooltips that require\n    // custom JavaScript code or configuration.  Note that since the\n    // below specify the target directly, elements using those should\n    // not have the tippy-zulip-tooltip class.\n\n    // message reaction tooltip showing who reacted.\n    let observer;\n    message_list_tooltip(\".message_reaction, .message_reactions .reaction_button\", {\n        placement: \"bottom\",\n        onShow(instance) {\n            if (!document.body.contains(instance.reference)) {\n                // It is possible for reaction to be removed before `onShow` is triggered,\n                // so, we check if the element exists before proceeding.\n                return false;\n            }\n            const $elem = $(instance.reference);\n            if (!instance.reference.classList.contains(\"reaction_button\")) {\n                const local_id = $elem.attr(\"data-reaction-id\");\n                const message_id = rows.get_message_id(instance.reference);\n                const title = reactions.get_reaction_title_data(message_id, local_id);\n                instance.setContent(title);\n            }\n\n            const config = {attributes: false, childList: true, subtree: true};\n            const target = $elem.parents(\".message_table.focused_table\").get(0);\n            const nodes_to_check_for_removal = [\n                $elem.parents(\".recipient_row\").get(0),\n                $elem.parents(\".message_reactions\").get(0),\n                $elem.get(0),\n            ];\n            hide_tooltip_if_reference_removed(target, config, instance, nodes_to_check_for_removal);\n            return true;\n        },\n        onHidden(instance) {\n            instance.destroy();\n            if (observer) {\n                observer.disconnect();\n            }\n        },\n    });\n\n    delegate(\"body\", {\n        target: [\n            // Ideally this would be `#compose_buttons .button`, but the\n            // reply button's actual area is its containing span.\n            \"#compose_buttons > .reply_button_container\",\n            \"#left_bar_compose_mobile_button_big\",\n            \"#left_bar_compose_stream_button_big\",\n            \"#left_bar_compose_private_button_big\",\n        ],\n        delay: EXTRA_LONG_HOVER_DELAY,\n        appendTo: () => document.body,\n        onHidden(instance) {\n            instance.destroy();\n        },\n    });\n\n    delegate(\"body\", {\n        target: \".compose_control_button\",\n        // Add some additional delay when they open\n        // so that regular users don't have to see\n        // them unless they want to.\n        delay: LONG_HOVER_DELAY,\n        // By default, tippyjs uses a trigger value of \"mouseenter focus\",\n        // which means the tooltips can appear either when the element is\n        // hovered over or when it receives focus (e.g. by being clicked).\n        // However, we only want the tooltips to appear on hover, not on click.\n        // Therefore, we need to remove the \"focus\" trigger from the buttons,\n        // so that the tooltips don't appear when the buttons are clicked.\n        trigger: \"mouseenter\",\n        // This ensures that the upload files tooltip\n        // doesn't hide behind the left sidebar.\n        appendTo: () => document.body,\n    });\n\n    delegate(\"body\", {\n        target: \"#compose-send-button\",\n        delay: EXTRA_LONG_HOVER_DELAY,\n        // By default, tippyjs uses a trigger value of \"mouseenter focus\",\n        // but by specifying \"mouseenter\", this will prevent showing the\n        // Send tooltip when tabbing to the Send button.\n        trigger: \"mouseenter\",\n        appendTo: () => document.body,\n        onShow(instance) {\n            if (user_settings.enter_sends) {\n                instance.setContent(parse_html($(\"#send-enter-tooltip-template\").html()));\n            } else {\n                instance.setContent(parse_html($(\"#send-ctrl-enter-tooltip-template\").html()));\n            }\n        },\n    });\n\n    message_list_tooltip(\".message_control_button\", {\n        delay: LONG_HOVER_DELAY,\n        onShow(instance) {\n            // Handle dynamic \"starred messages\" and \"edit\" widgets.\n            const $elem = $(instance.reference);\n            const tippy_content = $elem.attr(\"data-tippy-content\");\n            const $template = $(`#${CSS.escape($elem.attr(\"data-tooltip-template-id\"))}`);\n            instance.setContent(tippy_content ?? parse_html($template.html()));\n        },\n        onHidden(instance) {\n            instance.destroy();\n        },\n    });\n\n    $(\"body\").on(\"blur\", \".message_control_button\", (e) => {\n        // Remove tooltip when user is trying to tab through all the icons.\n        // If user tabs slowly, tooltips are displayed otherwise they are\n        // destroyed before they can be displayed.\n        e.currentTarget?._tippy?.destroy();\n    });\n\n    message_list_tooltip(\".slow-send-spinner\", {\n        onShow(instance) {\n            instance.setContent(\n                $t({\n                    defaultMessage:\n                        \"Your message is taking longer than expected to be sent. Sending\",\n                }),\n            );\n            const $elem = $(instance.reference);\n\n            // We need to check for removal of local class from message_row since\n            // .slow-send-spinner is not removed (hidden) from DOM when message is sent.\n            const target = $elem.parents(\".message_row\").get(0);\n            const config = {attributes: true, childList: false, subtree: false};\n            const nodes_to_check_for_removal = [$elem.get(0)];\n            hide_tooltip_if_reference_removed(target, config, instance, nodes_to_check_for_removal);\n        },\n        onHidden(instance) {\n            instance.destroy();\n        },\n    });\n\n    message_list_tooltip(\".message_table .message_time\", {\n        onShow(instance) {\n            const $time_elem = $(instance.reference);\n            const $row = $time_elem.closest(\".message_row\");\n            const message = message_lists.current.get(rows.id($row));\n            // Don't show time tooltip for locally echoed message.\n            if (message.locally_echoed) {\n                return false;\n            }\n            const time = new Date(message.timestamp * 1000);\n            instance.setContent(timerender.get_full_datetime_clarification(time));\n            return true;\n        },\n        onHidden(instance) {\n            instance.destroy();\n        },\n    });\n\n    message_list_tooltip(\".recipient_row_date > span\", {\n        onHidden(instance) {\n            instance.destroy();\n        },\n    });\n\n    message_list_tooltip(\".code_external_link\");\n\n    delegate(\"body\", {\n        target: [\n            \"#streams_header .sidebar-title\",\n            \"#userlist-title\",\n            \"#user_filter_icon\",\n            \"#scroll-to-bottom-button-clickable-area\",\n            \".spectator_narrow_login_button\",\n            \"#stream-specific-notify-table .unmute_stream\",\n            \"#add_streams_tooltip\",\n            \"#filter_streams_tooltip\",\n            \".error-icon-message-recipient .zulip-icon\",\n        ],\n        appendTo: () => document.body,\n    });\n\n    message_list_tooltip([\".recipient_bar_icon\"], {\n        delay: LONG_HOVER_DELAY,\n        onHidden(instance) {\n            instance.destroy();\n        },\n    });\n\n    message_list_tooltip([\".rendered_markdown time\", \".rendered_markdown .copy_codeblock\"], {\n        content: timerender.get_markdown_time_tooltip,\n        onHidden(instance) {\n            instance.destroy();\n        },\n    });\n\n    delegate(\"body\", {\n        target: [\n            \"#compose_top_right [data-tippy-content]\",\n            \"#compose_top_right [data-tooltip-template-id]\",\n        ],\n        delay: LONG_HOVER_DELAY,\n        appendTo: () => document.body,\n        onHidden(instance) {\n            instance.destroy();\n        },\n    });\n\n    delegate(\"body\", {\n        target: \".narrow_to_compose_recipients\",\n        delay: LONG_HOVER_DELAY,\n        appendTo: () => document.body,\n        content() {\n            const narrow_filter = narrow_state.filter();\n            let display_current_view;\n            if (narrow_state.is_message_feed_visible()) {\n                if (narrow_filter === undefined) {\n                    display_current_view = $t({defaultMessage: \"Currently viewing all messages.\"});\n                } else if (\n                    _.isEqual(narrow_filter.sorted_term_types(), [\"stream\"]) &&\n                    compose_state.get_message_type() === \"stream\" &&\n                    narrow_filter.operands(\"stream\")[0] === compose_state.stream_name()\n                ) {\n                    display_current_view = $t({\n                        defaultMessage: \"Currently viewing the entire stream.\",\n                    });\n                } else if (\n                    _.isEqual(narrow_filter.sorted_term_types(), [\"is-dm\"]) &&\n                    compose_state.get_message_type() === \"private\"\n                ) {\n                    display_current_view = $t({\n                        defaultMessage: \"Currently viewing all direct messages.\",\n                    });\n                }\n            }\n\n            return parse_html(render_narrow_to_compose_recipients_tooltip({display_current_view}));\n        },\n        onHidden(instance) {\n            instance.destroy();\n        },\n    });\n\n    delegate(\"body\", {\n        target: [\".enter_sends_true\", \".enter_sends_false\"],\n        delay: LONG_HOVER_DELAY,\n        content: $t({defaultMessage: \"Change send shortcut\"}),\n        onShow() {\n            // Don't show tooltip if the popover is displayed.\n            if (popover_menus.is_compose_enter_sends_popover_displayed()) {\n                return false;\n            }\n            return true;\n        },\n        appendTo: () => document.body,\n    });\n\n    message_list_tooltip(\".message_inline_image > a > img\", {\n        // Add a short delay so the user can mouseover several inline images without\n        // tooltips showing and hiding rapidly\n        delay: [300, 20],\n        onShow(instance) {\n            // Some message_inline_images aren't actually images with a title,\n            // for example youtube videos, so we default to the actual href\n            const title =\n                $(instance.reference).parent().attr(\"aria-label\") ||\n                $(instance.reference).parent().attr(\"href\");\n            instance.setContent(parse_html(render_message_inline_image_tooltip({title})));\n        },\n        onHidden(instance) {\n            instance.destroy();\n        },\n    });\n\n    delegate(\"body\", {\n        target: \".image-info-wrapper > .image-description > .title\",\n        appendTo: () => document.body,\n        onShow(instance) {\n            const title = $(instance.reference).attr(\"aria-label\");\n            const filename = $(instance.reference).prop(\"data-filename\");\n            const $markup = $(\"<span>\").text(title);\n            if (title !== filename) {\n                // If the image title is the same as the filename, there's no reason\n                // to show this next line.\n                const second_line = $t({defaultMessage: \"File name: {filename}\"}, {filename});\n                $markup.append($(\"<br>\"), $(\"<span>\").text(second_line));\n            }\n            instance.setContent($markup[0]);\n        },\n        onHidden(instance) {\n            instance.destroy();\n        },\n    });\n\n    delegate(\"body\", {\n        // Configure tooltips for the stream_sorter_toggle buttons.\n\n        // TODO: Ideally, we'd extend this to be a common mechanism for\n        // tab switchers, with the strings living in a more normal configuration\n        // location.\n        target: \".stream_sorter_toggle .ind-tab [data-tippy-content]\",\n\n        // Adjust their placement to `bottom`.\n        placement: \"bottom\",\n\n        // Avoid inheriting `position: relative` CSS on the stream sorter widget.\n        appendTo: () => document.body,\n    });\n\n    delegate(\"body\", {\n        // This tooltip appears on the \"Summary\" checkboxes in\n        // settings > custom profile fields, when at the limit of 2\n        // fields with display_in_profile_summary enabled.\n        target: [\n            \"#profile-field-settings .display_in_profile_summary_tooltip\",\n            \"#edit-custom-profile-field-form-modal .display_in_profile_summary_tooltip\",\n            \"#add-new-custom-profile-field-form .display_in_profile_summary_tooltip\",\n        ],\n        content: $t({\n            defaultMessage: \"Only 2 custom profile fields can be displayed on the user card.\",\n        }),\n        appendTo: () => document.body,\n        onTrigger(instance) {\n            // Sometimes just removing class is not enough to destroy/remove tooltip, especially in\n            // \"Add a new custom profile field\" form, so here we are manually calling `destroy()`.\n            if (!instance.reference.classList.contains(\"display_in_profile_summary_tooltip\")) {\n                instance.destroy();\n            }\n        },\n    });\n\n    delegate(\"body\", {\n        target: [\"#full_name_input_container.disabled_setting_tooltip\"],\n        content: $t({\n            defaultMessage:\n                \"Name changes are disabled in this organization. Contact an administrator to change your name.\",\n        }),\n        appendTo: () => document.body,\n        onHidden(instance) {\n            instance.destroy();\n        },\n    });\n\n    delegate(\"body\", {\n        target: [\"#change_email_button_container.disabled_setting_tooltip\"],\n        content: $t({defaultMessage: \"Email address changes are disabled in this organization.\"}),\n        appendTo: () => document.body,\n        onHidden(instance) {\n            instance.destroy();\n        },\n    });\n\n    delegate(\"body\", {\n        target: [\"#deactivate_account_container.disabled_setting_tooltip\"],\n        content: $t({\n            defaultMessage:\n                \"Because you are the only organization owner, you cannot deactivate your account.\",\n        }),\n        appendTo: () => document.body,\n        onHidden(instance) {\n            instance.destroy();\n        },\n    });\n\n    delegate(\"body\", {\n        target: [\"#deactivate_realm_button_container.disabled_setting_tooltip\"],\n        content: $t({\n            defaultMessage: \"Only organization owners may deactivate an organization.\",\n        }),\n        appendTo: () => document.body,\n        onHidden(instance) {\n            instance.destroy();\n        },\n    });\n\n    delegate(\"body\", {\n        target: \"#pm_tooltip_container\",\n        onShow(instance) {\n            if ($(\".private_messages_container\").hasClass(\"zoom-in\")) {\n                return false;\n            }\n\n            if ($(\"#toggle_private_messages_section_icon\").hasClass(\"fa-caret-down\")) {\n                instance.setContent(\n                    $t({\n                        defaultMessage: \"Collapse direct messages\",\n                    }),\n                );\n            } else {\n                instance.setContent($t({defaultMessage: \"Expand direct messages\"}));\n            }\n            return true;\n        },\n        delay: LONG_HOVER_DELAY,\n        appendTo: () => document.body,\n    });\n\n    message_list_tooltip(\".view_user_card_tooltip\", {\n        delay: LONG_HOVER_DELAY,\n        onHidden(instance) {\n            instance.destroy();\n        },\n    });\n\n    delegate(\"body\", {\n        target: \"#send_later\",\n        delay: LONG_HOVER_DELAY,\n        placement: \"top\",\n        appendTo: () => document.body,\n    });\n\n    delegate(\"body\", {\n        target: [\".disabled-compose-send-button-container\"],\n        maxWidth: 350,\n        content: () => compose_recipient.get_posting_policy_error_message(),\n        appendTo: () => document.body,\n        onHidden(instance) {\n            instance.destroy();\n        },\n    });\n\n    delegate(\"body\", {\n        target: [\"#stream_creation_form .add_subscribers_disabled\"],\n        content: $t({\n            defaultMessage:\n                \"You do not have permission to add other users to streams in this organization.\",\n        }),\n        appendTo: () => document.body,\n        onHidden(instance) {\n            instance.destroy();\n        },\n    });\n}\n\nexport function show_copied_confirmation($copy_button) {\n    // Display a tooltip to notify the user the message or code was copied.\n    const instance = tippy($copy_button, {\n        placement: \"top\",\n        appendTo: () => document.body,\n        onUntrigger() {\n            remove_instance();\n        },\n    });\n    instance.setContent($t({defaultMessage: \"Copied!\"}));\n    instance.show();\n    function remove_instance() {\n        if (!instance.state.isDestroyed) {\n            instance.destroy();\n        }\n    }\n    setTimeout(remove_instance, 1000);\n}\n", "output": {"vulnerability_count": 11, "vulnerabilities": [{"description": "User controlled data in a jQuery's `.html(...)` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 157}, {"description": "JQuery's `html` function is susceptible to Cross Site Scripting (XSS) attacks. If you're just passing text, consider `text` instead. Otherwise, use a function that escapes HTML such as edX's `HtmlUtils.setHtml()`.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 157}, {"description": "User controlled data in a `$(...)` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 257}, {"description": "User controlled data in a `$(...)` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 338}, {"description": "User controlled data in a `$(...)` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 340}, {"description": "User controlled data in a `$(...)` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 363}, {"description": "User controlled data in a `$(...)` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 379}, {"description": "User controlled data in a `$(...)` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 501}, {"description": "User controlled data in a `$(...)` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 502}, {"description": "User controlled data in a `$(...)` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 514}, {"description": "User controlled data in a `$(...)` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 515}]}}
{"CVE": "CVE-2023-33969", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "<?php\n    <a href=\"<?= $link['url'] ?>\" title=\"<?= $this->text->e($link['url']) ?>\" target=\"_blank\">\n        <?= $this->text->e($link['title']) ?>\n        <span class=\"ui-helper-hidden-accessible\">(<?= $this->text->e($link['url']) ?>)</span>\n    </a>\n>", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2023-34098", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "# BEGIN Shopware\n# The directives (lines) between \"# BEGIN Shopware\" and \"# END Shopware\" are dynamically generated. Any changes to the directives between these markers will be overwritten.\n\n<IfModule mod_rewrite.c>\nRewriteEngine on\n\n#RewriteBase /shopware/\n\n# Fix for office 365 autodiscover feature to prevent CSRF errors\nRewriteRule ^autodiscover/autodiscover.xml$ - [F,L,NC]\n\n# HTTPS config for the backend\n#RewriteCond %{HTTPS} !=on\n#RewriteRule backend/(.*) https://%{HTTP_HOST}%{REQUEST_URI} [L,R=301]\n\nRewriteRule shopware.dll shopware.php\nRewriteRule files/documents/.* engine [NC,L]\nRewriteRule backend/media/(.*) media/$1 [NC,L]\nRewriteRule custom/.*(config|menu|services|plugin)\\.xml$ ./shopware.php?controller=Error&action=pageNotFoundError [NC,L]\n\nRewriteCond %{REQUEST_URI} !(\\/(engine|files|templates|themes|web)\\/)\nRewriteCond %{REQUEST_URI} !(\\/media\\/(archive|banner|image|music|pdf|unknown|video)\\/)\nRewriteCond %{REQUEST_FILENAME} !-f\nRewriteCond %{REQUEST_FILENAME} !-d\nRewriteRule ^(.*)$ shopware.php [PT,L,QSA]\n\n# Fix missing authorization-header on fast_cgi installations\nRewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization},L]\n</IfModule>\n\n<IfModule mod_alias.c>\n    # Restrict access to VCS directories\n    RedirectMatch 404 /\\\\.(svn|git|hg|bzr|cvs)(/|$)\n\n    # Restrict access to root folder files\n    RedirectMatch 404 /(autoload\\.php|composer\\.(json|lock|phar)|README\\.md|UPGRADE-(.*)\\.md|CONTRIBUTING\\.md|eula.*\\.txt|\\.gitignore|.*\\.dist|\\.env.*)$\n\n    # Restrict access to shop configs files\n    RedirectMatch 404 /(web\\/cache\\/(config_\\d+\\.json|all.less))$\n\n    # Restrict access to theme configurations\n    RedirectMatch 404 /themes/(.*)(.*\\.lock|package\\.json|\\.gitignore|Gruntfile\\.js|all\\.less|node_modules\\/.*)$\n</IfModule>\n\n# Staging environment\n#SetEnvIf Host \"staging.test.shopware.in\" SHOPWARE_ENV=staging\n\n# Development environment\n#SetEnvIf Host \"dev.shopware.in\" SHOPWARE_ENV=dev\n#SetEnv SHOPWARE_ENV dev\n\nDirectoryIndex index.html\nDirectoryIndex index.php\nDirectoryIndex shopware.php\n\n# Disables download of configuration\n<Files ~ \"\\.(tpl|yml|ini)$\">\n    # Deny all requests from Apache 2.4+.\n    <IfModule mod_authz_core.c>\n          Require all denied\n    </IfModule>\n\n    # Deny all requests from Apache 2.0-2.2.\n    <IfModule !mod_authz_core.c>\n        Deny from all\n    </IfModule>\n</Files>\n\n# Enable gzip compression\n<IfModule mod_deflate.c>\n    AddOutputFilterByType DEFLATE text/html text/xml text/plain text/css text/javascript application/javascript application/json application/font-woff application/font-woff2 image/svg+xml\n</IfModule>\n\n<Files ~ \"\\.(jpe?g|png|gif|css|js|woff|woff2|ttf|svg|webp|eot|ico)$\">\n    <IfModule mod_expires.c>\n        ExpiresActive on\n        ExpiresDefault \"access plus 1 month\"\n    </IfModule>\n\n    <IfModule mod_headers.c>\n        Header append Cache-Control \"public\"\n        Header unset ETag\n    </IfModule>\n\n    FileETag None\n</Files>\n\n# Match generated files like:\n# 1429684458_t22_s1.css\n# 1429684458_t22_s1.js\n<FilesMatch \"([0-9]{10})_(.+)\\.(js|css)$\">\n    <ifModule mod_headers.c>\n        Header set Cache-Control \"max-age=31536000, public\"\n    </ifModule>\n\n    <IfModule mod_expires.c>\n        ExpiresActive on\n        ExpiresDefault \"access plus 1 year\"\n    </IfModule>\n</FilesMatch>\n\n<IfModule mod_headers.c>\n    <FilesMatch \"\\.(?i:svg)$\">\n        Header set Content-Security-Policy \"script-src 'none'\"\n    </FilesMatch>\n</IfModule>\n\n# Disables auto directory index\n<IfModule mod_autoindex.c>\n    Options -Indexes\n</IfModule>\n\n<IfModule mod_negotiation.c>\n    Options -MultiViews\n</IfModule>\n\n# AddType x-mapp-php7 .php\n# AddHandler x-mapp-php7.php\n\n<IfModule mod_headers.c>\n    Header append X-Frame-Options SAMEORIGIN\n    # Uncomment the following line to enable HSTS (https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security) and force clients to use HTTPS for at least one year (31536000 seconds)\n    # Header always set Strict-Transport-Security \"max-age=31536000\"\n</IfModule>\n\n# END Shopware\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2023-35155", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.sharepage;\n\nimport org.junit.jupiter.api.Test;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.template.TemplateManager;\nimport org.xwiki.template.script.TemplateScriptService;\nimport org.xwiki.test.annotation.ComponentList;\nimport org.xwiki.test.page.PageTest;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Page test for the {@code shareinline} template.\n *\n * @version $Id$\n */\n@ComponentList({\n    TemplateScriptService.class\n})\nclass ShareInlineTemplateTest extends PageTest\n{\n    /**\n     * Verify that when no \"from\" address is specified, one is constructed automatically, based on the server name.\n     */\n    @Test\n    void shareByEmailWhenNoFromAddress() throws Exception\n    {\n        // Log in (since the template checks that a user is logged in)\n        this.oldcore.getXWikiContext().setUserReference(new DocumentReference(\"xwiki\", \"XWiki\", \"SomeUser\"));\n\n        // Simulate that we're using the shareinline template to send the emails\n        this.request.put(\"send\", \"1\");\n\n        // Simulate the server name\n        this.request.setServerName(\"localhost\");\n\n        // Simulate a target recipient to send the share page to, specified using an email address\n        this.request.put(\"target\", \"john@doe.com\");\n\n        // Register a fake MailSenderPlugin in which we assert the \"from\" parameter for the mail sending call.\n        this.oldcore.getSpyXWiki().getPluginManager().addPlugin(\"mailsender\", TestableMailSenderPlugin.class.getName(),\n            this.oldcore.getXWikiContext());\n        TestableMailSenderPlugin plugin =\n            (TestableMailSenderPlugin) this.oldcore.getSpyXWiki().getPluginManager().getPlugin(\"mailsender\");\n\n        // This is the test, triggered by the call to templateManager.render()\n        plugin.setExpectations(\"=?UTF-8?Q?SomeUser?= <noreply@localhost>\");\n\n        TemplateManager templateManager = this.oldcore.getMocker().getInstance(TemplateManager.class);\n        String result = templateManager.render(\"shareinline.vm\");\n\n        assertTrue(result.contains(\"<div class=\\\"infomessage\\\">core.viewers.share.send.success [john]</div>\"));\n    }\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2023-35156", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "## ---------------------------------------------------------------------------\n## See the NOTICE file distributed with this work for additional\n## information regarding copyright ownership.\n##\n## This is free software; you can redistribute it and/or modify it\n## under the terms of the GNU Lesser General Public License as\n## published by the Free Software Foundation; either version 2.1 of\n## the License, or (at your option) any later version.\n##\n## This software is distributed in the hope that it will be useful,\n## but WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n## Lesser General Public License for more details.\n##\n## You should have received a copy of the GNU Lesser General Public\n## License along with this software; if not, write to the Free\n## Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n## 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n## ---------------------------------------------------------------------------\n#######################################################\n###              DELETE PAGE ACTION\n###              ------------------\n###\n#######################################################\n##\n#######################################################\n##                     GLOBALS\n#######################################################\n#set($fullmsg = '')\n#set($quote = '\"')\n#set($hasInlinks = false)\n#######################################################\n##                     DISPLAY\n#######################################################\n#set ($discard = $xwiki.jsfx.use('js/xwiki/delete.js'))\n#template('refactoringStatus_macros.vm')\n#template('refactoring_macros.vm')\n#template('xwikivars.vm')\n\n#controller()\n#macro(displayContent $deletecontent)\n#template(\"startpage.vm\")\n<div class=\"main\">\n  <div id=\"mainContentArea\">\n    #template(\"hierarchy.vm\")\n    #define($title)<a href=\"$doc.getURL('view')\">$!escapetool.xml($doc.plainTitle)</a>#end\n    #set($titleToDisplay = $services.localization.render('core.delete.title', [$title]))\n    <div class=\"xcontent\">\n      #template('contentheader.vm')\n      $deletecontent\n      <div class=\"clearfloats\"></div>\n    </div> ## xcontent\n  </div>## mainContentArea\n</div>## main\n#template(\"endpage.vm\")\n#end\n#######################################################\n##                    CONTROLLER\n#######################################################\n#macro(controller)\n  #if(\"$!{request.jobId}\" != '')\n    #set ($deleteJobStatus = $services.job.getJobStatus($request.jobId.split('/')))\n    ## A delete job is running\n    #if ($xcontext.action == 'get')\n      #outputDeleteJobStatusJSON($deleteJobStatus)\n    #else\n      #set ($content = \"#displayDeleteJobStatus($deleteJobStatus)\")\n      #displayContent($content)\n    #end\n  #else\n    #if(\"$!{request.id}\" != '')\n      ## request.id means that we are deleting a document from the recycle bin\n      #set ($content = \"#displayCompletelyDeleteConfirmMessage()\")\n      #displayContent($content)\n    #else\n      #set ($content = \"#displayConfirmationPage()\")\n      #displayContent($content)\n    #end\n  #end\n#end\n\n#macro (outputDeleteJobStatusJSON $deleteJobStatus)\n  #getJobStatusJSON($deleteJobStatus $json)\n  $response.setContentType('application/json')\n  $jsontool.serialize($json)\n#end\n\n#######################################################\n##            DISPLAY RUNNING JOB\n#######################################################\n#macro (displayDeleteJobStatus $deleteJobStatus)\n  #set ($discard = $xwiki.jsfx.use('uicomponents/job/job.js'))\n  ## TODO: allows question templates to inject the web resources they need\n  #set ($discard = $xwiki.linkx.use($services.webjars.url('org.xwiki.platform:xwiki-platform-tree-webjar', 'tree.min.css',\n    {'evaluate': true}), {'type': 'text/css', 'rel': 'stylesheet'}))\n  #set ($discard = $xwiki.jsfx.use(\"uicomponents/job/question/ExtensionBreakingQuestion.js\", true))\n  #set ($discard = $xwiki.jsfx.use(\"uicomponents/job/question/XClassBreakingQuestion.js\", true))\n  #set ($deleteJobState = $deleteJobStatus.state)\n  #set ($finished = $deleteJobState == 'FINISHED')\n  #set ($deleteJobRequest = $deleteJobStatus.request)\n  #set ($jobStatusURL = $doc.getURL('get', $escapetool.url({\n    'xpage': 'delete',\n    'jobId': $request.jobId,\n    'outputSyntax': 'plain'\n  })))\n  <div class=\"xcontent job-status\" data-url=\"$jobStatusURL\">\n  <h2>$services.localization.render('core.delete.waitmessage')</h2>\n  #if (!$finished)\n    #displayJobProgressBar($deleteJobStatus)\n    #displayJobQuestion($deleteJobStatus)\n  #else\n    #displayJobFinishedMessage($deleteJobStatus)\n  #end\n  #if ($isAdvancedUser || $isSuperAdmin)\n    #displayJobStatusLog($deleteJobStatus true)\n  #end\n  </div>\n#end\n\n#######################################################\n##            DISPLAY CONFIRMATION PAGE\n#######################################################\n#macro(displayConfirmationPage)\n  <form id=\"delete\" class=\"xform\" action=\"$doc.getURL('delete', \"$!{languageparams}\")\" method=\"post\">\n    #getChildren()\n    #displayNewTargetOption()\n    #getChildren_legacy()\n    #displayConfirmMessage()\n  </form>\n#end\n#######################################################\n##                  DISPLAY PANEL\n#######################################################\n#macro(displayPanel $panelId $panelClass $heading $body)\n  <div class=\"panel $!panelClass\">\n    <div class=\"panel-heading\">\n      $heading\n      <div class=\"pull-right\"><a class=\"panel-collapse-carret\" role=\"button\" data-toggle=\"collapse\" href=\"#$panelId\" aria-expanded=\"false\" aria-controls=\"$panelId\"><span class=\"caret\"></span></a></div>\n    </div>\n    <div class=\"panel-body collapse\" id=\"$panelId\">\n      $body\n    </div>\n  </div>\n#end\n#######################################################\n##                    CHILDREN\n#######################################################\n#macro(getChildren)\n  #if ($doc.documentReference.name == 'WebHome') ## terminal documents have no child\n    #set($childCountXWQL = \"WHERE doc.fullName LIKE :space AND doc.fullName <> :fullName\")\n    #set ($query = $services.query.xwql($childCountXWQL))\n    #set ($query = $query.bindValue('space').literal(\"${doc.space}.\").anyChars().query())\n    #set ($query = $query.bindValue('fullName', $doc.fullName))\n    ## Note: we don't use any filter since we display all documents including translations and hidden documents in the\n    ## table below.\n    #set($childCount = $query.count())\n    #if ($childCount > 0)\n      ## Check if we should propose by default to affect children when the only remaining children (after the delete) would be the WebPreferences document.\n      #set ($webPreferencesDocumentReference = $services.model.createDocumentReference('WebPreferences', $doc.documentReference.lastSpaceReference))\n      #if ($childCount == 1 && $xwiki.exists($webPreferencesDocumentReference))\n        #set ($forceAffectChildren = \" checked='checked'\")\n      #end\n      #define($heading)\n        <input name=\"affectChildren\" id=\"affectChildren\" type=\"checkbox\" $!{forceAffectChildren}/><label for=\"affectChildren\">$services.localization.render('core.delete.affectChildren')</label> ($childCount)\n      #end\n      #define($body)\n        ##\n        ## List the documents to be deleted using a livetable\n        ##\n        #set ($collist = ['doc.title', 'doc.location', 'doc.date', 'doc.author'])\n        #set ($colprops = {\n          'doc.title'    : { 'link' : 'view' },\n          'doc.location' : { 'type': 'text', 'filterable': true, 'html': true},\n          'doc.author'   : { 'link' : 'author' }\n        })\n        ## Note: we also display translations in the table since we want to show to the user all the pages that will\n        ## be deleted (including translations and hidden pages).\n        #set ($urlParameters = \"xpage=getdocuments&childrenOf=$escapetool.url($doc.space)&queryFilters=unique\")\n        #set ($options = { \n          'url' : \"$doc.getURL('get', $urlParameters)\",\n          'translationPrefix' : 'platform.index.',\n          'outputOnlyHtml' : true\n        })\n        #livetable('deleteSpaceIndex' $collist $colprops $options)\n      #end\n      #displayPanel('panel-children', 'panel-default', $heading, $body)\n    #end\n  #end\n#end\n#######################################################\n##                 LEGACY CHILDREN\n##\n## Get the children document based on the legacy\n## parent/child relationship.\n#######################################################\n#macro(getChildren_legacy)\n  #if($services.parentchild.isParentChildMechanismEnabled())\n    #set($childrenStatement = 'where doc.fullName <> :parentFullName and (doc.parent = :parentFullName or (doc.parent = :parentName and doc.space = :parentSpace))')\n    #set($childrenQuery = $services.query.xwql($childrenStatement))\n    #set($discard = $childrenQuery.bindValue('parentFullName', $doc.fullName).bindValue('parentName', $doc.documentReference.name).bindValue('parentSpace', $doc.space))\n    #set($children = $childrenQuery.addFilter('unique').execute())\n    #if($children && $children.size() > 0)\n      #define($heading)\n        <strong>Orphans</strong> ($children.size())\n      #end\n      #define($message)\n        <ul>\n          #foreach($docname in $children)\n            #set($rdoc = $xwiki.getDocument($docname).getTranslatedDocument())\n            <li><a href=\"$doc.getURL('view')\">$escapetool.xml($rdoc.getPlainTitle())</a></li>\n          #end\n        </ul>\n      #end\n      #set($body = $services.localization.render('core.delete.orphansWarning', [$message]))\n      #displayPanel('panel-legacy-children', 'panel-default', $heading, $body)\n    #end\n  #end\n#end\n#######################################################\n##                 DISPLAY NEW TARGET OPTION\n##\n## Display the possibility to select a new target for existing backlinks and / or to create an automatic redirect to a\n## different page.\n#######################################################\n#macro(displayNewTargetOption)\n  #set($links = $doc.getBacklinks())\n  #set ($hasInlinks = $links && $links.size() > 0)\n  #define($heading)\n    <strong>$escapetool.xml($services.localization.render('core.delete.backlinks'))</strong> ($links.size())\n  #end\n  #define($body)\n    <dl>\n      <dt>\n        <label for=\"newBacklinkTarget\">\n          $escapetool.xml($services.localization.render('core.delete.backlinkTarget.label'))\n        </label>\n        <span class=\"xHint\">$escapetool.xml($services.localization.render('core.delete.backlinkTarget.hint'))</span>\n      </dt>\n      <dd>\n        #set ($pagePickerParams = {\n          'id': 'newBacklinkTarget',\n          'name': 'newBacklinkTarget'\n        })\n        #pagePicker($pagePickerParams)\n      </dd>\n      ##------------\n      ## Links field\n      ##------------\n      #displayLinksCheckbox({\n        'label': 'core.delete.updateLinks.label',\n        'hint': 'core.delete.updateLinks.hint',\n        'disabled': true\n      })\n      #displayAutoRedirectCheckbox({\n        'label': 'core.delete.autoRedirect.label',\n        'hint': 'core.delete.autoRedirect.hint',\n        'disabled': true\n      })\n    </dl>\n  #end\n  $body\n#end\n#######################################################\n##              DISPLAY CONFIRM MESSAGE\n#######################################################\n#macro(displayConfirmMessage)\n  #if($xwiki.hasRecycleBin())\n    #if($services.refactoring.isRecycleBinSkippingAllowed())\n      <div class=\"xform\">\n        <dl>\n          <dt>\n            $escapetool.xml($services.localization.render('core.recycleBin.shouldSkip.label'))\n          </dt>\n          <dd>\n            <label class=\"xwiki-form-listclass\">\n              <input name=\"shouldSkipRecycleBin\" type=\"radio\" value=\"false\" checked/>\n              $escapetool.xml($services.localization.render('core.recycleBin.shouldSkip.no'))\n            </label>\n            <label class=\"xwiki-form-listclass\">\n              <input name=\"shouldSkipRecycleBin\" type=\"radio\" value=\"true\"/>\n              $escapetool.xml($services.localization.render('core.recycleBin.shouldSkip.yes'))\n            </label>\n          </dd>\n        </dl>\n      </div>\n    #else\n      #if($hasInlinks)\n        <p><strong>$escapetool.xml($services.localization.render('core.recyclebin.confirmWithInlinks'))</strong></p>\n      #else\n        <p>$escapetool.xml($services.localization.render('core.recyclebin.confirm'))</p>\n      #end\n    #end\n  #else\n    #if($hasInlinks)\n      <p><strong>$escapetool.xml($services.localization.render('core.delete.confirmWithInlinks'))</strong></p>\n    #else\n      <p>$escapetool.xml($services.localization.render('core.delete.confirm'))</p>\n    #end\n  #end\n  <div class=\"hidden\">\n    <input type=\"hidden\" name=\"form_token\" value=\"$!{services.csrf.getToken()}\" />\n    <input type=\"hidden\" name=\"confirm\" value=\"1\"/>\n    <input type=\"hidden\" name=\"async\" value=\"true\"/>\n    #if(\"$!{request.xredirect}\" != '')\n      <input type=\"hidden\" name=\"xredirect\" value=\"$!{escapetool.xml($request.xredirect)}\"/>\n    #end\n  </div>\n  <button class=\"btn btn-danger confirm\">$escapetool.xml($services.localization.render('delete'))</button>\n  #if(\"$!{request.xredirect}\" != '')\n    #set($cancelUrl = \"$request.xredirect\")\n  #else\n    #set($cancelUrl = $doc.getURL())\n  #end\n  <a class=\"btn btn-default cancel\" href=\"$!{escapetool.xml(${cancelUrl})}\">$escapetool.xml($services.localization.render('cancel'))</a>\n#end\n#######################################################\n##      DISPLAY DELETE COMPLETELY CONFIRM MESSAGE\n##\n## Display a confirmation message when the user wants \n## to delete a page from the recycle bin.\n#######################################################\n#macro(displayCompletelyDeleteConfirmMessage)\n  #xwikimessageboxstart($services.localization.render('core.delete') $services.localization.render('core.recyclebin.completelyDeleteConfirm'))\n    <form action=\"$xwiki.relativeRequestURL\" method=\"post\">\n      <div class=\"hidden\">\n        ## CSRF prevention\n        <input type=\"hidden\" name=\"form_token\" value=\"$!{services.csrf.getToken()}\" />\n        <input type=\"hidden\" name=\"confirm\" value=\"1\"/>\n        <input type=\"hidden\" name=\"id\" value=\"$!{escapetool.xml($request.id)}\"/>\n        #if(\"$!{request.xredirect}\" != '')\n          <input type=\"hidden\" name=\"xredirect\" value=\"$!{escapetool.xml($request.xredirect)}\"/>\n        #end\n      </div>\n      <input type=\"submit\" class=\"btn btn-primary\" value=\"$services.localization.render('yes')\"/>\n      #if(\"$!{request.xredirect}\" != '')\n        #set($cancelUrl = \"$request.xredirect\")\n      #else\n        #set($cancelUrl = $doc.getURL())\n      #end\n      <a class=\"btn btn-default\" href=\"$!{escapetool.xml(${cancelUrl})}\">$services.localization.render('no')</a>\n    </form>\n  #xwikimessageboxend()\n#end\n", "output": {"vulnerability_count": 2, "vulnerabilities": [{"description": "`$discard` is assigned twice; the first assignment is useless", "risk": "Medium", "conceptual_fix": "Not provided", "line": 94}, {"description": "`$discard` is assigned twice; the first assignment is useless", "risk": "Medium", "conceptual_fix": "Not provided", "line": 96}]}}
{"CVE": "CVE-2023-39000", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "<?php\n\n/*\n * Copyright (C) 2019 Deciso B.V.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\nnamespace OPNsense\\Diagnostics;\n\nuse OPNsense\\Base\\IndexController;\n\n/**\n * @inherit\n */\nclass LogController extends IndexController\n{\n    public function renderPage($module, $scope)\n    {\n        $this->view->pick('OPNsense/Diagnostics/log');\n        $this->view->module = $module;\n        $this->view->scope = $scope;\n        $this->view->service = '';\n        $this->view->default_log_severity = 'Warning';\n\n        $service = $module == 'core' ? $scope : $module;\n\n        /* XXX manually hook up known services and log severities for now */\n        switch ($service) {\n            case 'filter':\n                $this->view->default_log_severity = 'Informational';\n                break;\n            case 'ipsec':\n                $this->view->service = 'ipsec';\n                break;\n            case 'resolver':\n                $this->view->service = 'unbound';\n                break;\n            case 'suricata':\n                $this->view->service = 'ids';\n                break;\n            case 'squid':\n                $this->view->service = 'proxy';\n                break;\n            case 'system':\n                $this->view->default_log_severity = 'Notice';\n                break;\n            default:\n                /* no service API at the moment */\n                break;\n        }\n    }\n\n    public function __call($name, $arguments)\n    {\n        if (substr($name, -6) == 'Action') {\n            $scope = count($arguments) > 0 ? $arguments[0] : \"core\";\n            $module = substr($name, 0, strlen($name) - 6);\n            return $this->renderPage($module, $scope);\n        }\n    }\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2023-41054", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "<?php\n    function get_base_url($url) {\n        $split_url = explode(\"/\", $url);\n        $base_url = $split_url[0] . \"//\" . $split_url[2] . \"/\";\n        return $base_url;\n    }\n\n    function get_root_domain($url) {\n        $split_url = explode(\"/\", $url);\n        $base_url = $split_url[2];\n\n        $base_url_main_split = explode(\".\", strrev($base_url));\n        $root_domain = strrev($base_url_main_split[1]) . \".\" . strrev($base_url_main_split[0]);\n\n        return $root_domain;\n    }\n\n    function try_replace_with_frontend($url, $frontend, $original, $opts) {\n        $frontends = $opts->frontends;\n\n        if (array_key_exists($frontend, $opts->frontends)) {\n            $frontend = $frontends[$frontend][\"instance_url\"];\n\n            if (empty(trim($frontend)))\n                return $url;\n\n            if (strpos($url, \"wikipedia.org\") !== false) {\n                $wiki_split = explode(\".\", $url);\n                if (count($wiki_split) > 1) {\n                    $lang = explode(\"://\", $wiki_split[0])[1];\n                    $url =  $frontend . explode($original, $url)[1] . (strpos($url, \"?\") !== false ? \"&\" : \"?\")  . \"lang=\" . $lang;\n                }\n            } else if (strpos($url, \"fandom.com\") !== false) {\n                $fandom_split = explode(\".\", $url);\n                if (count($fandom_split) > 1) {\n                    $wiki_name = explode(\"://\", $fandom_split[0])[1];\n                    $url =  $frontend . \"/\" . $wiki_name . explode($original, $url)[1];\n                }\n            } else if (strpos($url, \"gist.github.com\") !== false) {\n                $gist_path = explode(\"gist.github.com\", $url)[1];\n                $url = $frontend . \"/gist\" . $gist_path;\n            } else if (strpos($url, \"stackexchange.com\") !== false) {\n                $se_domain = explode(\".\", explode(\"://\", $url)[1])[0];\n                $se_path = explode(\"stackexchange.com\", $url)[1];\n                $url = $frontend . \"/exchange\" . \"/\" . $se_domain . $se_path;\n            } else {\n                $url =  $frontend . explode($original, $url)[1];\n            }\n\n\n            return $url;\n        }\n\n        return $url;\n    }\n\n    function check_for_privacy_frontend($url, $opts) {\n        if ($opts->disable_frontends)\n            return $url;\n\n        foreach($opts->frontends as $frontend => $data) {\n            $original = $data[\"original_url\"];\n\n            if (strpos($url, $original)) {\n                $url = try_replace_with_frontend($url, $frontend, $original, $opts);\n                break;\n            } else if (strpos($url, \"stackexchange.com\")) {\n                $url = try_replace_with_frontend($url, \"anonymousoverflow\", \"stackexchange.com\", $opts);\n                break;\n            }\n        }\n\n        return $url;\n    }\n\n    function get_xpath($response) {\n        if (!$response)\n            return null;\n\n        $htmlDom = new DOMDocument;\n        @$htmlDom->loadHTML($response);\n        $xpath = new DOMXPath($htmlDom);\n\n        return $xpath;\n    }\n\n    function request($url) {\n        $config ??= require \"config.php\";\n\n        $ch = curl_init($url);\n        curl_setopt_array($ch, $config->curl_settings);\n        $response = curl_exec($ch);\n\n        return $response;\n    }\n\n    function human_filesize($bytes, $dec = 2) {\n        $size   = array('B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB');\n        $factor = floor((strlen($bytes) - 1) / 3);\n\n        return sprintf(\"%.{$dec}f \", $bytes / pow(1024, $factor)) . @$size[$factor];\n    }\n\n    function remove_special($string) {\n        $string = preg_replace(\"/[\\r\\n]+/\", \"\\n\", $string);\n        return trim(preg_replace(\"/\\s+/\", ' ', $string));\n     }\n\n    function print_elapsed_time($start_time) {\n            $end_time = number_format(microtime(true) - $start_time, 2, '.', '');\n            echo \"<p id=\\\"time\\\">Fetched the results in $end_time seconds</p>\";\n        }\n\n    function print_next_page_button($text, $page, $query, $type) {\n        echo \"<form class=\\\"page\\\" action=\\\"search.php\\\" target=\\\"_top\\\" method=\\\"get\\\" autocomplete=\\\"off\\\">\";\n        echo \"<input type=\\\"hidden\\\" name=\\\"p\\\" value=\\\"\" . $page . \"\\\" />\";\n        echo \"<input type=\\\"hidden\\\" name=\\\"q\\\" value=\\\"$query\\\" />\";\n        echo \"<input type=\\\"hidden\\\" name=\\\"t\\\" value=\\\"$type\\\" />\";\n        echo \"<button type=\\\"submit\\\">$text</button>\";\n        echo \"</form>\";\n    }\n\n    function copy_cookies($curl) {\n        if (array_key_exists(\"HTTP_COOKIE\", $_SERVER))\n            curl_setopt( $curl, CURLOPT_COOKIE, $_SERVER['HTTP_COOKIE'] );\n    }\n\n    \n    function get_country_emote($code) {\n        $emoji = [];\n        foreach(str_split($code) as $c) {\n            if(($o = ord($c)) > 64 && $o % 32 < 27) {\n                $emoji[] = hex2bin(\"f09f87\" . dechex($o % 32 + 165));\n                continue;\n            }\n            \n            $emoji[] = $c;\n        }\n\n        return join($emoji);\n    }\n\n?>\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2023-4220", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "<?php\n\nrequire_once '../../../../global.inc.php';\nrequire_once api_get_path(SYS_CODE_PATH).'work/work.lib.php';\n\nclass BigUploadResponse\n{\n    /**\n     * Temporary directory for uploading files.\n     */\n    const TEMP_DIRECTORY = '/tmp/';\n\n    /**\n     * Directory files will be moved to after the upload is completed.\n     */\n    const MAIN_DIRECTORY = '../files/';\n\n    /**\n     * Max allowed filesize. This is for unsupported browsers and\n     * as an additional security check in case someone bypasses the js filesize check.\n     */\n    private $maxSize;\n\n    /**\n     * Temporary directory.\n     *\n     * @var string\n     */\n    private $tempDirectory;\n\n    /**\n     * Directory for completed uploads.\n     *\n     * @var string\n     */\n    private $mainDirectory;\n\n    /**\n     * Name of the temporary file. Used as a reference to make sure chunks get written to the right file.\n     *\n     * @var string\n     */\n    private $tempName;\n\n    /**\n     * Constructor function, sets the temporary directory and main directory.\n     */\n    public function __construct()\n    {\n        $tempDirectory = api_get_path(SYS_ARCHIVE_PATH);\n        $this->setTempDirectory($tempDirectory);\n        $this->setMainDirectory(self::MAIN_DIRECTORY);\n        $this->maxSize = getIniMaxFileSizeInBytes();\n    }\n\n    /**\n     * Create a random file name for the file to use as it's being uploaded.\n     *\n     * @param string $value Temporary filename\n     */\n    public function setTempName($value = null)\n    {\n        if ($value) {\n            $this->tempName = $value;\n        } else {\n            if ('learnpath' === $_REQUEST['origin'] && !empty($_REQUEST['name'])) {\n                $this->tempName = disable_dangerous_file(\n                    api_replace_dangerous_char($_REQUEST['name'])\n                );\n            } else {\n                $this->tempName = mt_rand().'.tmp';\n            }\n        }\n    }\n\n    /**\n     * Return the name of the temporary file.\n     *\n     * @return string Temporary filename\n     */\n    public function getTempName()\n    {\n        return $this->tempName;\n    }\n\n    /**\n     * Set the name of the temporary directory.\n     *\n     * @param string $value Temporary directory\n     */\n    public function setTempDirectory($value)\n    {\n        $this->tempDirectory = $value;\n\n        return true;\n    }\n\n    /**\n     * Return the name of the temporary directory.\n     *\n     * @return string Temporary directory\n     */\n    public function getTempDirectory()\n    {\n        return $this->tempDirectory;\n    }\n\n    /**\n     * Set the name of the main directory.\n     *\n     * @param string $value Main directory\n     */\n    public function setMainDirectory($value)\n    {\n        $this->mainDirectory = $value;\n    }\n\n    /**\n     * Return the name of the main directory.\n     *\n     * @return string Main directory\n     */\n    public function getMainDirectory()\n    {\n        return $this->mainDirectory;\n    }\n\n    /**\n     * Function to upload the individual file chunks.\n     *\n     * @return string JSON object with result of upload\n     */\n    public function uploadFile()\n    {\n        //Make sure the total file we're writing to hasn't surpassed the file size limit\n        if (file_exists($this->getTempDirectory().$this->getTempName())) {\n            if (filesize($this->getTempDirectory().$this->getTempName()) > $this->maxSize) {\n                $this->abortUpload();\n\n                return json_encode([\n                        'errorStatus' => 1,\n                        'errorText' => get_lang('UplFileTooBig'),\n                    ]);\n            }\n        }\n\n        //Open the raw POST data from php://input\n        $fileData = file_get_contents('php://input');\n\n        //Write the actual chunk to the larger file\n        $handle = fopen($this->getTempDirectory().$this->getTempName(), 'a');\n\n        fwrite($handle, $fileData);\n        fclose($handle);\n\n        return json_encode([\n            'key' => $this->getTempName(),\n            'errorStatus' => 0,\n        ]);\n    }\n\n    /**\n     * Function for cancelling uploads while they're in-progress; deletes the temp file.\n     *\n     * @return string JSON object with result of deletion\n     */\n    public function abortUpload()\n    {\n        if (unlink($this->getTempDirectory().$this->getTempName())) {\n            return json_encode(['errorStatus' => 0]);\n        } else {\n            return json_encode([\n                'errorStatus' => 1,\n                'errorText' => get_lang('UnableToDeleteTempFile'),\n            ]);\n        }\n    }\n\n    /**\n     * Function to rename and move the finished file.\n     *\n     * @return string JSON object with result of rename\n     */\n    public function finishUpload()\n    {\n        $tempName = $this->getTempName();\n\n        $sessionBigUpload = ChamiloSession::read('bigupload', []);\n\n        if (!isset($sessionBigUpload[$tempName])) {\n            return json_encode(\n                [\n                    'errorStatus' => 1,\n                    'errorText' => get_lang('UnableToDeleteTempFile'),\n                ]\n            );\n        }\n\n        /** @var string $finalName Name to rename the finished upload to */\n        $finalName = $sessionBigUpload[$tempName];\n\n        $origin = $_POST['origin'];\n        if ($origin == 'document') {\n            $tmpFile = $this->getTempDirectory().$this->getTempName();\n            chmod($tmpFile, '0777');\n            $file = [\n                'name' => $finalName,\n                'type' => $_POST['type'],\n                'tmp_name' => $tmpFile,\n                'error' => 0,\n                'size' => $_POST['size'],\n                'copy_file' => true,\n            ];\n            $files = ['file' => $file];\n            $unzip = isset($_POST['unzip']) ? $_POST['unzip'] : null;\n            $index = isset($_POST['index_document']) ? $_POST['index_document'] : null;\n            DocumentManager::upload_document(\n                $files,\n                $_POST['curdirpath'],\n                $_POST['title'],\n                $_POST['comment'],\n                $unzip,\n                $_POST['if_exists'],\n                $index,\n                true\n            );\n            $redirectUrl = api_get_path(WEB_CODE_PATH).'document/document.php?'.api_get_cidreq();\n            if (!empty($_POST['id'])) {\n                $redirectUrl .= '&'.http_build_query(\n                    [\n                        'id' => $_POST['id'],\n                    ]\n                );\n            }\n\n            return json_encode(['errorStatus' => 0, 'redirect' => $redirectUrl]);\n        } elseif ($origin == 'learnpath') {\n            unset($_REQUEST['origin']);\n            $redirectUrl = api_get_path(WEB_CODE_PATH).'upload/upload.php?'.api_get_cidreq().'&'\n                .http_build_query(\n                    [\n                        'from' => 'bigUpload',\n                        'name' => $this->getTempName(),\n                        'use_max_score' => $_POST['use_max_score'] ?? 0,\n                    ]\n                );\n\n            return json_encode(['errorStatus' => 0, 'redirect' => $redirectUrl]);\n        } elseif ($origin == 'work') {\n            $tmpFile = $this->getTempDirectory().$this->getTempName();\n            chmod($tmpFile, '0777');\n            $workInfo = get_work_data_by_id($_REQUEST['id']);\n            $values = $_REQUEST;\n            $courseInfo = api_get_course_info();\n            $sessionId = api_get_session_id();\n            $groupId = api_get_group_id();\n            $userId = api_get_user_id();\n            $values['contains_file'] = 1;\n            $values['title'] = $finalName;\n            $file = [\n                'name' => $finalName,\n                'type' => $_POST['type'],\n                'tmp_name' => $tmpFile,\n                'error' => 0,\n                'size' => $_POST['size'],\n                'copy_file' => true,\n            ];\n\n            // Process work\n            $result = processWorkForm(\n                $workInfo,\n                $values,\n                $courseInfo,\n                $sessionId,\n                $groupId,\n                $userId,\n                $file,\n                api_get_configuration_value('assignment_prevent_duplicate_upload')\n            );\n            $extraParams = '';\n            if (!empty($_SESSION['oLP'])) {\n                $extraParams .= '&origin=learnpath';\n            }\n            $redirectUrl = api_get_path(WEB_CODE_PATH).'work/work.php?'.api_get_cidreq().$extraParams;\n\n            return json_encode(['errorStatus' => 0, 'redirect' => $redirectUrl]);\n        }\n\n        return json_encode(['errorStatus' => 0]);\n    }\n\n    /**\n     * Basic php file upload function, used for unsupported browsers.\n     * The output on success/failure is very basic, and it would be best to have these errors return the user to index.html\n     * with the errors printed on the form, but that is beyond the scope of this project as it is very application specific.\n     *\n     * @return string Success or failure of upload\n     */\n    public function postUnsupported()\n    {\n        $name = $_FILES['bigUploadFile']['name'];\n        $size = $_FILES['bigUploadFile']['size'];\n        $tempName = $_FILES['bigUploadFile']['tmp_name'];\n\n        if (filesize($tempName) > $this->maxSize) {\n            return get_lang('UplFileTooBig');\n        }\n\n        if (move_uploaded_file($tempName, $this->getMainDirectory().$name)) {\n            return get_lang('FileUploadSucces');\n        } else {\n            return get_lang('UplUnableToSaveFile');\n        }\n    }\n}\n\n$sessionBigUpload = ChamiloSession::read('bigupload', []);\n\n//Instantiate the class\n$bigUpload = new BigUploadResponse();\n\n//Set the temporary filename\n$tempName = null;\nif (isset($_GET['key'])) {\n    $tempName = $_GET['key'];\n}\nif (isset($_POST['key'])) {\n    $tempName = $_POST['key'];\n}\n\nif (!empty($tempName)) {\n    $tempName = api_replace_dangerous_char($tempName);\n    $tempName = disable_dangerous_file($tempName);\n}\n\n$bigUpload->setTempName($tempName);\n\nif (isset($_GET['name'])) {\n    $sessionBigUpload[$bigUpload->getTempName()] = disable_dangerous_file(\n        api_replace_dangerous_char($_GET['name'])\n    );\n    ChamiloSession::write('bigupload', $sessionBigUpload);\n}\n\nswitch ($_GET['action']) {\n    case 'upload':\n        print $bigUpload->uploadFile();\n        break;\n    case 'abort':\n        print $bigUpload->abortUpload();\n        break;\n    case 'finish':\n        print $bigUpload->finishUpload();\n\n        if (isset($sessionBigUpload[$bigUpload->getTempName()])) {\n            unset($sessionBigUpload[$bigUpload->getTempName()]);\n\n            ChamiloSession::write('bigupload', $sessionBigUpload);\n        }\n        break;\n    case 'post-unsupported':\n        print $bigUpload->postUnsupported();\n        break;\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2023-45135", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\n/*!\n#set ($paths = {\n  'treeRequireConfig': $services.webjars.url('org.xwiki.platform:xwiki-platform-tree-webjar', 'require-config.min.js',\n    {'evaluate': true, 'minify': $services.debug.minify})\n})\n#set ($l10nKeys = [\n  'entitynamevalidation.nametransformation.error',\n  'core.validation.valid.message',\n  'core.validation.required.message',\n  'core.validation.required.message.terminal'\n])\n#set ($l10n = {})\n#foreach ($key in $l10nKeys)\n  #set ($discard = $l10n.put($key, $services.localization.render($key)))\n#end\n#[[*/\n// Start JavaScript-only code.\n(function(paths, l10n) {\n  \"use strict\";\n\n// Location Tree Picker\nrequire([paths.treeRequireConfig], function() {\n  require(['tree'], function($) {\n    $('.location-picker').each(function() {\n      var picker = $(this);\n      var trigger = picker.find('.location-action-pick');\n      var modal = picker.find('.modal');\n      var treeElement = modal.find('.location-tree');\n      var selectButton = modal.find('.modal-footer .btn-primary');\n\n      trigger.on('click', function(event) {\n        event.preventDefault();\n        modal.modal();\n      });\n\n      modal.on('shown.bs.modal', function(event) {\n        // Open to the specified node only once. Preserve the tree state otherwise.\n        var openToNodeId = trigger.attr('data-openTo');\n        if (openToNodeId && openToNodeId !== modal.data('openTo')) {\n          modal.data('openTo', openToNodeId);\n        } else {\n          openToNodeId = false;\n        }\n        var tree = $.jstree.reference(treeElement);\n        if (!tree) {\n          // Initialize the tree and hook the event listeners.\n          treeElement.xtree({\n            core: {\n              multiple: treeElement.data('multiple') === 'true'\n            }\n          }).one('ready.jstree', function(event, data) {\n            openToNodeId && data.instance.openTo(openToNodeId);\n          }).on('changed.jstree', function(event, data) {\n            selectButton.prop('disabled', !data.selected.length);\n          }).on('dblclick', '.jstree-anchor', function() {\n            selectButton.click();\n          });\n        } else if (openToNodeId) {\n          tree.deselect_all();\n          tree.close_all();\n          tree.openTo(openToNodeId);\n        }\n      });\n\n      selectButton.on('click', function() {\n        modal.modal('hide');\n        modal.triggerHandler('xwiki:locationTreePicker:select', {\n          'tree': $.jstree.reference(treeElement)\n        });\n      });\n    });\n  });\n});\n\n// Document Tree Picker\nrequire(['jquery', 'xwiki-meta'], function($, xm) {\n  $('.location-picker').each(function() {\n    var picker = $(this);\n    // The wiki field can be either a select (drop down) or an input (text or hidden).\n    var wikiField = picker.find('.location-wiki-field');\n    var parentField = picker.find('input.location-parent-field');\n\n    picker.find('.location-action-pick').on('click', function(event) {\n      // Open to the parent wiki, by default. The wiki node should be visible in the tree, otherwise we wouldn't be able\n      // to move pages to top level, under the wiki node.\n      var wiki = wikiField.val() || xm.wiki;\n      var openToNodeId = 'wiki:' + wiki;\n      if (parentField.val()) {\n        // Open to the parent document, if specified.\n        var spaceReference = XWiki.Model.resolve(parentField.val(), XWiki.EntityType.SPACE, [wiki]);\n        var documentReference = new XWiki.EntityReference('WebHome', XWiki.EntityType.DOCUMENT, spaceReference);\n        openToNodeId = 'document:' + XWiki.Model.serialize(documentReference);\n      }\n      $(this).attr('data-openTo', openToNodeId);\n    });\n\n    picker.find('.modal').on('xwiki:locationTreePicker:select', function(event, data) {\n      var selectedNodeId = data.tree.get_selected()[0];\n      var separatorIndex = selectedNodeId.indexOf(':');\n      var nodeType = selectedNodeId.substr(0, separatorIndex);\n      var nodeStringReference = selectedNodeId.substr(separatorIndex + 1);\n      var nodeReference = XWiki.Model.resolve(nodeStringReference, XWiki.EntityType.byName(nodeType));\n      var wikiReference = nodeReference.extractReference(XWiki.EntityType.WIKI);\n      wikiField.val(wikiReference ? wikiReference.name : '');\n      var spaceReference = nodeReference.extractReference(XWiki.EntityType.SPACE);\n      var localSpaceReference = spaceReference ? XWiki.Model.serialize(spaceReference.relativeTo(wikiReference)) : '';\n\n      // Set the selected value and trigger and update of the location preview.\n      parentField.val(localSpaceReference);\n      // Notify interested listeners that we have new input. Note: PrototypeJS listeners will not be notified.\n      parentField.triggerHandler('input');\n    });\n  });\n});\n\n// Live synchronization between the Title, Location, Wiki, Parent and Name (as you type)\nrequire(['jquery', 'xwiki-meta', 'xwiki-events-bridge', 'xwiki-form-validation-async'], function($, xm) {\n  $('.location-picker').each(function() {\n    var picker = $(this);\n    var form = picker.closest('form');\n\n    var titleInput = picker.find('input.location-title-field');\n    // The wiki field can be either a select (drop down) or an input (text or hidden).\n    var wikiField = picker.find('.location-wiki-field');\n    var spaceReferenceInput = picker.find('input.location-parent-field');\n    var nameInput = picker.find('input.location-name-field');\n    var locationContainer = picker.find('.breadcrumb');\n    // Input timeouts used to avoid handling too soon each individual letter, as the user types.\n    var inputDelay = 500;\n\n    /**\n     * Compute a page name from a given title.\n     **/\n    var getPageName = function(title) {\n      var url = XWiki.currentDocument.getURL(\"get\");\n      return Promise.resolve($.get(url, {\n        'xpage': 'entitynamevalidation_json',\n        'outputSyntax': 'plain',\n        'name': title,\n        'form_token': xm.form_token\n      }));\n    };\n\n    /**\n     * Update the last element in the location preview.\n     * \n     * @param value the value to use\n     */\n    var updateLocationLastElement = function(value) {\n      var lastElement = locationContainer.children('.preview');\n      if (lastElement.length === 0) {\n        lastElement = $(document.createElement('li')).addClass('preview active').appendTo(locationContainer);\n      }\n      lastElement.text(value);\n    };\n\n    /**\n     * Event handler for the title input that updates both the location preview's last element and the name input.\n     **/\n    var scheduleUpdateOfLocationAndNameFromTitleInput = function(event) {\n      // Disable the page name input while its value is being updated based on the page title. This also disables the\n      // page name validation (client-side) until we receive the computed page name (a 'change' event is triggered\n      // afterwards in order to perform the synchronous client-side page name validation).\n      nameInput.prop('disabled', true);\n      if (event?.type === 'input') {\n        // Delay the update.\n        titleInput.validateAsync(updateLocationAndNameFromTitleInput, inputDelay, 'locationPicker');\n      } else {\n        // Update right away.\n        titleInput.validateAsync(updateLocationAndNameFromTitleInput(), 'locationPicker');\n      }\n    };\n\n    var updateLocationAndNameFromTitleInput = function() {\n      var titleInputVal = titleInput.val();\n      // Update the name field.\n      return getPageName(titleInputVal).then(data => {\n        // Ensure that the input didn't change while we were waiting the answer.\n        // It also protects the value if a previous request was slow to arrive.\n        if (titleInputVal === titleInput.val()) {\n          // Re-enable the page name input and trigger a change event to execute the client-side validations.\n          nameInput.prop('disabled', false).val(data.transformedName).trigger('change');\n\n          // Update the location preview.\n          updateLocationFromTitleInput();\n        }\n      }).catch(() => {\n        if (titleInputVal === titleInput.val()) {\n          new XWiki.widgets.Notification(l10n['entitynamevalidation.nametransformation.error'], 'error');\n          // Re-enable the page name input and trigger a change event to execute the client-side validations.\n          nameInput.prop('disabled', false).val(titleInputVal).trigger('change');\n          // Update the location preview.\n          updateLocationFromTitleInput();\n        }\n      });\n    };\n\n    /**\n     * Update the location preview's last element with the value from the title input.\n     **/\n    var updateLocationFromTitleInput = function() {\n      updateLocationLastElement(titleInput.val());\n    };\n\n    /**\n     * Event handler for the name input that updates the location preview's last element.\n     **/\n    var updateLocationFromNameInput = function(event) {\n      // Only update the location from the name when there is no title provided.\n      if (!titleInput.val()) {\n        updateLocationLastElement(nameInput.val());\n      }\n    };\n\n    var updateLocationFromTitleOrNameInput = function() {\n      var title = titleInput.val();\n      updateLocationLastElement(title ? title : nameInput.val());\n    };\n\n    /**\n     * Event handler for the space reference input that updates the location preview's space part.\n     **/\n    var updateLocationFromSpaceReference = function(event, data) {\n      var spaceReference;\n      if (data) {\n        // Suggest widget selection event.\n        spaceReference = data.value;\n      } else {\n        // Regular input event.\n        spaceReference = spaceReferenceInput.val();\n      }\n\n      // Delay the execution in case the user is still typing.\n      locationContainer.validateAsync(() => {\n        return updateLocation(wikiField.val(), spaceReference);\n      }, inputDelay, 'locationPicker');\n    };\n\n    var updateLocationFromWikiField = function(event) {\n      // TODO: Don't reload the entire location when the wiki changes. We should be able to update only the wiki element,\n      // but we need to be able to \"detect\" it (e.g. the breadcrumb should add some CSS classes on the path elements).\n      locationContainer.validateAsync(updateLocation, 'locationPicker');\n    };\n\n    var updateLocation = function(wiki, localSpaceReference) {\n      wiki = wiki || wikiField.val();\n      localSpaceReference = localSpaceReference || spaceReferenceInput.val();\n\n      // We need to pass a document reference to the hierarchy_reference template and we cannot create a document\n      // reference without the space reference. If the space reference is empty we use the current space reference and\n      // we remove the extra path elements afterwards from the breadcrumb HTML.\n      var spaceReference = XWiki.Model.resolve(localSpaceReference || xm.space, XWiki.EntityType.SPACE);\n      var documentReference = new XWiki.EntityReference('WebHome', XWiki.EntityType.DOCUMENT, spaceReference);\n      wiki && spaceReference.appendParent(new XWiki.WikiReference(wiki));\n\n      return $.post(getCurrentPageURL(), {\n        'xpage': 'hierarchy_reference',\n        'reference': XWiki.Model.serialize(documentReference)\n      }, function(data) {\n        // Update the space reference part of the new location.\n        var newLocationContainer = $(data);\n        // Preserve the id because it is needed for the asynchronous validation key.\n        newLocationContainer.attr('id', locationContainer.attr('id'));\n        locationContainer.replaceWith(newLocationContainer);\n        locationContainer = newLocationContainer;\n\n        // Remove all breadcrumb items that don't represent wikis if the space reference was empty.\n        localSpaceReference || locationContainer.find('li').not('.wiki').remove();\n\n        // Remove any redundant 'active' elements that we might inherit from the AJAX call, since the only active\n        // element will be the page name preview that we create.\n        locationContainer.find('.active').removeClass('active');\n\n        // Update the document part of the new location.\n        updateLocationFromTitleOrNameInput();\n      });\n    };\n\n    var getCurrentPageURL = function() {\n      var spaceReference = XWiki.Model.resolve(xm.space, XWiki.EntityType.SPACE);\n      var spacePath = spaceReference.getReversedReferenceChain().map(function(entityReference) {\n        return encodeURIComponent(entityReference.name);\n      }).join('/');\n\n      var url = XWiki.Document.URLTemplate;\n      url = url.replace('__space__', spacePath);\n      url = url.replace('__page__', xm.page);\n      url = url.replace('__action__', 'get');\n\n      return url;\n    };\n\n    // Synchronize the location fields while the user types.\n    // We catch the change event because we want to make sure everything's updated when the user change fields\n    // (particulary useful in our automated tests).\n    titleInput.on('input change', scheduleUpdateOfLocationAndNameFromTitleInput);\n    wikiField.on('change', updateLocationFromWikiField);\n    nameInput.on('input change', updateLocationFromNameInput);\n    spaceReferenceInput.on('input change xwiki:suggest:selected', updateLocationFromSpaceReference);\n\n    // Clean the output of the hierarchy macro when it should display a top level document.\n    if (!spaceReferenceInput.val()) {\n      updateLocationFromSpaceReference();\n    }\n\n    // Update the location with whatever the initial value of the title is.\n    if (nameInput.val() !== undefined && !nameInput.val() && titleInput.val()) {\n      scheduleUpdateOfLocationAndNameFromTitleInput();\n    } else {\n      updateLocationFromTitleInput();\n    }\n\n    // Show the location edit options when pressing the pencil button.\n    var locationEdit = picker.find('.location-edit');\n    picker.find('.location-action-edit').on('click', function(event) {\n      event.preventDefault();\n      // Note: Using toggleClass() instead of toggle() because using the 'hidden' class\n      // allows us to have the element hidden by default more easily from Velocity.\n      locationEdit.toggleClass('hidden');\n    });\n  });\n});\n\n//\n// Client-side input validation\n//\nrequire(['jquery'], function($) {\n  //\n  // Generic Validation\n  //\n  var isSimplePicker = function(picker) {\n    return picker.find('.location-actions').length > 0 && picker.find('.location-action-edit').length == 0;\n  };\n\n  var createPageValidator = function(picker) {\n    var pageInput = picker.find('input.location-name-field');\n    if (pageInput.length === 0) {\n      return null;\n    }\n\n    var titleInput = picker.find('input.location-title-field');\n    // The advanced location edit fields are not accessible to simple users.\n    var isSimpleUser = titleInput.length > 0 && isSimplePicker(picker);\n    var pageValidator = new LiveValidation(pageInput[0], {\n      validMessage: l10n['core.validation.valid.message'],\n      // Show the validation message after the title input for simple users because they can't access the page input.\n      insertAfterWhatNode: isSimpleUser ? titleInput[0] : pageInput[0]\n    });\n    pageValidator.displayMessageWhenEmpty = true;\n    pageValidator.add(Validate.Custom, {\n      failureMessage: l10n['core.validation.required.message'],\n      against: function(value) {\n        // The page name must not be blank.\n        return typeof value === 'string' && value.strip().length > 0;\n      }\n    });\n\n    // The page name can be set either directly, by typing in the page input, or indirectly, by typing in the title\n    // input. In the second case the code that updates the page name based on the page title triggers a 'change' event. \n    pageInput.on('change', function() {\n      pageValidator.validate();\n    });\n\n    return pageValidator;\n  };\n\n  var createSpaceValidator = function(picker) {\n    var spaceReferenceInput = picker.find('input.location-parent-field');\n    if (spaceReferenceInput.length > 0) {\n      var breadcrumbContainer = picker.find('.breadcrumb-container');\n      // The advanced location edit fields are not accessible to simple users.\n      var isSimpleUser = breadcrumbContainer.length > 0 && isSimplePicker(picker);\n      var spaceValidator = new LiveValidation(spaceReferenceInput[0], {\n        validMessage: l10n['core.validation.valid.message'],\n        // Validating automatically only on submit to avoid double validation caused by jQuery-PrototypeJS event\n        // triggering incompatibilities when setting the space reference with the tree picker. We are calling validate\n        // manually in the 'input' handler to achieve the same behavior as if 'onlyOnBlur' was false.\n        onlyOnBlur: true,\n        insertAfterWhatNode: isSimpleUser ? breadcrumbContainer[0] : spaceReferenceInput[0]\n      });\n      spaceValidator.displayMessageWhenEmpty = true;\n      return spaceValidator;\n    } else {\n      return null;\n    }\n  };\n\n  var setAllowedValues = function(validator, values, failureMessage) {\n    // Clean any previous existing values validators, using the previous parameters (if available).\n    if (validator._customValuesParams) {\n      validator.remove(Validate.Custom, validator._customValuesParams);\n      delete validator._customValuesParams;\n    }\n\n    // If any values are specified, add a custom validator.\n    if (values.length > 0) {\n      // Store the parameters so we can later be able to remove them in a future call.\n      validator._customValuesParams = {\n        failureMessage: failureMessage,\n        against: function(value) {\n          for (var i=0; i<values.length; i++) {\n            var allowedValue = values[i];\n            // Must be exactly one of the allowed values of prefixed by the allowed value followed by a dot (i.e. parent space).\n            if (allowedValue === value || value.indexOf(allowedValue + '.') === 0) {\n              return true;\n            }\n          }\n\n          // Does not validate for any of the allowed values.\n          return false;\n        }\n      };\n      validator.add(Validate.Custom, validator._customValuesParams);\n    }\n  };\n\n  var addTerminalPageValidation = function(spaceValidator, terminalCheckbox) {\n    spaceValidator.add(Validate.Custom, {\n      failureMessage: l10n['core.validation.required.message.terminal'],\n      against: function(value) {\n        if (terminalCheckbox.prop('checked')) {\n          // Space reference is required for terminal documents.\n          return typeof value === 'string' && value.strip().length > 0;\n        } else {\n          // Space reference can be empty for non-terminal documents.\n          return true;\n        }\n      }\n    });\n\n    // Trigger validation when the terminal status changes.\n    terminalCheckbox.on('change', function() {\n      spaceValidator.validate();\n    });\n  };\n\n  var synchChildrenWithTerminalPage = function(deepCheckbox, terminalCheckbox) {\n    deepCheckbox.on('change', function() {\n      deepCheckbox.prop('checked') && terminalCheckbox.prop('checked', false);\n    });\n    terminalCheckbox.on('change', function() {\n      terminalCheckbox.prop('checked') && deepCheckbox.prop('checked', false);\n    });\n  };\n\n  $('.location-picker').each(function() {\n    var picker = $(this);\n    var pickerValidators = [];\n    // Create the generic space and page input validators.\n    var spaceValidator = createSpaceValidator(picker);\n    if (spaceValidator) {\n      pickerValidators.push(spaceValidator);\n      picker.data('spaceValidator', spaceValidator);\n    }\n    var pageValidator = createPageValidator(picker);\n    if (pageValidator) {\n      pickerValidators.push(pageValidator);\n      picker.data('pageValidator', pageValidator);\n    }\n\n    var locationEdit = picker.find('.location-edit');\n    var locationEditToggle = picker.find('.location-action-edit');\n\n    // If the form is not valid on submission and the location edit is hidden, make sure to display it so that\n    // validation errors are also displayed.\n    picker.closest('form').on('submit', function(event) {\n      var isValid = LiveValidation.massValidate(pickerValidators);\n      if (!isValid && locationEdit.hasClass('hidden')) {\n        // Triggering the click event while handling a click event (the submit event is caused most of the time by\n        // clicking the submit button) has no effect (jQuery simply ignores the trigger call). The workaround is to\n        // trigger the click event right after the current click event is handled.\n        setTimeout(() => locationEditToggle.click(), 0);\n      }\n    });\n\n    // Call validate() manually on the spaceValidator when we get input on the space reference field, because\n    // LiveValidation (PrototypeJS) does not get notified about jQuery triggered events so we have to handle it\n    // ourselves.\n    var spaceReferenceInput = picker.find('input.location-parent-field');\n    spaceReferenceInput.on('input', function() {\n      spaceValidator.validate();\n    });\n  });\n\n  //\n  // Custom validation for the Create Page UI.\n  //\n\n  $('form#create').each(function() {\n    var form = $(this);\n    var picker = form.find('.location-picker');\n    var spaceValidator = picker.data('spaceValidator');\n\n    addTerminalPageValidation(spaceValidator, form.find('#terminal'));\n\n    var updateSpaceValidatorFromTemplateProviderInput = function(input) {\n      var restrictionsAreSuggestions = (input.attr('data-restrictions-are-suggestions') == \"true\");\n\n      var allowedSpaces = [];\n      var allowedSpacesData = input.attr('data-allowed-spaces');\n      // Read the alowed spaces specified by the template provider, unless they are just suggestions in which case they\n      // should be ignored by validation.\n      if (!restrictionsAreSuggestions && allowedSpacesData) {\n        allowedSpaces = JSON.parse(input.attr('data-allowed-spaces'));\n      }\n\n      var message = input.attr('data-allowed-spaces-message');\n\n      setAllowedValues(spaceValidator, allowedSpaces, message);\n    };\n\n    // Update the allowed spaces based on the selected template provider.\n    form.find('.xwiki-select').on('xwiki:select:updated', function (event) {\n      var type = $('input[name=\"type\"]:checked');\n      // Note: Even though the page type selector can provide elements that are not template providers (i.e.\n      // data-type='template'), we still need to clear any previously set validations. The upside of this is that we\n      // are also allowing these page types to specify 'allowed spaces', should they need it at some point.\n      updateSpaceValidatorFromTemplateProviderInput(type);\n      // Validate using the new configuration.\n      spaceValidator.validate();\n    });\n\n    // Make sure the spaceValidator is properly initialized when loading the page.\n    var initiallyCheckedTemplateProviderInput = form.find('input[name=\"templateprovider\"]');\n    if (initiallyCheckedTemplateProviderInput.length == 0) {\n        // If there is no (hidden) input called 'templateprovider', then we should look at the selected value\n        // in the xwiki selector widget\n        initiallyCheckedTemplateProviderInput = form.find('.xwiki-select input[name=\"type\"]:checked');\n    }\n\n    // Note that there could also be no template provider available, but we rely on jQuery's selectors here to avoid null values.\n    updateSpaceValidatorFromTemplateProviderInput(initiallyCheckedTemplateProviderInput);\n  });\n\n  //\n  // Custom validation for the Copy & Rename Page UI.\n  //\n\n  $('form#copy, form#rename').each(function() {\n    var form = $(this);\n    var picker = form.find('.location-picker');\n    var spaceValidator = picker.data('spaceValidator');\n    var terminalCheckbox = form.find('input[name=\"terminal\"]');\n    var deepCheckbox = form.find('input[name=\"deep\"]');\n    var languageSelect = form.find('select[name=\"language\"]');\n\n    addTerminalPageValidation(spaceValidator, terminalCheckbox);\n    synchChildrenWithTerminalPage(deepCheckbox, terminalCheckbox);\n\n    languageSelect.on('change', function() {\n      if (languageSelect.val() === 'ALL') {\n        deepCheckbox.prop('disabled', false);\n      } else {\n        deepCheckbox.prop({\n          'checked': false,\n          'disabled': true\n        });\n      }\n    });\n  });\n});\n\n// End JavaScript-only code.\n}).apply(']]#', $jsontool.serialize([$paths, $l10n]));\n", "output": {"vulnerability_count": 2, "vulnerabilities": [{"description": "Detected the use of require(variable). Calling require with a non-literal argument might allow an attacker to load and run arbitrary code, or access arbitrary files.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 41}, {"description": "User controlled data in a `$(...)` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 280}]}}
{"CVE": "CVE-2023-45958", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "<?php\n/**\n * 2007-2016 PrestaShop\n *\n * thirty bees is an extension to the PrestaShop e-commerce software developed by PrestaShop SA\n * Copyright (C) 2017-2018 thirty bees\n *\n * NOTICE OF LICENSE\n *\n * This source file is subject to the Open Software License (OSL 3.0)\n * that is bundled with this package in the file LICENSE.txt.\n * It is also available through the world-wide-web at this URL:\n * http://opensource.org/licenses/osl-3.0.php\n * If you did not receive a copy of the license and are unable to\n * obtain it through the world-wide-web, please send an email\n * to license@thirtybees.com so we can send you a copy immediately.\n *\n * DISCLAIMER\n *\n * Do not edit or add to this file if you wish to upgrade PrestaShop to newer\n * versions in the future. If you wish to customize PrestaShop for your\n * needs please refer to https://www.thirtybees.com for more information.\n *\n * @author    thirty bees <contact@thirtybees.com>\n * @author    PrestaShop SA <contact@prestashop.com>\n * @copyright 2017-2018 thirty bees\n * @copyright 2007-2016 PrestaShop SA\n * @license   http://opensource.org/licenses/osl-3.0.php  Open Software License (OSL 3.0)\n *  PrestaShop is an internationally registered trademark & property of PrestaShop SA\n */\n\n/**\n * Class HelperListCore\n */\nclass HelperListCore extends Helper\n{\n    /**\n     * @var array $cache_lang use to cache texts in current language\n     */\n    public static $cache_lang = [];\n\n    /**\n     * @var int Number of results in list\n     */\n    public $listTotal = 0;\n\n    /**\n     * @var array Number of results in list per page (used in select field)\n     */\n    public $_pagination = [20, 50, 100, 300, 1000];\n\n    /**\n     * @var int Default number of results in list per page\n     */\n    public $_default_pagination = 50;\n\n    /**\n     * @var string ORDER BY clause determined by field/arrows in list header\n     */\n    public $orderBy;\n\n    /**\n     * @var string Default ORDER BY clause when $orderBy is not defined\n     */\n    public $_defaultOrderBy = false;\n\n    /**\n     * @var array : list of vars for button delete\n     */\n    public $tpl_delete_link_vars = [];\n\n    /**\n     * @var string Order way (ASC, DESC) determined by arrows in list header\n     */\n    public $orderWay;\n\n    /**\n     * @var string\n     */\n    public $identifier;\n\n    /**\n     * @var bool $is_cms\n     */\n    public $is_cms = false;\n\n    /**\n     * @var string\n     */\n    public $position_identifier;\n\n    /**\n     * @var string | int\n     */\n    public $position_group_identifier;\n\n    /**\n     * @var string\n     */\n    public $table_id;\n\n    /**\n     * @var bool Content line is clickable if true\n     */\n    public $no_link = false;\n\n    /**\n     * @var string\n     */\n    public $list_id;\n\n    /**\n     * @var string\n     */\n    public $controller_name;\n\n    /**\n     * @var string\n     */\n    public $imageType;\n\n    /**\n     * @var array list of required actions for each list row\n     */\n    public $actions = [];\n\n    /**\n     * @var array list of row ids associated with a given action for witch this action have to not be available\n     */\n    public $list_skip_actions = [];\n\n    /**\n     * @var array\n     */\n    public $bulk_actions = [];\n\n    /**\n     * @var bool\n     */\n    public $force_show_bulk_actions = false;\n\n    /**\n     * @var string\n     */\n    public $specificConfirmDelete = null;\n\n    /**\n     * @var bool\n     */\n    public $colorOnBackground;\n\n    /**\n     * @var bool If true, activates color on hover\n     */\n    public $row_hover = true;\n\n    /**\n     * @var string|null If not null, a title will be added on that list\n     */\n    public $title = null;\n\n    /**\n     * @var bool ask for simple header : no filters, no paginations and no sorting\n     */\n    public $simple_header = false;\n\n    /**\n     * @var array\n     */\n    public $ajax_params = [];\n\n    /**\n     * @var int\n     */\n    public $page;\n\n    /**\n     * @var string\n     */\n    public $sql;\n\n    /**\n     * @var array Cache for query results\n     */\n    protected $_list = [];\n\n    /**\n     * @var array WHERE clause determined by filter fields\n     */\n    protected $_filter;\n\n    /**\n     * @var int $deleted\n     */\n    protected $deleted = 0;\n\n    /**\n     * @var array Customize list display\n     *\n     * align  : determine value alignment\n     * prefix : displayed before value\n     * suffix : displayed after value\n     * image  : object image\n     * icon   : icon determined by values\n     * active : allow to toggle status\n     */\n    protected $fields_list;\n\n    /**\n     * @var Smarty_Internal_Template|string\n     */\n    protected $header_tpl = 'list_header.tpl';\n\n    /**\n     * @var Smarty_Internal_Template|string\n     */\n    protected $content_tpl = 'list_content.tpl';\n\n    /**\n     * @var Smarty_Internal_Template|string\n     */\n    protected $footer_tpl = 'list_footer.tpl';\n\n    /**\n     * @var string $shopLinkType\n     */\n    public $shopLinkType;\n\n    /**\n     * @var callable method used to generate link\n     */\n    public $linkUrlCallback;\n\n    /**\n     * @var string target window for drilldown link\n     */\n    public $linkUrlTarget = '_self';\n\n    /**\n     * HelperListCore constructor.\n     */\n    public function __construct()\n    {\n        $this->base_folder = 'helpers/list/';\n        $this->base_tpl = 'list.tpl';\n\n        parent::__construct();\n    }\n\n    /**\n     * Return an html list given the data to fill it up\n     *\n     * @param array $list entries to display (rows)\n     * @param array $fieldsDisplay fields (cols)\n     *\n     * @return string html\n     *\n     * @throws PrestaShopException\n     * @throws SmartyException\n     */\n    public function generateList($list, $fieldsDisplay)\n    {\n        // Append when we get a syntax error in SQL query\n        if ($list === false) {\n            $this->getController()->warnings[] = $this->l('Bad SQL query');\n\n            return false;\n        }\n\n        $this->tpl = $this->createTemplate($this->base_tpl);\n        $this->header_tpl = $this->createTemplate($this->header_tpl);\n        $this->content_tpl = $this->createTemplate($this->content_tpl);\n        $this->footer_tpl = $this->createTemplate($this->footer_tpl);\n\n        $this->_list = $list;\n        $this->fields_list = $fieldsDisplay;\n\n        $this->orderBy = preg_replace('/^([a-z _]*!)/Ui', '', $this->orderBy ?? '');\n        $this->orderWay = preg_replace('/^([a-z _]*!)/Ui', '', $this->orderWay ?? '');\n\n        $this->tpl->assign(\n            [\n                'header'  => $this->displayListHeader(), // Display list header (filtering, pagination and column names)\n                'content' => $this->displayListContent(), // Show the content of the table\n                'footer'  => $this->displayListFooter(), // Close list table and submit button\n            ]\n        );\n\n        return parent::generate();\n    }\n\n    /**\n     * Display list header (filtering, pagination and column names)\n     *\n     * @return string\n     *\n     * @throws SmartyException\n     */\n    public function displayListHeader()\n    {\n        if (is_null($this->list_id)) {\n            $this->list_id = $this->table;\n        }\n\n        $idCat = Tools::getIntValue('id_'.($this->is_cms ? 'cms_' : '').'category');\n\n        if (empty($token)) {\n            $token = $this->token;\n        }\n\n        /* Determine total page number */\n        $pagination = $this->_default_pagination;\n        $cookie = $this->context->cookie;\n        if (in_array(Tools::getIntValue($this->list_id.'_pagination'), $this->_pagination)) {\n            $pagination = Tools::getIntValue($this->list_id.'_pagination');\n        } elseif (isset($cookie->{$this->list_id.'_pagination'}) && $cookie->{$this->list_id.'_pagination'}) {\n            $pagination = $cookie->{$this->list_id.'_pagination'};\n        }\n\n        $totalPages = max(1, ceil($this->listTotal / $pagination));\n\n        $identifier = Tools::getIsset($this->identifier) ? '&'.$this->identifier.'='.Tools::getIntValue($this->identifier) : '';\n//        $order = '';\n//        if (Tools::getIsset($this->table.'Orderby')) {\n//            $order = '&'.$this->table.'Orderby='.urlencode($this->orderBy).'&'.$this->table.'Orderway='.urlencode(strtolower($this->orderWay));\n//        }\n\n        $action = $this->currentIndex.$identifier.'&token='.$token.'#'.$this->list_id;\n\n        /* Determine current page number */\n        $page = Tools::getIntValue('submitFilter'.$this->list_id);\n\n        if (!$page) {\n            $page = 1;\n        }\n\n        if ($page > $totalPages) {\n            $page = $totalPages;\n        }\n\n        $this->page = (int) $page;\n\n        /* Choose number of results per page */\n        $selectedPagination = Tools::getValue(\n            $this->list_id.'_pagination',\n            $cookie->{$this->list_id . '_pagination'} ?? $this->_default_pagination\n        );\n\n        if (is_null($this->table_id) && $this->position_identifier && Tools::getIntValue($this->position_identifier, 1)) {\n            $this->table_id = substr($this->identifier, 3, strlen($this->identifier));\n        }\n\n        if ($this->position_identifier && ($this->orderBy == 'position' && $this->orderWay != 'DESC')) {\n            $tableDnd = true;\n        }\n\n        $prefix = str_replace(['admin', 'controller'], '', mb_strtolower((string)$this->controller_name));\n        $ajax = false;\n        $controller = $this->getController();\n        foreach ($this->fields_list as $key => $params) {\n            if (!isset($params['type'])) {\n                $params['type'] = 'text';\n            }\n\n            $valueKey = $prefix.$this->list_id.'Filter_'.(array_key_exists('filter_key', $params) ? $params['filter_key'] : $key);\n            if ($key == 'active' && strpos($key, '!') !== false) {\n                $keys = explode('!', $params['filter_key']);\n                $valueKey = $keys[1];\n            }\n            $value = $cookie->{$valueKey};\n            if (!$value && Tools::getIsset($valueKey)) {\n                $value = Tools::getValue($valueKey);\n            }\n\n            switch ($params['type']) {\n                case 'bool':\n                    if (isset($params['ajax']) && $params['ajax']) {\n                        $ajax = true;\n                    }\n                    break;\n\n                case 'date':\n                case 'datetime':\n                    if ($value) {\n                        if (is_string($value)) {\n                            $value = json_decode($value, true);\n                        }\n                        if (!Validate::isCleanHtml($value[0]) || !Validate::isCleanHtml($value[1])) {\n                            $value = '';\n                        }\n                    }\n                    $name = $this->list_id.'Filter_'.($params['filter_key'] ?? $key);\n                    $nameId = str_replace('!', '__', $name);\n\n                    $params['id_date'] = $nameId;\n                    $params['name_date'] = $name;\n\n                    $controller->addJqueryUI('ui.datepicker');\n                    break;\n\n                case 'select':\n                    foreach ($params['list'] as $optionValue => $optionDisplay) {\n                        if (isset($cookie->{$prefix.$this->list_id.'Filter_'.$params['filter_key']})\n                            && $cookie->{$prefix.$this->list_id.'Filter_'.$params['filter_key']} == $optionValue\n                            && $cookie->{$prefix.$this->list_id.'Filter_'.$params['filter_key']} != ''\n                        ) {\n                            $this->fields_list[$key]['select'][$optionValue]['selected'] = 'selected';\n                        }\n                    }\n                    break;\n\n                case 'text':\n                    if (!Validate::isCleanHtml($value)) {\n                        $value = '';\n                    }\n            }\n\n            $params['value'] = $value;\n            $this->fields_list[$key] = $params;\n        }\n\n        $hasValue = false;\n        $hasSearchField = false;\n\n        foreach ($this->fields_list as $field) {\n            if (isset($field['value']) && $field['value'] !== false && $field['value'] !== '') {\n                if (is_array($field['value']) && trim(implode('', $field['value'])) == '') {\n                    continue;\n                }\n\n                $hasValue = true;\n                break;\n            }\n            if (!(isset($field['search']) && $field['search'] === false)) {\n                $hasSearchField = true;\n            }\n        }\n\n        $this->context->smarty->assign(\n            [\n                'page'                => $page,\n                'simple_header'       => $this->simple_header,\n                'total_pages'         => $totalPages,\n                'selected_pagination' => $selectedPagination,\n                'pagination'          => $this->_pagination,\n                'list_total'          => $this->listTotal,\n                'sql'                 => str_replace('\\n', ' ', str_replace('\\r', '', (string)$this->sql)),\n                'table'               => $this->table,\n                'bulk_actions'        => $this->bulk_actions,\n                'show_toolbar'        => $this->show_toolbar,\n                'toolbar_scroll'      => $this->toolbar_scroll,\n                'toolbar_btn'         => $this->toolbar_btn,\n                'has_bulk_actions'    => $this->hasBulkActions($hasValue),\n                'filters_has_value'   => (bool) $hasValue,\n            ]\n        );\n\n        // Include dnd javascript if list contains position update functionality\n        if ($this->position_identifier && $this->orderBy === 'position') {\n            $controller->addJqueryPlugin('tablednd');\n            $controller->addJS(_PS_JS_DIR_ . 'admin/dnd.js');\n            Media::addJsDef([\n                'come_from' => $this->list_id ?? $this->table,\n                'alternate' => $this->orderWay === 'DESC'\n            ]);\n        }\n\n        $this->header_tpl->assign(\n            array_merge(\n                [\n                    'ajax'              => $ajax,\n                    'title'             => array_key_exists('title', $this->tpl_vars) ? $this->tpl_vars['title'] : $this->title,\n                    'show_filters'      => ((count($this->_list) > 1 && $hasSearchField) || $hasValue),\n                    'currentIndex'      => $this->currentIndex,\n                    'action'            => $action,\n                    'order_way'         => $this->orderWay,\n                    'order_by'          => $this->orderBy,\n                    'fields_display'    => $this->fields_list,\n                    'delete'            => in_array('delete', $this->actions),\n                    'identifier'        => $this->identifier,\n                    'id_cat'            => $idCat,\n                    'shop_link_type'    => $this->shopLinkType,\n                    'has_actions'       => !empty($this->actions),\n                    'table_id'          => $this->table_id ?? null,\n                    'table_dnd'         => $tableDnd ?? null,\n                    'name'              => $name ?? null,\n                    'name_id'           => $nameId ?? null,\n                    'row_hover'         => $this->row_hover,\n                    'list_id'           => $this->list_id ?? $this->table,\n                    'token'             => $this->token,\n                ],\n                $this->tpl_vars\n            )\n        );\n\n        return $this->header_tpl->fetch();\n    }\n\n    /**\n     * @param bool $hasValue\n     *\n     * @return bool\n     */\n    public function hasBulkActions($hasValue = false)\n    {\n        if ($this->force_show_bulk_actions) {\n            return true;\n        }\n\n        if (count($this->_list) === 0 && !$hasValue) {\n            return false;\n        }\n\n        if (is_array($this->list_skip_actions) && count($this->list_skip_actions)\n            && is_array($this->bulk_actions) && count($this->bulk_actions)\n        ) {\n            foreach ($this->bulk_actions as $action => $data) {\n                if (array_key_exists($action, $this->list_skip_actions)) {\n                    foreach ($this->_list as $row) {\n                        if (!in_array($row[$this->identifier], $this->list_skip_actions[$action])) {\n                            return true;\n                        }\n                    }\n\n                    return false;\n                }\n            }\n        }\n\n        return !empty($this->bulk_actions);\n    }\n\n    /**\n     * @return false|string\n     *\n     * @throws PrestaShopException\n     * @throws SmartyException\n     */\n    public function displayListContent()\n    {\n        $positionGroupIdentifier = 0;\n        if (isset($this->fields_list['position'])) {\n            if ($this->position_identifier) {\n                if (! is_null($this->position_group_identifier)) {\n                    $positionGroupIdentifier = Tools::getIsset($this->position_group_identifier)\n                        ? Tools::getValue($this->position_group_identifier)\n                        : $this->position_group_identifier;\n                } else {\n                    if ($this->is_cms) {\n                        $parameter = 'id_cms_category';\n                        $defaultId = 1;\n                    } else {\n                        $parameter = 'id_category';\n                        $defaultId = (int)Category::getRootCategory()->id;\n                    }\n                    $positionGroupIdentifier = Tools::getIntValue($parameter, $defaultId);\n                }\n            } else {\n                $positionGroupIdentifier = Category::getRootCategory()->id;\n            }\n\n            $positions = array_map(function ($elem) {\n                return (int) $elem['position'];\n            }, $this->_list);\n            sort($positions);\n        }\n\n        // key_to_get is used to display the correct product category or cms category after a position change\n        $identifier = in_array($this->identifier, ['id_category', 'id_cms_category']) ? '_parent' : '';\n        if ($identifier) {\n            $keyToGet = 'id_'.($this->is_cms ? 'cms_' : '').'category'.$identifier;\n        }\n\n        foreach ($this->_list as $index => $tr) {\n            $id = null;\n            if (isset($tr[$this->identifier])) {\n                $id = $tr[$this->identifier];\n            }\n            $name = $tr['name'] ?? null;\n\n            if ($this->shopLinkType) {\n                $this->_list[$index]['short_shop_name'] = mb_strlen($tr['shop_name']) > 15 ? mb_substr($tr['shop_name'], 0, 15).'...' : $tr['shop_name'];\n            }\n\n            $isFirst = true;\n            // Check all available actions to add to the current list row\n            $controller = $this->getController();\n            foreach ($this->actions as $action) {\n                //Check if the action is available for the current row\n                if (!array_key_exists($action, $this->list_skip_actions) || !in_array($id, $this->list_skip_actions[$action])) {\n                    $methodName = 'display'.ucfirst($action).'Link';\n\n                    if (method_exists($controller, $methodName)) {\n                        $this->_list[$index][$action] = $controller->$methodName($this->token, $id, $name);\n                    } elseif ($this->module instanceof Module && method_exists($this->module, $methodName)) {\n                        $this->_list[$index][$action] = $this->module->$methodName($this->token, $id, $name);\n                    } elseif (method_exists($this, $methodName)) {\n                        $this->_list[$index][$action] = $this->$methodName($this->token, $id, $name);\n                    }\n                }\n\n                if ($isFirst && isset($this->_list[$index][$action])) {\n                    $isFirst = false;\n\n                    if (!preg_match('/a\\s*.*class/', $this->_list[$index][$action])) {\n                        $this->_list[$index][$action] = preg_replace(\n                            '/href\\s*=\\s*\\\"([^\\\"]*)\\\"/',\n                            'href=\"$1\" class=\"btn btn-default\"',\n                            $this->_list[$index][$action]\n                        );\n                    } elseif (!preg_match('/a\\s*.*class\\s*=\\s*\\\".*btn.*\\\"/', $this->_list[$index][$action])) {\n                        $this->_list[$index][$action] = preg_replace(\n                            '/a(\\s*.*)class\\s*=\\s*\\\"(.*)\\\"/',\n                            'a $1 class=\"$2 btn btn-default\"',\n                            $this->_list[$index][$action]\n                        );\n                    }\n                }\n            }\n\n            // @todo skip action for bulk actions\n            // $this->_list[$index]['has_bulk_actions'] = true;\n            foreach ($this->fields_list as $key => $params) {\n                $tmp = explode('!', $key);\n                $key = $tmp[1] ?? $tmp[0];\n                $dataValue = $tr[$key] ?? null;\n\n                if (isset($params['active'])) {\n                    // If method is defined in calling controller, use it instead of the Helper method\n                    if (method_exists($controller, 'displayEnableLink')) {\n                        $callingObj = $controller;\n                    } elseif ($this->module && method_exists($this->module, 'displayEnableLink')) {\n                        $callingObj = $this->module;\n                    } else {\n                        $callingObj = $this;\n                    }\n\n                    if (!isset($params['ajax'])) {\n                        $params['ajax'] = false;\n                    }\n                    $this->_list[$index][$key] = $callingObj->displayEnableLink(\n                        $this->token,\n                        $id,\n                        $dataValue,\n                        $params['active'],\n                        Tools::getIntValue('id_category'),\n                        Tools::getIntValue('id_product'),\n                        $params['ajax']\n                    );\n                } elseif (isset($params['activeVisu'])) {\n                    $this->_list[$index][$key] = (bool) $dataValue;\n                } elseif (isset($params['position'])) {\n                    $this->_list[$index][$key] = [\n                        'position'          => $dataValue,\n                        'position_url_down' => $this->currentIndex.\n                            (isset($keyToGet) ? '&'.$keyToGet.'='.(int) $positionGroupIdentifier : '').\n                            '&'.$this->position_identifier.'='.$id.\n                            '&way=1&position='.((int) $tr['position'] + 1).'&token='.$this->token,\n                        'position_url_up'   => $this->currentIndex.\n                            (isset($keyToGet) ? '&'.$keyToGet.'='.(int) $positionGroupIdentifier : '').\n                            '&'.$this->position_identifier.'='.$id.\n                            '&way=0&position='.((int) $tr['position'] - 1).'&token='.$this->token,\n                    ];\n                } elseif (isset($params['image'])) {\n                    // item_id is the product id in a product image context, else it is the image id.\n                    $itemId = isset($params['image_id']) ? $tr[$params['image_id']] : $id;\n                    if ($params['image'] != 'p') {\n                        $pathToImage = _PS_IMG_DIR_.$params['image'].'/'.$itemId.(isset($tr['id_image']) ? '-'.(int) $tr['id_image'] : '').'.'.$this->imageType;\n                        $this->_list[$index][$key] = ImageManager::thumbnail($pathToImage, $this->table.'_mini_'.$itemId.'_'.$this->context->shop->id.'.'.$this->imageType, 45, $this->imageType);\n                    } else {\n                        $this->_list[$index][$key] = ImageManager::getProductImageThumbnailTag($tr['id_image']);\n                    }\n                } elseif (isset($params['icon']) && (isset($params['icon'][$dataValue]) || isset($params['icon']['default']))) {\n                    $defaultIcon = 'unknown.gif';\n                    if (isset($params['icon']['default'])) {\n                        if (is_array($params['icon']['default'])) {\n                            $defaultIcon = $params['icon']['default']['src'];\n                        } else {\n                            $defaultIcon = $params['icon']['default'];\n                        }\n                    }\n                    $iconValue = $params['icon'][$dataValue] ?? $defaultIcon;\n                    if (is_array($iconValue)) {\n                        $this->_list[$index][$key] = $iconValue;\n                    } else {\n                        $this->_list[$index][$key] = [\n                            'src' => $iconValue,\n                            'alt' => sprintf($this->l(\"Value: %s\"), $dataValue),\n                        ];\n                    }\n                    // backwards compatibility for build-in icon files stored in img/admin directory\n                    if (isset($this->_list[$index][$key]['src'])) {\n                        $iconFile = $this->_list[$index][$key]['src'];\n                        if (file_exists(_PS_IMG_DIR_.'admin/'.$iconFile)) {\n                            $this->_list[$index][$key]['src'] =_PS_ADMIN_IMG_.$iconFile;\n                        }\n                    }\n                } elseif (isset($params['type']) && $params['type'] == 'float') {\n                    $this->_list[$index][$key] = rtrim(rtrim($dataValue, '0'), '.');\n                } elseif (isset($dataValue)) {\n                    if (isset($params['callback'])) {\n                        $callbackObj = (isset($params['callback_object'])) ? $params['callback_object'] : $controller;\n                        $this->_list[$index][$key] = call_user_func_array([$callbackObj, $params['callback']], [$dataValue, $tr]);\n                    } else {\n                        $this->_list[$index][$key] = $dataValue;\n                    }\n                }\n            }\n        }\n\n        $this->content_tpl->assign(\n            array_merge(\n                $this->tpl_vars,\n                [\n                    'shop_link_type'            => $this->shopLinkType,\n                    'name'                      => $name ?? null,\n                    'position_identifier'       => $this->position_identifier,\n                    'identifier'                => $this->identifier,\n                    'table'                     => $this->table,\n                    'token'                     => $this->token,\n                    'color_on_bg'               => $this->colorOnBackground,\n                    'position_group_identifier' => $positionGroupIdentifier ?? false,\n                    'bulk_actions'              => $this->bulk_actions,\n                    'positions'                 => $positions ?? null,\n                    'order_by'                  => $this->orderBy,\n                    'order_way'                 => $this->orderWay,\n                    'is_cms'                    => $this->is_cms,\n                    'fields_display'            => $this->fields_list,\n                    'list'                      => $this->_list,\n                    'actions'                   => $this->actions,\n                    'no_link'                   => $this->no_link,\n                    'current_index'             => $this->currentIndex,\n                    'linkUrlCallback'           => is_callable($this->linkUrlCallback) ? $this->linkUrlCallback : null,\n                    'linkUrlTarget'             => $this->linkUrlTarget,\n                    'view'                      => in_array('view', $this->actions),\n                    'edit'                      => in_array('edit', $this->actions),\n                    'has_actions'               => !empty($this->actions),\n                    'list_skip_actions'         => $this->list_skip_actions,\n                    'row_hover'                 => $this->row_hover,\n                    'list_id'                   => $this->list_id ?? $this->table,\n                    'checked_boxes'             => Tools::getArrayValue(($this->list_id ?? $this->table).'Box'),\n                ]\n            )\n        );\n\n        return $this->content_tpl->fetch();\n    }\n\n    /**\n     * Fetch the template for action enable\n     *\n     * @param string $token\n     * @param string $id\n     * @param bool $value state enabled or not\n     * @param string $active status\n     * @param int|null $idCategory\n     * @param int|null $idProduct\n     * @param bool $ajax\n     *\n     * @return string\n     *\n     * @throws SmartyException\n     * @throws PrestaShopException\n     */\n    public function displayEnableLink($token, $id, $value, $active, $idCategory = null, $idProduct = null, $ajax = false)\n    {\n        $tplEnable = $this->createTemplate('list_action_enable.tpl');\n        $tplEnable->assign(\n            [\n                'ajax'       => $ajax,\n                'enabled'    => (bool) $value,\n                'url_enable' => $this->currentIndex.'&'.$this->identifier.'='.$id.'&'.$active.$this->table.($ajax ? '&action='.$active.$this->table.'&ajax='.(int) $ajax : '').((int) $idCategory && (int) $idProduct ? '&id_category='.(int) $idCategory : '').($this->page && $this->page > 1 ? '&page='.(int) $this->page : '').'&token='.($token != null ? $token : $this->token),\n            ]\n        );\n\n        return $tplEnable->fetch();\n    }\n\n    /**\n     * Close list table and submit button\n     *\n     * @throws SmartyException\n     */\n    public function displayListFooter()\n    {\n        if (is_null($this->list_id)) {\n            $this->list_id = $this->table;\n        }\n\n        $this->footer_tpl->assign(\n            array_merge(\n                $this->tpl_vars,\n                [\n                    'current' => $this->currentIndex,\n                    'list_id' => $this->list_id,\n                    'token'   => $this->token,\n                ]\n            )\n        );\n\n        return $this->footer_tpl->fetch();\n    }\n\n    /**\n     * Display duplicate action link\n     *\n     * @param string|null $token\n     * @param int $id\n     * @param string|null $name\n     *\n     * @return string\n     * @throws PrestaShopException\n     * @throws SmartyException\n     */\n    public function displayDuplicateLink($token, $id, $name = null)\n    {\n        $tpl = $this->createTemplate('list_action_duplicate.tpl');\n        if (!array_key_exists('Bad SQL query', static::$cache_lang)) {\n            static::$cache_lang['Duplicate'] = $this->l('Duplicate');\n        }\n\n        if (!array_key_exists('Copy images too?', static::$cache_lang)) {\n            static::$cache_lang['Copy images too?'] = $this->l('This will copy the images too. If you wish to proceed, click \"Yes\". If not, click \"No\".');\n        }\n\n        $duplicate = $this->currentIndex.'&'.$this->identifier.'='.$id.'&duplicate'.$this->table;\n\n        $confirm = static::$cache_lang['Copy images too?'];\n\n        if (($this->table == 'product') && !Image::hasImages($this->context->language->id, (int) $id)) {\n            $confirm = '';\n        }\n\n        $tpl->assign(\n            [\n                'href'        => $this->currentIndex.'&'.$this->identifier.'='.$id.'&view'.$this->table.'&token='.($token != null ? $token : $this->token),\n                'action'      => static::$cache_lang['Duplicate'],\n                'confirm'     => $confirm,\n                'location_ok' => $duplicate.'&token='.($token != null ? $token : $this->token),\n                'location_ko' => $duplicate.'&noimage=1&token='.($token ? $token : $this->token),\n            ]\n        );\n\n\n        return $tpl->fetch();\n    }\n\n    /**\n     * Display action show details of a table row\n     * This action need an ajax request with a return like this:\n     *   {\n     *     use_parent_structure: true // If false, data need to be an html\n     *     data:\n     *       [\n     *         {field_name: 'value'}\n     *       ],\n     *     fields_display: // attribute $fields_list of the admin controller\n     *   }\n     * or somethins like this:\n     *   {\n     *     use_parent_structure: false // If false, data need to be an html\n     *     data:\n     *       '<p>My html content</p>',\n     *     fields_display: // attribute $fields_list of the admin controller\n     *   }\n     *\n     * @param string|null $token\n     * @param int $id\n     * @param string|null $name\n     *\n     * @return string\n     * @throws PrestaShopException\n     * @throws SmartyException\n     */\n    public function displayDetailsLink($token, $id, $name = null)\n    {\n        $tpl = $this->createTemplate('list_action_details.tpl');\n        if (!array_key_exists('Details', static::$cache_lang)) {\n            static::$cache_lang['Details'] = $this->l('Details');\n        }\n\n        $ajaxParams = $this->ajax_params;\n        if (!is_array($ajaxParams) || !isset($ajaxParams['action'])) {\n            $ajaxParams['action'] = 'details';\n        }\n\n        $tpl->assign(\n            [\n                'id'          => $id,\n                'href'        => $this->currentIndex.'&'.$this->identifier.'='.$id.'&details'.$this->table.'&token='.($token != null ? $token : $this->token),\n                'controller'  => str_replace('Controller', '', get_class($this->getController())),\n                'token'       => $token != null ? $token : $this->token,\n                'action'      => static::$cache_lang['Details'],\n                'params'      => $ajaxParams,\n                'json_params' => json_encode($ajaxParams),\n            ]\n        );\n\n        return $tpl->fetch();\n    }\n\n    /**\n     * Display view action link\n     *\n     * @param string|null $token\n     * @param int $id\n     * @param string|null $name\n     *\n     * @return string\n     * @throws PrestaShopException\n     * @throws SmartyException\n     */\n    public function displayViewLink($token, $id, $name = null)\n    {\n        $tpl = $this->createTemplate('list_action_view.tpl');\n        if (!array_key_exists('View', static::$cache_lang)) {\n            static::$cache_lang['View'] = $this->l('View');\n        }\n        $tpl->assign(\n            [\n                'href'   => $this->currentIndex.'&'.$this->identifier.'='.$id.'&view'.$this->table.'&token='.($token != null ? $token : $this->token),\n                'action' => static::$cache_lang['View'],\n            ]\n        );\n\n        return $tpl->fetch();\n    }\n\n    /**\n     * Display edit action link\n     *\n     * @param string|null $token\n     * @param int $id\n     * @param string|null $name\n     *\n     * @return string\n     * @throws PrestaShopException\n     * @throws SmartyException\n     */\n    public function displayEditLink($token, $id, $name = null)\n    {\n        $tpl = $this->createTemplate('list_action_edit.tpl');\n        if (!array_key_exists('Edit', static::$cache_lang)) {\n            static::$cache_lang['Edit'] = $this->l('Edit');\n        }\n        $tpl->assign(\n            [\n                'href'   => $this->currentIndex.'&'.$this->identifier.'='.$id.'&update'.$this->table.($this->page && $this->page > 1 ? '&page='.(int) $this->page : '').'&token='.($token != null ? $token : $this->token),\n                'action' => static::$cache_lang['Edit'],\n                'id'     => $id,\n            ]\n        );\n        return $tpl->fetch();\n    }\n\n    /**\n     * Display delete action link\n     *\n     * @param string|null $token\n     * @param int $id\n     * @param string|null $name\n     *\n     * @return string\n     * @throws PrestaShopException\n     * @throws SmartyException\n     */\n    public function displayDeleteLink($token, $id, $name = null)\n    {\n        $tpl = $this->createTemplate('list_action_delete.tpl');\n\n        if (!array_key_exists('Delete', static::$cache_lang)) {\n            static::$cache_lang['Delete'] = $this->l('Delete');\n        }\n        if (!array_key_exists('DeleteItem', static::$cache_lang)) {\n            static::$cache_lang['DeleteItem'] = $this->l('Delete selected item?', 'Helper', true, false);\n        }\n        if (!array_key_exists('Name', static::$cache_lang)) {\n            static::$cache_lang['Name'] = $this->l('Name:', 'Helper', true, false);\n        }\n        if (!is_null($name)) {\n            $name = addcslashes('\\n\\n'.static::$cache_lang['Name'].' '.$name, '\\'');\n        }\n        $data = [\n            $this->identifier => $id,\n            'href'            => $this->currentIndex.'&'.$this->identifier.'='.$id.'&delete'.$this->table.'&token='.($token != null ? $token : $this->token),\n            'action'          => static::$cache_lang['Delete'],\n        ];\n        if ($this->specificConfirmDelete !== false) {\n            $data['confirm'] = !is_null($this->specificConfirmDelete)\n                ? '\\r'.$this->specificConfirmDelete\n                : Tools::safeOutput(static::$cache_lang['DeleteItem'].$name);\n        }\n        $tpl->assign(array_merge($this->tpl_delete_link_vars, $data));\n\n        return $tpl->fetch();\n    }\n\n    /**\n     * Display default action link\n     *\n     * @param string|null $token\n     * @param int $id\n     * @param string|null $name\n     *\n     * @return string\n     * @throws PrestaShopException\n     * @throws SmartyException\n     */\n    public function displayDefaultLink($token, $id, $name = null)\n    {\n        $tpl = $this->createTemplate('list_action_default.tpl');\n        if (!array_key_exists('Default', static::$cache_lang)) {\n            static::$cache_lang['Default'] = $this->l('Default');\n        }\n        $tpl->assign(\n            [\n                'href'   => $this->currentIndex.'&'.$this->identifier.'='.(int) $id.'&default'.$this->table.'&token='.($token != null ? $token : $this->token),\n                'action' => static::$cache_lang['Default'],\n                'name'   => $name,\n            ]\n        );\n\n        return $tpl->fetch();\n    }\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2023-48241", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.query.solr.internal;\n\nimport java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map.Entry;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Provider;\nimport javax.inject.Singleton;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.solr.client.solrj.SolrQuery;\nimport org.apache.solr.client.solrj.response.QueryResponse;\nimport org.apache.solr.common.SolrDocument;\nimport org.apache.solr.common.SolrDocumentList;\nimport org.slf4j.Logger;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.job.event.status.JobProgressManager;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.query.Query;\nimport org.xwiki.query.QueryException;\nimport org.xwiki.query.QueryExecutor;\nimport org.xwiki.query.SecureQuery;\nimport org.xwiki.search.solr.internal.api.SolrInstance;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.Right;\n\nimport com.xpn.xwiki.XWikiContext;\n\n/**\n * Executes Solr queries.\n * <p>\n * For now, the result is the direct {@link QueryResponse}, in lack of a more expressive result type than the generic\n * List that the {@link #execute(Query)} method allows.\n * \n * @version $Id$\n * @since 4.3M2\n */\n@Component\n@Named(SolrQueryExecutor.SOLR)\n@Singleton\npublic class SolrQueryExecutor implements QueryExecutor\n{\n    /**\n     * Query language ID.\n     */\n    public static final String SOLR = \"solr\";\n\n    /**\n     * The parameter that specifies the list of supported locales. This is used to add generic (unlocalized) aliases for\n     * localized query fields (e.g. 'title' alias for 'title_en' query field).\n     */\n    private static final String PARAM_SUPPORTED_LOCALES = \"xwiki.supportedLocales\";\n\n    /**\n     * Logging framework.\n     */\n    @Inject\n    protected Logger logger;\n\n    @Inject\n    protected AuthorizationManager authorization;\n\n    /**\n     * Provider for the {@link SolrInstance} that allows communication with the Solr server.\n     */\n    @Inject\n    protected SolrInstance solrInstance;\n\n    /**\n     * Used to retrieve the configured supported locales.\n     */\n    @Inject\n    private Provider<XWikiContext> xcontextProvider;\n\n    /**\n     * Used to extract a {@link DocumentReference} from a {@link SolrDocument}.\n     */\n    @Inject\n    private DocumentReferenceResolver<SolrDocument> solrDocumentReferenceResolver;\n\n    @Inject\n    private JobProgressManager progress;\n\n    @Override\n    public <T> List<T> execute(Query query) throws QueryException\n    {\n        this.progress.startStep(query, \"query.solr.progress.execute\", \"Execute Solr query [{}]\", query);\n        this.progress.pushLevelProgress(3, query);\n\n        try {\n            this.progress.startStep(query, \"query.solr.progress.execute.prepare\", \"Prepare\");\n\n            SolrQuery solrQuery = createSolrQuery(query);\n\n            this.progress.startStep(query, \"query.solr.progress.execute.execute\", \"Execute\");\n\n            QueryResponse response = this.solrInstance.query(solrQuery);\n\n            this.progress.startStep(query, \"query.solr.progress.execute.filter\", \"Filter\");\n\n            // Check access rights need to be checked before returning the response.\n            // FIXME: this is not really the best way, mostly because at this point all grouping operations\n            // have already been performed and any change on the result will not ensure that the grouping\n            // information (facets, highlighting, maxScore, etc.) is still relevant.\n            // A better way would be using a PostFilter as described in this article:\n            // http://java.dzone.com/articles/custom-security-filtering-solr\n            // Basically, we would be asking\n            List<DocumentReference> usersToCheck = new ArrayList<>(2);\n            if (query instanceof SecureQuery) {\n                if (((SecureQuery) query).isCurrentUserChecked()) {\n                    usersToCheck.add(xcontextProvider.get().getUserReference());\n                }\n                if (((SecureQuery) query).isCurrentAuthorChecked()) {\n                    usersToCheck.add(xcontextProvider.get().getAuthorReference());\n                }\n            } else {\n                usersToCheck.add(xcontextProvider.get().getUserReference());\n                usersToCheck.add(xcontextProvider.get().getAuthorReference());\n            }\n            if (!usersToCheck.isEmpty()) {\n                filterResponse(response, usersToCheck);\n            }\n\n            return (List<T>) Arrays.asList(response);\n        } catch (Exception e) {\n            throw new QueryException(\"Exception while executing query\", query, e);\n        } finally {\n            this.progress.popLevelProgress(query);\n            this.progress.endStep(query);\n        }\n    }\n\n    private SolrQuery createSolrQuery(Query query)\n    {\n        SolrQuery solrQuery = new SolrQuery(query.getStatement());\n\n        // Overwrite offset and limit only if the query object explicitly says so, otherwise use whatever the query\n        // statement says or the defaults.\n        if (query.getOffset() > 0) {\n            solrQuery.setStart(query.getOffset());\n        }\n        if (query.getLimit() > 0) {\n            solrQuery.setRows(query.getLimit());\n        }\n\n        // TODO: good idea? Any confusion? Do we really needs something like this?\n        // Reuse the Query.getNamedParameters() map to get extra parameters.\n        for (Entry<String, Object> entry : query.getNamedParameters().entrySet()) {\n            Object value = entry.getValue();\n\n            if (value instanceof Iterable) {\n                solrQuery.set(entry.getKey(), toStringArray((Iterable) value));\n            } else if (value != null && value.getClass().isArray()) {\n                solrQuery.set(entry.getKey(), toStringArray(value));\n            } else {\n                solrQuery.set(entry.getKey(), String.valueOf(value));\n            }\n        }\n\n        // Make sure the list of supported locales is set so the names of the fields that are indexed in multiple\n        // languages are expanded in the search query. For instance, the query \"title:text\" will be expanded to\n        // \"title__:text OR title_en:text OR title_fr:text\" if the list of supported locales is [en, fr].\n        if (!solrQuery.getParameterNames().contains(PARAM_SUPPORTED_LOCALES)) {\n            XWikiContext xcontext = this.xcontextProvider.get();\n            solrQuery.set(PARAM_SUPPORTED_LOCALES,\n                StringUtils.join(xcontext.getWiki().getAvailableLocales(xcontext), \",\"));\n        }\n\n        return solrQuery;\n    }\n\n    /**\n     * Converts an arbitrary array to an array containing its string representations.\n     * \n     * @param array an array of arbitrary type, must not be null\n     * @return an array with the string representations of the passed array's items\n     */\n    private String[] toStringArray(Object array)\n    {\n        int length = Array.getLength(array);\n        String[] args = new String[length];\n        for (int i = 0; i < length; i++) {\n            args[i] = String.valueOf(Array.get(array, i));\n        }\n\n        return args;\n    }\n\n    /**\n     * Converts the given iterable object to an array containing its string representations.\n     * \n     * @param iterable the iterable object, must not be null\n     * @return an array with the string representations of the passed iterable's items\n     */\n    private String[] toStringArray(Iterable iterable)\n    {\n        List<String> args = new ArrayList<String>();\n        for (Object obj : iterable) {\n            args.add(String.valueOf(obj));\n        }\n        return args.toArray(new String[args.size()]);\n    }\n\n    /**\n     * Filter out results from the response that the current user does not have access to view.\n     * \n     * @param response the Solr response to filter\n     */\n    protected void filterResponse(QueryResponse response, List<DocumentReference> usersToCheck)\n    {\n        SolrDocumentList results = response.getResults();\n        long numFound = results.getNumFound();\n\n        // Since we are modifying the results collection, we need to iterate over its copy.\n        for (SolrDocument result : new ArrayList<SolrDocument>(results)) {\n            try {\n                DocumentReference resultDocumentReference = this.solrDocumentReferenceResolver.resolve(result);\n\n                if (!isAllowed(resultDocumentReference, usersToCheck)) {\n\n                    // Remove the current incompatible result.\n                    results.remove(result);\n\n                    // Decrement the number of results.\n                    numFound--;\n\n                    // FIXME: We should update maxScore as well when removing the top scored item. How do we do that?\n                    // Sorting based on score might be a not so expensive option.\n\n                    // FIXME: What about highlighting, facets and all the other data inside the QueryResponse?\n                }\n            } catch (Exception e) {\n                this.logger.warn(\"Skipping bad result: {}\", result, e);\n            }\n        }\n\n        // Update the new number of results, excluding the filtered ones.\n        if (numFound < 0) {\n            // Lower bound guard for the total number of results.\n            numFound = 0;\n        }\n        results.setNumFound(numFound);\n    }\n\n    protected boolean isAllowed(DocumentReference resultDocumentReference, List<DocumentReference> usersToCheck)\n    {\n        for (DocumentReference user : usersToCheck) {\n            if (!this.authorization.hasAccess(Right.VIEW, user, resultDocumentReference)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2023-49289", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "Object.extend(Function.prototype, {\n\tgetArguments: function () {\n\t\tvar args = [];\n\t\tfor (var i = 0; i < this.arguments.length; i++) {\n\t\t\targs.push(this.arguments[i]);\n\t\t}\n\t\treturn args;\n\t}\n}, false);\n\nvar MS = { \"Browser\": {} };\n\nObject.extend(MS.Browser, {\n\tisIE: navigator.userAgent.indexOf('MSIE') != -1,\n\tisFirefox: navigator.userAgent.indexOf('Firefox') != -1,\n\tisOpera: window.opera != null\n}, false);\n\nvar AjaxPro = {};\n\nAjaxPro.IFrameXmlHttp = function () { };\nAjaxPro.IFrameXmlHttp.prototype = {\n\tonreadystatechange: null, headers: [], method: \"POST\", url: null, async: true, iframe: null,\n\tstatus: 0, readyState: 0, responseText: null,\n\tabort: function () {\n\t},\n\treadystatechanged: function () {\n\t\tvar doc = this.iframe.contentDocument || this.iframe.document;\n\t\tif (doc != null && doc.readyState == \"complete\" && doc.body != null && doc.body.res != null) {\n\t\t\tthis.status = 200;\n\t\t\tthis.statusText = \"OK\";\n\t\t\tthis.readyState = 4;\n\t\t\tthis.responseText = doc.body.res;\n\t\t\tthis.onreadystatechange();\n\t\t\treturn;\n\t\t}\n\t\tsetTimeout(this.readystatechanged.bind(this), 10);\n\t},\n\topen: function (method, url, async) {\n\t\tif (async == false) {\n\t\t\talert(\"Synchronous call using IFrameXMLHttp is not supported.\");\n\t\t\treturn;\n\t\t}\n\t\tif (this.iframe == null) {\n\t\t\tvar iframeID = \"hans\";\n\t\t\tif (document.createElement && document.documentElement &&\n\t\t\t\t(window.opera || navigator.userAgent.indexOf('MSIE 5.0') == -1)) {\n\t\t\t\tvar ifr = document.createElement('iframe');\n\t\t\t\tifr.setAttribute('id', iframeID);\n\t\t\t\tifr.style.visibility = 'hidden';\n\t\t\t\tifr.style.position = 'absolute';\n\t\t\t\tifr.style.width = ifr.style.height = ifr.borderWidth = '0px';\n\n\t\t\t\tthis.iframe = document.getElementsByTagName('body')[0].appendChild(ifr);\n\t\t\t}\n\t\t\telse if (document.body && document.body.insertAdjacentHTML) {\n\t\t\t\tdocument.body.insertAdjacentHTML('beforeEnd', '<iframe name=\"' + iframeID + '\" id=\"' + iframeID + '\" style=\"border:1px solid black;display:none\"></iframe>');\n\t\t\t}\n\t\t\tif (window.frames && window.frames[iframeID]) {\n\t\t\t\tthis.iframe = window.frames[iframeID];\n\t\t\t}\n\t\t\tthis.iframe.name = iframeID;\n\t\t\tthis.iframe.document.open();\n\t\t\tthis.iframe.document.write(\"<\" + \"html><\" + \"body></\" + \"body></\" + \"html>\");\n\t\t\tthis.iframe.document.close();\n\t\t}\n\t\tthis.method = method;\n\t\tthis.url = url;\n\t\tthis.async = async;\n\t},\n\tsetRequestHeader: function (name, value) {\n\t\tfor (var i = 0; i < this.headers.length; i++) {\n\t\t\tif (this.headers[i].name == name) {\n\t\t\t\tthis.headers[i].value = value;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthis.headers.push({ \"name\": name, \"value\": value });\n\t},\n\tgetResponseHeader: function (name, value) {\n\t\treturn null;\n\t},\n\taddInput: function (doc, form, name, value) {\n\t\tvar ele;\n\t\tvar tag = \"input\";\n\t\tif (value.indexOf(\"\\n\") >= 0) {\n\t\t\ttag = \"textarea\";\n\t\t}\n\n\t\tif (doc.all) {\n\t\t\tele = doc.createElement(\"<\" + tag + \" name=\\\"\" + name + \"\\\" />\");\n\t\t} else {\n\t\t\tele = doc.createElement(tag);\n\t\t\tele.setAttribute(\"name\", name);\n\t\t}\n\t\tele.setAttribute(\"value\", value);\n\t\tform.appendChild(ele);\n\t\tele = null;\n\t},\n\tsend: function (data) {\n\t\tif (this.iframe == null) {\n\t\t\treturn;\n\t\t}\n\t\tvar doc = this.iframe.contentDocument || this.iframe.document;\n\t\tvar form = doc.createElement(\"form\");\n\n\t\tdoc.body.appendChild(form);\n\n\t\tform.setAttribute(\"action\", this.url);\n\t\tform.setAttribute(\"method\", this.method);\n\t\tform.setAttribute(\"enctype\", \"application/x-www-form-urlencoded\");\n\n\t\tfor (var i = 0; i < this.headers.length; i++) {\n\t\t\tswitch (this.headers[i].name.toLowerCase()) {\n\t\t\t\tcase \"content-length\":\n\t\t\t\tcase \"accept-encoding\":\n\t\t\t\tcase \"content-type\":\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.addInput(doc, form, this.headers[i].name, this.headers[i].value);\n\t\t\t}\n\t\t}\n\t\tthis.addInput(doc, form, \"data\", data);\n\t\tform.submit();\n\n\t\tsetTimeout(this.readystatechanged.bind(this), 0);\n\t}\n};\n\nvar progids = [\"Msxml2.XMLHTTP.6.0\", \"Msxml2.XMLHTTP.3.0\", \"MSXML2.XMLHTTP\", \"Microsoft.XMLHTTP\"];\nvar progid = null;\n\nif (typeof ActiveXObject != \"undefined\") {\n\tvar ie7xmlhttp = false;\n\tif (typeof XMLHttpRequest == \"object\") {\n\t\ttry { var o = new XMLHttpRequest(); ie7xmlhttp = true; } catch (e) { }\n\t}\n\tif (typeof XMLHttpRequest == \"undefined\" || !ie7xmlhttp) {\n\t\tXMLHttpRequest = function () {\n\t\t\tvar xmlHttp = null;\n\t\t\tif (!AjaxPro.noActiveX) {\n\t\t\t\tif (progid != null) {\n\t\t\t\t\treturn new ActiveXObject(progid);\n\t\t\t\t}\n\t\t\t\tfor (var i = 0; i < progids.length && xmlHttp == null; i++) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\txmlHttp = new ActiveXObject(progids[i]);\n\t\t\t\t\t\tprogid = progids[i];\n\n\t\t\t\t\t} catch (e) { }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (xmlHttp == null && MS.Browser.isIE) {\n\t\t\t\treturn new AjaxPro.IFrameXmlHttp();\n\t\t\t}\n\t\t\treturn xmlHttp;\n\t\t};\n\t}\n}\n\nObject.extend(AjaxPro, {\n\tnoOperation: function () { },\n\tonLoading: function () { },\n\tonError: function () { },\n\tonTimeout: function () { return true; },\n\tonStateChanged: function () { },\n\tcryptProvider: null,\n\tqueue: null,\n\ttoken: \"\",\n\tversion: \"{AssemblyVersion}\",\n\tID: \"AjaxPro\",\n\tnoActiveX: false,\n\ttimeoutPeriod: 15 * 1000,\n\tqueue: null,\n\tnoUtcTime: false,\n\tregExDate: function (str, p1, p2, offset, s) {\n\t\tvar date = str.substring(1).replace('\"', '');\n\t\tif (date.substring(0, 7) == \"\\\\\\/Date(\") {\n\t\t\tvar d = date.match(/Date\\((.*?)\\)/)[1];\n\t\t\treturn \"new Date(\" + parseInt(d) + \")\";\n\t\t}\n\t\telse { // ISO Date 2007-12-31T23:59:59Z                                     \n\t\t\tvar matches = date.split(/[-,:,T,Z]/);\n\t\t\tif (matches.length == 7) {\n\t\t\t\tmatches[1] = (parseInt(matches[1], 0) - 1).toString();\n\t\t\t\tvar isDate = true;\n\t\t\t\tvar s = \"\";\n\t\t\t\tfor (var i = 0; i < matches.length; i++) {\n\t\t\t\t\tif (isNaN(parseInt(matches[i], 10))) {\n\t\t\t\t\t\tisDate = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\ts += \",\";\n                    }\n\t\t\t\t\ts += parseInt(matches[i], 10);\n\t\t\t\t}\n\t\t\t\tif (isDate) {\n\t\t\t\t\treturn \"new Date(Date.UTC(\" + s + \"))\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn str;\n\t},\n\tparse: function (text) {\n\t\t// not yet possible as we still return new type() JSON\n\t\t//\t\tif (!(!(/[^,:{}\\[\\]0-9.\\-+Eaeflnr-u \\n\\r\\t]/.test(\n\t\t//\t\ttext.replace(/\"(\\\\.|[^\"\\\\])*\"/g, '')))  ))\n\t\t//\t\t\tthrow new Error(\"Invalid characters in JSON parse string.\");                 \n\t\tvar regEx = /(\\\"\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}.*?\\\")|(\\\"\\\\\\/Date\\(.*?\\)\\\\\\/\")/g;\n\t\ttext = text.replace(regEx, this.regExDate);\n\t\treturn eval('(' + text + ')');\n\t},\n\tm: {\n\t\t'\\b': '\\\\b',\n\t\t'\\t': '\\\\t',\n\t\t'\\n': '\\\\n',\n\t\t'\\f': '\\\\f',\n\t\t'\\r': '\\\\r',\n\t\t'\"': '\\\\\"',\n\t\t'\\\\': '\\\\\\\\'\n\t},\n\ttoJSON: function (o) {\n\t\tif (o == null) {\n\t\t\treturn \"null\";\n\t\t}\n\t\tvar v = [];\n\t\tvar i;\n\t\tvar c = o.constructor;\n\t\tif (c == Number) {\n\t\t\treturn isFinite(o) ? o.toString() : AjaxPro.toJSON(null);\n\t\t} else if (c == Boolean) {\n\t\t\treturn o.toString();\n\t\t} else if (c == String) {\n\t\t\tif (/[\"\\\\\\x00-\\x1f]/.test(o)) {\n\t\t\t\to = o.replace(/([\\x00-\\x1f\\\\\"])/g, function (a, b) {\n\t\t\t\t\tvar c = AjaxPro.m[b];\n\t\t\t\t\tif (c) {\n\t\t\t\t\t\treturn c;\n\t\t\t\t\t}\n\t\t\t\t\tc = b.charCodeAt();\n\t\t\t\t\treturn '\\\\u00' +\n\t\t\t\t\t\tMath.floor(c / 16).toString(16) +\n\t\t\t\t\t\t(c % 16).toString(16);\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn '\"' + o + '\"';\n\t\t} else if (c == Array) {\n\t\t\tfor (i = 0; i < o.length; i++) {\n\t\t\t\tv.push(AjaxPro.toJSON(o[i]));\n\t\t\t}\n\t\t\treturn \"[\" + v.join(\",\") + \"]\";\n\t\t} else if (c == Date) {\n\t\t\treturn AjaxPro.toJSON(\"/Date(\" + new Date(Date.UTC(o.getUTCFullYear(), o.getUTCMonth(), o.getUTCDate(), o.getUTCHours(), o.getUTCMinutes(), o.getUTCSeconds(), o.getUTCMilliseconds())).getTime() + \")/\");\n\t\t}\n\t\tif (typeof o.toJSON == \"function\") {\n\t\t\treturn o.toJSON();\n\t\t}\n\t\tif (typeof o == \"object\") {\n\t\t\tfor (var attr in o) {\n\t\t\t\tif (typeof o[attr] != \"function\") {\n\t\t\t\t\tv.push('\"' + attr + '\":' + AjaxPro.toJSON(o[attr]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (v.length > 0) {\n\t\t\t\treturn \"{\" + v.join(\",\") + \"}\";\n\t\t\t}\n\t\t\treturn \"{}\";\n\t\t}\n\t\treturn o.toString();\n\t},\n\tdispose: function () {\n\t\tif (AjaxPro.queue != null) {\n\t\t\tAjaxPro.queue.dispose();\n\t\t}\n\t}\n}, false);\n\naddEvent(window, \"unload\", AjaxPro.dispose);\n\nAjaxPro.Request = function (url) {\n\tthis.url = url;\n\tthis.xmlHttp = null;\n};\n\nAjaxPro.Request.prototype = {\n\turl: null,\n\tcallback: null,\n\tonLoading: null,\n\tonError: null,\n\tonTimeout: null,\n\tonStateChanged: null,\n\targs: null,\n\tcontext: null,\n\tisRunning: false,\n\tabort: function () {\n\t\tif (this.timeoutTimer != null) {\n\t\t\tclearTimeout(this.timeoutTimer);\n\t\t}\n\t\tif (this.xmlHttp) {\n\t\t\tthis.xmlHttp.onreadystatechange = AjaxPro.noOperation;\n\t\t\tthis.xmlHttp.abort();\n\t\t}\n\t\tif (this.isRunning) {\n\t\t\tthis.isRunning = false;\n\t\t\tthis.onLoading(false);\n\t\t}\n\t},\n\tdispose: function () {\n\t\tthis.abort();\n\t},\n\tgetEmptyRes: function () {\n\t\treturn {\n\t\t\terror: null,\n\t\t\tvalue: null,\n\t\t\trequest: { method: this.method, args: this.args },\n\t\t\tcontext: this.context,\n\t\t\tduration: this.duration\n\t\t};\n\t},\n\tendRequest: function (res) {\n\t\tthis.abort();\n\t\tif (res.error != null) {\n\t\t\tthis.onError(res.error, this);\n\t\t}\n\n\t\tif (typeof this.callback == \"function\") {\n\t\t\tthis.callback(res, this);\n\t\t}\n\t},\n\tmozerror: function () {\n\t\tif (this.timeoutTimer != null) {\n\t\t\tclearTimeout(this.timeoutTimer);\n\t\t}\n\t\tvar res = this.getEmptyRes();\n\t\tres.error = { Message: \"Unknown\", Type: \"ConnectFailure\", Status: 0 };\n\t\tthis.endRequest(res);\n\t},\n\tdoStateChange: function () {\n\t\tthis.onStateChanged(this.xmlHttp.readyState, this);\n\t\tif (this.xmlHttp.readyState != 4 || !this.isRunning) {\n\t\t\treturn;\n\t\t}\n\t\tthis.duration = new Date().getTime() - this.__start;\n\t\tif (this.timeoutTimer != null) {\n\t\t\tclearTimeout(this.timeoutTimer);\n\t\t}\n\t\tvar res = this.getEmptyRes();\n\t\t//Ignore empty statustext to be http2 compatible\n\t\tif (this.xmlHttp.status == 200 && this.xmlHttp.statusText == \"OK\" || !this.xmlHttp.statusText) {\n\t\t\tres = this.createResponse(res);\n\t\t} else {\n\t\t\tres = this.createResponse(res, true);\n\t\t\tres.error = { Message: this.xmlHttp.statusText, Type: \"ConnectFailure\", Status: this.xmlHttp.status };\n\t\t}\n\n\t\tthis.endRequest(res);\n\t},\n\tcreateResponse: function (r, noContent) {\n\t\tif (!noContent) {\n\t\t\tif (typeof (this.xmlHttp.responseText) == \"unknown\") {\n\t\t\t\tr.error = { Message: \"XmlHttpRequest error reading property responseText.\", Type: \"XmlHttpRequestException\" };\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\t\tvar responseText = \"\" + this.xmlHttp.responseText;\n\n\t\t\tif (AjaxPro.cryptProvider != null && typeof AjaxPro.cryptProvider.decrypt == \"function\") {\n\t\t\t\tresponseText = AjaxPro.cryptProvider.decrypt(responseText);\n\t\t\t}\n\n\t\t\tif (this.xmlHttp.getResponseHeader(\"Content-Type\") == \"text/xml\") {\n\t\t\t\tr.value = this.xmlHttp.responseXML;\n\t\t\t} else {\n\t\t\t\tif (responseText != null && responseText.trim().length > 0) {\n\t\t\t\t\tr.json = responseText;\n\t\t\t\t\tvar v = null;\n\t\t\t\t\tv = AjaxPro.parse(responseText);\n\t\t\t\t\tif (v != null) {\n\t\t\t\t\t\tif (typeof v.value != \"undefined\") r.value = v.value;\n\t\t\t\t\t\telse if (typeof v.error != \"undefined\") r.error = v.error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* if(this.xmlHttp.getResponseHeader(\"X-\" + AjaxPro.ID + \"-Cache\") == \"server\") {\n\t\t\tr.isCached = true;\n\t\t} */\n\t\treturn r;\n\t},\n\ttimeout: function () {\n\t\tthis.duration = new Date().getTime() - this.__start;\n\t\tvar r = this.onTimeout(this.duration, this);\n\t\tif (typeof r == \"undefined\" || r != false) {\n\t\t\tthis.abort();\n\t\t} else {\n\t\t\tthis.timeoutTimer = setTimeout(this.timeout.bind(this), AjaxPro.timeoutPeriod);\n\t\t}\n\t},\n\tinvoke: function (method, args, callback, context) {\n\t\tthis.__start = new Date().getTime();\n\n\t\t// if(this.xmlHttp == null) {\n\t\tthis.xmlHttp = new XMLHttpRequest();\n\t\t// }\n\n\t\tthis.isRunning = true;\n\t\tthis.method = method;\n\t\tthis.args = args;\n\t\tthis.callback = callback;\n\t\tthis.context = context;\n\n\t\tvar async = typeof (callback) == \"function\" && callback != AjaxPro.noOperation;\n\n\t\tif (async) {\n\t\t\tif (MS.Browser.isIE) {\n\t\t\t\tthis.xmlHttp.onreadystatechange = this.doStateChange.bind(this);\n\t\t\t} else {\n\t\t\t\tthis.xmlHttp.onload = this.doStateChange.bind(this);\n\t\t\t\tthis.xmlHttp.onerror = this.mozerror.bind(this);\n\t\t\t}\n\t\t\tthis.onLoading(true);\n\t\t}\n\n\t\tvar json = AjaxPro.toJSON(args) + \"\";\n\t\tif (AjaxPro.cryptProvider != null && typeof AjaxPro.cryptProvider.encrypt == \"function\") {\n\t\t\tjson = AjaxPro.cryptProvider.encrypt(json);\n\t\t}\n\n\t\tthis.xmlHttp.open(\"POST\", this.url, async);\n\t\tthis.xmlHttp.setRequestHeader(\"Content-Type\", \"text/plain; charset=utf-8\");\n\t\tthis.xmlHttp.setRequestHeader(\"X-\" + AjaxPro.ID + \"-Method\", method);\n\n\t\tif (AjaxPro.token != null && AjaxPro.token.length > 0) {\n\t\t\tthis.xmlHttp.setRequestHeader(\"X-\" + AjaxPro.ID + \"-Token\", AjaxPro.token);\n\t\t}\n\n\t\t/* if(!MS.Browser.isIE) {\n\t\t\tthis.xmlHttp.setRequestHeader(\"Connection\", \"close\");\n\t\t} */\n\n\t\tthis.timeoutTimer = setTimeout(this.timeout.bind(this), AjaxPro.timeoutPeriod);\n\n\t\ttry { this.xmlHttp.send(json); } catch (e) { }\t// IE offline exception\n\n\t\tif (!async) {\n\t\t\treturn this.createResponse({ error: null, value: null });\n\t\t}\n\n\t\treturn true;\n\t}\n};\n\nAjaxPro.RequestQueue = function (conc) {\n\tthis.queue = [];\n\tthis.requests = [];\n\tthis.timer = null;\n\n\tif (isNaN(conc)) { conc = 2; }\n\n\tfor (var i = 0; i < conc; i++) {\t\t// max 2 http connections\n\t\tthis.requests[i] = new AjaxPro.Request();\n\t\tthis.requests[i].callback = function (res) {\n\t\t\tvar r = res.context;\n\t\t\tres.context = r[3][1];\n\n\t\t\tr[3][0](res, this);\n\t\t};\n\t\tthis.requests[i].callbackHandle = this.requests[i].callback.bind(this.requests[i]);\n\t}\n\n\tthis.processHandle = this.process.bind(this);\n};\n\nAjaxPro.RequestQueue.prototype = {\n\tprocess: function () {\n\t\tthis.timer = null;\n\t\tif (this.queue.length == 0) {\n\t\t\treturn;\n\t\t}\n\t\tfor (var i = 0; i < this.requests.length && this.queue.length > 0; i++) {\n\t\t\tif (this.requests[i].isRunning == false) {\n\t\t\t\tvar r = this.queue.shift();\n\n\t\t\t\tthis.requests[i].url = r[0];\n\t\t\t\tthis.requests[i].onLoading = r[3].length > 2 && r[3][2] != null && typeof r[3][2] == \"function\" ? r[3][2] : AjaxPro.onLoading;\n\t\t\t\tthis.requests[i].onError = r[3].length > 3 && r[3][3] != null && typeof r[3][3] == \"function\" ? r[3][3] : AjaxPro.onError;\n\t\t\t\tthis.requests[i].onTimeout = r[3].length > 4 && r[3][4] != null && typeof r[3][4] == \"function\" ? r[3][4] : AjaxPro.onTimeout;\n\t\t\t\tthis.requests[i].onStateChanged = r[3].length > 5 && r[3][5] != null && typeof r[3][5] == \"function\" ? r[3][5] : AjaxPro.onStateChanged;\n\n\t\t\t\tthis.requests[i].invoke(r[1], r[2], this.requests[i].callbackHandle, r);\n\t\t\t\tr = null;\n\t\t\t}\n\t\t}\n\t\tif (this.queue.length > 0 && this.timer == null) {\n\t\t\tthis.timer = setTimeout(this.processHandle, 0);\n\t\t}\n\t},\n\tadd: function (url, method, args, e) {\n\t\tthis.queue.push([url, method, args, e]);\n\t\tif (this.timer == null) {\n\t\t\tthis.timer = setTimeout(this.processHandle, 0);\n\t\t}\n\t\t// this.process();\n\t},\n\tabort: function () {\n\t\tthis.queue.length = 0;\n\t\tif (this.timer != null) {\n\t\t\tclearTimeout(this.timer);\n\t\t}\n\t\tthis.timer = null;\n\t\tfor (var i = 0; i < this.requests.length; i++) {\n\t\t\tif (this.requests[i].isRunning == true) {\n\t\t\t\tthis.requests[i].abort();\n\t\t\t}\n\t\t}\n\t},\n\tdispose: function () {\n\t\tfor (var i = 0; i < this.requests.length; i++) {\n\t\t\tvar r = this.requests[i];\n\t\t\tr.dispose();\n\t\t}\n\t\tthis.requests.clear();\n\t}\n};\n\nAjaxPro.queue = new AjaxPro.RequestQueue(2);\t// 2 http connections\n\nAjaxPro.AjaxClass = function (url) {\n\tthis.url = url;\n};\n\nAjaxPro.AjaxClass.prototype = {\n\tinvoke: function (method, args, e) {\n\n\t\tif (e != null) {\n\t\t\tif (e.length != 6) {\n\t\t\t\tfor (; e.length < 6;) { e.push(null); }\n\t\t\t}\n\t\t\tif (e[0] != null && typeof (e[0]) == \"function\") {\n\t\t\t\treturn AjaxPro.queue.add(this.url, method, args, e);\n\t\t\t}\n\t\t}\n\t\tvar r = new AjaxPro.Request();\n\t\tr.url = this.url;\n\t\treturn r.invoke(method, args);\n\t}\n};\n", "output": {"vulnerability_count": 5, "vulnerabilities": [{"description": "found alert() call; should this be in production code?", "risk": "Medium", "conceptual_fix": "Not provided", "line": 41}, {"description": "Detected a useless comparison operation `progid == progid` or `progid != progid`. This operation is always true. If testing for floating point NaN, use `math.isnan`, or `cmath.isnan` if the number is complex.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 142}, {"description": "`str.substring(1).replace` method will only replace the first occurrence when used with a string argument ('\"'). If this method is used for escaping of dangerous data then there is a possibility for a bypass. Try to use sanitization library instead or use a Regex with a global flag.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 177}, {"description": "Detected the use of eval(). eval() can be dangerous if used to evaluate dynamic content. If this content can be input from outside the program, this may be a code injection vulnerability. Ensure evaluated content is not definable by external sources.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 212}, {"description": "`v` is assigned twice; the first assignment is useless", "risk": "Medium", "conceptual_fix": "Not provided", "line": 377}]}}
{"CVE": "CVE-2023-49802", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "<?php\n/**\n * Linked custom fields plugin for MantisBT\n *\n * Copyright (c) 2011 Robert Munteanu (robert@lmn.ro)\n * Copyright (c) 2018, 2022 Damien Regad\n *\n * Linked custom fields for MantisBT is free software:\n * you can redistribute it and/or modify it under the terms of the GNU\n * General Public License as published by the Free Software Foundation,\n * either version 2 of the License, or (at your option) any later version.\n *\n * Linked custom fields plugin for MantisBT is distributed in the hope\n * that it will be useful, but WITHOUT ANY WARRANTY; without even the\n * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Linked custom fields plugin for MantisBT.\n * If not, see <http://www.gnu.org/licenses/>.\n */\n\nclass LinkedCustomFieldsDao {\n\n\t/**\n\t * Replaces existing custom field link values with the current ones.\n\t *\n\t * Note that the link will be removed if there are no mappings defined.\n\t *\n\t * @param int $p_source_field_id\n\t * @param int $p_target_field_id\n\t * @param array $p_value_mappings map of source field value to target field value(s)\n\t */\n\tstatic function replaceValues( $p_source_field_id, $p_target_field_id, $p_value_mappings ) {\n\n\t\t$t_data_table = plugin_table( 'data' );\n\t\t$t_query = \"DELETE FROM \" . $t_data_table . \" WHERE custom_field_id = \" . db_param();\n\n\t\tdb_query( $t_query, array( $p_source_field_id ) ) ;\n\n\t\t$t_insert_query = \"INSERT INTO \" . $t_data_table . \"\n\t\t\t(custom_field_id, custom_field_value_order, custom_field_value, target_field_id, target_field_values)\n\t\t\tVALUES ( \" . db_param() .\", \" . db_param().\", \" . db_param().\", \". db_param().\", \" .db_param().\" )\";\n\n\t\t$t_idx = 0 ;\n\n\t\tforeach( $p_value_mappings as $t_key => $t_value ) {\n\t\t\tdb_query($t_insert_query, array( $p_source_field_id, $t_idx, $t_key, $p_target_field_id, implode( '|', $t_value ) ) );\n\t\t\t$t_idx++;\n\t\t}\n\t}\n\n\t/**\n\t * Retrieve the Target custom field's Id\n\t *\n\t * @param int $p_source_field_id\n\t * @return NULL|int the target field id or null if no link exists\n\t */\n\tstatic function getLinkedFieldId( $p_source_field_id ) {\n\n\t\t$t_query = \"SELECT target_field_id FROM \" . plugin_table( 'data' ) . \" WHERE custom_field_id = \" . db_param();\n\n\t\t$t_result = db_query( $t_query, array( $p_source_field_id ) );\n\n\t\tif( 0 == db_num_rows( $t_result ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t$t_array = db_fetch_array( $t_result );\n\t\treturn $t_array['target_field_id'];\n\t}\n\n\t/**\n\t * Retrieve the values mappings between the source and target fields\n\t *\n\t * @param int $p_source_field_id\n\t * @return array Structure of each row: SourceCF value => [TargetCF values]\n\t */\n\tstatic function getLinkedValuesMap( $p_source_field_id ) {\n\n\t\t$t_query = \"SELECT custom_field_value, target_field_values FROM \" . plugin_table( 'data' ) .\n\t\t\t\t\t\" WHERE custom_field_id=\".db_param() .\" ORDER BY custom_field_value_order\" ;\n\t\t$t_result = db_query( $t_query, array( $p_source_field_id ) );\n\t\tif( 0 == db_num_rows( $t_result ) ) {\n\t\t\treturn array();\n\t\t}\n\n\t\t$t_map = array();\n\t\twhile( $t_row = db_fetch_array( $t_result ) ) {\n\t\t\t$t_source_value = $t_row['custom_field_value'];\n\t\t\t$t_target_values_imploded = $t_row['target_field_values'];\n\t\t\t$t_map[$t_source_value] = explode( '|', $t_target_values_imploded );\n\t\t}\n\n\t\treturn $t_map;\n\t}\n} \n\n\nclass JavascriptUtils {\n\n\tconst LOG_DEBUG = 1;\n\tconst LOG_INFO = 2;\n\tconst LOG_WARN = 3;\n\tconst LOG_ERROR = 4;\n\n\tstatic function toJSArray( $p_array ) {\n\n\t\t$t_field_values_js = '[ ';\n\n\t\tforeach( $p_array as $t_custom_field_value ) {\n\t\t\t$t_field_values_js .= '\"'.string_attribute( $t_custom_field_value ).'\" ,';\n\t\t}\n\n\t\t$t_field_values_js = rtrim( $t_field_values_js, ',' );\n\t\t$t_field_values_js .= ']';\n\n\t\treturn $t_field_values_js;\n\t}\n\n\tstatic function consoleLog( $p_message, $p_level = self::LOG_INFO ) {\n\n\t\t$t_method = false;\n\t\tswitch( $p_level ) {\n\t\t\tcase self::LOG_DEBUG:\n\t\t\t\t$t_method = 'debug';\n\t\t\t\tbreak;\n\n\t\t\tcase self::LOG_INFO:\n\t\t\t\t$t_method = 'info';\n\t\t\t\tbreak;\n\n\t\t\tcase self::LOG_WARN:\n\t\t\t\t$t_method = 'warn';\n\t\t\t\tbreak;\n\n\t\t\tcase self::LOG_ERROR:\n\t\t\t\t$t_method = 'error';\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif( $t_method ) {\n\t\t\treturn 'if( console && console.' . $t_method . ' ) console.'\n\t\t\t\t. $t_method . '( \"' . $p_message . '\" );' . \"\\n\";\n\t\t}\n\t\treturn '';\n\t}\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2024-13426", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "<?php\n### Check Whether User Can Manage Polls\nif( ! current_user_can( 'manage_polls' ) ) {\n    die( 'Access Denied' );\n}\n\n\n### Variables\n$max_records = 2000;\n$pollip_answers = array();\n$poll_question_data = $wpdb->get_row( $wpdb->prepare( \"SELECT pollq_multiple, pollq_question, pollq_totalvoters FROM $wpdb->pollsq WHERE pollq_id = %d\", $poll_id ) );\n$poll_question = wp_kses_post( removeslashes( $poll_question_data->pollq_question ) );\n$poll_totalvoters = (int) $poll_question_data->pollq_totalvoters;\n$poll_multiple = (int) $poll_question_data->pollq_multiple;\n$poll_registered = $wpdb->get_var( $wpdb->prepare( \"SELECT COUNT(pollip_userid) FROM $wpdb->pollsip WHERE pollip_qid = %d AND pollip_userid > 0\", $poll_id ) );\n$poll_comments = $wpdb->get_var( $wpdb->prepare( \"SELECT COUNT(pollip_user) FROM $wpdb->pollsip WHERE pollip_qid = %d AND pollip_user != %s AND pollip_userid = 0\", $poll_id, __( 'Guest', 'wp-polls' ) ) );\n$poll_guest = $wpdb->get_var( $wpdb->prepare( \"SELECT COUNT(pollip_user) FROM $wpdb->pollsip WHERE pollip_qid = %d AND pollip_user = %s\", $poll_id, __( 'Guest', 'wp-polls' ) ) );\n$poll_totalrecorded = ( $poll_registered + $poll_comments + $poll_guest );\nlist( $order_by, $sort_order ) = _polls_get_ans_sort();\n$poll_answers_data = $wpdb->get_results( $wpdb->prepare( \"SELECT polla_aid, polla_answers FROM $wpdb->pollsa WHERE polla_qid = %d ORDER BY $order_by $sort_order\", $poll_id ) );\n$poll_voters = $wpdb->get_col( $wpdb->prepare( \"SELECT DISTINCT pollip_user FROM $wpdb->pollsip WHERE pollip_qid = %d AND pollip_user != %s ORDER BY pollip_user ASC\", $poll_id, __( 'Guest', 'wp-polls' ) ) );\n$poll_logs_count = $wpdb->get_var( $wpdb->prepare( \"SELECT COUNT(pollip_id) FROM $wpdb->pollsip WHERE pollip_qid = %d\", $poll_id ) );\n\n$exclude_registered = 0;\n$exclude_comment = 0;\n$exclude_guest = 0;\n\n$users_voted_for = null;\n$what_user_voted = null;\n\n### Process Filters\nif( ! empty( $_POST['do'] ) ) {\n    check_admin_referer('wp-polls_logs');\n    $registered_sql = '';\n    $comment_sql = '';\n    $guest_sql = '';\n    $users_voted_for_sql = '';\n    $what_user_voted_sql = '';\n    $num_choices_sql = '';\n    $num_choices_sign_sql = '';\n    $order_by = '';\n    switch((int) sanitize_key( $_POST['filter'] ) ) {\n        case 1:\n            $users_voted_for = (int) sanitize_key( $_POST['users_voted_for'] );\n            $exclude_registered = isset( $_POST['exclude_registered'] ) && (int) sanitize_key( $_POST['exclude_registered'] ) === 1;\n            $exclude_comment = isset( $_POST['exclude_comment'] ) && (int) sanitize_key( $_POST['exclude_comment'] ) === 1;\n            $exclude_guest = isset( $_POST['exclude_guest'] ) && (int) sanitize_key( $_POST['exclude_guest'] ) === 1;\n            $users_voted_for_sql = \"AND pollip_aid = $users_voted_for\";\n            if($exclude_registered) {\n                $registered_sql = 'AND pollip_userid = 0';\n            }\n            if($exclude_comment) {\n                if(!$exclude_registered) {\n                    $comment_sql = 'AND pollip_userid > 0';\n                } else {\n                    $comment_sql = 'AND pollip_user = \\''.__('Guest', 'wp-polls').'\\'';\n                }\n            }\n            if($exclude_guest) {\n                $guest_sql  = 'AND pollip_user != \\''.__('Guest', 'wp-polls').'\\'';\n            }\n            $order_by = 'pollip_timestamp DESC';\n            break;\n        case 2:\n            $exclude_registered_2 = (int) sanitize_key( $_POST['exclude_registered_2'] );\n            $exclude_comment_2 = (int) sanitize_key( $_POST['exclude_comment_2'] );\n            $num_choices = (int) sanitize_key( $_POST['num_choices']);\n            $num_choices_sign = sanitize_key( $_POST['num_choices_sign'] );\n            switch($num_choices_sign) {\n                case 'more':\n                    $num_choices_sign_sql = '>';\n                    break;\n                case 'more_exactly':\n                    $num_choices_sign_sql = '>=';\n                    break;\n                case 'exactly':\n                    $num_choices_sign_sql = '=';\n                    break;\n                case 'less_exactly':\n                    $num_choices_sign_sql = '<=';\n                    break;\n                case 'less':\n                    $num_choices_sign_sql = '<';\n                    break;\n            }\n            if($exclude_registered_2) {\n                $registered_sql = 'AND pollip_userid = 0';\n            }\n            if($exclude_comment_2) {\n                if(!$exclude_registered_2) {\n                    $comment_sql = 'AND pollip_userid > 0';\n                } else {\n                    $comment_sql = 'AND pollip_user = \\''.__('Guest', 'wp-polls').'\\'';\n                }\n            }\n            $guest_sql  = 'AND pollip_user != \\''.__('Guest', 'wp-polls').'\\'';\n            $num_choices_query = $wpdb->get_col(\"SELECT pollip_user, COUNT(pollip_ip) AS num_choices FROM $wpdb->pollsip WHERE pollip_qid = $poll_id GROUP BY pollip_ip, pollip_user HAVING num_choices $num_choices_sign_sql $num_choices\");\n            $num_choices_sql = 'AND pollip_user IN (\\''.implode('\\',\\'',$num_choices_query).'\\')';\n            $order_by = 'pollip_user, pollip_ip';\n            break;\n        case 3;\n            $what_user_voted = esc_sql( $_POST['what_user_voted'] );\n            $what_user_voted_sql = \"AND pollip_user = '$what_user_voted'\";\n            $order_by = 'pollip_user, pollip_ip';\n            break;\n    }\n    $poll_ips = $wpdb->get_results(\"SELECT $wpdb->pollsip.* FROM $wpdb->pollsip WHERE pollip_qid = $poll_id $users_voted_for_sql $registered_sql $comment_sql $guest_sql $what_user_voted_sql $num_choices_sql ORDER BY $order_by\");\n} else {\n    $poll_ips = $wpdb->get_results( $wpdb->prepare( \"SELECT pollip_aid, pollip_ip, pollip_host, pollip_timestamp, pollip_user FROM $wpdb->pollsip WHERE pollip_qid = %d ORDER BY pollip_aid ASC, pollip_user ASC LIMIT %d\", $poll_id, $max_records ) );\n}\n?>\n<?php if(!empty($text)) { echo '<!-- Last Action --><div id=\"message\" class=\"updated fade\">'.removeslashes($text).'</div>'; } else { echo '<div id=\"message\" class=\"updated\" style=\"display: none;\"></div>'; } ?>\n<div class=\"wrap\">\n    <h2><?php _e('Poll\\'s Logs', 'wp-polls'); ?></h2>\n    <h3><?php echo $poll_question; ?></h3>\n    <p>\n        <?php printf(_n('There are a total of <strong>%s</strong> recorded vote for this poll.', 'There are a total of <strong>%s</strong> recorded votes for this poll.', $poll_totalrecorded, 'wp-polls'), number_format_i18n($poll_totalrecorded)); ?><br />\n        <?php printf(_n('<strong>&raquo;</strong> <strong>%s</strong> vote is cast by registered users', '<strong>&raquo;</strong> <strong>%s</strong> votes are cast by registered users', $poll_registered, 'wp-polls'), number_format_i18n($poll_registered)); ?><br />\n        <?php printf(_n('<strong>&raquo;</strong> <strong>%s</strong> vote is cast by comment authors', '<strong>&raquo;</strong> <strong>%s</strong> votes are cast by comment authors', $poll_comments, 'wp-polls'), number_format_i18n($poll_comments)); ?><br />\n        <?php printf(_n('<strong>&raquo;</strong> <strong>%s</strong> vote is cast by guests', '<strong>&raquo;</strong> <strong>%s</strong> votes are cast by guests', $poll_guest, 'wp-polls'), number_format_i18n($poll_guest)); ?>\n    </p>\n</div>\n<?php if($poll_totalrecorded > 0 && apply_filters( 'wp_polls_log_show_log_filter', true )) { ?>\n<div class=\"wrap\">\n    <h3><?php _e('Filter Poll\\'s Logs', 'wp-polls') ?></h3>\n    <table width=\"100%\"  border=\"0\" cellspacing=\"0\" cellpadding=\"0\">\n        <tr>\n            <td width=\"50%\">\n                <form method=\"post\" action=\"<?php echo admin_url('admin.php?page='.$base_name.'&amp;mode=logs&amp;id='.$poll_id); ?>\">\n                <?php wp_nonce_field('wp-polls_logs'); ?>\n                <p style=\"display: none;\"><input type=\"hidden\" name=\"filter\" value=\"1\" /></p>\n                <table class=\"form-table\">\n                    <tr>\n                        <th scope=\"row\" valign=\"top\"><?php _e('Display All Users That Voted For', 'wp-polls'); ?></th>\n                        <td>\n                            <select name=\"users_voted_for\" size=\"1\">\n                                <?php\n                                    if($poll_answers_data) {\n                                        foreach($poll_answers_data as $data) {\n                                            $polla_id = (int) $data->polla_aid;\n                                            $polla_answers = removeslashes( strip_tags( esc_attr( $data->polla_answers ) ) );\n                                            if($polla_id  == $users_voted_for) {\n                                                echo '<option value=\"'.$polla_id .'\" selected=\"selected\">'.$polla_answers.'</option>';\n                                            } else {\n                                                echo '<option value=\"'.$polla_id .'\">'.$polla_answers.'</option>';\n                                            }\n                                            $pollip_answers[$polla_id] = $polla_answers;\n                                        }\n                                    }\n                                ?>\n                            </select>\n                        </td>\n                    </tr>\n                    <tr>\n                        <th scope=\"row\" valign=\"top\"><?php _e('Voters To EXCLUDE', 'wp-polls'); ?></th>\n                        <td>\n                            <input type=\"checkbox\" id=\"exclude_registered_1\" name=\"exclude_registered\" value=\"1\" <?php checked('1', $exclude_registered); ?> />&nbsp;<label for=\"exclude_registered_1\"><?php _e('Registered Users', 'wp-polls'); ?></label><br />\n                            <input type=\"checkbox\" id=\"exclude_comment_1\" name=\"exclude_comment\" value=\"1\" <?php checked('1', $exclude_comment); ?> />&nbsp;<label for=\"exclude_comment_1\"><?php _e('Comment Authors', 'wp-polls'); ?></label><br />\n                            <input type=\"checkbox\" id=\"exclude_guest_1\" name=\"exclude_guest\" value=\"1\" <?php checked('1', $exclude_guest); ?> />&nbsp;<label for=\"exclude_guest_1\"><?php _e('Guests', 'wp-polls'); ?></label>\n                        </td>\n                    </tr>\n                    <tr>\n                        <td colspan=\"2\" align=\"center\"><input type=\"submit\" name=\"do\" value=\"<?php _e('Filter', 'wp-polls'); ?>\" class=\"button\" /></td>\n                    </tr>\n                </table>\n                </form>\n            </td>\n            <td width=\"50%\">\n                <?php if($poll_multiple > 0) { ?>\n                    <form method=\"post\" action=\"<?php echo admin_url('admin.php?page='.$base_name.'&amp;mode=logs&amp;id='.$poll_id); ?>\">\n                    <?php wp_nonce_field('wp-polls_logs'); ?>\n                    <p style=\"display: none;\"><input type=\"hidden\" name=\"filter\" value=\"2\" /></p>\n                    <table class=\"form-table\">\n                        <tr>\n                            <th scope=\"row\" valign=\"top\"><?php _e('Display Users That Voted For', 'wp-polls'); ?></th>\n                            <td>\n                                <select name=\"num_choices_sign\" size=\"1\">\n                                    <option value=\"more\" <?php selected('more', $num_choices_sign); ?>><?php _e('More Than', 'wp-polls'); ?></option>\n                                    <option value=\"more_exactly\" <?php selected('more_exactly', $num_choices_sign); ?>><?php _e('More Than Or Exactly', 'wp-polls'); ?></option>\n                                    <option value=\"exactly\" <?php selected('exactly', $num_choices_sign); ?>><?php _e('Exactly', 'wp-polls'); ?></option>\n                                    <option value=\"less_exactly\" <?php selected('less_exactly', $num_choices_sign); ?>><?php _e('Less Than Or Exactly', 'wp-polls'); ?></option>\n                                    <option value=\"less\" <?php selected('less', $num_choices_sign); ?>><?php _e('Less Than', 'wp-polls'); ?></option>\n                                </select>\n                                &nbsp;&nbsp;\n                                <select name=\"num_choices\" size=\"1\">\n                                    <?php\n                                        for($i = 1; $i <= $poll_multiple; $i++) {\n                                            if($i == 1) {\n                                                echo '<option value=\"1\">'.__('1 Answer', 'wp-polls').'</option>';\n                                            } else {\n                                                if($i == $num_choices) {\n                                                    echo '<option value=\"'.$i.'\" selected=\"selected\">'.sprintf(_n('%s Answer', '%s Answers', $i, 'wp-polls'), number_format_i18n($i)).'</option>';\n                                                } else {\n                                                    echo '<option value=\"'.$i.'\">'.sprintf(_n('%s Answer', '%s Answers', $i, 'wp-polls'), number_format_i18n($i)).'</option>';\n                                                }\n                                            }\n                                        }\n                                    ?>\n                                </select>\n                            </td>\n                        </tr>\n                        <tr>\n                            <th scope=\"row\" valign=\"top\"><?php _e('Voters To EXCLUDE', 'wp-polls'); ?></th>\n                            <td>\n                                <input type=\"checkbox\" id=\"exclude_registered_2\" name=\"exclude_registered_2\" value=\"1\" <?php checked('1', $exclude_registered_2); ?> />&nbsp;<label for=\"exclude_registered_2\"><?php _e('Registered Users', 'wp-polls'); ?></label><br />\n                                <input type=\"checkbox\" id=\"exclude_comment_2\" name=\"exclude_comment_2\" value=\"1\" <?php checked('1', $exclude_comment_2); ?> />&nbsp;<label for=\"exclude_comment_2\"><?php _e('Comment Authors', 'wp-polls'); ?></label><br />\n                                <?php _e('Guests will automatically be excluded', 'wp-polls'); ?>\n                            </td>\n                        </tr>\n                        <tr>\n                            <td colspan=\"2\" align=\"center\"><input type=\"submit\" name=\"do\" value=\"<?php _e('Filter', 'wp-polls'); ?>\" class=\"button\" /></td>\n                        </tr>\n                    </table>\n                    </form>\n                <?php } else { ?>\n                    &nbsp;\n                <?php } // End if($poll_multiple > -1) ?>\n            </td>\n        </tr>\n        <tr>\n            <td>\n                <?php if($poll_voters) { ?>\n                <form method=\"post\" action=\"<?php echo admin_url('admin.php?page='.$base_name.'&amp;mode=logs&amp;id='.$poll_id); ?>\">\n                <?php wp_nonce_field('wp-polls_logs'); ?>\n                <p style=\"display: none;\"><input type=\"hidden\" name=\"filter\" value=\"3\" /></p>\n                <table class=\"form-table\">\n                    <tr>\n                        <th scope=\"row\" valign=\"top\"><?php _e('Display What This User Has Voted', 'wp-polls'); ?></th>\n                        <td>\n                            <select name=\"what_user_voted\" size=\"1\">\n                                <?php\n                                    if($poll_voters) {\n                                        foreach($poll_voters as $pollip_user) {\n                                            if($pollip_user == $what_user_voted) {\n                                                echo '<option value=\"' . removeslashes( esc_attr( $pollip_user ) ) . '\" selected=\"selected\">' . removeslashes( esc_attr( $pollip_user ) ) . '</option>';\n                                            } else {\n                                                echo '<option value=\"' . removeslashes( esc_attr( $pollip_user ) ) . '\">' . removeslashes( esc_attr( $pollip_user ) ) . '</option>';\n                                            }\n                                        }\n                                    }\n                                ?>\n                            </select>\n                        </td>\n                    </tr>\n                    <tr>\n                        <td colspan=\"2\" align=\"center\"><input type=\"submit\" name=\"do\" value=\"<?php _e('Filter', 'wp-polls'); ?>\" class=\"button\" /></td>\n                    </tr>\n                </table>\n                </form>\n                <?php } else { ?>\n                    &nbsp;\n                <?php } // End if($poll_multiple > -1) ?>\n            </td>\n            <td align=\"center\"><input type=\"button\" value=\"<?php _e('Clear Filter', 'wp-polls'); ?>\" onclick=\"self.location.href = '<?php echo esc_attr( $base_page ); ?>&amp;mode=logs&amp;id=<?php echo $poll_id; ?>';\" class=\"button\" /></td>\n        </tr>\n    </table>\n</div>\n<p>&nbsp;</p>\n<?php } // End if($poll_totalrecorded > 0) ?>\n<div class=\"wrap\">\n    <h3><?php _e('Poll Logs', 'wp-polls'); ?></h3>\n    <div id=\"poll_logs_display\">\n        <?php\n            if($poll_ips) {\n                if(empty($_POST['do'])) {\n                    echo '<p>'.sprintf(__('This default filter is limited to display only <strong>%s</strong> records.', 'wp-polls'), number_format_i18n($max_records)).'</p>';\n                }\n                echo '<table class=\"widefat\">'.\"\\n\";\n                echo \"<tr class=\\\"highlight\\\"><td colspan=\\\"4\\\">\". $poll_question . \"</td></tr>\";\n                $k = 1;\n                $j = 0;\n                $poll_last_aid = -1;\n                $temp_pollip_user = null;\n                if(isset($_POST['filter']) && (int) sanitize_key( $_POST['filter'] ) > 1) {\n                    echo \"<tr class=\\\"thead\\\">\\n\";\n                    echo \"<th>\".__('Answer', 'wp-polls').\"</th>\\n\";\n                    echo \"<th>\".__('IP', 'wp-polls').\"</th>\\n\";\n                    echo \"<th>\".__('Host', 'wp-polls').\"</th>\\n\";\n                    echo \"<th>\".__('Date', 'wp-polls').\"</th>\\n\";\n                    echo \"</tr>\\n\";\n                    foreach($poll_ips as $poll_ip) {\n                        $pollip_aid = (int) $poll_ip->pollip_aid;\n                        $pollip_user = removeslashes($poll_ip->pollip_user);\n                        $pollip_ip = $poll_ip->pollip_ip;\n                        $pollip_host = $poll_ip->pollip_host;\n                        $pollip_date = mysql2date(sprintf(__('%s @ %s', 'wp-polls'), get_option('date_format'), get_option('time_format')), gmdate('Y-m-d H:i:s', $poll_ip->pollip_timestamp));\n\n                        $i = 0;\n                        if($i % 2 === 0) {\n                            $style = '';\n                        }  else {\n                            $style = 'class=\"alternate\"';\n                        }\n                        if($pollip_user != $temp_pollip_user) {\n                            echo '<tr class=\"highlight\">'.\"\\n\";\n                            echo \"<td colspan=\\\"4\\\"><strong>\".__('User', 'wp-polls').\" \".number_format_i18n($k).\": $pollip_user</strong></td>\\n\";\n                            echo '</tr>';\n                            $k++;\n                        }\n                        echo \"<tr $style>\\n\";\n                        echo \"<td>{$pollip_answers[$pollip_aid]}</td>\\n\";\n                        echo \"<td>$pollip_ip</td>\\n\";\n                        echo \"<td>$pollip_host</td>\\n\";\n                        echo \"<td>$pollip_date</td>\\n\";\n                        echo \"</tr>\\n\";\n                        $temp_pollip_user = $pollip_user;\n                        $i++;\n                        $j++;\n                    }\n                } else {\n                    foreach($poll_ips as $poll_ip) {\n                        $pollip_aid = (int) $poll_ip->pollip_aid;\n                        $pollip_user = apply_filters( 'wp_polls_log_secret_ballot', removeslashes( $poll_ip->pollip_user ) );\n                        $pollip_ip = $poll_ip->pollip_ip;\n                        $pollip_host = $poll_ip->pollip_host;\n                        $pollip_date = mysql2date(sprintf(__('%s @ %s', 'wp-polls'), get_option('date_format'), get_option('time_format')), gmdate('Y-m-d H:i:s', $poll_ip->pollip_timestamp));\n                        if($pollip_aid != $poll_last_aid) {\n                            if($pollip_aid == 0) {\n                                echo \"<tr class=\\\"highlight\\\">\\n<td colspan=\\\"4\\\"><strong>$pollip_answers[$pollip_aid]</strong></td>\\n</tr>\\n\";\n                            } else {\n                                $polla_answer = ! empty( $pollip_answers[$pollip_aid] ) ? $pollip_answers[ $pollip_aid ] : $poll_answers_data[ $k-1 ]->polla_answers;\n                                echo \"<tr class=\\\"highlight\\\">\\n<td colspan=\\\"4\\\"><strong>\".__('Answer', 'wp-polls').\" \".number_format_i18n($k).\": \" . $polla_answer . \"</strong></td>\\n</tr>\\n\";\n                                $k++;\n                            }\n                            echo \"<tr class=\\\"thead\\\">\\n\";\n                            echo \"<th>\".__('No.', 'wp-polls').\"</th>\\n\";\n                            echo \"<th>\".__('User', 'wp-polls').\"</th>\\n\";\n                            echo \"<th>\".__('Hashed IP / Host', 'wp-polls').\"</th>\\n\";\n                            echo \"<th>\".__('Date', 'wp-polls').\"</th>\\n\";\n                            echo \"</tr>\\n\";\n                            $i = 1;\n                        }\n                        if($i%2 == 0) {\n                            $style = '';\n                        }  else {\n                            $style = 'class=\"alternate\"';\n                        }\n                        echo \"<tr $style>\\n\";\n                        echo \"<td>\".number_format_i18n($i).\"</td>\\n\";\n                        echo \"<td>$pollip_user</td>\\n\";\n                        echo \"<td>$pollip_ip / $pollip_host</td>\\n\";\n                        echo \"<td>$pollip_date</td>\\n\";\n                        echo \"</tr>\\n\";\n                        $poll_last_aid = $pollip_aid;\n                        $i++;\n                        $j++;\n                    }\n                }\n                echo \"<tr class=\\\"highlight\\\">\\n\";\n                echo \"<td colspan=\\\"4\\\">\".sprintf(__('Total number of records that matches this filter: <strong>%s</strong>', 'wp-polls'), number_format_i18n($j)).\"</td>\";\n                echo \"</tr>\\n\";\n                echo '</table>'.\"\\n\";\n            }\n        ?>\n    </div>\n    <?php if(!empty($_POST['do'])) { ?>\n        <br class=\"clear\" /><div id=\"poll_logs_display_none\" style=\"text-align: center; display: <?php if(!$poll_ips) { echo 'block'; } else { echo 'none'; } ?>;\" ><?php _e('No poll logs matches the filter.', 'wp-polls'); ?></div>\n    <?php } else { ?>\n        <br class=\"clear\" /><div id=\"poll_logs_display_none\" style=\"text-align: center; display: <?php if(!$poll_logs_count) { echo 'block'; } else { echo 'none'; } ?>;\" ><?php _e('No poll logs available for this poll.', 'wp-polls'); ?></div>\n    <?php } ?>\n</div>\n<p>&nbsp;</p>\n\n<!-- Delete Poll Logs -->\n<div class=\"wrap\">\n    <h3><?php _e('Delete Poll Logs', 'wp-polls'); ?></h3>\n    <br class=\"clear\" />\n    <div align=\"center\" id=\"poll_logs\">\n        <?php if($poll_logs_count) { ?>\n            <strong><?php _e('Are You Sure You Want To Delete Logs For This Poll Only?', 'wp-polls'); ?></strong><br /><br />\n            <input type=\"checkbox\" id=\"delete_logs_yes\" name=\"delete_logs_yes\" value=\"yes\" />&nbsp;<label for=\"delete_logs_yes\"><?php _e('Yes', 'wp-polls'); ?></label><br /><br />\n            <input type=\"button\" name=\"do\" value=\"<?php _e('Delete Logs For This Poll Only', 'wp-polls'); ?>\" class=\"button\" onclick=\"delete_this_poll_logs(<?php echo $poll_id; ?>, '<?php printf( esc_js( __( 'You are about to delete poll logs for this poll \\'%s\\' ONLY. This action is not reversible.', 'wp-polls' ) ), esc_js( esc_attr( $poll_question ) ) ); ?>', '<?php echo wp_create_nonce('wp-polls_delete-poll-logs'); ?>');\" />\n        <?php\n            } else {\n                _e('No poll logs available for this poll.', 'wp-polls');\n            }\n        ?>\n    </div>\n    <p><?php _e('Note: If your logging method is by IP and Cookie or by Cookie, users may still be unable to vote if they have voted before as the cookie is still stored in their computer.', 'wp-polls'); ?></p>\n</div>\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2024-21517", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "<?php\nnamespace Opencart\\Catalog\\Controller\\Account;\n/**\n * Class Login\n *\n * @package Opencart\\Catalog\\Controller\\Account\n */\nclass Login extends \\Opencart\\System\\Engine\\Controller {\n\t/**\n\t * @return void\n\t */\n\tpublic function index(): void {\n\t\t$this->load->language('account/login');\n\n\t\t$this->document->setTitle($this->language->get('heading_title'));\n\n\t\t// If already logged in and has matching token then redirect to account page\n\t\tif ($this->customer->isLogged() && isset($this->request->get['customer_token']) && isset($this->session->data['customer_token']) && ($this->request->get['customer_token'] == $this->session->data['customer_token'])) {\n\t\t\t$this->response->redirect($this->url->link('account/account', 'language=' . $this->config->get('config_language') . '&customer_token=' . $this->session->data['customer_token']));\n\t\t}\n\n\t\t$data['breadcrumbs'] = [];\n\n\t\t$data['breadcrumbs'][] = [\n\t\t\t'text' => $this->language->get('text_home'),\n\t\t\t'href' => $this->url->link('common/home', 'language=' . $this->config->get('config_language'))\n\t\t];\n\n\t\t$data['breadcrumbs'][] = [\n\t\t\t'text' => $this->language->get('text_account'),\n\t\t\t'href' => $this->url->link('account/account', 'language=' . $this->config->get('config_language'))\n\t\t];\n\n\t\t$data['breadcrumbs'][] = [\n\t\t\t'text' => $this->language->get('text_login'),\n\t\t\t'href' => $this->url->link('account/login', 'language=' . $this->config->get('config_language'))\n\t\t];\n\n\t\t// Check to see if user is using incorrect token\n\t\tif (isset($this->session->data['customer_token'])) {\n\t\t\t$data['error_warning'] = $this->language->get('error_token');\n\n\t\t\t$this->customer->logout();\n\n\t\t\tunset($this->session->data['customer']);\n\t\t\tunset($this->session->data['shipping_address']);\n\t\t\tunset($this->session->data['shipping_method']);\n\t\t\tunset($this->session->data['shipping_methods']);\n\t\t\tunset($this->session->data['payment_address']);\n\t\t\tunset($this->session->data['payment_method']);\n\t\t\tunset($this->session->data['payment_methods']);\n\t\t\tunset($this->session->data['comment']);\n\t\t\tunset($this->session->data['order_id']);\n\t\t\tunset($this->session->data['coupon']);\n\t\t\tunset($this->session->data['reward']);\n\t\t\tunset($this->session->data['voucher']);\n\t\t\tunset($this->session->data['vouchers']);\n\t\t\tunset($this->session->data['customer_token']);\n\t\t} elseif (isset($this->session->data['error'])) {\n\t\t\t$data['error_warning'] = $this->session->data['error'];\n\n\t\t\tunset($this->session->data['error']);\n\t\t} else {\n\t\t\t$data['error_warning'] = '';\n\t\t}\n\n\t\tif (isset($this->session->data['success'])) {\n\t\t\t$data['success'] = $this->session->data['success'];\n\n\t\t\tunset($this->session->data['success']);\n\t\t} else {\n\t\t\t$data['success'] = '';\n\t\t}\n\n\t\tif (isset($this->session->data['redirect'])) {\n\t\t\t$data['redirect'] = $this->session->data['redirect'];\n\n\t\t\tunset($this->session->data['redirect']);\n\t\t} elseif (isset($this->request->get['redirect'])) {\n\t\t\t$data['redirect'] = urldecode($this->request->get['redirect']);\n\t\t} else {\n\t\t\t$data['redirect'] = '';\n\t\t}\n\n\t\t$this->session->data['login_token'] = oc_token(26);\n\n\t\t$data['login'] = $this->url->link('account/login.login', 'language=' . $this->config->get('config_language') . '&login_token=' . $this->session->data['login_token']);\n\t\t$data['register'] = $this->url->link('account/register', 'language=' . $this->config->get('config_language'));\n\t\t$data['forgotten'] = $this->url->link('account/forgotten', 'language=' . $this->config->get('config_language'));\n\n\t\t$data['column_left'] = $this->load->controller('common/column_left');\n\t\t$data['column_right'] = $this->load->controller('common/column_right');\n\t\t$data['content_top'] = $this->load->controller('common/content_top');\n\t\t$data['content_bottom'] = $this->load->controller('common/content_bottom');\n\t\t$data['footer'] = $this->load->controller('common/footer');\n\t\t$data['header'] = $this->load->controller('common/header');\n\n\t\t$this->response->setOutput($this->load->view('account/login', $data));\n\t}\n\n\t/**\n\t * Login\n\t *\n\t * @return void\n\t */\n\tpublic function login(): void {\n\t\t$this->load->language('account/login');\n\n\t\t$json = [];\n\n\t\t// Stop any undefined index messages.\n\t\t$keys = [\n\t\t\t'email',\n\t\t\t'password',\n\t\t\t'redirect'\n\t\t];\n\n\t\tforeach ($keys as $key) {\n\t\t\tif (!isset($this->request->post[$key])) {\n\t\t\t\t$this->request->post[$key] = '';\n\t\t\t}\n\t\t}\n\n\t\t$this->customer->logout();\n\n\t\tif (!isset($this->request->get['login_token']) || !isset($this->session->data['login_token']) || ($this->request->get['login_token'] != $this->session->data['login_token'])) {\n\t\t\t$json['redirect'] = $this->url->link('account/login', 'language=' . $this->config->get('config_language'), true);\n\t\t}\n\n\t\tif (!$json) {\n\t\t\t// Check how many login attempts have been made.\n\t\t\t$this->load->model('account/customer');\n\n\t\t\t$login_info = $this->model_account_customer->getLoginAttempts($this->request->post['email']);\n\n\t\t\tif ($login_info && ($login_info['total'] >= $this->config->get('config_login_attempts')) && strtotime('-1 hour') < strtotime($login_info['date_modified'])) {\n\t\t\t\t$json['error']['warning'] = $this->language->get('error_attempts');\n\t\t\t}\n\n\t\t\t// Check if customer has been approved.\n\t\t\t$customer_info = $this->model_account_customer->getCustomerByEmail($this->request->post['email']);\n\n\t\t\tif ($customer_info && !$customer_info['status']) {\n\t\t\t\t$json['error']['warning'] = $this->language->get('error_approved');\n\t\t\t} elseif (!$this->customer->login($this->request->post['email'], html_entity_decode($this->request->post['password'], ENT_QUOTES, 'UTF-8'))) {\n\t\t\t\t$json['error']['warning'] = $this->language->get('error_login');\n\n\t\t\t\t$this->model_account_customer->addLoginAttempt($this->request->post['email']);\n\t\t\t}\n\t\t}\n\n\t\tif (!$json) {\n\t\t\t// Add customer details into session\n\t\t\t$this->session->data['customer'] = [\n\t\t\t\t'customer_id'       => $customer_info['customer_id'],\n\t\t\t\t'customer_group_id' => $customer_info['customer_group_id'],\n\t\t\t\t'firstname'         => $customer_info['firstname'],\n\t\t\t\t'lastname'          => $customer_info['lastname'],\n\t\t\t\t'email'             => $customer_info['email'],\n\t\t\t\t'telephone'         => $customer_info['telephone'],\n\t\t\t\t'custom_field'      => $customer_info['custom_field']\n\t\t\t];\n\n\t\t\tunset($this->session->data['order_id']);\n\t\t\tunset($this->session->data['shipping_method']);\n\t\t\tunset($this->session->data['shipping_methods']);\n\t\t\tunset($this->session->data['payment_method']);\n\t\t\tunset($this->session->data['payment_methods']);\n\n\t\t\t// Wishlist\n\t\t\tif (isset($this->session->data['wishlist']) && is_array($this->session->data['wishlist'])) {\n\t\t\t\t$this->load->model('account/wishlist');\n\n\t\t\t\tforeach ($this->session->data['wishlist'] as $key => $product_id) {\n\t\t\t\t\t$this->model_account_wishlist->addWishlist($product_id);\n\n\t\t\t\t\tunset($this->session->data['wishlist'][$key]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Log the IP info\n\t\t\t$this->model_account_customer->addLogin($this->customer->getId(), $this->request->server['REMOTE_ADDR']);\n\n\t\t\t// Create customer token\n\t\t\t$this->session->data['customer_token'] = oc_token(26);\n\n\t\t\t$this->model_account_customer->deleteLoginAttempts($this->request->post['email']);\n\n\t\t\t// Added strpos check to pass McAfee PCI compliance test (http://forum.opencart.com/viewtopic.php?f=10&t=12043&p=151494#p151295)\n\t\t\tif (isset($this->request->post['redirect']) && str_starts_with(html_entity_decode($this->request->post['redirect'], ENT_QUOTES, 'UTF-8'), $this->config->get('config_url'))) {\n\t\t\t\t$json['redirect'] = html_entity_decode($this->request->post['redirect'], ENT_QUOTES, 'UTF-8') . '&customer_token=' . $this->session->data['customer_token'];\n\t\t\t} else {\n\t\t\t\t$json['redirect'] = $this->url->link('account/account', 'language=' . $this->config->get('config_language') . '&customer_token=' . $this->session->data['customer_token'], true);\n\t\t\t}\n\t\t}\n\n\t\t$this->response->addHeader('Content-Type: application/json');\n\t\t$this->response->setOutput(json_encode($json));\n\t}\n\n\t/**\n\t * Token\n\t *\n\t * @return void\n\t */\n\tpublic function token(): void {\n\t\t$this->load->language('account/login');\n\n\t\tif (isset($this->request->get['email'])) {\n\t\t\t$email = $this->request->get['email'];\n\t\t} else {\n\t\t\t$email = '';\n\t\t}\n\n\t\tif (isset($this->request->get['login_token'])) {\n\t\t\t$token = $this->request->get['login_token'];\n\t\t} else {\n\t\t\t$token = '';\n\t\t}\n\n\t\t// Login override for admin users\n\t\t$this->customer->logout();\n\t\t$this->cart->clear();\n\n\t\tunset($this->session->data['order_id']);\n\t\tunset($this->session->data['payment_address']);\n\t\tunset($this->session->data['payment_method']);\n\t\tunset($this->session->data['payment_methods']);\n\t\tunset($this->session->data['shipping_address']);\n\t\tunset($this->session->data['shipping_method']);\n\t\tunset($this->session->data['shipping_methods']);\n\t\tunset($this->session->data['comment']);\n\t\tunset($this->session->data['coupon']);\n\t\tunset($this->session->data['reward']);\n\t\tunset($this->session->data['voucher']);\n\t\tunset($this->session->data['vouchers']);\n\t\tunset($this->session->data['customer_token']);\n\n\t\t$this->load->model('account/customer');\n\n\t\t$customer_info = $this->model_account_customer->getCustomerByEmail($email);\n\n\t\tif ($customer_info && $customer_info['token'] && $customer_info['token'] == $token && $this->customer->login($customer_info['email'], '', true)) {\n\t\t\t// Add customer details into session\n\t\t\t$this->session->data['customer'] = [\n\t\t\t\t'customer_id'       => $customer_info['customer_id'],\n\t\t\t\t'customer_group_id' => $customer_info['customer_group_id'],\n\t\t\t\t'firstname'         => $customer_info['firstname'],\n\t\t\t\t'lastname'          => $customer_info['lastname'],\n\t\t\t\t'email'             => $customer_info['email'],\n\t\t\t\t'telephone'         => $customer_info['telephone'],\n\t\t\t\t'custom_field'      => $customer_info['custom_field']\n\t\t\t];\n\n\t\t\t// Default Addresses\n\t\t\t$this->load->model('account/address');\n\n\t\t\t$address_info = $this->model_account_address->getAddress($this->customer->getId(), $this->customer->getAddressId());\n\n\t\t\tif ($address_info) {\n\t\t\t\t$this->session->data['shipping_address'] = $address_info;\n\t\t\t}\n\n\t\t\tif ($this->config->get('config_tax_customer') && $address_info) {\n\t\t\t\t$this->session->data[$this->config->get('config_tax_customer') . '_address'] = $address_info;\n\t\t\t}\n\n\t\t\t$this->model_account_customer->editToken($email, '');\n\n\t\t\t// Create customer token\n\t\t\t$this->session->data['customer_token'] = oc_token(26);\n\n\t\t\t$this->response->redirect($this->url->link('account/account', 'language=' . $this->config->get('config_language') . '&customer_token=' . $this->session->data['customer_token']));\n\t\t} else {\n\t\t\t$this->session->data['error'] = $this->language->get('error_login');\n\n\t\t\t$this->model_account_customer->editToken($email, '');\n\n\t\t\t$this->response->redirect($this->url->link('account/login', 'language=' . $this->config->get('config_language')));\n\t\t}\n\t}\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2024-21550", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "/*\n * SteVe - SteckdosenVerwaltung - https://github.com/steve-community/steve\n * Copyright (C) 2013-2022 SteVe Community Team\n * All Rights Reserved.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\npackage de.rwth.idsg.steve.config;\n\nimport com.google.common.collect.Lists;\nimport de.rwth.idsg.steve.ocpp.ws.OcppWebSocketHandshakeHandler;\nimport de.rwth.idsg.steve.ocpp.ws.ocpp12.Ocpp12WebSocketEndpoint;\nimport de.rwth.idsg.steve.ocpp.ws.ocpp15.Ocpp15WebSocketEndpoint;\nimport de.rwth.idsg.steve.ocpp.ws.ocpp16.Ocpp16WebSocketEndpoint;\nimport de.rwth.idsg.steve.service.ChargePointHelperService;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.socket.config.annotation.EnableWebSocket;\nimport org.springframework.web.socket.config.annotation.WebSocketConfigurer;\nimport org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;\nimport org.springframework.web.socket.server.support.DefaultHandshakeHandler;\n\nimport java.time.Duration;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @author Sevket Goekay <sevketgokay@gmail.com>\n * @since 11.03.2015\n */\n@EnableWebSocket\n@Configuration\n@Slf4j\npublic class WebSocketConfiguration implements WebSocketConfigurer {\n\n    @Autowired private ChargePointHelperService chargePointHelperService;\n\n    @Autowired private Ocpp12WebSocketEndpoint ocpp12WebSocketEndpoint;\n    @Autowired private Ocpp15WebSocketEndpoint ocpp15WebSocketEndpoint;\n    @Autowired private Ocpp16WebSocketEndpoint ocpp16WebSocketEndpoint;\n\n    public static final String PATH_INFIX = \"/websocket/CentralSystemService/\";\n    public static final long PING_INTERVAL = TimeUnit.MINUTES.toMinutes(15);\n    public static final Duration IDLE_TIMEOUT = Duration.ofHours(2);\n    public static final int MAX_MSG_SIZE = 8_388_608; // 8 MB for max message size\n\n    @Override\n    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {\n\n        OcppWebSocketHandshakeHandler handshakeHandler = new OcppWebSocketHandshakeHandler(\n            new DefaultHandshakeHandler(),\n            Lists.newArrayList(ocpp16WebSocketEndpoint, ocpp15WebSocketEndpoint, ocpp12WebSocketEndpoint),\n            chargePointHelperService\n        );\n\n        registry.addHandler(handshakeHandler.getDummyWebSocketHandler(), PATH_INFIX + \"*\")\n                .setHandshakeHandler(handshakeHandler)\n                .setAllowedOrigins(\"*\");\n    }\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2024-22191", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "/* eslint-disable max-len */\nimport { Controller } from '@hotwired/stimulus'\nimport { castBoolean } from '../../helpers/cast_boolean'\n\nexport default class extends Controller {\n  static targets = ['input', 'controller', 'rows']\n\n  fieldValue = []\n\n  options = {}\n\n  get keyInputDisabled() {\n    return !this.options.editable || this.options.disable_editing_keys\n  }\n\n  get valueInputDisabled() {\n    return !this.options.editable\n  }\n\n  connect() {\n    this.setOptions()\n\n    try {\n      const objectValue = JSON.parse(this.inputTarget.value)\n      Object.keys(objectValue).forEach((key) => this.fieldValue.push([key, objectValue[key]]))\n    } catch (error) {\n      this.fieldValue = []\n    }\n\n    this.updateKeyValueComponent()\n  }\n\n  addRow() {\n    if (this.options.disable_adding_rows || !this.options.editable) return\n    this.fieldValue.push(['', ''])\n    this.updateKeyValueComponent()\n    this.focusLastRow()\n  }\n\n  deleteRow(event) {\n    if (this.options.disable_deleting_rows || !this.options.editable) return\n    const { index } = event.params\n    this.fieldValue.splice(index, 1)\n    this.updateTextareaInput()\n    this.updateKeyValueComponent()\n  }\n\n  focusLastRow() {\n    return this.rowsTarget.querySelector('.flex.key-value-row:last-child .key-value-input-key').focus()\n  }\n\n  valueFieldUpdated(event) {\n    const { value } = event.target\n    const { index } = event.target.dataset\n    this.fieldValue[index][1] = value\n\n    this.updateTextareaInput()\n  }\n\n  keyFieldUpdated(event) {\n    const { value } = event.target\n    const { index } = event.target.dataset\n    this.fieldValue[index][0] = value\n\n    this.updateTextareaInput()\n  }\n\n  updateTextareaInput() {\n    if (!this.hasInputTarget) return\n    let result = {}\n    if (this.fieldValue && this.fieldValue.length > 0) {\n      result = Object.assign(...this.fieldValue.map(([key, val]) => ({ [key]: val })))\n    }\n    this.inputTarget.innerText = JSON.stringify(result)\n    this.inputTarget.dispatchEvent(new Event('input'))\n  }\n\n  updateKeyValueComponent() {\n    let result = ''\n    let index = 0\n    this.fieldValue.forEach((row) => {\n      const [key, value] = row\n      result += this.interpolatedRow(key, value, index)\n      index++\n    })\n    this.rowsTarget.innerHTML = result\n    window.initTippy()\n  }\n\n  interpolatedRow(key, value, index) {\n    let result = `<div class=\"flex key-value-row\">\n      ${this.inputField('key', index, key, value)}\n      ${this.inputField('value', index, key, value)}`\n    if (this.options.editable) {\n      result += `<a\n  href=\"javascript:void(0);\"\n  data-key-value-index-param=\"${index}\"\n  data-action=\"click->key-value#deleteRow\"\n  title=\"${this.options.delete_text}\"\n  data-tippy=\"tooltip\"\n  data-button=\"delete-row\"\n  tabindex=\"-1\"\n  ${this.options.disable_deleting_rows ? \"disabled='disabled'\" : ''}\n  class=\"flex items-center justify-center p-2 px-3 border-none ${this.options.disable_deleting_rows ? 'cursor-not-allowed' : ''}\"\n><svg class=\"pointer-events-none text-gray-500 h-5 hover:text-gray-500\" fill=\"none\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" viewBox=\"0 0 24 24\" stroke=\"currentColor\"><path d=\"M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16\"></path></svg></a>`\n    }\n    result += '</div>'\n\n    return result\n  }\n\n  inputField(id = 'key', index, key, value) {\n    const inputValue = id === 'key' ? key : value\n\n    return `<input\n  class=\"${this.options.inputClasses} focus:bg-gray-100 !rounded-none border-gray-600 border-r border-l-0 border-b-0 border-t-0 focus:border-gray-300 w-1/2 focus:outline-none outline-none key-value-input-${id}\"\n  data-action=\"input->key-value#${id}FieldUpdated\"\n  placeholder=\"${this.options[`${id}_label`]}\"\n  data-index=\"${index}\"\n  ${this[`${id}InputDisabled`] ? \"disabled='disabled'\" : ''}\n  value=\"${typeof inputValue === 'undefined' || inputValue === null ? '' : inputValue}\"\n/>`\n  }\n\n  setOptions() {\n    let fieldOptions\n\n    try {\n      fieldOptions = JSON.parse(this.controllerTarget.dataset.options)\n    } catch (error) {\n      fieldOptions = {}\n    }\n    this.options = {\n      ...fieldOptions,\n      inputClasses: this.controllerTarget.dataset.inputClasses,\n      editable: castBoolean(this.controllerTarget.dataset.editable),\n    }\n  }\n}\n", "output": {"vulnerability_count": 5, "vulnerabilities": [{"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 86}, {"description": "User controlled data in a `this.rowsTarget.innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 86}, {"description": "This template literal looks like HTML and has interpolated variables. These variables are not HTML-encoded by default. If the variables contain HTML tags, these may be interpreted by the browser, resulting in cross-site scripting (XSS).", "risk": "Medium", "conceptual_fix": "Not provided", "line": 91}, {"description": "This template literal looks like HTML and has interpolated variables. These variables are not HTML-encoded by default. If the variables contain HTML tags, these may be interpreted by the browser, resulting in cross-site scripting (XSS).", "risk": "Medium", "conceptual_fix": "Not provided", "line": 95}, {"description": "This template literal looks like HTML and has interpolated variables. These variables are not HTML-encoded by default. If the variables contain HTML tags, these may be interpreted by the browser, resulting in cross-site scripting (XSS).", "risk": "Medium", "conceptual_fix": "Not provided", "line": 115}]}}
{"CVE": "CVE-2024-22418", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "<?php\n\n\nnamespace GO\\Files\\Controller;\n\nuse GO\\Base\\Exception\\AccessDenied;\nuse GO\\Base\\Exception\\NotFound;\nuse go\\core\\http\\Client;\nuse go\\core\\http\\Request;\nuse go\\core\\http\\Response;\nuse go\\core\\util\\StringUtil;\nuse GO\\Email\\Model\\Account;\nuse GO\\Files\\Model\\File;\nuse go\\core\\fs\\Blob;\nuse go\\core\\fs\\File as GoFile;\nuse go\\core\\fs\\Folder;\nuse GO\\Email\\Controller\\MessageController;\nuse go\\modules\\community\\history\\Module;\nuse Exception;\n\nclass FileController extends \\GO\\Base\\Controller\\AbstractModelController {\n\n\tprotected $model = 'GO\\Files\\Model\\File';\n\t\n\tprotected function allowGuests() {\n\t\treturn array('download'); //permissions will be checked manually in that action\n\t}\n\t\n\tprotected function ignoreAclPermissions() {\n\t\treturn array('correctquotauser');\n\t}\n\t\n\tprotected function actionTest($params) {\n\n\t\t$md = new \\go\\core\\fs\\MetaData($this);\n\t\t$tag = $md->extractID3(__DIR__.'/test.mp3');\n\t\tvar_dump($tag->toArray());\n\t}\n\tprotected function actionExif(){\n\t\t\n\t\t$md = new \\go\\core\\fs\\MetaData($this);\n\t\t$exif = $md->extractExif(__DIR__.'/test.jpg');\n\t\t\n\t}\n\n\tpublic function actionCreateBlob($ids) {\n\t\t$ids = explode(',', $ids);\n\t\t$blobs = [];\n\t\tforeach($ids as $id) {\n\t\t\t$file = File::model()->findByPk($id);\n\n\t\t\t$fsFile = new GOFile($file->fsFile->path());\n\t\t\t$blob = Blob::fromFile($fsFile);\n\t\t\t$blob->save();\t\t\t\n\n\t\t\t$blobs[] = ['name' => $file->name, 'blobId' => $blob->id];\n\t\t}\n\n\t\treturn array_merge(['success' => true, 'blobs' => $blobs], $blob->toArray());\n\t}\n\t\n\t\n\tprotected function actionExpiredList($params){\n\t\t\t\t\n\t\t$store = \\GO\\Base\\Data\\Store::newInstance(\\GO\\Files\\Model\\File::model());\n\t\t$store->getColumnModel()->formatColumn('path', '$model->path', array(), array('first_name', 'last_name'));\n\n//\t\t$findParams = $store->getDefaultParams($params);\n\t\t\n\t\t$findParams = \\GO\\Base\\Db\\FindParams::newInstance()->ignoreAcl();\n\n\n\t\t$joinSearchCacheCriteria = \\GO\\Base\\Db\\FindCriteria::newInstance()\n\t\t\t\t\t->addRawCondition('`t`.`id`', '`sc`.`entityId`')\n\t\t\t\t\t->addCondition('entityTypeId', \\GO\\Files\\Model\\File::model()->modelTypeId(),'=','sc');\n\n\t\t$findParams->join(\\GO\\Base\\Model\\SearchCacheRecord::model()->tableName(), $joinSearchCacheCriteria, 'sc', 'INNER');\n\n\n\t\t$aclJoinCriteria = \\GO\\Base\\Db\\FindCriteria::newInstance()\n\t\t\t\t\t\t\t->addRawCondition('a.aclId', 'sc.aclId','=', false);\n\n\t\t$aclWhereCriteria = \\GO\\Base\\Db\\FindCriteria::newInstance()\n\t\t\t\t\t\t->addInCondition(\"groupId\", \\GO\\Base\\Model\\User::getGroupIds(\\GO::user()->id),\"a\", false);\n\n\t\t$findParams->join(\\GO\\Base\\Model\\AclUsersGroups::model()->tableName(), $aclJoinCriteria, 'a', 'INNER');\n\n\t\t$findParams->criteria(\\GO\\Base\\Db\\FindCriteria::newInstance()\n\t\t\t\t\t\t\t\t->addModel(\\GO\\Files\\Model\\Folder::model())\n\t\t\t\t\t\t\t\t->mergeWith($aclWhereCriteria));\n\n\t\t$findParams->group(array('t.id'))->order('mtime','DESC');\n\t\t\n\t\t$findParams->getCriteria()->addCondition('content_expire_date', time() ,'<');\n\n\t\t$store->setStatement (\\GO\\Files\\Model\\File::model()->find($findParams));\n\t\t\n\t\t$response = $store->getData();\n\t\t$response['total'] = $store->getTotal();\n\t\t\n\t\treturn $response;\n\t\t\n\t}\n\t\n\t/**\n\t * Will calculate the used diskspace per user\n\t * If no ID is passed diskspace will be recalculated for all user\n\t * @param integer $id id of the user to recalculate used space for\n\t */\n\tprotected function actionRecalculateDiskUsage($id=false) {\n\t\t\n\t\t\\GO::session()->closeWriting();\n\t\t\n\t\t$users = array();\n\t\tif(!empty($id)) {\n\t\t\t$user = \\GO\\Base\\Model\\User::model()->findByPk($id);\n\t\t\tif(!empty($user)) {\n\t\t\t\t$users[] = $user;\n\t\t\t}\n\t\t} else {\n\t\t\t$users = \\GO\\Base\\Model\\User::model()->find();\n\t\t}\n\t\t\n\t\tforeach($users as $user) {\n\t\t\tif($user->calculatedDiskUsage()->save())\n\t\t\t\techo $user->getName() . ' uses ' . $user->disk_usage. \"<br>\\n\";\n\t\t}\n\t}\n\t\n\tprotected function actionCorrectQuotaUser() {\n\t\t$time_start = microtime(true); \n\t\t$count = 0;\n\t\t\n\t\t$userFolder = \\GO\\Files\\Model\\Folder::model()->findByPath('users');\n\t\tforeach($userFolder->folders() as $homeFolder) {\n\t\t\t$homeId = $homeFolder->user_id;\n\t\t\t\n\t\t\t$walkSubfolders = function($folder) use($homeId, &$walkSubfolders, &$count) {\n\t\t\t\t\n\t\t\t\t//echo $folder->path.' -> '.$homeId.'<br />';\n\t\t\t\t$folder->quota_user_id = $homeId;\n\t\t\t\tif(!$folder->save()) {\n\t\t\t\t\tthrow new \\Exception(\"Could not save folder: \".var_export($folder->getValidationErrors(), true));\n\t\t\t\t}\n\n\t\t\t\tforeach($folder->folders() as $subFolder) {\n\t\t\t\t\t$walkSubfolders($subFolder);\t\t\t\t\t\n\t\t\t\t\t$count++;\n\t\t\t\t}\n\t\t\t};\n\t\t\t$walkSubfolders($homeFolder);\n\t\t}\n\t\t$time_end = microtime(true);\n\t\t$execution_time = ($time_end - $time_start);\n\t\t//echo '<b>'.$count.' Folders updated in:</b> '.$execution_time.' Seconds';\n\t}\n\t\n\tprotected function actionDisplay($params) {\n\t\t\n\t\t//custom fields send path as ID.\n\t\tif(!empty($params['id']) && !is_numeric($params['id'])){\n\t\t\t$file = \\GO\\Files\\Model\\File::model()->findByPath($params['id']);\n\t\t\t$params['id']=$file->id;\n\t\t}\n\t\t\n\t\treturn parent::actionDisplay($params);\n\t}\n\n\tprivate function isAnimatedGif($filename) {\n\t\tif(!($fh = @fopen($filename, 'rb')))\n\t\t\treturn false;\n\t\t$count = 0;\n\t\t//an animated gif contains multiple \"frames\", with each frame having a\n\t\t//header made up of:\n\t\t// * a static 4-byte sequence (\\x00\\x21\\xF9\\x04)\n\t\t// * 4 variable bytes\n\t\t// * a static 2-byte sequence (\\x00\\x2C)\n\n\t\t// We read through the file til we reach the end of the file, or we've found\n\t\t// at least 2 frame headers\n\t\twhile(!feof($fh) && $count < 2) {\n\t\t\t$chunk = fread($fh, 1024 * 100); //read 100kb at a time\n\t\t\t$count += preg_match_all('#\\x00\\x21\\xF9\\x04.{4}\\x00[\\x2C\\x21]#s', $chunk, $matches);\n\t\t}\n\n\t\tfclose($fh);\n\t\treturn $count > 1;\n\t}\n\t\n\tprotected function afterDisplay(&$response, &$model, &$params) {\n\n\t\t$response['data']['path'] = $model->path;\n\t\t$response['data']['size'] = $model->fsFile->size();\n\t\t$response['data']['extension'] = strtolower($model->fsFile->extension());\n\t\t$response['data']['type'] = \\GO::t($response['data']['extension'], 'base', 'filetypes');\n\t\t\n\t\t$response['data']['locked_user_name']=$model->lockedByUser ? $model->lockedByUser->name : '';\n\t\t$response['data']['locked']=$model->isLocked();\n\t\t$response['data']['unlock_allowed']=$model->unlockAllowed();\n\t\t\n\n\t\tif (!empty($model->random_code) && time() < $model->expire_time) {\n\t\t\t$response['data']['expire_time'] = \\GO\\Base\\Util\\Date::get_timestamp(\\GO\\Base\\Util\\Date::date_add($model->expire_time, -1),false);\n\t\t\t$response['data']['download_link'] = $model->emailDownloadURL;\n\t\t} else {\n\t\t\t$response['data']['expire_time'] = \"\";\n\t\t\t$response['data']['download_link'] = \"\";\n\t\t}\n\t\t\n\t\t$response['data']['url']=\\GO::url('files/file/download',array('id'=>$model->id), false, true);\n\n\t\tif ($model->fsFile->isImage()) {\n\t\t\tif($response['data']['extension'] == 'gif' && $this->isAnimatedGif(\\GO::config()->file_storage_path . $model->path)) {\n\t\t\t\t$response['data']['thumbnail_url'] = $model->getDownloadURL(false);\n\t\t\t} else {\n\t\t\t\t$response['data']['thumbnail_url'] = $model->thumbURL;\n\t\t\t}\n\t\t}else\n\t\t\t$response['data']['thumbnail_url'] = \"\";\n\t\t\n\t\t$response['data']['handler']='startjs:function(){'.$model->getDefaultHandler()->getHandler($model).'}:endjs';\n\t\t\n\t\ttry{\n\t\t\tif(\\GO::modules()->filesearch){\n\t\t\t\t$filesearch = \\GO\\Filesearch\\Model\\Filesearch::model()->findByPk($model->id);\n//\t\t\t\tif(!$filesearch){\n//\t\t\t\t\t$filesearch = \\GO\\Filesearch\\Model\\Filesearch::model()->createFromFile($model);\n//\t\t\t\t}\n\t\t\t\tif($filesearch){\n\t\t\t\t\t$response['data']=array_merge($filesearch->getAttributes('formatted'), $response['data']);\n\t\t\t\t\n\n\t\t\t\t\tif (!empty($params['query_params'])) {\n\t\t\t\t\t\t$qp = json_decode($params['query_params'], true);\n\t\t\t\t\t\tif (isset($qp['content_all'])){\n\n\t\t\t\t\t\t\t$c = new \\GO\\Filesearch\\Controller\\FilesearchController();\n\n\t\t\t\t\t\t\t$response['data']['text'] = $c->highlightSearchParams($qp, $response['data']['text']);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else\n\t\t\t\t{\n\t\t\t\t\t$response['data']['text'] = \\GO::t(\"This file has not been indexed yet\", \"filesearch\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch(\\Exception $e){\n\t\t\t\\GO::debug((string) $e);\n\t\t\t\n\t\t\t$response['data']['text'] = \"Index out of date. Please rebuild it using the admin tools.\";\n\t\t}\n\n\t\treturn parent::afterDisplay($response, $model, $params);\n\t}\n\n\tprotected function afterLoad(&$response, &$model, &$params) {\n\n\t\t$response['data']['path'] = $model->path;\n\t\t$response['data']['size'] = \\GO\\Base\\Util\\Number::formatSize($model->fsFile->size());\n\t\t$response['data']['extension'] = strtolower($model->fsFile->extension());\n\t\t$response['data']['type'] = \\GO::t($response['data']['extension'], 'base', 'filetypes');\n\t\t\n\t\t$response['data']['name']=$model->fsFile->nameWithoutExtension();\n\t\t\n\t\tif (!empty($model->user))\n\t\t\t$response['data']['username']=$model->user->name;\n\t\tif (!empty($model->mUser))\n\t\t\t$response['data']['musername'] = $model->mUser->name;\n\t\t$response['data']['locked_user_name']=$model->lockedByUser ? $model->lockedByUser->name : '';\n\t\t\n\t\t\n\t\t\n\t\t$fh = \\GO\\Files\\Model\\FileHandler::model()->findByPk(\n\t\t\t\t\t\tarray('extension'=>$model->extension, 'user_id'=>\\GO::user()->id));\n\t\tif($fh){\n\t\t\t$fileHandler = new $fh->cls;\n\t\t\t\n\t\t\t$response['data']['handlerCls']=$fh->cls;\n\t\t\t$response['data']['handlerName']=$fileHandler->getName();\n\t\t}else\n\t\t{\n\t\t\t$response['data']['handlerCls']=\"\";\n\t\t\t$response['data']['handlerName']=\"\";\n\t\t}\n\t\t\n\n\t\treturn parent::afterLoad($response, $model, $params);\n\t}\n\t\n\tprotected function beforeSubmit(&$response, &$model, &$params) {\n\t\t\n\t\tif(isset($params['name'])){\t\t\n\t\t\t$params['name'] = \\GO\\Base\\Fs\\File::stripInvalidChars($params['name']); // Strip invalid chars\n\t\t\tif(isset($params['extension'])) {\n\t\t\t\t$params['name'].='.'.$params['extension'];\n\t\t\t\t$model->extension = $params['extension'];\n\t\t\t} else if(!empty($model->fsFile->extension())) {\n\t\t\t\t$params['name'].='.'.$model->fsFile->extension();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(isset($params['lock'])){\n\t\t\t//GOTA sends lock parameter It does not know the user ID.\n\t\t\t$model->locked_user_id=empty($params['lock']) ? 0 : \\GO::user()->id;\n\t\t}\n\t\t\n\t\t\n\t\t$fh = \\GO\\Files\\Model\\FileHandler::model()->findByPk(array(\n\t\t\t'extension' => strtolower($model->extension), \n\t\t\t'user_id' => \\GO::user()->id\n\t\t));\n\t\t\n\t\tif(!$fh)\n\t\t\t$fh = new \\GO\\Files\\Model\\FileHandler();\n\t\t\n\t\t$fh->extension=strtolower($model->extension);\n\t\t\n\t\tif(isset($params['handlerCls']))\n\t\t\t$fh->cls=$params['handlerCls'];\n\t\t\n\t\tif(empty($params['handlerCls']))\n\t\t\t$fh->delete();\n\t\telse\n\t\t\t$fh->save();\n\t\t\n\t\treturn parent::beforeSubmit($response, $model, $params);\n\t}\n\n\tprotected function actionSaveAttachmentToTmp($params) {\n\n\t\t$tmpFolder = \\GO\\Files\\Model\\Folder::model()->tmpFolder();\n\t\tforeach($tmpFolder->files as $file) {\n\t\t\t//clean up older temp files\n\t\t\tif($file->mtime < strtotime(\"-4 hours\")) {\n\t\t\t\t$file->delete(true);\n\t\t\t}\n\t\t}\n\n\t\t$params['filename'] = \\GO\\Base\\Fs\\File::stripInvalidChars($params['filename']);\n\t\t$file = new \\GO\\Base\\Fs\\File(\\GO::config()->file_storage_path . $tmpFolder->path.'/'.$params['filename']);\n\t\t$file->parent()->create();\n\n\t\tif(empty($params['tmp_file'])){\n\t\t\t$account = Account::model()->findByPk($params['account_id']);\n\t\t\t$imap = $account->openImapConnection($params['mailbox']);\n\t\t\tif(!$imap->save_to_file($params['uid'], $file->path(), $params['number'], $params['encoding'])) {\n\t\t\t\tthrow new Exception(\"Could not save file from IMAP\");\n\t\t\t}\n\t\t}else\n\t\t{\n\t\t\t$tmpfile = new \\GO\\Base\\Fs\\File(\\GO::config()->tmpdir.$params['tmp_file']);\n\t\t\t$file = $tmpfile->copy($file->parent(), $file->name());\n\t\t\tif(!$file) {\n\t\t\t\tthrow new Exception(\"IO error\");\n\t\t\t}\n\t\t}\n\t\t$maxLength = go()->getDatabase()->getTable(\"fs_files\")->getColumn(\"name\")->length;\n\t\t$file->shortenFileName($maxLength);\n\n\t\t$dbFile = $tmpFolder->hasFile($file->name());\n\t\tif($dbFile) {\n\t\t\tFile::$deleteInDatabaseOnly = true;\n\t\t\t$dbFile->delete();\n\t\t}\n\t\t$dbFile = $tmpFolder->addFile($file->name(), true);\n\n\t\treturn ['success' => true, 'data' => $dbFile->getAttributes()];\n\t}\n\t\n\tprotected function actionHandlers($params){\n\t\tif(!empty($params['path'])){\n\t\t\t$folder = \\GO\\Files\\Model\\Folder::model()->findByPath(dirname($params['path']));\n\t\t\t$file = $folder->hasFile(\\GO\\Base\\Fs\\File::utf8Basename($params['path']));\n\t\t}else\n\t\t{\n\t\t\t$file = \\GO\\Files\\Model\\File::model()->findByPk($params['id'], false, true);\n\t\t}\n\n\t\tif(empty($params['all'])){\n\t\t\t$fileHandlers = array($file->getDefaultHandler());\n\t\t}else\n\t\t{\n\t\t\t$fileHandlers = $file->getHandlers();\n\t\t}\n//\tvar_dump($fileHandlers);\n\t\t\n\t\t$store = new \\GO\\Base\\Data\\ArrayStore();\n\t\t\n\t\tforeach($fileHandlers as $fileHandler){\t\n\t\t\t$store->addRecord(array(\n\t\t\t\t\t'name'=>$fileHandler->getName(),\n\t\t\t\t\t'handler'=>$fileHandler->getHandler($file),\n\t\t\t\t\t'iconCls'=>$fileHandler->getIconCls(),\n\t\t\t\t\t'cls'=>  get_class($fileHandler),\n\t\t\t\t\t'extension'=>$file->extension\n\t\t\t));\t\n\t\t}\t\n\t\t\n\t\treturn $store->getData();\t\t\n\t}\n\t\n\tprotected function actionSaveHandler($params){\n//\t\t\\GO::config()->save_setting('fh_'.$, $value)\n\t\t\n\t\t$fh = \\GO\\Files\\Model\\FileHandler::model()->findByPk(\n\t\t\t\t\t\tarray('extension'=>strtolower($params['extension']), 'user_id'=>\\GO::user()->id));\n\t\t\n\t\tif(!$fh)\n\t\t\t$fh = new \\GO\\Files\\Model\\FileHandler();\n\t\t\n\t\t$fh->extension=strtolower($params['extension']);\n\t\t$fh->cls=$params['cls'];\n\t\treturn array('success'=>empty($params['cls']) ? $fh->delete() : $fh->save());\n\t}\n\t\n\t\n\tprotected function actionOpen($params) {\n\t\tif(!empty($params['path'])) {\n\t\t\t$file = \\GO\\Files\\Model\\File::model()->findByPath($params['path']);\n\t\t} else\n\t\t{\n\t\t\t$file = \\GO\\Files\\Model\\File::model()->findByPath($params['id']);\n\t\t}\n\n\t\tif(!$file){\n\t\t\tthrow new \\Exception(\"File not found\");\n\t\t}\n\t\t\n\t\t$response = [\n\t\t\t\t'success' => true,\n\t\t\t\t'file' => $file->getAttributes(),\n\t\t\t\t'handler' => 'startjs:function(){'.$file->getDefaultHandler()->getHandler($file).'}:endjs'\n\t\t];\n\t\t\n\t\treturn $response;\n\t}\n\t\n\n\tprotected function actionDownload($params) {\n\n\t\t\\GO::session()->closeWriting();\n\t\t\n\t\t\\GO::setMaxExecutionTime(0);\n\n\t\ttry {\n\t\t\tif (isset($params['path'])) {\n\t\t\t\t$folder = \\GO\\Files\\Model\\Folder::model()->findByPath(dirname($params['path']));\n\t\t\t\tif (!$folder) {\n\t\t\t\t\tthrow new NotFound($params['path']);\n\t\t\t\t}\n\t\t\t\t$file = $folder->hasFile(\\GO\\Base\\Fs\\File::utf8Basename($params['path']));\n\t\t\t} else {\n\t\t\t\t$file = \\GO\\Files\\Model\\File::model()->findByPk($params['id'], false, true);\n\t\t\t}\n\n\t\t\tif (!$file)\n\t\t\t\tthrow new \\GO\\Base\\Exception\\NotFound();\n\n\t\t\tif (!empty($params['random_code'])) {\n\t\t\t\tif ($file->random_code != $params['random_code'])\n\t\t\t\t\tthrow new \\GO\\Base\\Exception\\NotFound();\n\n\t\t\t\tif (time() > $file->expire_time)\n\t\t\t\t\tthrow new \\Exception(\\GO::t(\"Sorry, the download link for this file has expired\", \"files\"));\n\t\t\t} else {\n\t\t\t\t$public = substr($file->path, 0, 6) == 'public';\n\n\t\t\t\tif (!$public) {\n\t\t\t\t\tif (!\\GO::user() || !$file->checkPermissionLevel(\\GO\\Base\\Model\\Acl::READ_PERMISSION)) {\n\t\t\t\t\t\tthrow new \\GO\\Base\\Exception\\AccessDenied();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$ua_info = \\donatj\\UserAgent\\parse_user_agent();\n\t\t\tif($ua_info['browser'] == 'Safari' && $file->extension == 'webm' && !strstr(Request::get()->getUri(), 'webm')) {\n\t\t\t\t//workaround webm bug in safari that needs a webm extension :(\n\t\t\t\theader(\"Location: \" . str_replace('index.php?', 'index.php/' . rawurlencode($file->name) . '?', Request::get()->getFullUrl()));\n\t\t\t\texit();\n\t\t\t}\n\n\n\t\t\t// Show the file inside the browser or give it as a download\n\t\t\t$inline = true; // Defaults to show inside the browser\n\t\t\tif (isset($params['inline']) && ((bool)$params['inline'] === false || $params['inline'] == 'false')) {\n\t\t\t\t$inline = false;\n\t\t\t}\n\n//\t\t\t\\GO\\Base\\Util\\Http::outputDownloadHeaders($file->fsFile, $inline, !empty($params['cache']));\n\t\t\t$file->open();\n\n\t\t\t$this->fireEvent('beforedownload', array(\n\t\t\t\t&$this,\n\t\t\t\t&$params,\n\t\t\t\t&$file\n\t\t\t));\n\n\t\t\tif(\\go\\core\\model\\Module::isInstalled('community', 'history')) {\n\t\t\t\tModule::logActiveRecord($file, 'download');\n\t\t\t}\n\n\t\t\t//Supports range download\n\t\t\t$coreFsFile = new \\go\\core\\fs\\File($file->fsFile->path());\n\n\t\t\t// prevent html to render on same domain having access to all global JS stuff\n\t\t\tif($coreFsFile->getContentType() == 'text/html') {\n\t\t\t\t$inline = false;\n\t\t\t}\n\n\t\t\t$coreFsFile->output(true, !array_key_exists('cache', $params) || !empty($params['cache']), [], $inline);\n\n\t\t}catch(NotFound $e) {\n\t\t\tResponse::get()->setStatus(404);\n\n\t\t\techo $e->getMessage();\n\n\t\t}catch (AccessDenied $e) {\n\t\t\tResponse::get()->setStatus(403);\n\n\t\t\techo $e->getMessage();\n\n\t\t}catch(\\Throwable $e) {\n\t\t\tResponse::get()->setStatus(500);\n\n\t\t\techo $e->getMessage();\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * @param type $params \n\t * @todo\n\t */\n\tprotected function actionCreateDownloadLink($params){\n\t\t\n\t\t$response=array();\n\t\t\n\t\t$file = \\GO\\Files\\Model\\File::model()->findByPk($params['id']);\n\t\t\n\t\t$url = $file->getEmailDownloadURL(true,\\GO\\Base\\Util\\Date::date_add($params['expire_time'],1),$params['delete_when_expired']);\n\t\t\n\t\t$response['url']=$url;\n\t\t$response['success']=true;\n\t\t\n\t\treturn $response;\n\t\t\n\t}\t\n\t\n\t/**\n\t * This action will generate multiple Email Download link and return a JSON\n\t * response with the generated links in the email subject\n\t * @param array $params\n\t * - string ids: json encode file ids to mail\n\t * - timestamp expire_time: chosen email link expire time \n\t * - int template_id: id of used template\n\t * - int alias_id: id of alias to mail from\n\t * - string content_type : html | plain  \n\t * @return StringHelper Json response\n\t */\n\tprotected function actionEmailDownloadLink($params){\n\t\t$msgController = new MessageController();\n\t\t$templateContent = $msgController->loadTemplate($params);\n\t\t$files = \\GO\\Files\\Model\\File::model()->findByAttribute('id', json_decode($params['ids']));\n\t\t\n\t\t$html=$params['content_type']=='html';\n\t\t$bodyindex = $html ? 'htmlbody' : 'plainbody';\n\t\t$lb = $html ? '<br />' : \"\\n\";\n\n\t\t$text = $html ? \\GO::t(\"Click on the link to download the file\", \"files\") : \\GO::t(\"Click the secured link below or copy it to your browser's address bar to download the file.\", \"files\");\n\t\t$linktext = $html ? \"<ul>\" : $lb;\n\t\t\n\t\tforeach($files as $file) {\n\t\t\t$url = $file->getEmailDownloadURL($html,\\GO\\Base\\Util\\Date::date_add($params['expire_time'],1),$params['delete_when_expired']);\n\t\t\t$linktext .= $html ?  '<li><a href=\"'.$url.'\">'.$file->name.'</a></li>'.$lb : $url.$lb;\n\t\t}\n\t\t$linktext .= $html ? \"</ul>\" : \"\\n\";\n\t\t$text .= ' ('.\\GO::t(\"possible until\", \"files\").' '.\\GO\\Base\\Util\\Date::get_timestamp(\\GO\\Base\\Util\\Date::date_add($file->expire_time,-1), false).')'.$lb;\n\t\t$text .= $linktext;\n\n\t\t$params['body']= $text;\n\n    $msgController = new MessageController();\n    $response = $msgController->loadTemplate($params);\n\n//\t\t$response['data'][$bodyindex]=$text;\n\t\t\t\t\n\t\t$response['data']['subject'] = \\GO::t(\"Download link\", \"files\"); //.' '.$file->name;\n\t\t$response['success']=true;\n\t\t\n\t\treturn $response;\n\t}\n\t\n\t\n\tpublic function actionRecent($params){\n\t\t\n\t\t$start = !empty($params['start']) ? $params['start'] : 0;\n\t\t$limit = !empty($params['limit']) ? $params['limit'] : 20;\n\t\t\n\t\t$store = \\GO\\Base\\Data\\Store::newInstance(\\GO\\Files\\Model\\File::model());\n\n\t\t$store->getColumnModel()->formatColumn('path', '$model->path', array(), array('first_name', 'last_name'));\n\t\t$store->getColumnModel()->formatColumn('weekday', '$fullDays[date(\"w\", $model->mtime)].\" \".\\GO\\Base\\Util\\Date::get_timestamp($model->mtime, false);', array('fullDays'=>\\GO::t(\"full_days\")),array('first_name', 'last_name'));\n\t\t\n\t\t$store->setStatement(\\GO\\Files\\Model\\File::model()->findRecent($start,$limit));\n\n\t\t$response = $store->getData();\n\t\t\n\t\t$store->setStatement(\\GO\\Files\\Model\\File::model()->findRecent());\n\t\t$response['total'] = $store->getTotal();\n\t\t\n\t\treturn $response;\n\t}\n\t\n\tpublic function actionCleanup() {\n\t\t\n\t\t$cleanupRoot = \\GO::config()->file_storage_path.'cleanup/';\n\t\t\n\t\t\\GO\\Files\\Model\\File::$deleteInDatabaseOnly = true;\n\t\t\t\t\t\t\n\t\t\n\t\t\n\t\t$findParams = \\GO\\Base\\Db\\FindParams::newInstance();\n\t\t\n\t\t\n\t\t$findCriteria = \\GO\\Base\\Db\\FindCriteria::newInstance()->addRawCondition(\"t.name REGEXP '^.+ \\\\\\([0-9]+\\\\\\)\\\\\\..+'\");\n\t\t$findParams->criteria($findCriteria);\n\t\t$stmt = \\GO\\Files\\Model\\File::model()->find($findParams);\n\t\t\n\t\tforeach ($stmt as $copySubfixFile) {\n\t\t\t\n\t\t\t\n\t\t\t$name = preg_replace('/(\\w+) (\\\\([0-9]+\\)).(\\w+)/i', '${1}.$3', $copySubfixFile->name);\n\t\t\t\n\t\t\t$findParams = \\GO\\Base\\Db\\FindParams::newInstance();\n\t\t\t$findCriteria = \\GO\\Base\\Db\\FindCriteria::newInstance()->addCondition('name', $name)->addCondition('folder_id', $copySubfixFile->folder_id);\n\t\t\t$findParams->criteria($findCriteria);\n\t\t\t$stmt2 = \\GO\\Files\\Model\\File::model()->find($findParams);\n\t\t\t\n\t\t\tforeach ($stmt2 as $file) {\n\t\t\t\t\n\t\t\t\tif($file->fsFile->md5Hash() == $copySubfixFile->fsFile->md5Hash()) {\n\t\t\t\t\techo $copySubfixFile->path . ' ## ' . $copySubfixFile->folder_id. \"<br/>\";\n\t\t\t\t\t\n\t\t\t\t\t$cleanupPath = $cleanupRoot.$copySubfixFile->folder->getFullPath(); //projects2/Projectnaam/bestand (1).jpg\n\t\t\t\t\t\n\t\t\t\t\t$folderTo = new \\GO\\Base\\Fs\\Folder($cleanupPath);\n\t\t\t\t\t$folderTo->create();\n\t\t\t\t\t\n\t\t\t\t\tif($folderTo->exists()) {\n\t\t\t\t\t\tif(!$copySubfixFile->fsFile->move($folderTo)) {\n\t\t\t\t\t\t\tthrow new Exception('file move error from: '. $copySubfixFile->path . ' to '. $folderTo->getFullPath());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t$copySubfixFile->delete();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Exception('Folder do not exists: '.$cleanupPath);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * @param $params\n\t * @throws AccessDenied\n\t * @throws \\go\\core\\exception\\NotFound\n\t */\n\tpublic function actionConvert($params)\n\t{\n\t\t$fileId = !empty($params['id']) ? $params['id'] : 0;\n\t\t$format = !empty($params['format']) ? $params['format'] : 'pdf';\n\n\t\t//check if file exists\n\t\t$fileRecord = \\GO\\Files\\Model\\File::model()->findByPk($fileId);\n\t\tif (!$fileRecord) {\n\t\t\tthrow new \\go\\core\\exception\\NotFound();\n\t\t}\n\n\t\t//check user permissions\n\t\tif (!\\GO::user() || !$fileRecord->checkPermissionLevel(\\GO\\Base\\Model\\Acl::READ_PERMISSION)) {\n\t\t\tthrow new AccessDenied();\n\t\t}\n\n\t\t$nameWithoutExtension = $fileRecord->fsFile->nameWithoutExtension();\n\t\t$outputFileName = $nameWithoutExtension . '.' . $format;\n\n\t\t//create temporary file\n\t\t$tmpFile = \\GO\\Base\\Fs\\File::tempFile();\n\n\t\t//convert file -> put output to temporary\n\t\t$fileRecord->convertTo($tmpFile, $format);\n\n\t\t$outputFileRecord = $fileRecord->folder->addFilesystemFile($tmpFile, true, $outputFileName);\n\t\tif (!$outputFileRecord) {\n\t\t\tthrow new Exception('File move error from: '. $tmpFile->path() . ' to '. $fileRecord->folder->getFullPath());\n\t\t}\n\n\t\t$response['file'] = $outputFileRecord->getAttributes();\n\t\t$response['success'] = true;\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * @param $params\n\t * @throws AccessDenied\n\t * @throws \\go\\core\\exception\\NotFound\n\t */\n\tpublic function actionConvertAndDownload($params)\n\t{\n\t\t$fileId = !empty($params['id']) ? $params['id'] : 0;\n\t\t$format = !empty($params['format']) ? $params['format'] : 'pdf';\n\n\t\t//check if file exists\n\t\t$fileRecord = \\GO\\Files\\Model\\File::model()->findByPk($fileId);\n\t\tif (!$fileRecord) {\n\t\t\tthrow new \\go\\core\\exception\\NotFound();\n\t\t}\n\n\t\t//check user permissions\n\t\tif (!\\GO::user() || !$fileRecord->checkPermissionLevel(\\GO\\Base\\Model\\Acl::READ_PERMISSION)) {\n\t\t\tthrow new AccessDenied();\n\t\t}\n\n\t\t//create temporary file\n\t\t$tmpFile = \\GO\\Base\\Fs\\File::tempFile();\n\n\t\t//convert file -> put output to temporary\n\t\t$fileRecord->convertTo($tmpFile, $format);\n\n\t\t//get pdf file name\n\t\t$nameWithoutExtension = $fileRecord->fsFile->nameWithoutExtension();\n\t\t$outputFileName = $nameWithoutExtension . '.' . $format;\n\n\t\t//override previous headers because tempoary\n\t\t$extraHeaders = [\n\t\t\t'Content-Disposition' => 'inline; filename=\"' . $outputFileName . '\"',\n\t\t];\n\n\t\t//download\n\t\t\\GO\\Base\\Util\\Http::outputDownloadHeaders($tmpFile, true, !empty($params['cache']), $extraHeaders);\n\t\t$tmpFile->output();\n\t}\n}\n\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2024-23331", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "import path from 'node:path'\nimport type * as net from 'node:net'\nimport { get as httpGet } from 'node:http'\nimport { get as httpsGet } from 'node:https'\nimport type * as http from 'node:http'\nimport { performance } from 'node:perf_hooks'\nimport type { Http2SecureServer } from 'node:http2'\nimport connect from 'connect'\nimport corsMiddleware from 'cors'\nimport colors from 'picocolors'\nimport chokidar from 'chokidar'\nimport type { FSWatcher, WatchOptions } from 'dep-types/chokidar'\nimport type { Connect } from 'dep-types/connect'\nimport launchEditorMiddleware from 'launch-editor-middleware'\nimport type { SourceMap } from 'rollup'\nimport picomatch from 'picomatch'\nimport type { Matcher } from 'picomatch'\nimport type { InvalidatePayload } from 'types/customEvent'\nimport type { CommonServerOptions } from '../http'\nimport {\n  httpServerStart,\n  resolveHttpServer,\n  resolveHttpsConfig,\n  setClientErrorHandler,\n} from '../http'\nimport type { InlineConfig, ResolvedConfig } from '../config'\nimport { isDepsOptimizerEnabled, resolveConfig } from '../config'\nimport {\n  diffDnsOrderChange,\n  isInNodeModules,\n  isObject,\n  isParentDirectory,\n  mergeConfig,\n  normalizePath,\n  resolveHostname,\n  resolveServerUrls,\n} from '../utils'\nimport { getFsUtils } from '../fsUtils'\nimport { ssrLoadModule } from '../ssr/ssrModuleLoader'\nimport { ssrFixStacktrace, ssrRewriteStacktrace } from '../ssr/ssrStacktrace'\nimport { ssrTransform } from '../ssr/ssrTransform'\nimport { ERR_OUTDATED_OPTIMIZED_DEP } from '../plugins/optimizedDeps'\nimport {\n  getDepsOptimizer,\n  initDepsOptimizer,\n  initDevSsrDepsOptimizer,\n} from '../optimizer'\nimport { bindCLIShortcuts } from '../shortcuts'\nimport type { BindCLIShortcutsOptions } from '../shortcuts'\nimport { CLIENT_DIR, DEFAULT_DEV_PORT } from '../constants'\nimport type { Logger } from '../logger'\nimport { printServerUrls } from '../logger'\nimport { createNoopWatcher, resolveChokidarOptions } from '../watch'\nimport { initPublicFiles } from '../publicDir'\nimport type { PluginContainer } from './pluginContainer'\nimport { ERR_CLOSED_SERVER, createPluginContainer } from './pluginContainer'\nimport type { WebSocketServer } from './ws'\nimport { createWebSocketServer } from './ws'\nimport { baseMiddleware } from './middlewares/base'\nimport { proxyMiddleware } from './middlewares/proxy'\nimport { htmlFallbackMiddleware } from './middlewares/htmlFallback'\nimport { transformMiddleware } from './middlewares/transform'\nimport {\n  createDevHtmlTransformFn,\n  indexHtmlMiddleware,\n} from './middlewares/indexHtml'\nimport {\n  servePublicMiddleware,\n  serveRawFsMiddleware,\n  serveStaticMiddleware,\n} from './middlewares/static'\nimport { timeMiddleware } from './middlewares/time'\nimport type { ModuleNode } from './moduleGraph'\nimport { ModuleGraph } from './moduleGraph'\nimport { notFoundMiddleware } from './middlewares/notFound'\nimport { errorMiddleware, prepareError } from './middlewares/error'\nimport type { HmrOptions } from './hmr'\nimport {\n  getShortName,\n  handleFileAddUnlink,\n  handleHMRUpdate,\n  updateModules,\n} from './hmr'\nimport { openBrowser as _openBrowser } from './openBrowser'\nimport type { TransformOptions, TransformResult } from './transformRequest'\nimport { transformRequest } from './transformRequest'\nimport { searchForWorkspaceRoot } from './searchRoot'\nimport { warmupFiles } from './warmup'\n\nexport interface ServerOptions extends CommonServerOptions {\n  /**\n   * Configure HMR-specific options (port, host, path & protocol)\n   */\n  hmr?: HmrOptions | boolean\n  /**\n   * Warm-up files to transform and cache the results in advance. This improves the\n   * initial page load during server starts and prevents transform waterfalls.\n   */\n  warmup?: {\n    /**\n     * The files to be transformed and used on the client-side. Supports glob patterns.\n     */\n    clientFiles?: string[]\n    /**\n     * The files to be transformed and used in SSR. Supports glob patterns.\n     */\n    ssrFiles?: string[]\n  }\n  /**\n   * chokidar watch options or null to disable FS watching\n   * https://github.com/paulmillr/chokidar#api\n   */\n  watch?: WatchOptions | null\n  /**\n   * Create Vite dev server to be used as a middleware in an existing server\n   * @default false\n   */\n  middlewareMode?:\n    | boolean\n    | {\n        /**\n         * Parent server instance to attach to\n         *\n         * This is needed to proxy WebSocket connections to the parent server.\n         */\n        server: http.Server\n      }\n  /**\n   * Options for files served via '/\\@fs/'.\n   */\n  fs?: FileSystemServeOptions\n  /**\n   * Origin for the generated asset URLs.\n   *\n   * @example `http://127.0.0.1:8080`\n   */\n  origin?: string\n  /**\n   * Pre-transform known direct imports\n   * @default true\n   */\n  preTransformRequests?: boolean\n  /**\n   * Whether or not to ignore-list source files in the dev server sourcemap, used to populate\n   * the [`x_google_ignoreList` source map extension](https://developer.chrome.com/blog/devtools-better-angular-debugging/#the-x_google_ignorelist-source-map-extension).\n   *\n   * By default, it excludes all paths containing `node_modules`. You can pass `false` to\n   * disable this behavior, or, for full control, a function that takes the source path and\n   * sourcemap path and returns whether to ignore the source path.\n   */\n  sourcemapIgnoreList?:\n    | false\n    | ((sourcePath: string, sourcemapPath: string) => boolean)\n}\n\nexport interface ResolvedServerOptions extends ServerOptions {\n  fs: Required<FileSystemServeOptions>\n  middlewareMode: boolean\n  sourcemapIgnoreList: Exclude<\n    ServerOptions['sourcemapIgnoreList'],\n    false | undefined\n  >\n}\n\nexport interface FileSystemServeOptions {\n  /**\n   * Strictly restrict file accessing outside of allowing paths.\n   *\n   * Set to `false` to disable the warning\n   *\n   * @default true\n   */\n  strict?: boolean\n\n  /**\n   * Restrict accessing files outside the allowed directories.\n   *\n   * Accepts absolute path or a path relative to project root.\n   * Will try to search up for workspace root by default.\n   */\n  allow?: string[]\n\n  /**\n   * Restrict accessing files that matches the patterns.\n   *\n   * This will have higher priority than `allow`.\n   * picomatch patterns are supported.\n   *\n   * @default ['.env', '.env.*', '*.crt', '*.pem']\n   */\n  deny?: string[]\n\n  /**\n   * Enable caching of fs calls.\n   *\n   * @experimental\n   * @default false\n   */\n  cachedChecks?: boolean\n}\n\nexport type ServerHook = (\n  this: void,\n  server: ViteDevServer,\n) => (() => void) | void | Promise<(() => void) | void>\n\nexport type HttpServer = http.Server | Http2SecureServer\n\nexport interface ViteDevServer {\n  /**\n   * The resolved vite config object\n   */\n  config: ResolvedConfig\n  /**\n   * A connect app instance.\n   * - Can be used to attach custom middlewares to the dev server.\n   * - Can also be used as the handler function of a custom http server\n   *   or as a middleware in any connect-style Node.js frameworks\n   *\n   * https://github.com/senchalabs/connect#use-middleware\n   */\n  middlewares: Connect.Server\n  /**\n   * native Node http server instance\n   * will be null in middleware mode\n   */\n  httpServer: HttpServer | null\n  /**\n   * chokidar watcher instance\n   * https://github.com/paulmillr/chokidar#api\n   */\n  watcher: FSWatcher\n  /**\n   * web socket server with `send(payload)` method\n   */\n  ws: WebSocketServer\n  /**\n   * Rollup plugin container that can run plugin hooks on a given file\n   */\n  pluginContainer: PluginContainer\n  /**\n   * Module graph that tracks the import relationships, url to file mapping\n   * and hmr state.\n   */\n  moduleGraph: ModuleGraph\n  /**\n   * The resolved urls Vite prints on the CLI. null in middleware mode or\n   * before `server.listen` is called.\n   */\n  resolvedUrls: ResolvedServerUrls | null\n  /**\n   * Programmatically resolve, load and transform a URL and get the result\n   * without going through the http request pipeline.\n   */\n  transformRequest(\n    url: string,\n    options?: TransformOptions,\n  ): Promise<TransformResult | null>\n  /**\n   * Same as `transformRequest` but only warm up the URLs so the next request\n   * will already be cached. The function will never throw as it handles and\n   * reports errors internally.\n   */\n  warmupRequest(url: string, options?: TransformOptions): Promise<void>\n  /**\n   * Apply vite built-in HTML transforms and any plugin HTML transforms.\n   */\n  transformIndexHtml(\n    url: string,\n    html: string,\n    originalUrl?: string,\n  ): Promise<string>\n  /**\n   * Transform module code into SSR format.\n   */\n  ssrTransform(\n    code: string,\n    inMap: SourceMap | { mappings: '' } | null,\n    url: string,\n    originalCode?: string,\n  ): Promise<TransformResult | null>\n  /**\n   * Load a given URL as an instantiated module for SSR.\n   */\n  ssrLoadModule(\n    url: string,\n    opts?: { fixStacktrace?: boolean },\n  ): Promise<Record<string, any>>\n  /**\n   * Returns a fixed version of the given stack\n   */\n  ssrRewriteStacktrace(stack: string): string\n  /**\n   * Mutates the given SSR error by rewriting the stacktrace\n   */\n  ssrFixStacktrace(e: Error): void\n  /**\n   * Triggers HMR for a module in the module graph. You can use the `server.moduleGraph`\n   * API to retrieve the module to be reloaded. If `hmr` is false, this is a no-op.\n   */\n  reloadModule(module: ModuleNode): Promise<void>\n  /**\n   * Start the server.\n   */\n  listen(port?: number, isRestart?: boolean): Promise<ViteDevServer>\n  /**\n   * Stop the server.\n   */\n  close(): Promise<void>\n  /**\n   * Print server urls\n   */\n  printUrls(): void\n  /**\n   * Bind CLI shortcuts\n   */\n  bindCLIShortcuts(options?: BindCLIShortcutsOptions<ViteDevServer>): void\n  /**\n   * Restart the server.\n   *\n   * @param forceOptimize - force the optimizer to re-bundle, same as --force cli flag\n   */\n  restart(forceOptimize?: boolean): Promise<void>\n\n  /**\n   * Open browser\n   */\n  openBrowser(): void\n  /**\n   * @internal\n   */\n  _setInternalServer(server: ViteDevServer): void\n  /**\n   * @internal\n   */\n  _importGlobMap: Map<string, { affirmed: string[]; negated: string[] }[]>\n  /**\n   * @internal\n   */\n  _restartPromise: Promise<void> | null\n  /**\n   * @internal\n   */\n  _forceOptimizeOnRestart: boolean\n  /**\n   * @internal\n   */\n  _pendingRequests: Map<\n    string,\n    {\n      request: Promise<TransformResult | null>\n      timestamp: number\n      abort: () => void\n    }\n  >\n  /**\n   * @internal\n   */\n  _fsDenyGlob: Matcher\n  /**\n   * @internal\n   */\n  _shortcutsOptions?: BindCLIShortcutsOptions<ViteDevServer>\n  /**\n   * @internal\n   */\n  _currentServerPort?: number | undefined\n  /**\n   * @internal\n   */\n  _configServerPort?: number | undefined\n}\n\nexport interface ResolvedServerUrls {\n  local: string[]\n  network: string[]\n}\n\nexport function createServer(\n  inlineConfig: InlineConfig = {},\n): Promise<ViteDevServer> {\n  return _createServer(inlineConfig, { ws: true })\n}\n\nexport async function _createServer(\n  inlineConfig: InlineConfig = {},\n  options: { ws: boolean },\n): Promise<ViteDevServer> {\n  const config = await resolveConfig(inlineConfig, 'serve')\n\n  const initPublicFilesPromise = initPublicFiles(config)\n\n  const { root, server: serverConfig } = config\n  const httpsOptions = await resolveHttpsConfig(config.server.https)\n  const { middlewareMode } = serverConfig\n\n  const resolvedWatchOptions = resolveChokidarOptions(config, {\n    disableGlobbing: true,\n    ...serverConfig.watch,\n  })\n\n  const middlewares = connect() as Connect.Server\n  const httpServer = middlewareMode\n    ? null\n    : await resolveHttpServer(serverConfig, middlewares, httpsOptions)\n  const ws = createWebSocketServer(httpServer, config, httpsOptions)\n\n  if (httpServer) {\n    setClientErrorHandler(httpServer, config.logger)\n  }\n\n  // eslint-disable-next-line eqeqeq\n  const watchEnabled = serverConfig.watch !== null\n  const watcher = watchEnabled\n    ? (chokidar.watch(\n        // config file dependencies and env file might be outside of root\n        [...new Set([root, ...config.configFileDependencies, config.envDir])],\n        resolvedWatchOptions,\n      ) as FSWatcher)\n    : createNoopWatcher(resolvedWatchOptions)\n\n  const moduleGraph: ModuleGraph = new ModuleGraph((url, ssr) =>\n    container.resolveId(url, undefined, { ssr }),\n  )\n\n  const container = await createPluginContainer(config, moduleGraph, watcher)\n  const closeHttpServer = createServerCloseFn(httpServer)\n\n  let exitProcess: () => void\n\n  const devHtmlTransformFn = createDevHtmlTransformFn(config)\n\n  let server: ViteDevServer = {\n    config,\n    middlewares,\n    httpServer,\n    watcher,\n    pluginContainer: container,\n    ws,\n    moduleGraph,\n    resolvedUrls: null, // will be set on listen\n    ssrTransform(\n      code: string,\n      inMap: SourceMap | { mappings: '' } | null,\n      url: string,\n      originalCode = code,\n    ) {\n      return ssrTransform(code, inMap, url, originalCode, server.config)\n    },\n    transformRequest(url, options) {\n      return transformRequest(url, server, options)\n    },\n    async warmupRequest(url, options) {\n      await transformRequest(url, server, options).catch((e) => {\n        if (\n          e?.code === ERR_OUTDATED_OPTIMIZED_DEP ||\n          e?.code === ERR_CLOSED_SERVER\n        ) {\n          // these are expected errors\n          return\n        }\n        // Unexpected error, log the issue but avoid an unhandled exception\n        server.config.logger.error(`Pre-transform error: ${e.message}`, {\n          error: e,\n          timestamp: true,\n        })\n      })\n    },\n    transformIndexHtml(url, html, originalUrl) {\n      return devHtmlTransformFn(server, url, html, originalUrl)\n    },\n    async ssrLoadModule(url, opts?: { fixStacktrace?: boolean }) {\n      if (isDepsOptimizerEnabled(config, true)) {\n        await initDevSsrDepsOptimizer(config, server)\n      }\n      return ssrLoadModule(\n        url,\n        server,\n        undefined,\n        undefined,\n        opts?.fixStacktrace,\n      )\n    },\n    ssrFixStacktrace(e) {\n      ssrFixStacktrace(e, moduleGraph)\n    },\n    ssrRewriteStacktrace(stack: string) {\n      return ssrRewriteStacktrace(stack, moduleGraph)\n    },\n    async reloadModule(module) {\n      if (serverConfig.hmr !== false && module.file) {\n        updateModules(module.file, [module], Date.now(), server)\n      }\n    },\n    async listen(port?: number, isRestart?: boolean) {\n      await startServer(server, port)\n      if (httpServer) {\n        server.resolvedUrls = await resolveServerUrls(\n          httpServer,\n          config.server,\n          config,\n        )\n        if (!isRestart && config.server.open) server.openBrowser()\n      }\n      return server\n    },\n    openBrowser() {\n      const options = server.config.server\n      const url =\n        server.resolvedUrls?.local[0] ?? server.resolvedUrls?.network[0]\n      if (url) {\n        const path =\n          typeof options.open === 'string'\n            ? new URL(options.open, url).href\n            : url\n\n        // We know the url that the browser would be opened to, so we can\n        // start the request while we are awaiting the browser. This will\n        // start the crawling of static imports ~500ms before.\n        // preTransformRequests needs to be enabled for this optimization.\n        if (server.config.server.preTransformRequests) {\n          setTimeout(() => {\n            const getMethod = path.startsWith('https:') ? httpsGet : httpGet\n\n            getMethod(\n              path,\n              {\n                headers: {\n                  // Allow the history middleware to redirect to /index.html\n                  Accept: 'text/html',\n                },\n              },\n              (res) => {\n                res.on('end', () => {\n                  // Ignore response, scripts discovered while processing the entry\n                  // will be preprocessed (server.config.server.preTransformRequests)\n                })\n              },\n            )\n              .on('error', () => {\n                // Ignore errors\n              })\n              .end()\n          }, 0)\n        }\n\n        _openBrowser(path, true, server.config.logger)\n      } else {\n        server.config.logger.warn('No URL available to open in browser')\n      }\n    },\n    async close() {\n      if (!middlewareMode) {\n        process.off('SIGTERM', exitProcess)\n        if (process.env.CI !== 'true') {\n          process.stdin.off('end', exitProcess)\n        }\n      }\n      await Promise.allSettled([\n        watcher.close(),\n        ws.close(),\n        container.close(),\n        getDepsOptimizer(server.config)?.close(),\n        getDepsOptimizer(server.config, true)?.close(),\n        closeHttpServer(),\n      ])\n      // Await pending requests. We throw early in transformRequest\n      // and in hooks if the server is closing for non-ssr requests,\n      // so the import analysis plugin stops pre-transforming static\n      // imports and this block is resolved sooner.\n      // During SSR, we let pending requests finish to avoid exposing\n      // the server closed error to the users.\n      while (server._pendingRequests.size > 0) {\n        await Promise.allSettled(\n          [...server._pendingRequests.values()].map(\n            (pending) => pending.request,\n          ),\n        )\n      }\n      server.resolvedUrls = null\n    },\n    printUrls() {\n      if (server.resolvedUrls) {\n        printServerUrls(\n          server.resolvedUrls,\n          serverConfig.host,\n          config.logger.info,\n        )\n      } else if (middlewareMode) {\n        throw new Error('cannot print server URLs in middleware mode.')\n      } else {\n        throw new Error(\n          'cannot print server URLs before server.listen is called.',\n        )\n      }\n    },\n    bindCLIShortcuts(options) {\n      bindCLIShortcuts(server, options)\n    },\n    async restart(forceOptimize?: boolean) {\n      if (!server._restartPromise) {\n        server._forceOptimizeOnRestart = !!forceOptimize\n        server._restartPromise = restartServer(server).finally(() => {\n          server._restartPromise = null\n          server._forceOptimizeOnRestart = false\n        })\n      }\n      return server._restartPromise\n    },\n\n    _setInternalServer(_server: ViteDevServer) {\n      // Rebind internal the server variable so functions reference the user\n      // server instance after a restart\n      server = _server\n    },\n    _restartPromise: null,\n    _importGlobMap: new Map(),\n    _forceOptimizeOnRestart: false,\n    _pendingRequests: new Map(),\n    _fsDenyGlob: picomatch(config.server.fs.deny, { matchBase: true }),\n    _shortcutsOptions: undefined,\n  }\n\n  if (!middlewareMode) {\n    exitProcess = async () => {\n      try {\n        await server.close()\n      } finally {\n        process.exit()\n      }\n    }\n    process.once('SIGTERM', exitProcess)\n    if (process.env.CI !== 'true') {\n      process.stdin.on('end', exitProcess)\n    }\n  }\n\n  const publicFiles = await initPublicFilesPromise\n\n  const onHMRUpdate = async (file: string, configOnly: boolean) => {\n    if (serverConfig.hmr !== false) {\n      try {\n        await handleHMRUpdate(file, server, configOnly)\n      } catch (err) {\n        ws.send({\n          type: 'error',\n          err: prepareError(err),\n        })\n      }\n    }\n  }\n\n  const normalizedPublicDir = normalizePath(config.publicDir)\n\n  const onFileAddUnlink = async (file: string, isUnlink: boolean) => {\n    file = normalizePath(file)\n    await container.watchChange(file, { event: isUnlink ? 'delete' : 'create' })\n\n    if (config.publicDir && publicFiles) {\n      if (file.startsWith(normalizedPublicDir)) {\n        publicFiles[isUnlink ? 'delete' : 'add'](\n          file.slice(normalizedPublicDir.length),\n        )\n      }\n    }\n    await handleFileAddUnlink(file, server, isUnlink)\n    await onHMRUpdate(file, true)\n  }\n\n  watcher.on('change', async (file) => {\n    file = normalizePath(file)\n    await container.watchChange(file, { event: 'update' })\n    // invalidate module graph cache on file change\n    moduleGraph.onFileChange(file)\n    await onHMRUpdate(file, false)\n  })\n\n  getFsUtils(config).initWatcher?.(watcher)\n\n  watcher.on('add', (file) => {\n    onFileAddUnlink(file, false)\n  })\n  watcher.on('unlink', (file) => {\n    onFileAddUnlink(file, true)\n  })\n\n  ws.on('vite:invalidate', async ({ path, message }: InvalidatePayload) => {\n    const mod = moduleGraph.urlToModuleMap.get(path)\n    if (mod && mod.isSelfAccepting && mod.lastHMRTimestamp > 0) {\n      config.logger.info(\n        colors.yellow(`hmr invalidate `) +\n          colors.dim(path) +\n          (message ? ` ${message}` : ''),\n        { timestamp: true },\n      )\n      const file = getShortName(mod.file!, config.root)\n      updateModules(\n        file,\n        [...mod.importers],\n        mod.lastHMRTimestamp,\n        server,\n        true,\n      )\n    }\n  })\n\n  if (!middlewareMode && httpServer) {\n    httpServer.once('listening', () => {\n      // update actual port since this may be different from initial value\n      serverConfig.port = (httpServer.address() as net.AddressInfo).port\n    })\n  }\n\n  // apply server configuration hooks from plugins\n  const postHooks: ((() => void) | void)[] = []\n  for (const hook of config.getSortedPluginHooks('configureServer')) {\n    postHooks.push(await hook(server))\n  }\n\n  // Internal middlewares ------------------------------------------------------\n\n  // request timer\n  if (process.env.DEBUG) {\n    middlewares.use(timeMiddleware(root))\n  }\n\n  // cors (enabled by default)\n  const { cors } = serverConfig\n  if (cors !== false) {\n    middlewares.use(corsMiddleware(typeof cors === 'boolean' ? {} : cors))\n  }\n\n  // proxy\n  const { proxy } = serverConfig\n  if (proxy) {\n    const middlewareServer =\n      (isObject(serverConfig.middlewareMode)\n        ? serverConfig.middlewareMode.server\n        : null) || httpServer\n    middlewares.use(proxyMiddleware(middlewareServer, proxy, config))\n  }\n\n  // base\n  if (config.base !== '/') {\n    middlewares.use(baseMiddleware(config.rawBase, middlewareMode))\n  }\n\n  // open in editor support\n  middlewares.use('/__open-in-editor', launchEditorMiddleware())\n\n  // ping request handler\n  // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`\n  middlewares.use(function viteHMRPingMiddleware(req, res, next) {\n    if (req.headers['accept'] === 'text/x-vite-ping') {\n      res.writeHead(204).end()\n    } else {\n      next()\n    }\n  })\n\n  // serve static files under /public\n  // this applies before the transform middleware so that these files are served\n  // as-is without transforms.\n  if (config.publicDir) {\n    middlewares.use(servePublicMiddleware(server, publicFiles))\n  }\n\n  // main transform middleware\n  middlewares.use(transformMiddleware(server))\n\n  // serve static files\n  middlewares.use(serveRawFsMiddleware(server))\n  middlewares.use(serveStaticMiddleware(server))\n\n  // html fallback\n  if (config.appType === 'spa' || config.appType === 'mpa') {\n    middlewares.use(\n      htmlFallbackMiddleware(\n        root,\n        config.appType === 'spa',\n        getFsUtils(config),\n      ),\n    )\n  }\n\n  // run post config hooks\n  // This is applied before the html middleware so that user middleware can\n  // serve custom content instead of index.html.\n  postHooks.forEach((fn) => fn && fn())\n\n  if (config.appType === 'spa' || config.appType === 'mpa') {\n    // transform index.html\n    middlewares.use(indexHtmlMiddleware(root, server))\n\n    // handle 404s\n    middlewares.use(notFoundMiddleware())\n  }\n\n  // error handler\n  middlewares.use(errorMiddleware(server, middlewareMode))\n\n  // httpServer.listen can be called multiple times\n  // when port when using next port number\n  // this code is to avoid calling buildStart multiple times\n  let initingServer: Promise<void> | undefined\n  let serverInited = false\n  const initServer = async () => {\n    if (serverInited) return\n    if (initingServer) return initingServer\n\n    initingServer = (async function () {\n      await container.buildStart({})\n      // start deps optimizer after all container plugins are ready\n      if (isDepsOptimizerEnabled(config, false)) {\n        await initDepsOptimizer(config, server)\n      }\n      warmupFiles(server)\n      initingServer = undefined\n      serverInited = true\n    })()\n    return initingServer\n  }\n\n  if (!middlewareMode && httpServer) {\n    // overwrite listen to init optimizer before server start\n    const listen = httpServer.listen.bind(httpServer)\n    httpServer.listen = (async (port: number, ...args: any[]) => {\n      try {\n        // ensure ws server started\n        ws.listen()\n        await initServer()\n      } catch (e) {\n        httpServer.emit('error', e)\n        return\n      }\n      return listen(port, ...args)\n    }) as any\n  } else {\n    if (options.ws) {\n      ws.listen()\n    }\n    await initServer()\n  }\n\n  return server\n}\n\nasync function startServer(\n  server: ViteDevServer,\n  inlinePort?: number,\n): Promise<void> {\n  const httpServer = server.httpServer\n  if (!httpServer) {\n    throw new Error('Cannot call server.listen in middleware mode.')\n  }\n\n  const options = server.config.server\n  const hostname = await resolveHostname(options.host)\n  const configPort = inlinePort ?? options.port\n  // When using non strict port for the dev server, the running port can be different from the config one.\n  // When restarting, the original port may be available but to avoid a switch of URL for the running\n  // browser tabs, we enforce the previously used port, expect if the config port changed.\n  const port =\n    (!configPort || configPort === server._configServerPort\n      ? server._currentServerPort\n      : configPort) ?? DEFAULT_DEV_PORT\n  server._configServerPort = configPort\n\n  const serverPort = await httpServerStart(httpServer, {\n    port,\n    strictPort: options.strictPort,\n    host: hostname.host,\n    logger: server.config.logger,\n  })\n  server._currentServerPort = serverPort\n}\n\nfunction createServerCloseFn(server: HttpServer | null) {\n  if (!server) {\n    return () => {}\n  }\n\n  let hasListened = false\n  const openSockets = new Set<net.Socket>()\n\n  server.on('connection', (socket) => {\n    openSockets.add(socket)\n    socket.on('close', () => {\n      openSockets.delete(socket)\n    })\n  })\n\n  server.once('listening', () => {\n    hasListened = true\n  })\n\n  return () =>\n    new Promise<void>((resolve, reject) => {\n      openSockets.forEach((s) => s.destroy())\n      if (hasListened) {\n        server.close((err) => {\n          if (err) {\n            reject(err)\n          } else {\n            resolve()\n          }\n        })\n      } else {\n        resolve()\n      }\n    })\n}\n\nfunction resolvedAllowDir(root: string, dir: string): string {\n  return normalizePath(path.resolve(root, dir))\n}\n\nexport function resolveServerOptions(\n  root: string,\n  raw: ServerOptions | undefined,\n  logger: Logger,\n): ResolvedServerOptions {\n  const server: ResolvedServerOptions = {\n    preTransformRequests: true,\n    ...(raw as Omit<ResolvedServerOptions, 'sourcemapIgnoreList'>),\n    sourcemapIgnoreList:\n      raw?.sourcemapIgnoreList === false\n        ? () => false\n        : raw?.sourcemapIgnoreList || isInNodeModules,\n    middlewareMode: !!raw?.middlewareMode,\n  }\n  let allowDirs = server.fs?.allow\n  const deny = server.fs?.deny || ['.env', '.env.*', '*.{crt,pem}']\n\n  if (!allowDirs) {\n    allowDirs = [searchForWorkspaceRoot(root)]\n  }\n\n  allowDirs = allowDirs.map((i) => resolvedAllowDir(root, i))\n\n  // only push client dir when vite itself is outside-of-root\n  const resolvedClientDir = resolvedAllowDir(root, CLIENT_DIR)\n  if (!allowDirs.some((dir) => isParentDirectory(dir, resolvedClientDir))) {\n    allowDirs.push(resolvedClientDir)\n  }\n\n  server.fs = {\n    strict: server.fs?.strict ?? true,\n    allow: allowDirs,\n    deny,\n    cachedChecks:\n      server.fs?.cachedChecks ?? !!process.env.VITE_SERVER_FS_CACHED_CHECKS,\n  }\n\n  if (server.origin?.endsWith('/')) {\n    server.origin = server.origin.slice(0, -1)\n    logger.warn(\n      colors.yellow(\n        `${colors.bold('(!)')} server.origin should not end with \"/\". Using \"${\n          server.origin\n        }\" instead.`,\n      ),\n    )\n  }\n\n  return server\n}\n\nasync function restartServer(server: ViteDevServer) {\n  global.__vite_start_time = performance.now()\n  const shortcutsOptions = server._shortcutsOptions\n\n  let inlineConfig = server.config.inlineConfig\n  if (server._forceOptimizeOnRestart) {\n    inlineConfig = mergeConfig(inlineConfig, {\n      optimizeDeps: {\n        force: true,\n      },\n    })\n  }\n\n  // Reinit the server by creating a new instance using the same inlineConfig\n  // This will triger a reload of the config file and re-create the plugins and\n  // middlewares. We then assign all properties of the new server to the existing\n  // server instance and set the user instance to be used in the new server.\n  // This allows us to keep the same server instance for the user.\n  {\n    let newServer = null\n    try {\n      // delay ws server listen\n      newServer = await _createServer(inlineConfig, { ws: false })\n    } catch (err: any) {\n      server.config.logger.error(err.message, {\n        timestamp: true,\n      })\n      server.config.logger.error('server restart failed', { timestamp: true })\n      return\n    }\n\n    await server.close()\n\n    // Assign new server props to existing server instance\n    const middlewares = server.middlewares\n    newServer._configServerPort = server._configServerPort\n    newServer._currentServerPort = server._currentServerPort\n    Object.assign(server, newServer)\n\n    // Keep the same connect instance so app.use(vite.middlewares) works\n    // after a restart in middlewareMode (.route is always '/')\n    middlewares.stack = newServer.middlewares.stack\n    server.middlewares = middlewares\n\n    // Rebind internal server variable so functions reference the user server\n    newServer._setInternalServer(server)\n  }\n\n  const {\n    logger,\n    server: { port, middlewareMode },\n  } = server.config\n  if (!middlewareMode) {\n    await server.listen(port, true)\n  } else {\n    server.ws.listen()\n  }\n  logger.info('server restarted.', { timestamp: true })\n\n  if (shortcutsOptions) {\n    shortcutsOptions.print = false\n    bindCLIShortcuts(server, shortcutsOptions)\n  }\n}\n\n/**\n * Internal function to restart the Vite server and print URLs if changed\n */\nexport async function restartServerWithUrls(\n  server: ViteDevServer,\n): Promise<void> {\n  if (server.config.server.middlewareMode) {\n    await server.restart()\n    return\n  }\n\n  const { port: prevPort, host: prevHost } = server.config.server\n  const prevUrls = server.resolvedUrls\n\n  await server.restart()\n\n  const {\n    logger,\n    server: { port, host },\n  } = server.config\n  if (\n    (port ?? DEFAULT_DEV_PORT) !== (prevPort ?? DEFAULT_DEV_PORT) ||\n    host !== prevHost ||\n    diffDnsOrderChange(prevUrls, server.resolvedUrls)\n  ) {\n    logger.info('')\n    server.printUrls()\n  }\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2024-23633", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "\"\"\"This file and its contents are licensed under the Apache License 2.0. Please see the included NOTICE for copyright information and LICENSE for a copy of the license.\n\"\"\"\nimport base64\nimport json\nimport logging\nimport mimetypes\nimport time\nfrom urllib.parse import unquote, urlparse\n\nimport drf_yasg.openapi as openapi\nfrom core.feature_flags import flag_set\nfrom core.permissions import ViewClassPermission, all_permissions\nfrom core.redis import start_job_async_or_sync\nfrom core.utils.common import retry_database_locked, timeit\nfrom core.utils.exceptions import LabelStudioValidationErrorSentryIgnored\nfrom core.utils.params import bool_from_request, list_of_strings_from_request\nfrom django.conf import settings\nfrom django.db import transaction\nfrom django.http import HttpResponse, HttpResponseRedirect\nfrom django.utils.decorators import method_decorator\nfrom drf_yasg.utils import swagger_auto_schema\nfrom projects.models import Project, ProjectImport, ProjectReimport\nfrom ranged_fileresponse import RangedFileResponse\nfrom rest_framework import generics, status\nfrom rest_framework.exceptions import ValidationError\nfrom rest_framework.parsers import FormParser, JSONParser, MultiPartParser\nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\nfrom tasks.models import Prediction, Task\nfrom users.models import User\nfrom webhooks.models import WebhookAction\nfrom webhooks.utils import emit_webhooks_for_instance\n\nfrom .functions import (\n    async_import_background,\n    async_reimport_background,\n    reformat_predictions,\n    set_import_background_failure,\n    set_reimport_background_failure,\n)\nfrom .models import FileUpload\nfrom .serializers import FileUploadSerializer, ImportApiSerializer, PredictionSerializer\nfrom .uploader import create_file_uploads, load_tasks\n\nlogger = logging.getLogger(__name__)\n\n\ntask_create_response_scheme = {\n    201: openapi.Response(\n        description='Tasks successfully imported',\n        schema=openapi.Schema(\n            title='Task creation response',\n            description='Task creation response',\n            type=openapi.TYPE_OBJECT,\n            properties={\n                'task_count': openapi.Schema(\n                    title='task_count', description='Number of tasks added', type=openapi.TYPE_INTEGER\n                ),\n                'annotation_count': openapi.Schema(\n                    title='annotation_count', description='Number of annotations added', type=openapi.TYPE_INTEGER\n                ),\n                'predictions_count': openapi.Schema(\n                    title='predictions_count', description='Number of predictions added', type=openapi.TYPE_INTEGER\n                ),\n                'duration': openapi.Schema(\n                    title='duration', description='Time in seconds to create', type=openapi.TYPE_NUMBER\n                ),\n                'file_upload_ids': openapi.Schema(\n                    title='file_upload_ids',\n                    description='Database IDs of uploaded files',\n                    type=openapi.TYPE_ARRAY,\n                    items=openapi.Schema(title='File Upload IDs', type=openapi.TYPE_INTEGER),\n                ),\n                'could_be_tasks_list': openapi.Schema(\n                    title='could_be_tasks_list',\n                    description='Whether uploaded files can contain lists of tasks, like CSV/TSV files',\n                    type=openapi.TYPE_BOOLEAN,\n                ),\n                'found_formats': openapi.Schema(\n                    title='found_formats',\n                    description='The list of found file formats',\n                    type=openapi.TYPE_ARRAY,\n                    items=openapi.Schema(title='File format', type=openapi.TYPE_STRING),\n                ),\n                'data_columns': openapi.Schema(\n                    title='data_columns',\n                    description='The list of found data columns',\n                    type=openapi.TYPE_ARRAY,\n                    items=openapi.Schema(title='Data column name', type=openapi.TYPE_STRING),\n                ),\n            },\n        ),\n    ),\n    400: openapi.Schema(\n        title='Incorrect task data', description='String with error description', type=openapi.TYPE_STRING\n    ),\n}\n\n\n@method_decorator(\n    name='post',\n    decorator=swagger_auto_schema(\n        tags=['Import'],\n        responses=task_create_response_scheme,\n        manual_parameters=[\n            openapi.Parameter(\n                name='id',\n                type=openapi.TYPE_INTEGER,\n                in_=openapi.IN_PATH,\n                description='A unique integer value identifying this project.',\n            ),\n        ],\n        operation_summary='Import tasks',\n        operation_description=\"\"\"\n            Import data as labeling tasks in bulk using this API endpoint. You can use this API endpoint to import multiple tasks.\n            One POST request is limited at 250K tasks and 200 MB.\n\n            **Note:** Imported data is verified against a project *label_config* and must\n            include all variables that were used in the *label_config*. For example,\n            if the label configuration has a *$text* variable, then each item in a data object\n            must include a \"text\" field.\n            <br>\n\n            ## POST requests\n            <hr style=\"opacity:0.3\">\n\n            There are three possible ways to import tasks with this endpoint:\n\n            ### 1\\. **POST with data**\n            Send JSON tasks as POST data. Only JSON is supported for POSTing files directly.\n            Update this example to specify your authorization token and Label Studio instance host, then run the following from\n            the command line.\n\n            ```bash\n            curl -H 'Content-Type: application/json' -H 'Authorization: Token abc123' \\\\\n            -X POST '{host}/api/projects/1/import' --data '[{{\"text\": \"Some text 1\"}}, {{\"text\": \"Some text 2\"}}]'\n            ```\n\n            ### 2\\. **POST with files**\n            Send tasks as files. You can attach multiple files with different names.\n\n            - **JSON**: text files in JavaScript object notation format\n            - **CSV**: text files with tables in Comma Separated Values format\n            - **TSV**: text files with tables in Tab Separated Value format\n            - **TXT**: simple text files are similar to CSV with one column and no header, supported for projects with one source only\n\n            Update this example to specify your authorization token, Label Studio instance host, and file name and path,\n            then run the following from the command line:\n\n            ```bash\n            curl -H 'Authorization: Token abc123' \\\\\n            -X POST '{host}/api/projects/1/import' -F file=@path/to/my_file.csv\n            ```\n\n            ### 3\\. **POST with URL**\n            You can also provide a URL to a file with labeling tasks. Supported file formats are the same as in option 2.\n\n            ```bash\n            curl -H 'Content-Type: application/json' -H 'Authorization: Token abc123' \\\\\n            -X POST '{host}/api/projects/1/import' \\\\\n            --data '[{{\"url\": \"http://example.com/test1.csv\"}}, {{\"url\": \"http://example.com/test2.csv\"}}]'\n            ```\n\n            <br>\n        \"\"\".format(\n            host=(settings.HOSTNAME or 'https://localhost:8080')\n        ),\n    ),\n)\n# Import\nclass ImportAPI(generics.CreateAPIView):\n    permission_required = all_permissions.projects_change\n    parser_classes = (JSONParser, MultiPartParser, FormParser)\n    serializer_class = ImportApiSerializer\n    queryset = Task.objects.all()\n\n    def get_serializer_context(self):\n        project_id = self.kwargs.get('pk')\n        if project_id:\n            project = generics.get_object_or_404(Project.objects.for_user(self.request.user), pk=project_id)\n        else:\n            project = None\n        return {'project': project, 'user': self.request.user}\n\n    def post(self, *args, **kwargs):\n        return super(ImportAPI, self).post(*args, **kwargs)\n\n    def _save(self, tasks):\n        serializer = self.get_serializer(data=tasks, many=True)\n        serializer.is_valid(raise_exception=True)\n        task_instances = serializer.save(project_id=self.kwargs['pk'])\n        project = generics.get_object_or_404(Project.objects.for_user(self.request.user), pk=self.kwargs['pk'])\n        emit_webhooks_for_instance(\n            self.request.user.active_organization, project, WebhookAction.TASKS_CREATED, task_instances\n        )\n        return task_instances, serializer\n\n    def sync_import(self, request, project, preannotated_from_fields, commit_to_project, return_task_ids):\n        start = time.time()\n        tasks = None\n        # upload files from request, and parse all tasks\n        # TODO: Stop passing request to load_tasks function, make all validation before\n        parsed_data, file_upload_ids, could_be_tasks_list, found_formats, data_columns = load_tasks(request, project)\n\n        if preannotated_from_fields:\n            # turn flat task JSONs {\"column1\": value, \"column2\": value} into {\"data\": {\"column1\"..}, \"predictions\": [{...\"column2\"}]\n            parsed_data = reformat_predictions(parsed_data, preannotated_from_fields)\n\n        if commit_to_project:\n            # Immediately create project tasks and update project states and counters\n            tasks, serializer = self._save(parsed_data)\n            task_count = len(tasks)\n            annotation_count = len(serializer.db_annotations)\n            prediction_count = len(serializer.db_predictions)\n\n            recalculate_stats_counts = {\n                'task_count': task_count,\n                'annotation_count': annotation_count,\n                'prediction_count': prediction_count,\n            }\n\n            # Update counters (like total_annotations) for new tasks and after bulk update tasks stats. It should be a\n            # single operation as counters affect bulk is_labeled update\n            project.update_tasks_counters_and_task_states(\n                tasks_queryset=tasks,\n                maximum_annotations_changed=False,\n                overlap_cohort_percentage_changed=False,\n                tasks_number_changed=True,\n                recalculate_stats_counts=recalculate_stats_counts,\n            )\n            logger.info('Tasks bulk_update finished (sync import)')\n\n            project.summary.update_data_columns(parsed_data)\n            # TODO: project.summary.update_created_annotations_and_labels\n        else:\n            # Do nothing - just output file upload ids for further use\n            task_count = len(parsed_data)\n            annotation_count = None\n            prediction_count = None\n\n        duration = time.time() - start\n\n        response = {\n            'task_count': task_count,\n            'annotation_count': annotation_count,\n            'prediction_count': prediction_count,\n            'duration': duration,\n            'file_upload_ids': file_upload_ids,\n            'could_be_tasks_list': could_be_tasks_list,\n            'found_formats': found_formats,\n            'data_columns': data_columns,\n        }\n        if tasks and return_task_ids:\n            response['task_ids'] = [task.id for task in tasks]\n\n        return Response(response, status=status.HTTP_201_CREATED)\n\n    @timeit\n    def async_import(self, request, project, preannotated_from_fields, commit_to_project, return_task_ids):\n\n        project_import = ProjectImport.objects.create(\n            project=project,\n            preannotated_from_fields=preannotated_from_fields,\n            commit_to_project=commit_to_project,\n            return_task_ids=return_task_ids,\n        )\n\n        if len(request.FILES):\n            logger.debug(f'Import from files: {request.FILES}')\n            file_upload_ids, could_be_tasks_list = create_file_uploads(request.user, project, request.FILES)\n            project_import.file_upload_ids = file_upload_ids\n            project_import.could_be_tasks_list = could_be_tasks_list\n            project_import.save(update_fields=['file_upload_ids', 'could_be_tasks_list'])\n        elif 'application/x-www-form-urlencoded' in request.content_type:\n            logger.debug(f'Import from url: {request.data.get(\"url\")}')\n            # empty url\n            url = request.data.get('url')\n            if not url:\n                raise ValidationError('\"url\" is not found in request data')\n            project_import.url = url\n            project_import.save(update_fields=['url'])\n        # take one task from request DATA\n        elif 'application/json' in request.content_type and isinstance(request.data, dict):\n            project_import.tasks = [request.data]\n            project_import.save(update_fields=['tasks'])\n\n        # take many tasks from request DATA\n        elif 'application/json' in request.content_type and isinstance(request.data, list):\n            project_import.tasks = request.data\n            project_import.save(update_fields=['tasks'])\n\n        # incorrect data source\n        else:\n            raise ValidationError('load_tasks: No data found in DATA or in FILES')\n\n        start_job_async_or_sync(\n            async_import_background,\n            project_import.id,\n            request.user.id,\n            on_failure=set_import_background_failure,\n            project_id=project.id,\n            organization_id=request.user.active_organization.id,\n        )\n\n        response = {'import': project_import.id}\n        return Response(response, status=status.HTTP_201_CREATED)\n\n    def create(self, request, *args, **kwargs):\n        commit_to_project = bool_from_request(request.query_params, 'commit_to_project', True)\n        return_task_ids = bool_from_request(request.query_params, 'return_task_ids', False)\n        preannotated_from_fields = list_of_strings_from_request(request.query_params, 'preannotated_from_fields', None)\n\n        # check project permissions\n        project = generics.get_object_or_404(Project.objects.for_user(self.request.user), pk=self.kwargs['pk'])\n\n        if (\n            flag_set('fflag_feat_all_lsdv_4915_async_task_import_13042023_short', request.user)\n            and settings.VERSION_EDITION != 'Community'\n        ):\n            return self.async_import(request, project, preannotated_from_fields, commit_to_project, return_task_ids)\n        else:\n            return self.sync_import(request, project, preannotated_from_fields, commit_to_project, return_task_ids)\n\n\n# Import\nclass ImportPredictionsAPI(generics.CreateAPIView):\n    permission_required = all_permissions.projects_change\n    parser_classes = (JSONParser, MultiPartParser, FormParser)\n    serializer_class = PredictionSerializer\n    queryset = Project.objects.all()\n    swagger_schema = None  # TODO: create API schema\n\n    def create(self, request, *args, **kwargs):\n        # check project permissions\n        project = self.get_object()\n\n        tasks_ids = set(Task.objects.filter(project=project).values_list('id', flat=True))\n\n        logger.debug(\n            f'Importing {len(self.request.data)} predictions to project {project} with {len(tasks_ids)} tasks'\n        )\n        predictions = []\n        for item in self.request.data:\n            if item.get('task') not in tasks_ids:\n                raise LabelStudioValidationErrorSentryIgnored(\n                    f'{item} contains invalid \"task\" field: corresponding task ID couldn\\'t be retrieved '\n                    f'from project {project} tasks'\n                )\n            predictions.append(\n                Prediction(\n                    task_id=item['task'],\n                    project_id=project.id,\n                    result=Prediction.prepare_prediction_result(item.get('result'), project),\n                    score=item.get('score'),\n                    model_version=item.get('model_version', 'undefined'),\n                )\n            )\n        predictions_obj = Prediction.objects.bulk_create(predictions, batch_size=settings.BATCH_SIZE)\n        project.update_tasks_counters(Task.objects.filter(id__in=tasks_ids))\n        return Response({'created': len(predictions_obj)}, status=status.HTTP_201_CREATED)\n\n\nclass TasksBulkCreateAPI(ImportAPI):\n    # just for compatibility - can be safely removed\n    swagger_schema = None\n\n\nclass ReImportAPI(ImportAPI):\n    permission_required = all_permissions.projects_change\n\n    def sync_reimport(self, project, file_upload_ids, files_as_tasks_list):\n        start = time.time()\n        tasks, found_formats, data_columns = FileUpload.load_tasks_from_uploaded_files(\n            project, file_upload_ids, files_as_tasks_list=files_as_tasks_list\n        )\n\n        with transaction.atomic():\n            project.remove_tasks_by_file_uploads(file_upload_ids)\n            tasks, serializer = self._save(tasks)\n        duration = time.time() - start\n\n        task_count = len(tasks)\n        annotation_count = len(serializer.db_annotations)\n        prediction_count = len(serializer.db_predictions)\n\n        # Update counters (like total_annotations) for new tasks and after bulk update tasks stats. It should be a\n        # single operation as counters affect bulk is_labeled update\n        project.update_tasks_counters_and_task_states(\n            tasks_queryset=tasks,\n            maximum_annotations_changed=False,\n            overlap_cohort_percentage_changed=False,\n            tasks_number_changed=True,\n            recalculate_stats_counts={\n                'task_count': task_count,\n                'annotation_count': annotation_count,\n                'prediction_count': prediction_count,\n            },\n        )\n        logger.info('Tasks bulk_update finished (sync reimport)')\n\n        project.summary.update_data_columns(tasks)\n        # TODO: project.summary.update_created_annotations_and_labels\n\n        return Response(\n            {\n                'task_count': task_count,\n                'annotation_count': annotation_count,\n                'prediction_count': prediction_count,\n                'duration': duration,\n                'file_upload_ids': file_upload_ids,\n                'found_formats': found_formats,\n                'data_columns': data_columns,\n            },\n            status=status.HTTP_201_CREATED,\n        )\n\n    def async_reimport(self, project, file_upload_ids, files_as_tasks_list, organization_id):\n\n        project_reimport = ProjectReimport.objects.create(\n            project=project, file_upload_ids=file_upload_ids, files_as_tasks_list=files_as_tasks_list\n        )\n\n        start_job_async_or_sync(\n            async_reimport_background,\n            project_reimport.id,\n            organization_id,\n            self.request.user,\n            on_failure=set_reimport_background_failure,\n            project_id=project.id,\n        )\n\n        response = {'reimport': project_reimport.id}\n        return Response(response, status=status.HTTP_201_CREATED)\n\n    @retry_database_locked()\n    def create(self, request, *args, **kwargs):\n        files_as_tasks_list = bool_from_request(request.data, 'files_as_tasks_list', True)\n        file_upload_ids = self.request.data.get('file_upload_ids')\n\n        # check project permissions\n        project = generics.get_object_or_404(Project.objects.for_user(self.request.user), pk=self.kwargs['pk'])\n\n        if not file_upload_ids:\n            return Response(\n                {\n                    'task_count': 0,\n                    'annotation_count': 0,\n                    'prediction_count': 0,\n                    'duration': 0,\n                    'file_upload_ids': [],\n                    'found_formats': {},\n                    'data_columns': [],\n                },\n                status=status.HTTP_200_OK,\n            )\n\n        if (\n            flag_set('fflag_fix_all_lsdv_4971_async_reimport_09052023_short', request.user)\n            and settings.VERSION_EDITION != 'Community'\n        ):\n            return self.async_reimport(\n                project, file_upload_ids, files_as_tasks_list, request.user.active_organization_id\n            )\n        else:\n            return self.sync_reimport(project, file_upload_ids, files_as_tasks_list)\n\n    @swagger_auto_schema(\n        auto_schema=None,\n        operation_summary='Re-import tasks',\n        operation_description=\"\"\"\n        Re-import tasks using the specified file upload IDs for a specific project.\n        \"\"\",\n    )\n    def post(self, *args, **kwargs):\n        return super(ReImportAPI, self).post(*args, **kwargs)\n\n\n@method_decorator(\n    name='get',\n    decorator=swagger_auto_schema(\n        tags=['Import'],\n        operation_summary='Get files list',\n        manual_parameters=[\n            openapi.Parameter(\n                name='all',\n                type=openapi.TYPE_BOOLEAN,\n                in_=openapi.IN_QUERY,\n                description='Set to \"true\" if you want to retrieve all file uploads',\n            ),\n            openapi.Parameter(\n                name='ids',\n                type=openapi.TYPE_ARRAY,\n                in_=openapi.IN_QUERY,\n                items=openapi.Schema(title='File upload ID', type=openapi.TYPE_INTEGER),\n                description='Specify the list of file upload IDs to retrieve, e.g. ids=[1,2,3]',\n            ),\n        ],\n        operation_description=\"\"\"\n        Retrieve the list of uploaded files used to create labeling tasks for a specific project.\n        \"\"\",\n    ),\n)\n@method_decorator(\n    name='delete',\n    decorator=swagger_auto_schema(\n        tags=['Import'],\n        operation_summary='Delete files',\n        operation_description=\"\"\"\n        Delete uploaded files for a specific project.\n        \"\"\",\n    ),\n)\nclass FileUploadListAPI(generics.mixins.ListModelMixin, generics.mixins.DestroyModelMixin, generics.GenericAPIView):\n    parser_classes = (JSONParser, MultiPartParser, FormParser)\n    serializer_class = FileUploadSerializer\n    permission_required = ViewClassPermission(\n        GET=all_permissions.projects_view,\n        DELETE=all_permissions.projects_change,\n    )\n    queryset = FileUpload.objects.all()\n\n    def get_queryset(self):\n        project = generics.get_object_or_404(Project.objects.for_user(self.request.user), pk=self.kwargs.get('pk', 0))\n        if project.is_draft or bool_from_request(self.request.query_params, 'all', False):\n            # If project is in draft state, we return all uploaded files, ignoring queried ids\n            logger.debug(f'Return all uploaded files for draft project {project}')\n            return FileUpload.objects.filter(project_id=project.id, user=self.request.user)\n\n        # If requested in regular import, only queried IDs are returned to avoid showing previously imported\n        ids = json.loads(self.request.query_params.get('ids', '[]'))\n        logger.debug(f'File Upload IDs found: {ids}')\n        return FileUpload.objects.filter(project_id=project.id, id__in=ids, user=self.request.user)\n\n    def get(self, request, *args, **kwargs):\n        return self.list(request, *args, **kwargs)\n\n    def delete(self, request, *args, **kwargs):\n        project = generics.get_object_or_404(Project.objects.for_user(self.request.user), pk=self.kwargs['pk'])\n        ids = self.request.data.get('file_upload_ids')\n        if ids is None:\n            deleted, _ = FileUpload.objects.filter(project=project).delete()\n        elif isinstance(ids, list):\n            deleted, _ = FileUpload.objects.filter(project=project, id__in=ids).delete()\n        else:\n            raise ValueError('\"file_upload_ids\" parameter must be a list of integers')\n        return Response({'deleted': deleted}, status=status.HTTP_200_OK)\n\n\n@method_decorator(\n    name='get',\n    decorator=swagger_auto_schema(\n        tags=['Import'],\n        operation_summary='Get file upload',\n        operation_description='Retrieve details about a specific uploaded file.',\n    ),\n)\n@method_decorator(\n    name='patch',\n    decorator=swagger_auto_schema(\n        tags=['Import'],\n        operation_summary='Update file upload',\n        operation_description='Update a specific uploaded file.',\n        request_body=FileUploadSerializer,\n    ),\n)\n@method_decorator(\n    name='delete',\n    decorator=swagger_auto_schema(\n        tags=['Import'],\n        operation_summary='Delete file upload',\n        operation_description='Delete a specific uploaded file.',\n    ),\n)\nclass FileUploadAPI(generics.RetrieveUpdateDestroyAPIView):\n    parser_classes = (JSONParser, MultiPartParser, FormParser)\n    permission_classes = (IsAuthenticated,)\n    serializer_class = FileUploadSerializer\n    queryset = FileUpload.objects.all()\n\n    def get(self, *args, **kwargs):\n        return super(FileUploadAPI, self).get(*args, **kwargs)\n\n    def patch(self, *args, **kwargs):\n        return super(FileUploadAPI, self).patch(*args, **kwargs)\n\n    def delete(self, *args, **kwargs):\n        return super(FileUploadAPI, self).delete(*args, **kwargs)\n\n    @swagger_auto_schema(auto_schema=None)\n    def put(self, *args, **kwargs):\n        return super(FileUploadAPI, self).put(*args, **kwargs)\n\n\nclass UploadedFileResponse(generics.RetrieveAPIView):\n    permission_classes = (IsAuthenticated,)\n\n    @swagger_auto_schema(auto_schema=None)\n    def get(self, *args, **kwargs):\n        request = self.request\n        filename = kwargs['filename']\n        # XXX needed, on windows os.path.join generates '\\' which breaks FileUpload\n        file = settings.UPLOAD_DIR + ('/' if not settings.UPLOAD_DIR.endswith('/') else '') + filename\n        logger.debug(f'Fetch uploaded file by user {request.user} => {file}')\n        file_upload = FileUpload.objects.filter(file=file).last()\n\n        if not file_upload.has_permission(request.user):\n            return Response(status=status.HTTP_403_FORBIDDEN)\n\n        file = file_upload.file\n        if file.storage.exists(file.name):\n            content_type, encoding = mimetypes.guess_type(str(file.name))\n            content_type = content_type or 'application/octet-stream'\n            return RangedFileResponse(request, file.open(mode='rb'), content_type=content_type)\n        else:\n            return Response(status=status.HTTP_404_NOT_FOUND)\n\n\nclass DownloadStorageData(APIView):\n    \"\"\"Check auth for nginx auth_request\"\"\"\n\n    swagger_schema = None\n    http_method_names = ['get']\n    permission_classes = (IsAuthenticated,)\n\n    def get(self, request, *args, **kwargs):\n        \"\"\"Get export files list\"\"\"\n        request = self.request\n        filepath = request.GET.get('filepath')\n        if filepath is None:\n            return Response(status=status.HTTP_404_NOT_FOUND)\n\n        filepath = unquote(request.GET['filepath'])\n\n        url = None\n        if filepath.startswith(settings.UPLOAD_DIR):\n            logger.debug(f'Fetch uploaded file by user {request.user} => {filepath}')\n            file_upload = FileUpload.objects.filter(file=filepath).last()\n\n            if file_upload is not None and file_upload.has_permission(request.user):\n                url = file_upload.file.storage.url(file_upload.file.name, storage_url=True)\n        elif filepath.startswith(settings.AVATAR_PATH):\n            user = User.objects.filter(avatar=filepath).first()\n            if user is not None and request.user.active_organization.has_user(user):\n                url = user.avatar.storage.url(user.avatar.name, storage_url=True)\n\n        if url is None:\n            return Response(status=status.HTTP_403_FORBIDDEN)\n\n        protocol = urlparse(url).scheme\n\n        # Let NGINX handle it\n        response = HttpResponse()\n        # The below header tells NGINX to catch it and serve, see docker-config/nginx-app.conf\n        redirect = '/file_download/' + protocol + '/' + url.replace(protocol + '://', '')\n\n        response['X-Accel-Redirect'] = redirect\n        response['Content-Disposition'] = 'attachment; filename=\"{}\"'.format(filepath)\n        return response\n\n\nclass PresignStorageData(APIView):\n    \"\"\"A file proxy to presign storage urls.\"\"\"\n\n    swagger_schema = None\n    http_method_names = ['get']\n    permission_classes = (IsAuthenticated,)\n\n    def get(self, request, *args, **kwargs):\n        \"\"\"Get the presigned url for a given fileuri\"\"\"\n        request = self.request\n        task_id = kwargs.get('task_id')\n        fileuri = request.GET.get('fileuri')\n\n        if fileuri is None or task_id is None:\n            return Response(status=status.HTTP_404_NOT_FOUND)\n\n        try:\n            task = Task.objects.get(pk=task_id)\n        except Task.DoesNotExist:\n            return Response(status=status.HTTP_404_NOT_FOUND)\n\n        project = task.project\n\n        if not project.has_permission(request.user):\n            return Response(status=status.HTTP_403_FORBIDDEN)\n\n        # Attempt to base64 decode the fileuri\n        try:\n            fileuri = base64.urlsafe_b64decode(fileuri.encode()).decode()\n        # For backwards compatibility, try unquote if this fails\n        except Exception as exc:\n            logger.debug(f'Failed to decode base64 {fileuri} for task {task_id}: {exc} falling back to unquote')\n            fileuri = unquote(fileuri)\n\n        try:\n            resolved = task.resolve_storage_uri(fileuri, project)\n        except Exception as exc:\n            logger.error(f'Failed to resolve storage uri {fileuri} for task {task_id}: {exc}')\n            return Response(status=status.HTTP_404_NOT_FOUND)\n\n        if resolved is None or resolved.get('url') is None:\n            return Response(status=status.HTTP_404_NOT_FOUND)\n\n        url = resolved['url']\n        max_age = 0\n        if resolved.get('presign_ttl'):\n            max_age = resolved.get('presign_ttl') * 60\n\n        # Proxy to presigned url\n        response = HttpResponseRedirect(redirect_to=url, status=status.HTTP_303_SEE_OTHER)\n        response.headers['Cache-Control'] = f'no-store, max-age={max_age}'\n\n        return response\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2024-23643", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "/**\n * This program is free software: you can redistribute it and/or modify it under the terms of the\n * GNU Lesser General Public License as published by the Free Software Foundation, either version 3\n * of the License, or (at your option) any later version.\n *\n * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * <p>You should have received a copy of the GNU Lesser General Public License along with this\n * program. If not, see <http://www.gnu.org/licenses/>.\n *\n * @author Marius Suta / The Open Planning Project 2008\n * @author Arne Kepp / The Open Planning Project 2009\n * @author David Vick / Boundless 2017\n *     <p>Original file\n *     <p>SeedFormRestlet.java\n */\npackage org.geowebcache.rest.service;\n\nimport static org.geowebcache.seed.TileBreeder.TILE_FAILURE_RETRY_COUNT_DEFAULT;\nimport static org.geowebcache.seed.TileBreeder.TILE_FAILURE_RETRY_WAIT_TIME_DEFAULT;\nimport static org.geowebcache.seed.TileBreeder.TOTAL_FAILURES_BEFORE_ABORTING_DEFAULT;\nimport static org.geowebcache.seed.TileBreeder.createTileRange;\n\nimport java.text.NumberFormat;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport javax.servlet.http.HttpServletRequest;\nimport org.geowebcache.GeoWebCacheException;\nimport org.geowebcache.filter.parameters.FloatParameterFilter;\nimport org.geowebcache.filter.parameters.ParameterFilter;\nimport org.geowebcache.filter.parameters.RegexParameterFilter;\nimport org.geowebcache.filter.parameters.StringParameterFilter;\nimport org.geowebcache.grid.BoundingBox;\nimport org.geowebcache.grid.GridSubset;\nimport org.geowebcache.layer.TileLayer;\nimport org.geowebcache.mime.ImageMime;\nimport org.geowebcache.mime.MimeType;\nimport org.geowebcache.rest.exception.RestException;\nimport org.geowebcache.seed.GWCTask;\nimport org.geowebcache.seed.SeedRequest;\nimport org.geowebcache.seed.TileBreeder;\nimport org.geowebcache.storage.TileRange;\nimport org.geowebcache.util.ServletUtils;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.MediaType;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.stereotype.Service;\nimport org.springframework.util.Assert;\n\n@Service\npublic class FormService {\n\n    @Autowired TileBreeder seeder;\n\n    public ResponseEntity<?> handleKillAllThreadsPost(Map<String, String> form, TileLayer tl)\n            throws RestException {\n\n        final boolean allLayers = tl == null;\n\n        String killCode = form.get(\"kill_all\");\n\n        final Iterator<GWCTask> tasks;\n        if (\"1\".equals(killCode) || \"running\".equalsIgnoreCase(killCode)) {\n            killCode = \"running\";\n            tasks = seeder.getRunningTasks();\n        } else if (\"pending\".equalsIgnoreCase(killCode)) {\n            tasks = seeder.getPendingTasks();\n        } else if (\"all\".equalsIgnoreCase(killCode)) {\n            tasks = seeder.getRunningAndPendingTasks();\n        } else {\n            throw new RestException(\n                    \"Unknown kill_all code: '\"\n                            + killCode\n                            + \"'. One of all|running|pending is expected.\",\n                    HttpStatus.BAD_REQUEST);\n        }\n\n        List<GWCTask> terminatedTasks = new LinkedList<>();\n        List<GWCTask> nonTerminatedTasks = new LinkedList<>();\n        while (tasks.hasNext()) {\n            GWCTask task = tasks.next();\n            String layerName = task.getLayerName();\n            if (!allLayers && !tl.getName().equals(layerName)) {\n                continue;\n            }\n            long taskId = task.getTaskId();\n            boolean terminated = seeder.terminateGWCTask(taskId);\n            if (terminated) {\n                terminatedTasks.add(task);\n            } else {\n                nonTerminatedTasks.add(task);\n            }\n        }\n        StringBuilder doc = new StringBuilder();\n\n        makeHeader(doc);\n        doc.append(\"<p>Requested to terminate \").append(killCode).append(\" tasks.\");\n        doc.append(\"Terminated tasks: <ul>\");\n        for (GWCTask t : terminatedTasks) {\n            doc.append(\"<li>\").append(t).append(\"</li>\");\n        }\n        doc.append(\"</ul>Tasks already finished: <ul>\");\n        for (GWCTask t : nonTerminatedTasks) {\n            doc.append(\"<li>\").append(t).append(\"</li>\");\n        }\n        if (tl != null) {\n            doc.append(\"</ul><p><a href=\\\"./\" + tl.getName() + \"\\\">Go back</a></p>\\n\");\n        }\n\n        return new ResponseEntity<>(doc.toString(), getHeaders(), HttpStatus.OK);\n    }\n\n    public ResponseEntity<?> handleKillThreadPost(Map<String, String> form, TileLayer tl) {\n        String id = form.get(\"thread_id\");\n\n        StringBuilder doc = new StringBuilder();\n\n        makeHeader(doc);\n\n        if (seeder.terminateGWCTask(Long.parseLong(id))) {\n            doc.append(\"<ul><li>Requested to terminate task \" + id + \".</li></ul>\");\n        } else {\n            doc.append(\n                    \"<ul><li>Sorry, either task \"\n                            + id\n                            + \" has not started yet, or it is a truncate task that cannot be interrutped.</li></ul>\");\n        }\n\n        if (tl != null) {\n            doc.append(\"<p><a href=\\\"./\" + tl.getName() + \"\\\">Go back</a></p>\\n\");\n        }\n\n        return new ResponseEntity<Object>(doc.toString(), getHeaders(), HttpStatus.OK);\n    }\n\n    public ResponseEntity<?> handleFormPost(String layer, Map<String, String> params)\n            throws RestException, GeoWebCacheException {\n        final TileLayer tl;\n        {\n            String layerName = layer;\n            if (layer != null) {\n                try {\n                    tl = seeder.findTileLayer(layerName);\n                } catch (GeoWebCacheException e) {\n                    throw new RestException(e.getMessage(), HttpStatus.BAD_REQUEST);\n                }\n            } else {\n                tl = null;\n            }\n        }\n\n        if (params.containsKey(\"list\")) {\n            if (tl == null) {\n                throw new RestException(\"No layer specified\", HttpStatus.BAD_REQUEST);\n            }\n            boolean listAllTasks = \"all\".equals(params.get(\"list\"));\n            return handleDoGet(tl, listAllTasks);\n        } else if (params.containsKey(\"kill_thread\")) {\n            return handleKillThreadPost(params, tl);\n        } else if (params.containsKey(\"kill_all\")) {\n            return handleKillAllThreadsPost(params, tl);\n        } else if (params.get(\"minX\") != null) {\n            if (tl == null) {\n                throw new RestException(\"No layer specified\", HttpStatus.BAD_REQUEST);\n            }\n            return handleDoSeedPost(params, tl);\n        }\n\n        return new ResponseEntity<>(HttpStatus.BAD_REQUEST);\n    }\n\n    private ResponseEntity<?> handleDoSeedPost(Map<String, String> form, TileLayer tl)\n            throws RestException, GeoWebCacheException {\n        String gridSetId = form.get(\"gridSetId\");\n\n        BoundingBox bounds = null;\n\n        if (form.get(\"minX\") != null && !form.get(\"minX\").equalsIgnoreCase(\"\")) {\n            bounds =\n                    new BoundingBox(\n                            parseDouble(form, \"minX\"),\n                            parseDouble(form, \"minY\"),\n                            parseDouble(form, \"maxX\"),\n                            parseDouble(form, \"maxY\"));\n        } else {\n            // Use default values for tile layer\n            GridSubset subset = tl.getGridSubset(gridSetId);\n            bounds = subset.getOriginalExtent();\n        }\n\n        int threadCount = Integer.parseInt(form.get(\"threadCount\"));\n        int zoomStart = Integer.parseInt(form.get(\"zoomStart\"));\n        int zoomStop = Integer.parseInt(form.get(\"zoomStop\"));\n        String format = form.get(\"tileFormat\");\n        Map<String, String> fullParameters;\n        {\n            Map<String, String> parameters = new HashMap<>();\n            Set<String> paramNames = form.keySet();\n            String prefix = \"parameter_\";\n            for (String name : paramNames) {\n                if (name.startsWith(prefix)) {\n                    String paramName = name.substring(prefix.length());\n                    String value = form.get(name);\n                    parameters.put(paramName, value);\n                }\n            }\n            fullParameters = tl.getModifiableParameters(parameters, \"UTF-8\");\n        }\n\n        GWCTask.TYPE type = GWCTask.TYPE.valueOf(form.get(\"type\").toUpperCase());\n\n        final String layerName = tl.getName();\n        SeedRequest sr =\n                new SeedRequest(\n                        layerName,\n                        bounds,\n                        gridSetId,\n                        threadCount,\n                        zoomStart,\n                        zoomStop,\n                        format,\n                        type,\n                        fullParameters);\n\n        int tileFailureRetryCount = (int) getOptionalLongParam(form, \"tileFailureRetryCount\", 0);\n        long tileFailureRetryWaitTime = getOptionalLongParam(form, \"tileFailureRetryWaitTime\", 0);\n        long totalFailuresBeforeAborting =\n                getOptionalLongParam(form, \"totalFailuresBeforeAborting\", 0);\n        TileRange tr = createTileRange(sr, tl);\n\n        GWCTask[] tasks;\n        try {\n            tasks =\n                    seeder.createTasks(\n                            tr,\n                            tl,\n                            sr.getType(),\n                            sr.getThreadCount(),\n                            sr.getFilterUpdate(),\n                            tileFailureRetryCount,\n                            tileFailureRetryWaitTime,\n                            totalFailuresBeforeAborting);\n        } catch (GeoWebCacheException e) {\n            throw new RestException(e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);\n        }\n\n        seeder.dispatchTasks(tasks);\n\n        // Give the thread executor a chance to run\n        try {\n            Thread.sleep(500);\n        } catch (InterruptedException e) {\n            // Ok, no worries\n            Thread.currentThread().interrupt();\n        }\n\n        return new ResponseEntity<Object>(this.makeResponsePage(tl), getHeaders(), HttpStatus.OK);\n    }\n\n    private long getOptionalLongParam(Map<String, String> form, String key, long defaultValue) {\n        String value = form.get(key);\n        if (value == null) return defaultValue;\n        return Long.parseLong(value);\n    }\n\n    private static double parseDouble(Map<String, String> form, String key) throws RestException {\n        String value = form.get(key);\n        if (value == null || value.length() == 0)\n            throw new RestException(\"Missing value for \" + key, HttpStatus.BAD_REQUEST);\n        try {\n            return Double.parseDouble(value);\n        } catch (NumberFormatException nfe) {\n            throw new RestException(\n                    \"Value for \" + key + \" is not a double\", HttpStatus.BAD_REQUEST);\n        }\n    }\n\n    public ResponseEntity<?> handleGet(HttpServletRequest request, String layer) {\n        TileLayer tl;\n        try {\n            tl = seeder.findTileLayer(layer);\n        } catch (GeoWebCacheException e) {\n            throw new RestException(e.getMessage(), HttpStatus.BAD_REQUEST);\n        }\n        return handleDoGet(tl, false);\n    }\n\n    public void setTileBreeder(TileBreeder seeder) {\n        this.seeder = seeder;\n    }\n\n    private ResponseEntity<?> handleDoGet(TileLayer tl, boolean listAllTasks) {\n        return new ResponseEntity<>(makeFormPage(tl, listAllTasks), getHeaders(), HttpStatus.OK);\n    }\n\n    protected String makeFormPage(TileLayer tl, boolean listAllTasks) {\n\n        StringBuilder doc = new StringBuilder();\n\n        makeHeader(doc);\n\n        makeTaskList(doc, tl, listAllTasks);\n\n        makeWarningsAndHints(doc, tl);\n\n        makeFormHeader(doc, tl);\n\n        makeThreadCountPullDown(doc);\n\n        makeTypePullDown(doc);\n\n        makeGridSetPulldown(doc, tl);\n\n        makeFormatPullDown(doc, tl);\n\n        makeZoomStartPullDown(doc, tl);\n\n        makeZoomStopPullDown(doc, tl);\n\n        makeModifiableParameters(doc, tl);\n\n        makeBboxFields(doc);\n\n        makeFailureHandlingPolicies(doc);\n\n        makeSubmit(doc);\n\n        makeFormFooter(doc);\n\n        makeFooter(doc);\n\n        return doc.toString();\n    }\n\n    private void makeModifiableParameters(StringBuilder doc, TileLayer tl) {\n        List<ParameterFilter> parameterFilters = tl.getParameterFilters();\n        if (parameterFilters == null || parameterFilters.isEmpty()) {\n            return;\n        }\n        doc.append(\"<tr><td>Modifiable Parameters:</td><td>\\n\");\n        doc.append(\"<table>\");\n        for (ParameterFilter pf : parameterFilters) {\n            Assert.notNull(pf, \"Parameter filter must be non null\");\n            String key = pf.getKey();\n            String defaultValue = pf.getDefaultValue();\n            List<String> legalValues = pf.getLegalValues();\n            doc.append(\"<tr><td>\").append(key.toUpperCase()).append(\": \").append(\"</td><td>\");\n            String parameterId = \"parameter_\" + key;\n            if (pf instanceof StringParameterFilter) {\n                Map<String, String> keysValues = makeParametersMap(defaultValue, legalValues);\n                makePullDown(doc, parameterId, keysValues, defaultValue);\n            } else if (pf instanceof RegexParameterFilter) {\n                makeTextInput(doc, parameterId, 25);\n            } else if (pf instanceof FloatParameterFilter) {\n                FloatParameterFilter floatFilter = (FloatParameterFilter) pf;\n                if (floatFilter.getValues().isEmpty()) {\n                    // accepts any value\n                    makeTextInput(doc, parameterId, 25);\n                } else {\n                    Map<String, String> keysValues = makeParametersMap(defaultValue, legalValues);\n                    makePullDown(doc, parameterId, keysValues, defaultValue);\n                }\n            } else if (\"org.geowebcache.filter.parameters.NaiveWMSDimensionFilter\"\n                    .equals(pf.getClass().getName())) {\n                makeTextInput(doc, parameterId, 25);\n            } else {\n                // Unknown filter type\n                if (legalValues == null) {\n                    // Doesn't have a defined set of values, just provide a text field\n                    makeTextInput(doc, parameterId, 25);\n                } else {\n                    // Does have a defined set of values, so provide a drop down\n                    Map<String, String> keysValues = makeParametersMap(defaultValue, legalValues);\n                    makePullDown(doc, parameterId, keysValues, defaultValue);\n                }\n            }\n            doc.append(\"</td></tr>\");\n        }\n        doc.append(\"</table>\");\n        doc.append(\"</td></tr>\\n\");\n    }\n\n    private Map<String, String> makeParametersMap(String defaultValue, List<String> legalValues) {\n        Map<String, String> map = new TreeMap<>();\n        for (String s : legalValues) {\n            map.put(s, s);\n        }\n        map.put(defaultValue, defaultValue);\n        return map;\n    }\n\n    private String makeResponsePage(TileLayer tl) {\n\n        StringBuilder doc = new StringBuilder();\n\n        makeHeader(doc);\n\n        doc.append(\"<h3>Task submitted</h3>\\n\");\n\n        doc.append(\n                \"<p>Below you can find a list of currently executing tasks, take the numbers with a grain of salt\");\n        doc.append(\" until the task has had a chance to run for a few minutes. \");\n\n        makeTaskList(doc, tl, false);\n\n        makeFooter(doc);\n\n        return doc.toString();\n    }\n\n    private void makeTypePullDown(StringBuilder doc) {\n        doc.append(\"<tr><td>Type of operation:</td><td>\\n\");\n        Map<String, String> keysValues = new TreeMap<>();\n\n        keysValues.put(\"Truncate - remove tiles\", \"truncate\");\n        keysValues.put(\"Seed - generate missing tiles\", \"seed\");\n        keysValues.put(\"Reseed - regenerate all tiles\", \"reseed\");\n\n        makePullDown(doc, \"type\", keysValues, \"Seed - generate missing tiles\");\n        doc.append(\"</td></tr>\\n\");\n    }\n\n    private void makeThreadCountPullDown(StringBuilder doc) {\n        doc.append(\"<tr><td>Number of tasks to use:</td><td>\\n\");\n        Map<String, String> keysValues = new LinkedHashMap<>();\n\n        for (int i = 1; i < 129; i++) {\n            if (i < 10) {\n                keysValues.put(\"0\" + Integer.toString(i), \"0\" + Integer.toString(i));\n            } else {\n                keysValues.put(Integer.toString(i), Integer.toString(i));\n            }\n        }\n        makePullDown(doc, \"threadCount\", keysValues, Integer.toString(2));\n        doc.append(\"</td></tr>\\n\");\n    }\n\n    private void makeBboxFields(StringBuilder doc) {\n        doc.append(\"<tr><td valign=\\\"top\\\">Bounding box:</td><td>\\n\");\n        makeTextInput(doc, \"minX\", 6);\n        makeTextInput(doc, \"minY\", 6);\n        makeTextInput(doc, \"maxX\", 6);\n        makeTextInput(doc, \"maxY\", 6);\n        doc.append(\n                \"</br><span style=\\\"font-size:80%\\\">These are optional, approximate values are fine.</span>\");\n        doc.append(\"</td></tr>\\n\");\n    }\n\n    private void makeFailureHandlingPolicies(StringBuilder doc) {\n        doc.append(\"<tr><td valign=\\\"top\\\">Tile failure retries:</td><td>\");\n        makeTextInput(\n                doc, \"tileFailureRetryCount\", 6, String.valueOf(TILE_FAILURE_RETRY_COUNT_DEFAULT));\n        doc.append(\n                \"</br><span style=\\\"font-size:80%\\\">Set to -1 to disable retries and stop seed thread on the first failure.</span>\");\n        doc.append(\"</td></tr>\");\n        doc.append(\"<tr><td valign=\\\"top\\\">Pause before retry (ms):</td><td>\");\n        makeTextInput(\n                doc,\n                \"tileFailureRetryWaitTime\",\n                6,\n                String.valueOf(TILE_FAILURE_RETRY_WAIT_TIME_DEFAULT));\n        doc.append(\"</td></tr>\");\n        doc.append(\"<tr><td valign=\\\"top\\\">Total failures before aborting:</td><td>\");\n        makeTextInput(\n                doc,\n                \"totalFailuresBeforeAborting\",\n                6,\n                String.valueOf(TOTAL_FAILURES_BEFORE_ABORTING_DEFAULT));\n        doc.append(\"</td></tr>\");\n    }\n\n    private void makeBboxHints(StringBuilder doc, TileLayer tl) {\n\n        for (String gridSetId : tl.getGridSubsets()) {\n            GridSubset subset = tl.getGridSubset(gridSetId);\n            doc.append(\n                    \"<li>\"\n                            + gridSetId\n                            + \":   \"\n                            + subset.getOriginalExtent().toString()\n                            + \"</li>\\n\");\n        }\n    }\n\n    private void makeTextInput(StringBuilder doc, String id, int size) {\n        makeTextInput(doc, id, size, \"\");\n    }\n\n    private void makeTextInput(StringBuilder doc, String id, int size, String defaultValue) {\n        doc.append(\n                \"<input name=\\\"\"\n                        + id\n                        + \"\\\" type=\\\"text\\\" size=\\\"\"\n                        + size\n                        + \"\\\" value=\\\"\"\n                        + defaultValue\n                        + \"\\\"/>\");\n    }\n\n    private void makeSubmit(StringBuilder doc) {\n        doc.append(\"<tr><td></td><td><input type=\\\"submit\\\" value=\\\"Submit\\\"></td></tr>\\n\");\n    }\n\n    private void makeZoomStopPullDown(StringBuilder doc, TileLayer tl) {\n        doc.append(\"<tr><td>Zoom stop:</td><td>\\n\");\n        makeZoomPullDown(doc, false, tl);\n        doc.append(\"</td></tr>\\n\");\n    }\n\n    private void makeZoomStartPullDown(StringBuilder doc, TileLayer tl) {\n        doc.append(\"<tr><td>Zoom start:</td><td>\\n\");\n        makeZoomPullDown(doc, true, tl);\n        doc.append(\"</td></tr>\\n\");\n    }\n\n    private void makeZoomPullDown(StringBuilder doc, boolean isStart, TileLayer tl) {\n        Map<String, String> keysValues = new TreeMap<>();\n\n        int minStart = Integer.MAX_VALUE;\n        int maxStop = Integer.MIN_VALUE;\n\n        for (String gridSetId : tl.getGridSubsets()) {\n            GridSubset subset = tl.getGridSubset(gridSetId);\n\n            int start = subset.getZoomStart();\n            int stop = subset.getZoomStop();\n\n            if (start < minStart) {\n                minStart = start;\n            }\n            if (stop > maxStop) {\n                maxStop = stop;\n            }\n        }\n\n        for (int i = minStart; i <= maxStop; i++) {\n            if (i < 10) {\n                keysValues.put(\"0\" + Integer.toString(i), \"0\" + Integer.toString(i));\n            } else {\n                keysValues.put(Integer.toString(i), Integer.toString(i));\n            }\n        }\n\n        if (isStart) {\n            if (minStart < 10) {\n                makePullDown(doc, \"zoomStart\", keysValues, \"0\" + Integer.toString(minStart));\n            } else {\n                makePullDown(doc, \"zoomStart\", keysValues, Integer.toString(minStart));\n            }\n\n        } else {\n            int midStop = (minStart + maxStop) / 2;\n            if (midStop < 10) {\n                makePullDown(doc, \"zoomStop\", keysValues, \"0\" + Integer.toString(midStop));\n            } else {\n                makePullDown(doc, \"zoomStop\", keysValues, Integer.toString(midStop));\n            }\n        }\n    }\n\n    private void makeFormatPullDown(StringBuilder doc, TileLayer tl) {\n        doc.append(\"<tr><td>Format:</td><td>\\n\");\n        Map<String, String> keysValues = new TreeMap<>();\n\n        Iterator<MimeType> iter = tl.getMimeTypes().iterator();\n\n        while (iter.hasNext()) {\n            MimeType mime = iter.next();\n            keysValues.put(mime.getFormat(), mime.getFormat());\n        }\n\n        makePullDown(doc, \"tileFormat\", keysValues, ImageMime.png.getFormat());\n        doc.append(\"</td></tr>\\n\");\n    }\n\n    private void makeGridSetPulldown(StringBuilder doc, TileLayer tl) {\n        doc.append(\"<tr><td>Grid Set:</td><td>\\n\");\n        Map<String, String> keysValues = new TreeMap<>();\n\n        String firstGridSetId = null;\n        for (String gridSetId : tl.getGridSubsets()) {\n            if (firstGridSetId == null) {\n                firstGridSetId = gridSetId;\n            }\n            keysValues.put(gridSetId, gridSetId);\n        }\n\n        makePullDown(doc, \"gridSetId\", keysValues, firstGridSetId);\n        doc.append(\"</td></tr>\\n\");\n    }\n\n    private void makePullDown(\n            StringBuilder doc, String id, Map<String, String> keysValues, String defaultKey) {\n        doc.append(\"<select name=\\\"\" + id + \"\\\">\\n\");\n\n        Iterator<Map.Entry<String, String>> iter = keysValues.entrySet().iterator();\n\n        while (iter.hasNext()) {\n            Map.Entry<String, String> entry = iter.next();\n            if (entry.getKey().equals(defaultKey)) {\n                doc.append(\n                        \"<option value=\\\"\"\n                                + entry.getValue()\n                                + \"\\\" selected=\\\"selected\\\">\"\n                                + entry.getKey()\n                                + \"</option>\\n\");\n            } else {\n                doc.append(\n                        \"<option value=\\\"\"\n                                + entry.getValue()\n                                + \"\\\">\"\n                                + entry.getKey()\n                                + \"</option>\\n\");\n            }\n        }\n\n        doc.append(\"</select>\\n\");\n    }\n\n    private void makeFormHeader(StringBuilder doc, TileLayer tl) {\n        doc.append(\"<h4>Create a new task:</h4>\\n\");\n        doc.append(\"<form id=\\\"seed\\\" action=\\\"./\" + tl.getName() + \"\\\" method=\\\"post\\\">\\n\");\n        doc.append(\"<table border=\\\"0\\\" cellspacing=\\\"10\\\">\\n\");\n    }\n\n    private void makeFormFooter(StringBuilder doc) {\n        doc.append(\"</table>\\n\");\n        doc.append(\"</form>\\n\");\n    }\n\n    private void makeHeader(StringBuilder doc) {\n        doc.append(\n                \"<html>\\n\"\n                        + ServletUtils.gwcHtmlHeader(\"../../\", \"GWC Seed Form\")\n                        + \"<body>\\n\"\n                        + ServletUtils.gwcHtmlLogoLink(\"../../\"));\n    }\n\n    private void makeWarningsAndHints(StringBuilder doc, TileLayer tl) {\n        doc.append(\n                \"<h4>Please note:</h4><ul>\\n\"\n                        + \"<li>This minimalistic interface does not check for correctness.</li>\\n\"\n                        + \"<li>Seeding past zoomlevel 20 is usually not recommended.</li>\\n\"\n                        + \"<li>Truncating KML will also truncate all KMZ archives.</li>\\n\"\n                        + \"<li>Please check the logs of the container to look for error messages and progress indicators.</li>\\n\"\n                        + \"</ul>\\n\");\n\n        doc.append(\"Here are the max bounds, if you do not specify bounds these will be used.\\n\");\n        doc.append(\"<ul>\\n\");\n        makeBboxHints(doc, tl);\n        doc.append(\"</ul>\\n\");\n    }\n\n    private void makeTaskList(StringBuilder doc, TileLayer tl, boolean listAll) {\n\n        doc.append(makeKillallThreadsForm(tl, listAll));\n\n        doc.append(\"<h4>List of currently executing tasks:</h4>\\n\");\n\n        Iterator<GWCTask> iter = seeder.getRunningAndPendingTasks();\n\n        boolean tasks = false;\n        if (!iter.hasNext()) {\n            doc.append(\"<ul><li><i>none</i></li></ul>\\n\");\n        } else {\n            doc.append(\"<table border=\\\"0\\\">\");\n            doc.append(\n                    \"<tr style=\\\"font-weight: bold;\\\"><td style=\\\"padding-right:20px;\\\">Id</td><td style=\\\"padding-right:20px;\\\">Layer</td><td style=\\\"padding-right:20px;\\\">Status</td><td style=\\\"padding-right:20px;\\\">Type</td><td>Estimated # of tiles</td>\"\n                            + \"<td style=\\\"padding-right:20px;\\\">Tiles completed</td><td style=\\\"padding-right:20px;\\\">Time elapsed</td><td>Time remaining</td><td>Tasks</td><td>&nbsp;</td>\");\n            doc.append(\"</tr>\");\n            tasks = true;\n        }\n\n        int row = 0;\n\n        final String layerName = tl.getName();\n        while (iter.hasNext()) {\n            GWCTask task = iter.next();\n            if (!listAll && !layerName.equals(task.getLayerName())) {\n                continue;\n            }\n            final long spent = task.getTimeSpent();\n            final long remining = task.getTimeRemaining();\n            final long tilesDone = task.getTilesDone();\n            final long tilesTotal = task.getTilesTotal();\n\n            NumberFormat nf = NumberFormat.getInstance(Locale.ENGLISH);\n            nf.setGroupingUsed(true);\n            final String tilesTotalStr;\n            if (tilesTotal < 0) {\n                tilesTotalStr = \"Too many to count\";\n            } else {\n                tilesTotalStr = nf.format(tilesTotal);\n            }\n            final String tilesDoneStr = nf.format(task.getTilesDone());\n            final GWCTask.STATE state = task.getState();\n\n            final String status =\n                    GWCTask.STATE.UNSET.equals(state) || GWCTask.STATE.READY.equals(state)\n                            ? \"PENDING\"\n                            : state.toString();\n\n            String timeSpent = toTimeString(spent, tilesDone, tilesTotal);\n            String timeRemaining = toTimeString(remining, tilesDone, tilesTotal);\n\n            String bgColor = ++row % 2 == 0 ? \"#FFFFFF\" : \"#DDDDDD\";\n            doc.append(\"<tr style=\\\"background-color:\" + bgColor + \";\\\">\");\n            doc.append(\"<td style=\\\"text-align:right\\\">\").append(task.getTaskId()).append(\"</td>\");\n            doc.append(\"<td>\");\n            if (!layerName.equals(task.getLayerName())) {\n                doc.append(\"<a href=\\\"./\").append(task.getLayerName()).append(\"\\\">\");\n            }\n            doc.append(task.getLayerName());\n            if (!layerName.equals(task.getLayerName())) {\n                doc.append(\"</a>\");\n            }\n            doc.append(\"</td>\");\n            doc.append(\"<td>\").append(status).append(\"</td>\");\n            doc.append(\"<td>\").append(task.getType()).append(\"</td>\");\n            doc.append(\"<td>\").append(tilesTotalStr).append(\"</td>\");\n            doc.append(\"<td>\").append(tilesDoneStr).append(\"</td>\");\n            doc.append(\"<td>\").append(timeSpent).append(\"</td>\");\n            doc.append(\"<td>\").append(timeRemaining).append(\"</td>\");\n            doc.append(\"<td>(Task \")\n                    .append(task.getThreadOffset() + 1)\n                    .append(\" of \")\n                    .append(task.getThreadCount())\n                    .append(\") </td>\");\n            doc.append(\"<td>\").append(makeThreadKillForm(task.getTaskId(), tl)).append(\"</td>\");\n            doc.append(\"<tr>\");\n        }\n\n        if (tasks) {\n            doc.append(\"</table>\");\n        }\n        doc.append(\"<p><a href=\\\"./\" + layerName + \"\\\">Refresh list</a></p>\\n\");\n    }\n\n    private String toTimeString(long timeSeconds, final long tilesDone, final long tilesTotal) {\n        String timeString;\n        if (tilesDone < 50) {\n            timeString = \" Estimating...\";\n        } else {\n            final int MINUTE_SECONDS = 60;\n            final int HOUR_SECONDS = MINUTE_SECONDS * 60;\n            final int DAY_SECONDS = HOUR_SECONDS * 24;\n\n            if (timeSeconds == -2 && tilesDone < tilesTotal) {\n                timeString = \" A decade or three.\";\n            } else {\n                if (timeSeconds > DAY_SECONDS) {\n                    long days = timeSeconds / DAY_SECONDS;\n                    long hours = (timeSeconds % DAY_SECONDS) / HOUR_SECONDS;\n                    timeString = days + \" day\" + (days > 1 ? \"s \" : \" \");\n                    timeString += hours == 0 ? \"\" : (hours + \" h\");\n                } else if (timeSeconds > HOUR_SECONDS) {\n                    long hours = timeSeconds / HOUR_SECONDS;\n                    long minutes = (timeSeconds % HOUR_SECONDS) / MINUTE_SECONDS;\n                    timeString = hours + \" hour\" + (hours > 1 ? \"s \" : \" \");\n                    timeString += minutes == 0 ? \"\" : (minutes + \" m\");\n                } else if (timeSeconds > MINUTE_SECONDS) {\n                    long minutes = timeSeconds / MINUTE_SECONDS;\n                    long seconds = timeSeconds % MINUTE_SECONDS;\n                    timeString = minutes + \" minute\" + (minutes > 1 ? \"s \" : \" \");\n                    timeString += seconds == 0 ? \"\" : seconds + \" s\";\n                } else {\n                    timeString = timeSeconds + \" second\" + (timeSeconds == 1 ? \"\" : \"s\");\n                }\n            }\n        }\n        return timeString;\n    }\n\n    private String makeThreadKillForm(Long key, TileLayer tl) {\n        String ret =\n                \"<form form id=\\\"kill\\\" action=\\\"./\"\n                        + tl.getName()\n                        + \"\\\" method=\\\"post\\\">\"\n                        + \"<input type=\\\"hidden\\\" name=\\\"kill_thread\\\"  value=\\\"1\\\" />\"\n                        + \"<input type=\\\"hidden\\\" name=\\\"thread_id\\\"  value=\\\"\"\n                        + key\n                        + \"\\\" />\"\n                        + \"<span><input style=\\\"padding: 0; margin-bottom: -12px; border: 1;\\\"type=\\\"submit\\\" value=\\\"Kill Task\\\"></span>\"\n                        + \"</form>\";\n\n        return ret;\n    }\n\n    private String makeKillallThreadsForm(TileLayer tl, boolean listAll) {\n        StringBuilder doc = new StringBuilder();\n\n        final String layerName = tl.getName();\n        int otherLayersTaskCount = 0;\n        if (!listAll) {\n            Iterator<GWCTask> tasks = seeder.getRunningAndPendingTasks();\n            while (tasks.hasNext()) {\n                if (!layerName.equals(tasks.next().getLayerName())) {\n                    otherLayersTaskCount++;\n                }\n            }\n        }\n\n        doc.append(\"<table><tr><td>\");\n        doc.append(\"<form form id=\\\"list\\\" action=\\\"./\")\n                .append(layerName)\n                .append(\"\\\" method=\\\"post\\\">\\n\");\n        doc.append(\"List \");\n        doc.append(\"<select name=\\\"list\\\" onchange=\\\"this.form.submit();\\\">\\n\");\n        doc.append(\"<option value=\\\"layer\\\"\")\n                .append(listAll ? \"\" : \" selected\")\n                .append(\">this Layer tasks</option>\\n\");\n        doc.append(\"<option value=\\\"all\\\"\")\n                .append(listAll ? \" selected\" : \"\")\n                .append(\">all Layers tasks</option>\\n\");\n        doc.append(\"</select>\\n\");\n        if (!listAll) {\n            doc.append(\" (there are \");\n            if (otherLayersTaskCount > 0) {\n                doc.append(otherLayersTaskCount);\n            } else {\n                doc.append(\"no\");\n            }\n            doc.append(\" tasks for other Layers)\");\n        }\n        doc.append(\"</form>\\n\");\n\n        doc.append(\"</td></tr><tr><td>\");\n\n        doc.append(\"<form form id=\\\"kill\\\" action=\\\"./\")\n                .append(layerName)\n                .append(\"\\\" method=\\\"post\\\">\\n\");\n        doc.append(\"<span>Kill \\n\");\n        doc.append(\"<select name=\\\"kill_all\\\">\\n\");\n        doc.append(\"<option value=\\\"all\\\">all</option>\\n\");\n        doc.append(\"<option value=\\\"running\\\">running</option>\\n\");\n        doc.append(\"<option value=\\\"pending\\\">pending</option>\\n\");\n        doc.append(\"</select>\\n\");\n        doc.append(\" Tasks for Layer '\").append(layerName).append(\"'.\");\n        doc.append(\"<input type=\\\"submit\\\" value=\\\" Submit\\\">\");\n        doc.append(\"</span>\\n\");\n        doc.append(\"</form>\\n\");\n\n        doc.append(\"</td></tr></table>\");\n        return doc.toString();\n    }\n\n    private void makeFooter(StringBuilder doc) {\n        doc.append(\"</body></html>\\n\");\n    }\n\n    private HttpHeaders getHeaders() {\n        HttpHeaders headers = new HttpHeaders();\n        Map<String, String> utf8 = Collections.singletonMap(\"charset\", \"utf-8\");\n        headers.setContentType(new MediaType(MediaType.TEXT_HTML, utf8));\n        return headers;\n    }\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2024-23818", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"DTD/xhtml1-strict.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n    <head>\n        <title>OpenLayers map preview</title>\n        <!-- Import OL CSS, auto import does not work with our minified OL.js build -->\n        <link rel=\"stylesheet\" type=\"text/css\" href=\"${relBaseUrl}/openlayers/theme/default/style.css\"/>\n        <!-- Basic CSS definitions -->\n        <style type=\"text/css\">\n            /* General settings */\n            body {\n                font-family: Verdana, Geneva, Arial, Helvetica, sans-serif;\n                font-size: small;\n            }\n            /* Toolbar styles */\n            #toolbar {\n                position: relative;\n                padding-bottom: 0.5em;\n                display: none;\n            }\n            \n            #toolbar ul {\n                list-style: none;\n                padding: 0;\n                margin: 0;\n            }\n            \n            #toolbar ul li {\n                float: left;\n                padding-right: 1em;\n                padding-bottom: 0.5em;\n            }\n            \n            #toolbar ul li a {\n                font-weight: bold;\n                font-size: smaller;\n                vertical-align: middle;\n                color: black;\n                text-decoration: none;\n            }\n\n            #toolbar ul li a:hover {\n                text-decoration: underline;\n            }\n            \n            #toolbar ul li * {\n                vertical-align: middle;\n            }\n\n            /* The map and the location bar */\n            #map {\n                clear: both;\n                position: relative;\n                width: ${request.width?c}px;\n                height: ${request.height?c}px;\n                border: 1px solid black;\n            }\n            \n            #wrapper {\n                width: ${request.width?c}px;\n            }\n            \n            #location {\n                float: right;\n            }\n            \n            #options {\n                position: absolute;\n                left: 13px;\n                top: 7px;\n                z-index: 3000;\n            }\n\n            /* Styles used by the default GetFeatureInfo output, added to make IE happy */\n            table.featureInfo, table.featureInfo td, table.featureInfo th {\n                border: 1px solid #ddd;\n                border-collapse: collapse;\n                margin: 0;\n                padding: 0;\n                font-size: 90%;\n                padding: .2em .1em;\n            }\n            \n            table.featureInfo th {\n                padding: .2em .2em;\n                font-weight: bold;\n                background: #eee;\n            }\n            \n            table.featureInfo td {\n                background: #fff;\n            }\n            \n            table.featureInfo tr.odd td {\n                background: #eee;\n            }\n            \n            table.featureInfo caption {\n                text-align: left;\n                font-size: 100%;\n                font-weight: bold;\n                padding: .2em .2em;\n            }\n        </style>\n        <!-- Import OpenLayers, reduced, wms read only version -->\n        <script src=\"${relBaseUrl}/openlayers/OpenLayers.js\" type=\"text/javascript\">\n        </script>\n        <script defer=\"defer\" type=\"text/javascript\">\n            var map;\n            var untiled;\n            var tiled;\n            var pureCoverage = ${pureCoverage?string};\n            var supportsFiltering = ${supportsFiltering?string};\n            // pink tile avoidance\n            OpenLayers.IMAGE_RELOAD_ATTEMPTS = 5;\n            // make OL compute scale according to WMS spec\n            OpenLayers.DOTS_PER_INCH = 25.4 / 0.28;\n        \n            function init(){\n                // if this is just a coverage or a group of them, disable a few items,\n                // and default to jpeg format\n                format = 'image/png';\n                if(pureCoverage) {\n                    document.getElementById('antialiasSelector').disabled = true;\n                    document.getElementById('jpeg').selected = true;\n                    format = \"image/jpeg\";\n                }\n\n\n                if (!supportsFiltering) {\n                    document.getElementById('filterType').disabled = true;\n                    document.getElementById('filter').disabled = true;\n                    document.getElementById('updateFilterButton').disabled = true;\n                    document.getElementById('resetFilterButton').disabled = true;\n                }\n            \n                var bounds = new OpenLayers.Bounds(\n                    ${request.bbox.minX?c}, ${request.bbox.minY?c},\n                    ${request.bbox.maxX?c}, ${request.bbox.maxY?c}\n                );\n                var options = {\n                    controls: [],\n                    maxExtent: bounds,\n                    maxResolution: ${maxResolution?c},\n                    projection: \"${request.SRS?js_string}\",\n                    units: '${units?js_string}'\n                };\n                map = new OpenLayers.Map('map', options);\n            \n                // setup tiled layer\n                tiled = new OpenLayers.Layer.WMS(\n                    \"${layerName} - Tiled\", \"${baseUrl}/${servicePath}\",\n                    {\n                        <#list parameters as param>\n                        \"${param.name?js_string}\": '${param.value?js_string}',\n                        </#list>\n                        format: format,\n                        tilesOrigin: map.maxExtent.left + ',' + map.maxExtent.bottom,\n                        tiled: true\n                    },\n                    {\n                        buffer: 0,\n                        displayOutsideMaxExtent: true,\n                        isBaseLayer: true,\n                        yx : {'${request.SRS?js_string}' : ${yx}}\n                    } \n                );\n                  \n                // setup single tiled layer\n                untiled = new OpenLayers.Layer.WMS(\n                    \"${layerName} - Untiled\", \"${baseUrl}/${servicePath}\",\n                    {\n                        <#list parameters as param>\n                        \"${param.name?js_string}\": '${param.value?js_string}',\n                        </#list>\n                        format: format\n                    },\n                    {\n                       singleTile: true, \n                       ratio: 1, \n                       isBaseLayer: true,\n                       yx : {'${request.SRS?js_string}' : ${yx}}\n                    } \n                );\n        \n                map.addLayers([untiled, tiled]);\n\n                // build up all controls\n                map.addControl(new OpenLayers.Control.PanZoomBar({\n                    position: new OpenLayers.Pixel(2, 15)\n                }));\n                map.addControl(new OpenLayers.Control.Navigation());\n                map.addControl(new OpenLayers.Control.Scale($('scale')));\n                map.addControl(new OpenLayers.Control.MousePosition({element: $('location')}));\n                map.zoomToExtent(bounds);\n                \n                // wire up the option button\n                var options = document.getElementById(\"options\");\n                options.onclick = toggleControlPanel;\n                \n                // support GetFeatureInfo\n                map.events.register('click', map, function (e) {\n                    document.getElementById('nodelist').innerHTML = \"Loading... please wait...\";\n                    var params = {\n                        REQUEST: \"GetFeatureInfo\",\n                        EXCEPTIONS: \"application/vnd.ogc.se_xml\",\n                        BBOX: map.getExtent().toBBOX(),\n                        SERVICE: \"WMS\",\n                        INFO_FORMAT: 'text/html',\n                        QUERY_LAYERS: map.layers[0].params.LAYERS,\n                        FEATURE_COUNT: 50,\n                        <#assign skipped=[\"request\",\"bbox\",\"width\",\"height\",\"format\", \"styles\"]>\n                        <#list parameters as param>            \n                        <#if !(skipped?seq_contains(param.name?lower_case))>\n                        \"${(param.name?js_string)?capitalize}\": '${param.value?js_string}',\n                        </#if>\n                        </#list>\n                        WIDTH: map.size.w,\n                        HEIGHT: map.size.h,\n                        format: format,\n                        styles: map.layers[0].params.STYLES,\n                        srs: map.layers[0].params.SRS};\n                    \n                    // handle the wms 1.3 vs wms 1.1 madness\n                    if(map.layers[0].params.VERSION == \"1.3.0\") {\n                        params.version = \"1.3.0\";\n                        params.j = parseInt(e.xy.x);\n                        params.i = parseInt(e.xy.y);\n                    } else {\n                        params.version = \"1.1.1\";\n                        params.x = parseInt(e.xy.x);\n                        params.y = parseInt(e.xy.y);\n                    }\n                        \n                    // merge filters\n                    if(map.layers[0].params.CQL_FILTER != null) {\n                        params.cql_filter = map.layers[0].params.CQL_FILTER;\n                    } \n                    if(map.layers[0].params.FILTER != null) {\n                        params.filter = map.layers[0].params.FILTER;\n                    }\n                    if(map.layers[0].params.FEATUREID) {\n                        params.featureid = map.layers[0].params.FEATUREID;\n                    }\n                    OpenLayers.loadURL(\"${baseUrl}/${servicePath}\", params, this, setHTML, setHTML);\n                    OpenLayers.Event.stop(e);\n                });\n            }\n            \n            // sets the HTML provided into the nodelist element\n            function setHTML(response){\n                document.getElementById('nodelist').innerHTML = response.responseText;\n            };\n            \n            // shows/hide the control panel\n            function toggleControlPanel(event){\n                var toolbar = document.getElementById(\"toolbar\");\n                if (toolbar.style.display == \"none\") {\n                    toolbar.style.display = \"block\";\n                }\n                else {\n                    toolbar.style.display = \"none\";\n                }\n                event.stopPropagation();\n                map.updateSize()\n            }\n            \n            // Tiling mode, can be 'tiled' or 'untiled'\n            function setTileMode(tilingMode){\n                if (tilingMode == 'tiled') {\n                    untiled.setVisibility(false);\n                    tiled.setVisibility(true);\n                    map.setBaseLayer(tiled);\n                }\n                else {\n                    untiled.setVisibility(true);\n                    tiled.setVisibility(false);\n                    map.setBaseLayer(untiled);\n                }\n            }\n            \n            // Transition effect, can be null or 'resize'\n            function setTransitionMode(transitionEffect){\n                if (transitionEffect === 'resize') {\n                    tiled.transitionEffect = transitionEffect;\n                    untiled.transitionEffect = transitionEffect;\n                }\n                else {\n                    tiled.transitionEffect = null;\n                    untiled.transitionEffect = null;\n                }\n            }\n            \n            // changes the current tile format\n            function setImageFormat(mime){\n                // we may be switching format on setup\n                if(tiled == null)\n                  return;\n                  \n                tiled.mergeNewParams({\n                    format: mime\n                });\n                untiled.mergeNewParams({\n                    format: mime\n                });\n                /*\n                var paletteSelector = document.getElementById('paletteSelector')\n                if (mime == 'image/jpeg') {\n                    paletteSelector.selectedIndex = 0;\n                    setPalette('');\n                    paletteSelector.disabled = true;\n                }\n                else {\n                    paletteSelector.disabled = false;\n                }\n                */\n            }\n            \n            // sets the chosen style\n            function setStyle(style){\n                // we may be switching style on setup\n                if(tiled == null)\n                  return;\n                  \n                tiled.mergeNewParams({\n                    styles: style\n                });\n                untiled.mergeNewParams({\n                    styles: style\n                });\n            }\n            \n            // sets the chosen WMS version\n            function setWMSVersion(wmsVersion){\n                // we may be switching style on setup\n                if(wmsVersion == null)\n                  return;\n                  \n                if(wmsVersion == \"1.3.0\") {\n                   origin = map.maxExtent.bottom + ',' + map.maxExtent.left;\n                } else {\n                   origin = map.maxExtent.left + ',' + map.maxExtent.bottom;\n                }\n                  \n                tiled.mergeNewParams({\n                    version: wmsVersion,\n                    tilesOrigin : origin\n                });\n                untiled.mergeNewParams({\n                    version: wmsVersion\n                });\n            }\n            \n            function setAntialiasMode(mode){\n                tiled.mergeNewParams({\n                    format_options: 'antialias:' + mode\n                });\n                untiled.mergeNewParams({\n                    format_options: 'antialias:' + mode\n                });\n            }\n            \n            function setPalette(mode){\n                if (mode == '') {\n                    tiled.mergeNewParams({\n                        palette: null\n                    });\n                    untiled.mergeNewParams({\n                        palette: null\n                    });\n                }\n                else {\n                    tiled.mergeNewParams({\n                        palette: mode\n                    });\n                    untiled.mergeNewParams({\n                        palette: mode\n                    });\n                }\n            }\n            \n            function setWidth(size){\n                var mapDiv = document.getElementById('map');\n                var wrapper = document.getElementById('wrapper');\n                \n                if (size == \"auto\") {\n                    // reset back to the default value\n                    mapDiv.style.width = null;\n                    wrapper.style.width = null;\n                }\n                else {\n                    mapDiv.style.width = size + \"px\";\n                    wrapper.style.width = size + \"px\";\n                }\n                // notify OL that we changed the size of the map div\n                map.updateSize();\n            }\n            \n            function setHeight(size){\n                var mapDiv = document.getElementById('map');\n                \n                if (size == \"auto\") {\n                    // reset back to the default value\n                    mapDiv.style.height = null;\n                }\n                else {\n                    mapDiv.style.height = size + \"px\";\n                }\n                // notify OL that we changed the size of the map div\n                map.updateSize();\n            }\n            \n            function updateFilter(){\n                if(!supportsFiltering)\n                  return;\n            \n                var filterType = document.getElementById('filterType').value;\n                var filter = document.getElementById('filter').value;\n                \n                // by default, reset all filters\n                var filterParams = {\n                    filter: null,\n                    cql_filter: null,\n                    featureId: null\n                };\n                if (OpenLayers.String.trim(filter) != \"\") {\n                    if (filterType == \"cql\") \n                        filterParams[\"cql_filter\"] = filter;\n                    if (filterType == \"ogc\") \n                        filterParams[\"filter\"] = filter;\n                    if (filterType == \"fid\") \n                        filterParams[\"featureId\"] = filter;\n                }\n                // merge the new filter definitions\n                mergeNewParams(filterParams);\n            }\n            \n            function resetFilter() {\n                if(!supportsFiltering)\n                  return;\n            \n                document.getElementById('filter').value = \"\";\n                updateFilter();\n            }\n            \n            function mergeNewParams(params){\n                tiled.mergeNewParams(params);\n                untiled.mergeNewParams(params);\n            }\n        </script>\n    </head>\n    <body onload=\"init()\">\n        <div id=\"toolbar\" class=\"d-none\">\n            <ul>\n                <li>\n                    <a>WMS version:</a>\n                    <select id=\"wmsVersionSelector\" onchange=\"setWMSVersion(value)\">\n                        <option value=\"1.1.1\">1.1.1</option>\n                        <option value=\"1.3.0\">1.3.0</option>\n                    </select>\n                </li>\n                <li>\n                    <a>Tiling:</a>\n                    <select id=\"tilingModeSelector\" onchange=\"setTileMode(value)\">\n                        <option value=\"untiled\">Single tile</option>\n                        <option value=\"tiled\">Tiled</option>\n                    </select>\n                </li>\n                <li>\n                    <a>Transition effect:</a>\n                    <select id=\"transitionEffectSelector\" onchange=\"setTransitionMode(value)\">\n                        <option value=\"\">None</option>\n                        <option value=\"resize\">Resize</option>\n                    </select>\n                </li>\n                <li>\n                    <a>Antialias:</a>\n                    <select id=\"antialiasSelector\" onchange=\"setAntialiasMode(value)\">\n                        <option value=\"full\">Full</option>\n                        <option value=\"text\">Text only</option>\n                        <option value=\"none\">Disabled</option>\n                    </select>\n                </li>\n                <li>\n                    <a>Format:</a>\n                    <select id=\"imageFormatSelector\" onchange=\"setImageFormat(value)\">\n                        <option value=\"image/png\">PNG 24bit</option>\n                        <option value=\"image/png8\">PNG 8bit</option>\n                        <option value=\"image/gif\">GIF</option>\n                        <option id=\"jpeg\" value=\"image/jpeg\">JPEG</option>\n                        <option id=\"jpeg-png\" value=\"image/vnd.jpeg-png\">JPEG-PNG</option>\n                        <option id=\"jpeg-png8\" value=\"image/vnd.jpeg-png8\">JPEG-PNG8</option>\n                    </select>\n                </li>\n                <li>\n                    <a>Styles:</a>\n                    <select id=\"imageFormatSelector\" onchange=\"setStyle(value)\">\n                        <option value=\"\">Default</option>\n                        <#list styles as style>          \n                          <option value=\"${style}\">${style}</option>  \n                        </#list>     \n                    </select>\n                </li>\n                <!-- Commented out for the moment, some code needs to be extended in \n                     order to list the available palettes\n                <li>\n                    <a>Palette:</a>\n                    <select id=\"paletteSelector\" onchange=\"setPalette(value)\">\n                        <option value=\"\">None</option>\n                        <option value=\"safe\">Web safe</option>\n                    </select>\n                </li>\n                -->\n                <li>\n                    <a>Width/Height:</a>\n                    <select id=\"widthSelector\" onchange=\"setWidth(value)\">\n                        <!--\n                        These values come from a statistics of the viewable area given a certain screen area\n                        (but have been adapted a litte, simplified numbers, added some resolutions for wide screen)\n                        You can find them here: http://www.evolt.org/article/Real_World_Browser_Size_Stats_Part_II/20/2297/\n                        --><option value=\"auto\">Auto</option>\n                        <option value=\"600\">600</option>\n                        <option value=\"750\">750</option>\n                        <option value=\"950\">950</option>\n                        <option value=\"1000\">1000</option>\n                        <option value=\"1200\">1200</option>\n                        <option value=\"1400\">1400</option>\n                        <option value=\"1600\">1600</option>\n                        <option value=\"1900\">1900</option>\n                    </select>\n                    <select id=\"heigthSelector\" onchange=\"setHeight(value)\">\n                        <option value=\"auto\">Auto</option>\n                        <option value=\"300\">300</option>\n                        <option value=\"400\">400</option>\n                        <option value=\"500\">500</option>\n                        <option value=\"600\">600</option>\n                        <option value=\"700\">700</option>\n                        <option value=\"800\">800</option>\n                        <option value=\"900\">900</option>\n                        <option value=\"1000\">1000</option>\n                    </select>\n                </li>\n                <li>\n                    <a>Filter:</a>\n                    <select id=\"filterType\">\n                        <option value=\"cql\">CQL</option>\n                        <option value=\"ogc\">OGC</option>\n                        <option value=\"fid\">FeatureID</option>\n                    </select>\n                    <input type=\"text\" size=\"80\" id=\"filter\"/>\n                    <img id=\"updateFilterButton\" src=\"${baseUrl}/openlayers/img/east-mini.png\" onClick=\"updateFilter()\" title=\"Apply filter\"/>\n                    <img id=\"resetFilterButton\" src=\"${baseUrl}/openlayers/img/cancel.png\" onClick=\"resetFilter()\" title=\"Reset filter\"/>\n                </li>\n            </ul>\n        </div>\n        <div id=\"map\">\n            <img id=\"options\" title=\"Toggle options toolbar\" src=\"${baseUrl}/options.png\"/>\n        </div>\n        <div id=\"wrapper\">\n            <div id=\"location\">location</div>\n            <div id=\"scale\">\n            </div>\n        </div>\n        <div id=\"nodelist\">\n            <em>Click on the map to get feature info</em>\n        </div>\n    </body>\n</html>\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2024-23819", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "/* (c) 2019 Open Source Geospatial Foundation - all rights reserved\n * This code is licensed under the GPL 2.0 license, available at the root\n * application directory.\n */\n\npackage org.geoserver.mapml;\n\nimport static org.geoserver.mapml.MapMLConstants.MAPML_MIME_TYPE;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Optional;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.geoserver.catalog.LayerGroupInfo;\nimport org.geoserver.catalog.LayerInfo;\nimport org.geoserver.catalog.PublishedInfo;\nimport org.geoserver.catalog.ResourceInfo;\nimport org.geoserver.config.GeoServer;\nimport org.geoserver.mapml.tcrs.Bounds;\nimport org.geoserver.mapml.tcrs.Point;\nimport org.geoserver.mapml.tcrs.TiledCRS;\nimport org.geoserver.mapml.xml.Mapml;\nimport org.geoserver.mapml.xml.ProjType;\nimport org.geoserver.ows.URLMangler;\nimport org.geoserver.ows.util.ResponseUtils;\nimport org.geoserver.wms.WMS;\nimport org.geotools.geometry.jts.ReferencedEnvelope;\nimport org.geotools.referencing.crs.DefaultGeographicCRS;\nimport org.opengis.referencing.FactoryException;\nimport org.opengis.referencing.NoSuchAuthorityCodeException;\nimport org.opengis.referencing.operation.TransformException;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.CrossOrigin;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\n/**\n * Spring MVC controller for MapML requests\n *\n * @author Chris Hodgson\n * @author prushforth\n *     <p>This controller has two methods which map requests for layers depending on the MIME media\n *     type requested by the client. The first returns HTML (text/html) representing a layer\n *     preview. This preview uses the Web-Map-Custom-Element viewer polyfill, which is bundled as\n *     static resources in the built project. The second method returns MapML (text/mapml) for a\n *     layer, which is how the layer polyfill embedded in the text/html response \"requests itself\".\n */\n@RestController\n@RequestMapping(path = \"/mapml\")\n@CrossOrigin\npublic class MapMLController {\n\n    @Autowired GeoServer geoServer;\n    @Autowired WMS wms;\n\n    public static final HashMap<String, TiledCRS> previewTcrsMap = new HashMap<>();\n\n    private static final Bounds DISPLAY_BOUNDS_PHONE_PORTRAIT =\n            new Bounds(new Point(0, 0), new Point(300, 812));\n    private static final Bounds DISPLAY_BOUNDS_PHONE_LANDSCAPE =\n            new Bounds(new Point(0, 0), new Point(812, 300));\n    private static final Bounds DISPLAY_BOUNDS_TABLET_PORTRAIT =\n            new Bounds(new Point(0, 0), new Point(760, 1024));\n    private static final Bounds DISPLAY_BOUNDS_TABLET_LANDSCAPE =\n            new Bounds(new Point(0, 0), new Point(1024, 760));\n    private static final Bounds DISPLAY_BOUNDS_DESKTOP_PORTRAIT =\n            new Bounds(new Point(0, 0), new Point(1024, 768));\n    private static final Bounds DISPLAY_BOUNDS_DESKTOP_LANDSCAPE =\n            new Bounds(new Point(0, 0), new Point(768, 1024));\n    private static final HashMap<String, List<Bounds>> DISPLAYS = new HashMap<>();\n\n    static {\n        previewTcrsMap.put(\"OSMTILE\", new TiledCRS(\"OSMTILE\"));\n        previewTcrsMap.put(\"CBMTILE\", new TiledCRS(\"CBMTILE\"));\n        previewTcrsMap.put(\"APSTILE\", new TiledCRS(\"APSTILE\"));\n        previewTcrsMap.put(\"WGS84\", new TiledCRS(\"WGS84\"));\n\n        ArrayList<Bounds> phones = new ArrayList<>();\n        phones.add(DISPLAY_BOUNDS_PHONE_PORTRAIT);\n        phones.add(DISPLAY_BOUNDS_PHONE_LANDSCAPE);\n        DISPLAYS.put(\"PHONE\", phones);\n\n        ArrayList<Bounds> tablets = new ArrayList<>();\n        tablets.add(DISPLAY_BOUNDS_TABLET_PORTRAIT);\n        tablets.add(DISPLAY_BOUNDS_TABLET_LANDSCAPE);\n        DISPLAYS.put(\"TABLET\", tablets);\n\n        ArrayList<Bounds> desktops = new ArrayList<>();\n        desktops.add(DISPLAY_BOUNDS_DESKTOP_PORTRAIT);\n        desktops.add(DISPLAY_BOUNDS_DESKTOP_LANDSCAPE);\n        DISPLAYS.put(\"DESKTOP\", desktops);\n    }\n\n    /**\n     * Return an HTML representation of a layer, by embedding the Web-Map-Custom-Element viewer\n     * reference in the generated HTML.\n     *\n     * @param request\n     * @param response\n     * @param layer layer or layer group name\n     * @param proj TCRS name\n     * @param style A named WMS style\n     * @param transparent boolean corresponding to WMS' transparent parameter\n     * @param format string corresponding to WMS' format parameter\n     * @return a text/html representation\n     */\n    @RequestMapping(\n            value = \"/{layer}/{proj}\",\n            method = {RequestMethod.GET, RequestMethod.POST},\n            produces = {\"text/html\", \"text/html;charset=UTF-8\", \"!\" + MAPML_MIME_TYPE})\n    public String Html(\n            HttpServletRequest request,\n            HttpServletResponse response,\n            @PathVariable(\"layer\") String layer,\n            @PathVariable(\"proj\") String proj,\n            @RequestParam(\"style\") Optional<String> style,\n            @RequestParam(\"transparent\") Optional<Boolean> transparent,\n            @RequestParam(\"format\") Optional<String> format) {\n        LayerInfo layerInfo = geoServer.getCatalog().getLayerByName(layer);\n        ReferencedEnvelope bbox = new ReferencedEnvelope(DefaultGeographicCRS.WGS84);\n        ResourceInfo resourceInfo = null;\n        LayerGroupInfo layerGroupInfo = null;\n        boolean isLayerGroup = (layerInfo == null);\n        String layerLabel = \"Layer\";\n        String styleName =\n                geoServer.getCatalog().getStyleByName(style.orElse(\"\")) != null ? style.get() : \"\";\n        if (isLayerGroup) {\n            layerGroupInfo = geoServer.getCatalog().getLayerGroupByName(layer);\n            if (layerGroupInfo == null) {\n                response.setStatus(HttpServletResponse.SC_NOT_FOUND);\n                return \"Invalid layer or layer group name\";\n            }\n            for (LayerInfo li : layerGroupInfo.layers()) {\n                bbox.expandToInclude(li.getResource().getLatLonBoundingBox());\n            }\n            layerLabel = getLabel(layerGroupInfo, layer, request);\n        } else {\n            resourceInfo = layerInfo.getResource();\n            bbox = resourceInfo.getLatLonBoundingBox();\n            layerLabel = getLabel(layerInfo, layer, request);\n        }\n        ProjType projType;\n        try {\n            projType = ProjType.fromValue(proj.toUpperCase());\n        } catch (IllegalArgumentException iae) {\n            response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n            return \"Invalid TCRS name\";\n        }\n        TiledCRS TCRS = previewTcrsMap.get(projType.value());\n\n        Double longitude = bbox.centre().getX();\n        Double latitude = bbox.centre().getY();\n\n        final ReferencedEnvelope bbbox;\n        int zoom = 0;\n        try {\n            ReferencedEnvelope lb =\n                    isLayerGroup\n                            ? layerGroupInfo.getBounds()\n                            : layerInfo.getResource().boundingBox();\n            bbbox = lb.transform(previewTcrsMap.get(projType.value()).getCRS(), true);\n            final Bounds pb =\n                    new Bounds(\n                            new Point(bbbox.getMinX(), bbbox.getMinY()),\n                            new Point(bbbox.getMaxX(), bbbox.getMaxY()));\n            // allowing for the data to be displayed at 1024x768 pixels, figure out\n            // the zoom level at which the projected bounds fits into 1024x768\n            // in both dimensions\n            zoom = TCRS.fitProjectedBoundsToDisplay(pb, DISPLAY_BOUNDS_DESKTOP_LANDSCAPE);\n\n        } catch (Exception e) {\n            // what to do?\n            // log.info(\"Exception occured retrieving bbox for \"+ layer\n            // );\n        }\n        String base = ResponseUtils.baseURL(request);\n        String viewerPath =\n                ResponseUtils.buildURL(\n                        base,\n                        \"/mapml/viewer/widget/mapml-viewer.js\",\n                        null,\n                        URLMangler.URLType.RESOURCE);\n        String title = layerLabel;\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"<!DOCTYPE html>\\n\")\n                .append(\"<html>\\n\")\n                .append(\"<head>\\n\")\n                .append(\"<title>\")\n                .append(title)\n                .append(\"</title>\\n\")\n                .append(\"<meta charset='utf-8'>\\n\")\n                .append(\"<script type=\\\"module\\\"  src=\\\"\")\n                .append(viewerPath)\n                .append(\"\\\"></script>\\n\")\n                .append(\"<style>\\n\")\n                .append(\"html, body { height: 100%; }\\n\")\n                .append(\"* { margin: 0; padding: 0; }\\n\")\n                .append(\n                        \"mapml-viewer:defined { max-width: 100%; width: 100%; height: 100%; border: none; vertical-align: middle }\\n\")\n                .append(\"mapml-viewer:not(:defined) > * { display: none; } n\")\n                .append(\"layer- { display: none; }\\n\")\n                .append(\"</style>\\n\")\n                .append(\"<noscript>\\n\")\n                .append(\"<style>\\n\")\n                .append(\"mapml-viewer:not(:defined) > :not(layer-) { display: initial; }\\n\")\n                .append(\"</style>\\n\")\n                .append(\"</noscript>\\n\")\n                .append(\"</head>\\n\")\n                .append(\"<body>\\n\")\n                .append(\"<mapml-viewer projection=\\\"\")\n                .append(projType.value())\n                .append(\"\\\" \")\n                .append(\"zoom=\\\"\")\n                .append(zoom)\n                .append(\"\\\" lat=\\\"\")\n                .append(latitude)\n                .append(\"\\\" \")\n                .append(\"lon=\\\"\")\n                .append(longitude)\n                .append(\"\\\" controls controlslist=\\\"geolocation\\\">\\n\")\n                .append(\"<layer- label=\\\"\")\n                .append(layerLabel)\n                .append(\"\\\" \")\n                .append(\"src=\\\"\")\n                .append(request.getContextPath())\n                .append(request.getServletPath())\n                .append(\"/\")\n                .append(layer)\n                .append(\"/\")\n                .append(proj)\n                .append(\"/\")\n                .append(!styleName.isEmpty() ? \"?style=\" + styleName : \"\")\n                .append(\"\\\" checked></layer->\\n\")\n                .append(\"</mapml-viewer>\\n\")\n                .append(\"</body>\\n\")\n                .append(\"</html>\");\n        return sb.toString();\n    }\n\n    /**\n     * Return a MapML representation of a layer\n     *\n     * @param request\n     * @param response\n     * @param layer\n     * @param proj\n     * @param style\n     * @param transparent boolean corresponding to WMS' transparent parameter\n     * @param format string corresponding to WMS' format parameter\n     * @return a text/mapml representation\n     * @throws NoSuchAuthorityCodeException - NoSuchAuthorityCodeException\n     * @throws TransformException - TransformException\n     * @throws FactoryException - FactoryException\n     * @throws IOException - IOException\n     */\n    @RequestMapping(\n            value = \"/{layer}/{proj}\",\n            method = {RequestMethod.GET, RequestMethod.POST},\n            produces = {MAPML_MIME_TYPE, \"!text/html;charset=UTF-8\"})\n    public Mapml mapML(\n            HttpServletRequest request,\n            HttpServletResponse response,\n            @PathVariable(\"layer\") String layer,\n            @PathVariable(\"proj\") String proj,\n            @RequestParam(\"style\") Optional<String> style,\n            @RequestParam(\"transparent\") Optional<Boolean> transparent,\n            @RequestParam(\"format\") Optional<String> format)\n            throws NoSuchAuthorityCodeException, TransformException, FactoryException, IOException {\n        MapMLDocumentBuilder mb =\n                new MapMLDocumentBuilder(\n                        this, request, response, layer, proj, style, transparent, format);\n        return mb.getMapMLDocument();\n    }\n    /**\n     * Get the potentially localized label string for a layer or layer group\n     *\n     * @param p LayerInfo or LayerGroupInfo object\n     * @param def default label string, usually pass in the layer name\n     * @param request the localized servlet request\n     * @return the potentially localized label string for a layer or layer group\n     */\n    String getLabel(PublishedInfo p, String def, HttpServletRequest request) {\n        if (p instanceof LayerGroupInfo) {\n            LayerGroupInfo li = (LayerGroupInfo) p;\n            if (li.getInternationalTitle() != null\n                    && li.getInternationalTitle().toString(request.getLocale()) != null) {\n                // use international title per request or default locale\n                return li.getInternationalTitle().toString(request.getLocale());\n            } else if (li.getTitle() != null && !li.getTitle().trim().isEmpty()) {\n                return li.getTitle().trim();\n            } else {\n                return li.getName().trim().isEmpty() ? def : li.getName().trim();\n            }\n        } else {\n            LayerInfo li = (LayerInfo) p;\n            if (li.getInternationalTitle() != null\n                    && li.getInternationalTitle().toString(request.getLocale()) != null) {\n                // use international title per request or default locale\n                return li.getInternationalTitle().toString(request.getLocale());\n            } else if (li.getTitle() != null && !li.getTitle().trim().isEmpty()) {\n                return li.getTitle().trim();\n            } else {\n                return li.getName().trim().isEmpty() ? def : li.getName().trim();\n            }\n        }\n    }\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2024-24574", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "<?php\n\n/**\n * Frontend for handling with attachments.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public License,\n * v. 2.0. If a copy of the MPL was not distributed with this file, You can\n * obtain one at https://mozilla.org/MPL/2.0/.\n *\n * @package   phpMyFAQ\n * @author    Anatoliy Belsky <ab@php.net>\n * @copyright 2010-2023 phpMyFAQ Team\n * @license   https://www.mozilla.org/MPL/2.0/ Mozilla Public License Version 2.0\n * @link      https://www.phpmyfaq.de\n * @since     2010-12-13\n */\n\nuse phpMyFAQ\\Attachment\\AttachmentCollection;\nuse phpMyFAQ\\Filter;\nuse phpMyFAQ\\Pagination;\nuse phpMyFAQ\\Session\\Token;\nuse phpMyFAQ\\Translation;\nuse phpMyFAQ\\Utils;\nuse Symfony\\Component\\HttpFoundation\\Request;\n\nif (!defined('IS_VALID_PHPMYFAQ')) {\n    http_response_code(400);\n    exit();\n}\n\n$request = Request::createFromGlobals();\n\n$page = Filter::filterVar($request->query->get('page'), FILTER_VALIDATE_INT);\n$page = max(1, $page);\n\n$attachmentCollection = new AttachmentCollection($faqConfig);\n$itemsPerPage = 24;\n$allCrumbs = $attachmentCollection->getBreadcrumbs();\n\n$crumbs = array_slice($allCrumbs, ($page - 1) * $itemsPerPage, $itemsPerPage);\n\n$pagination = new Pagination(\n    [\n        'baseUrl' => $faqConfig->getDefaultUrl() . $request->getRequestUri(),\n        'total' => is_countable($allCrumbs) ? count($allCrumbs) : 0,\n        'perPage' => $itemsPerPage,\n    ]\n);\n?>\n<div class=\"d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom\">\n  <h1 class=\"h2\">\n    <i aria-hidden=\"true\" class=\"fa fa-paperclip\"></i>\n      <?= Translation::get('ad_menu_attachment_admin') ?>\n  </h1>\n</div>\n\n<div class=\"row\">\n  <div class=\"col-lg-12\">\n    <table class=\"table table-striped align-middle\">\n      <thead>\n      <tr>\n        <th>#</th>\n        <th><?= Translation::get('msgAttachmentsFilename') ?></th>\n        <th><?= Translation::get('msgTransToolLanguage') ?></th>\n        <th><?= Translation::get('msgAttachmentsFilesize') ?></th>\n        <th colspan=\"3\"><?= Translation::get('msgAttachmentsMimeType') ?></th>\n      </tr>\n      </thead>\n      <tbody id=\"attachment-table\">\n      <?php foreach ($crumbs as $item) : ?>\n        <tr id=\"attachment_<?= $item->id ?>\" title=\"<?= $item->thema ?>\">\n          <td><?= $item->id ?></td>\n          <td><?= $item->filename ?></td>\n          <td><?= $item->record_lang ?></td>\n          <td><?= Utils::formatBytes($item->filesize) ?></td>\n          <td><?= $item->mime_type ?></td>\n          <td>\n            <button class=\"btn btn-danger btn-delete-attachment\" title=\"<?= Translation::get('ad_gen_delete') ?>\"\n                    data-attachment-id=\"<?= $item->id ?>\"\n                    data-csrf=\"<?= Token::getInstance()->getTokenString('delete-attachment') ?>\">\n              <i aria-hidden=\"true\" class=\"fa fa-trash btn-delete-attachment\" data-attachment-id=\"<?= $item->id ?>\"\n                    data-csrf=\"<?= Token::getInstance()->getTokenString('delete-attachment') ?>\"></i>\n            </button>\n          </td>\n          <td>\n            <a title=\"<?= Translation::get('ad_entry_faq_record') ?>\" class=\"btn btn-info\"\n               href=\"../index.php?action=faq&id=<?= $item->record_id ?>&lang=<?= $item->record_lang ?>\">\n              <i aria-hidden=\"true\" class=\"fa fa-link\"></i>\n            </a>\n          </td>\n        </tr>\n      <?php endforeach; ?>\n      </tbody>\n      <tfoot>\n      <tr>\n        <td colspan=\"5\"><?= $pagination->render(); ?></td>\n      </tr>\n      </tfoot>\n    </table>\n  </div>\n</div>\n\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2024-24816", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "/**\n * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * CKEditor 4 LTS (\"Long Term Support\") is available under the terms of the Extended Support Model.\n */\n\n/**\n * Provides an \"event like\" system to parse strings of HTML data.\n *\n *\t\tvar parser = new CKEDITOR.htmlParser();\n *\t\tparser.onTagOpen = function( tagName, attributes, selfClosing ) {\n *\t\t\talert( tagName );\n *\t\t};\n *\t\tparser.parse( '<p>Some <b>text</b>.</p>' ); // Alerts 'p', 'b'.\n *\n * @class\n * @constructor Creates a htmlParser class instance.\n */\nCKEDITOR.htmlParser = function() {\n\tthis._ = {\n\t\thtmlPartsRegex: /<(?:(?:\\/([^>]+)>)|(?:!--([\\S|\\s]*?)--!?>)|(?:([^\\/\\s>]+)((?:\\s+[\\w\\-:.]+(?:\\s*=\\s*?(?:(?:\"[^\"]*\")|(?:'[^']*')|[^\\s\"'\\/>]+))?)*)[\\S\\s]*?(\\/?)>))/g\n\t};\n};\n\n( function() {\n\tvar attribsRegex = /([\\w\\-:.]+)(?:(?:\\s*=\\s*(?:(?:\"([^\"]*)\")|(?:'([^']*)')|([^\\s>]+)))|(?=\\s|$))/g,\n\t\temptyAttribs = { checked: 1, compact: 1, declare: 1, defer: 1, disabled: 1, ismap: 1, multiple: 1, nohref: 1, noresize: 1, noshade: 1, nowrap: 1, readonly: 1, selected: 1 };\n\n\tCKEDITOR.htmlParser.prototype = {\n\t\t/**\n\t\t * Function to be fired when a tag opener is found. This function\n\t\t * should be overriden when using this class.\n\t\t *\n\t\t *\t\tvar parser = new CKEDITOR.htmlParser();\n\t\t *\t\tparser.onTagOpen = function( tagName, attributes, selfClosing ) {\n\t\t *\t\t\talert( tagName ); // e.g. 'b'\n\t\t *\t\t} );\n\t\t *\t\tparser.parse( '<!-- Example --><b>Hello</b>' );\n\t\t *\n\t\t * @param {String} tagName The tag name. The name is guarantted to be lowercased.\n\t\t * @param {Object} attributes An object containing all tag attributes. Each\n\t\t * property in this object represent and attribute name and its value is the attribute value.\n\t\t * @param {Boolean} selfClosing `true` if the tag closes itself, false if the tag doesn't.\n\t\t */\n\t\tonTagOpen: function() {},\n\n\t\t/**\n\t\t * Function to be fired when a tag closer is found. This function\n\t\t * should be overriden when using this class.\n\t\t *\n\t\t *\t\tvar parser = new CKEDITOR.htmlParser();\n\t\t *\t\tparser.onTagClose = function( tagName ) {\n\t\t *\t\t\talert( tagName ); // 'b'\n\t\t *\t\t} );\n\t\t *\t\tparser.parse( '<!-- Example --><b>Hello</b>' );\n\t\t *\n\t\t * @param {String} tagName The tag name. The name is guarantted to be lowercased.\n\t\t */\n\t\tonTagClose: function() {},\n\n\t\t/**\n\t\t * Function to be fired when text is found. This function\n\t\t * should be overriden when using this class.\n\t\t *\n\t\t *\t\tvar parser = new CKEDITOR.htmlParser();\n\t\t *\t\tparser.onText = function( text ) {\n\t\t *\t\t\talert( text ); // 'Hello'\n\t\t *\t\t} );\n\t\t *\t\tparser.parse( '<!-- Example --><b>Hello</b>' );\n\t\t *\n\t\t * @param {String} text The text found.\n\t\t */\n\t\tonText: function() {},\n\n\t\t/**\n\t\t * Function to be fired when CDATA section is found. This function\n\t\t * should be overriden when using this class.\n\t\t *\n\t\t *\t\tvar parser = new CKEDITOR.htmlParser();\n\t\t *\t\tparser.onCDATA = function( cdata ) {\n\t\t *\t\t\talert( cdata ); // 'var hello;'\n\t\t *\t\t} );\n\t\t *\t\tparser.parse( '<script>var hello;</script>' );\n\t\t *\n\t\t * @param {String} cdata The CDATA been found.\n\t\t */\n\t\tonCDATA: function() {},\n\n\t\t/**\n\t\t * Function to be fired when a commend is found. This function\n\t\t * should be overriden when using this class.\n\t\t *\n\t\t *\t\tvar parser = new CKEDITOR.htmlParser();\n\t\t *\t\tparser.onComment = function( comment ) {\n\t\t *\t\t\talert( comment ); // ' Example '\n\t\t *\t\t} );\n\t\t *\t\tparser.parse( '<!-- Example --><b>Hello</b>' );\n\t\t *\n\t\t * @param {String} comment The comment text.\n\t\t */\n\t\tonComment: function() {},\n\n\t\t/**\n\t\t * Parses text, looking for HTML tokens, like tag openers or closers,\n\t\t * or comments. This function fires the onTagOpen, onTagClose, onText\n\t\t * and onComment function during its execution.\n\t\t *\n\t\t *\t\tvar parser = new CKEDITOR.htmlParser();\n\t\t *\t\t// The onTagOpen, onTagClose, onText and onComment should be overriden\n\t\t *\t\t// at this point.\n\t\t *\t\tparser.parse( '<!-- Example --><b>Hello</b>' );\n\t\t *\n\t\t * @param {String} html The HTML to be parsed.\n\t\t */\n\t\tparse: function( html ) {\n\t\t\tvar parts, tagName,\n\t\t\t\tnextIndex = 0,\n\t\t\t\tcdata; // The collected data inside a CDATA section.\n\n\t\t\twhile ( ( parts = this._.htmlPartsRegex.exec( html ) ) ) {\n\t\t\t\tvar tagIndex = parts.index;\n\t\t\t\tif ( tagIndex > nextIndex ) {\n\t\t\t\t\tvar text = html.substring( nextIndex, tagIndex );\n\n\t\t\t\t\tif ( cdata )\n\t\t\t\t\t\tcdata.push( text );\n\t\t\t\t\telse\n\t\t\t\t\t\tthis.onText( text );\n\t\t\t\t}\n\n\t\t\t\tnextIndex = this._.htmlPartsRegex.lastIndex;\n\n\t\t\t\t// \"parts\" is an array with the following items:\n\t\t\t\t//\t\t0 : The entire match for opening/closing tags and comments.\n\t\t\t\t//\t\t  : Group filled with the tag name for closing tags.\n\t\t\t\t//\t\t2 : Group filled with the comment text.\n\t\t\t\t//\t\t3 : Group filled with the tag name for opening tags.\n\t\t\t\t//\t\t4 : Group filled with the attributes part of opening tags.\n\n\t\t\t\t// Closing tag\n\t\t\t\tif ( ( tagName = parts[ 1 ] ) ) {\n\t\t\t\t\ttagName = tagName.toLowerCase();\n\n\t\t\t\t\tif ( cdata && CKEDITOR.dtd.$cdata[ tagName ] ) {\n\t\t\t\t\t\t// Send the CDATA data.\n\t\t\t\t\t\tthis.onCDATA( cdata.join( '' ) );\n\t\t\t\t\t\tcdata = null;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( !cdata ) {\n\t\t\t\t\t\tthis.onTagClose( tagName );\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If CDATA is enabled, just save the raw match.\n\t\t\t\tif ( cdata ) {\n\t\t\t\t\tcdata.push( parts[ 0 ] );\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Opening tag\n\t\t\t\tif ( ( tagName = parts[ 3 ] ) ) {\n\t\t\t\t\ttagName = tagName.toLowerCase();\n\n\t\t\t\t\t// There are some tag names that can break things, so let's\n\t\t\t\t\t// simply ignore them when parsing. (https://dev.ckeditor.com/ticket/5224)\n\t\t\t\t\tif ( /=\"/.test( tagName ) )\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tvar attribs = {},\n\t\t\t\t\t\tattribMatch,\n\t\t\t\t\t\tattribsPart = parts[ 4 ],\n\t\t\t\t\t\tselfClosing = !!parts[ 5 ];\n\n\t\t\t\t\tif ( attribsPart ) {\n\t\t\t\t\t\twhile ( ( attribMatch = attribsRegex.exec( attribsPart ) ) ) {\n\t\t\t\t\t\t\tvar attName = attribMatch[ 1 ].toLowerCase(),\n\t\t\t\t\t\t\t\tattValue = attribMatch[ 2 ] || attribMatch[ 3 ] || attribMatch[ 4 ] || '';\n\n\t\t\t\t\t\t\tif ( !attValue && emptyAttribs[ attName ] )\n\t\t\t\t\t\t\t\tattribs[ attName ] = attName;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tattribs[ attName ] = CKEDITOR.tools.htmlDecodeAttr( attValue );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.onTagOpen( tagName, attribs, selfClosing );\n\n\t\t\t\t\t// Open CDATA mode when finding the appropriate tags.\n\t\t\t\t\tif ( !cdata && CKEDITOR.dtd.$cdata[ tagName ] )\n\t\t\t\t\t\tcdata = [];\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Comment\n\t\t\t\tif ( ( tagName = parts[ 2 ] ) )\n\t\t\t\t\tthis.onComment( tagName );\n\t\t\t}\n\n\t\t\tif ( html.length > nextIndex )\n\t\t\t\tthis.onText( html.substring( nextIndex, html.length ) );\n\t\t}\n\t};\n} )();\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2024-26129", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "<?php\n\n/**\n * Copyright since 2007 PrestaShop SA and Contributors\n * PrestaShop is an International Registered Trademark & Property of PrestaShop SA\n *\n * NOTICE OF LICENSE\n *\n * This source file is subject to the Open Software License (OSL 3.0)\n * that is bundled with this package in the file LICENSE.md.\n * It is also available through the world-wide-web at this URL:\n * https://opensource.org/licenses/OSL-3.0\n * If you did not receive a copy of the license and are unable to\n * obtain it through the world-wide-web, please send an email\n * to license@prestashop.com so we can send you a copy immediately.\n *\n * DISCLAIMER\n *\n * Do not edit or add to this file if you wish to upgrade PrestaShop to newer\n * versions in the future. If you wish to customize PrestaShop for your\n * needs please refer to https://devdocs.prestashop.com/ for more information.\n *\n * @author    PrestaShop SA and Contributors <contact@prestashop.com>\n * @copyright Since 2007 PrestaShop SA and Contributors\n * @license   https://opensource.org/licenses/OSL-3.0 Open Software License (OSL 3.0)\n */\n\nuse PrestaShop\\PrestaShop\\Adapter\\Configuration as ConfigurationAdapter;\nuse PrestaShop\\PrestaShop\\Adapter\\ContainerBuilder;\nuse PrestaShop\\PrestaShop\\Adapter\\Image\\ImageRetriever;\nuse PrestaShop\\PrestaShop\\Adapter\\Presenter\\Cart\\CartPresenter;\nuse PrestaShop\\PrestaShop\\Adapter\\Presenter\\Object\\ObjectPresenter;\nuse PrestaShop\\PrestaShop\\Core\\Security\\PasswordPolicyConfiguration;\nuse Symfony\\Component\\Filesystem\\Filesystem;\nuse Symfony\\Component\\HttpFoundation\\IpUtils;\n\nclass FrontControllerCore extends Controller\n{\n    /** @var array Controller warning notifications */\n    public $warning = [];\n\n    /** @var array Controller success notifications */\n    public $success = [];\n\n    /** @var array Controller info notifications */\n    public $info = [];\n\n    /** @var string Language ISO code */\n    public $iso;\n\n    /**\n     * @deprecated Since 8.0 and will be removed in the next major.\n     *\n     * @var string ORDER BY field\n     */\n    public $orderBy;\n\n    /**\n     * @deprecated Since 8.0 and will be removed in the next major.\n     *\n     * @var string Order way string ('ASC', 'DESC')\n     */\n    public $orderWay;\n\n    /**\n     * @deprecated Since 8.0 and will be removed in the next major.\n     *\n     * @var int Current page number\n     */\n    public $p;\n\n    /**\n     * @deprecated Since 8.0 and will be removed in the next major.\n     *\n     * @var int Items (products) per page\n     */\n    public $n;\n\n    /** @var bool If set to true, will redirected user to login page during init function. */\n    public $auth = false;\n\n    /**\n     * If set to true, user can be logged in as guest when checking if logged in.\n     *\n     * @deprecated Since 8.0 and will be removed in the next major.\n     * @see $auth\n     *\n     * @var bool\n     */\n    public $guestAllowed = false;\n\n    /**\n     * Route of PrestaShop page to redirect to after forced login.\n     *\n     * @see $auth\n     *\n     * @var bool|string\n     */\n    public $authRedirection = false;\n\n    /** @var bool SSL connection flag */\n    public $ssl = false;\n\n    /** @var int If Country::GEOLOC_CATALOG_MODE, switches display to restricted country page during init. */\n    protected $restrictedCountry = Country::GEOLOC_ALLOWED;\n\n    /** @var bool If true, forces display to maintenance page. */\n    protected $maintenance = false;\n\n    /** @var string[] Adds excluded `$_GET` keys for redirection */\n    protected $redirectionExtraExcludedKeys = [];\n\n    /**\n     * True if controller has already been initialized.\n     * Prevents initializing controller more than once.\n     *\n     * @var bool\n     */\n    public static $initialized = false;\n\n    /**\n     * @var array Holds current customer's groups\n     */\n    protected static $currentCustomerGroups;\n\n    /**\n     * @deprecated Since 8.0 and will be removed in the next major.\n     *\n     * @var int\n     */\n    public $nb_items_per_page;\n\n    /**\n     * @var ObjectPresenter\n     */\n    public $objectPresenter;\n\n    /**\n     * @var object CartPresenter\n     */\n    public $cart_presenter;\n\n    /**\n     * @var object TemplateFinder\n     */\n    private $templateFinder;\n\n    /**\n     * @var object StylesheetManager\n     */\n    protected $stylesheetManager;\n\n    /**\n     * @var object JavascriptManager\n     */\n    protected $javascriptManager;\n\n    /**\n     * @var object CccReducer\n     */\n    protected $cccReducer;\n\n    /**\n     * @var array Contains the result of getTemplateVarUrls method\n     */\n    protected $urls;\n\n    /**\n     * Set this parameter to false if you don't want cart's invoice address\n     * to be set automatically (this behavior is kept for legacy and BC purpose)\n     *\n     * @var bool automaticallyAllocateInvoiceAddress\n     */\n    protected $automaticallyAllocateInvoiceAddress = true;\n\n    /**\n     * Set this parameter to false if you don't want cart's delivery address\n     * to be set automatically (this behavior is kept for legacy and BC purpose)\n     *\n     * @var bool automaticallyAllocateDeliveryAddress\n     */\n    protected $automaticallyAllocateDeliveryAddress = true;\n\n    /** @var string Page name */\n    public $page_name;\n\n    /**\n     * Controller constructor.\n     *\n     * @global bool $useSSL SSL connection flag\n     */\n    public function __construct()\n    {\n        $this->controller_type = 'front';\n\n        global $useSSL;\n\n        parent::__construct();\n\n        if (Configuration::get('PS_SSL_ENABLED') && Configuration::get('PS_SSL_ENABLED_EVERYWHERE')) {\n            $this->ssl = true;\n        }\n\n        if (isset($useSSL)) {\n            $this->ssl = $useSSL;\n        } else {\n            $useSSL = $this->ssl;\n        }\n\n        // Prepare presenters that we will require on every page\n        $this->objectPresenter = new ObjectPresenter();\n        $this->cart_presenter = new CartPresenter();\n\n        $this->templateFinder = new TemplateFinder($this->context->smarty->getTemplateDir(), '.tpl');\n        $this->stylesheetManager = new StylesheetManager(\n            [_PS_THEME_URI_, _PS_PARENT_THEME_URI_, __PS_BASE_URI__],\n            new ConfigurationAdapter()\n        );\n        $this->javascriptManager = new JavascriptManager(\n            [_PS_THEME_URI_, _PS_PARENT_THEME_URI_, __PS_BASE_URI__],\n            new ConfigurationAdapter()\n        );\n        $this->cccReducer = new CccReducer(\n            _PS_THEME_DIR_ . 'assets/cache/',\n            new ConfigurationAdapter(),\n            new Filesystem()\n        );\n    }\n\n    /**\n     * Check if the controller is available for the current user/visitor.\n     *\n     * @see Controller::checkAccess()\n     *\n     * @return bool\n     */\n    public function checkAccess()\n    {\n        return true;\n    }\n\n    /**\n     * Check if the current user/visitor has valid view permissions.\n     *\n     * @see Controller::viewAccess\n     *\n     * @return bool\n     */\n    public function viewAccess()\n    {\n        return true;\n    }\n\n    /**\n     * Initializes front controller: sets smarty variables,\n     * class properties, redirects depending on context, etc.\n     *\n     * @global bool     $useSSL           SSL connection flag\n     *\n     * @throws PrestaShopException\n     */\n    public function init()\n    {\n        Hook::exec(\n            'actionFrontControllerInitBefore',\n            [\n                'controller' => $this,\n            ]\n        );\n\n        /*\n         * Globals are DEPRECATED as of version 1.5.0.1\n         * Use the Context object to access objects instead.\n         * Example: $this->context->cart\n         */\n        global $useSSL;\n\n        if (self::$initialized) {\n            return;\n        }\n\n        self::$initialized = true;\n\n        parent::init();\n\n        // If current URL use SSL, set it true (used a lot for module redirect)\n        if (Tools::usingSecureMode()) {\n            $useSSL = true;\n        }\n\n        // Redirect to SSL variant of the page if required and visited in non-ssl mode\n        $this->sslRedirection();\n\n        if ($this->ajax) {\n            $this->display_header = false;\n            $this->display_footer = false;\n        }\n\n        // If account created with the 2 steps register process, remove 'account_created' from cookie\n        if (isset($this->context->cookie->account_created)) {\n            unset($this->context->cookie->account_created);\n        }\n\n        ob_start();\n\n        // Initialize URL provider in context, depending on SSL mode\n        $protocol_link = (Configuration::get('PS_SSL_ENABLED') || Tools::usingSecureMode()) ? 'https://' : 'http://';\n        $useSSL = ($this->ssl && Configuration::get('PS_SSL_ENABLED')) || Tools::usingSecureMode();\n        $protocol_content = ($useSSL) ? 'https://' : 'http://';\n        $link = new Link($protocol_link, $protocol_content);\n        $this->context->link = $link;\n\n        // Attempt to recover cart, if the user is using recovery link\n        // This is used by abandoned cart modules or when sending a prepared order to customer from backoffice\n        $this->recoverCart();\n\n        // Redirect user to login page, if the controller requires authentication\n        if ($this->auth && !$this->context->customer->isLogged()) {\n            Tools::redirect('index.php?controller=authentication' . ($this->authRedirection ? '&back=' . $this->authRedirection : ''));\n        }\n\n        // If the theme is missing, we need to throw an Exception\n        if (!is_dir(_PS_THEME_DIR_)) {\n            throw new PrestaShopException($this->trans('Current theme is unavailable. Please check your theme\\'s directory name (\"%s\") and permissions.', [basename(rtrim(_PS_THEME_DIR_, '/\\\\'))], 'Admin.Design.Notification'));\n        }\n\n        if (Configuration::get('PS_GEOLOCATION_ENABLED')) {\n            if (($new_default = $this->geolocationManagement($this->context->country)) && Validate::isLoadedObject($new_default)) {\n                $this->context->country = $new_default;\n            }\n        } elseif (Configuration::get('PS_DETECT_COUNTRY')) {\n            $has_currency = isset($this->context->cookie->id_currency) && (int) $this->context->cookie->id_currency;\n            $has_country = isset($this->context->cookie->iso_code_country) && $this->context->cookie->iso_code_country;\n            $has_address_type = false;\n\n            if ((int) $this->context->cookie->id_cart) {\n                $cart = new Cart((int) $this->context->cookie->id_cart);\n                if (Validate::isLoadedObject($cart)) {\n                    $has_address_type = isset($cart->{Configuration::get('PS_TAX_ADDRESS_TYPE')}) && $cart->{Configuration::get('PS_TAX_ADDRESS_TYPE')};\n                }\n            }\n\n            if ((!$has_currency || $has_country) && !$has_address_type) {\n                if ($has_country && Validate::isLanguageIsoCode($this->context->cookie->iso_code_country)) {\n                    $id_country = (int) Country::getByIso(strtoupper($this->context->cookie->iso_code_country));\n                } elseif (Tools::isCountryFromBrowserAvailable()) {\n                    $id_country = (int) Country::getByIso(Tools::getCountryIsoCodeFromHeader(), true);\n                } else {\n                    $id_country = Tools::getCountry();\n                }\n\n                $country = new Country($id_country, (int) $this->context->cookie->id_lang);\n\n                if (!$has_currency && Validate::isLoadedObject($country) && $this->context->country->id !== $country->id) {\n                    $this->context->country = $country;\n                    $this->context->cookie->id_currency = (int) Currency::getCurrencyInstance($country->id_currency ? (int) $country->id_currency : Currency::getDefaultCurrencyId())->id;\n                    $this->context->cookie->iso_code_country = strtoupper($country->iso_code);\n                }\n            }\n        }\n\n        /*\n         * Get proper currency from the cookie and $_GET parameters. It will provide us with a requested currency\n         * or a default currency, if the requested one is not valid anymore.\n         */\n        $currency = Tools::setCurrency($this->context->cookie);\n\n        // Assign that currency to the context, so we can immediately use it for calculations.\n        $this->context->currency = $currency;\n\n        if (isset($_GET['logout']) || ($this->context->customer->logged && Customer::isBanned($this->context->customer->id))) {\n            $this->context->customer->logout();\n\n            Tools::redirect(isset($_SERVER['HTTP_REFERER']) ? $_SERVER['HTTP_REFERER'] : null);\n        } elseif (isset($_GET['mylogout'])) {\n            $this->context->customer->mylogout();\n            Tools::redirect(isset($_SERVER['HTTP_REFERER']) ? $_SERVER['HTTP_REFERER'] : null);\n        }\n\n        /*\n         * If we have an information about some cart in the cookie, we will try to use it, but we need to properly validate it.\n         * It can be deleted, order already placed for it and other edge scenarios.\n         */\n        if ((int) $this->context->cookie->id_cart) {\n            if (!isset($cart)) {\n                $cart = new Cart((int) $this->context->cookie->id_cart);\n            }\n\n            /*\n             * Check if cart object is valid and not deleted.\n             * Check if there is not an order already placed on a different device or different tab.\n             */\n            if (!Validate::isLoadedObject($cart) || $cart->orderExists()) {\n                PrestaShopLogger::addLog('Frontcontroller::init - Cart cannot be loaded or an order has already been placed using this cart', 1, null, 'Cart', (int) $this->context->cookie->id_cart, true);\n                unset($this->context->cookie->id_cart, $cart, $this->context->cookie->checkedTOS);\n                $this->context->cookie->check_cgv = false;\n\n            /*\n             * If geolocation is enabled and we are not allowed to order from our country, we will delete the cart.\n             */\n            } elseif (\n                (int) (Configuration::get('PS_GEOLOCATION_ENABLED'))\n                && !in_array(strtoupper($this->context->cookie->iso_code_country), explode(';', Configuration::get('PS_ALLOWED_COUNTRIES')))\n                && $cart->nbProducts()\n                && (int) (Configuration::get('PS_GEOLOCATION_NA_BEHAVIOR')) != -1\n                && !FrontController::isInWhitelistForGeolocation()\n                && !in_array($_SERVER['SERVER_NAME'], ['localhost', '127.0.0.1', '::1'])\n            ) {\n                /* Delete product of cart, if user can't make an order from his country */\n                PrestaShopLogger::addLog('Frontcontroller::init - GEOLOCATION is deleting a cart', 1, null, 'Cart', (int) $this->context->cookie->id_cart, true);\n                unset($this->context->cookie->id_cart, $cart);\n\n            /*\n             * Check if cart data is still matching to what is set in our cookie - currency, language and customer.\n             * If not, update it on the cart.\n             */\n            } elseif (\n                $this->context->cookie->id_customer != $cart->id_customer\n                || $this->context->cookie->id_lang != $cart->id_lang\n                || $currency->id != $cart->id_currency\n            ) {\n                // update cart values\n                if ($this->context->cookie->id_customer) {\n                    $cart->id_customer = (int) $this->context->cookie->id_customer;\n                }\n                $cart->id_lang = (int) $this->context->cookie->id_lang;\n                $cart->id_currency = (int) $currency->id;\n                $cart->update();\n            }\n\n            /*\n             * If we don't have any addresses set on the cart and we have a valid customer ID, we will try to automatically\n             * assign addresses to that cart. We will do it by taking the first valid address of the customer.\n             *\n             * If that customer exists but don't have any addresses, it will assign zero and we go on.\n             */\n            if (\n                isset($cart)\n                && (!isset($cart->id_address_delivery) || $cart->id_address_delivery == 0 || !isset($cart->id_address_invoice) || $cart->id_address_invoice == 0)\n                && $this->context->cookie->id_customer\n            ) {\n                $to_update = false;\n                if ($this->automaticallyAllocateDeliveryAddress && (!isset($cart->id_address_delivery) || $cart->id_address_delivery == 0)) {\n                    $to_update = true;\n                    $cart->id_address_delivery = (int) Address::getFirstCustomerAddressId($cart->id_customer);\n                }\n                if ($this->automaticallyAllocateInvoiceAddress && (!isset($cart->id_address_invoice) || $cart->id_address_invoice == 0)) {\n                    $to_update = true;\n                    $cart->id_address_invoice = (int) Address::getFirstCustomerAddressId($cart->id_customer);\n                }\n                if ($to_update) {\n                    $cart->update();\n                }\n            }\n        }\n\n        /*\n         * If the previous logic didn't resolve into any valid cart we can use, we will create a new empty one.\n         *\n         * It does not have any ID yet. It's just an empty cart object, but modules can use it and ask for it's data\n         * without checking a cart exists in a context and all that boring stuff. It will get assigned an ID after\n         * first save or update.\n         */\n        if (!isset($cart) || !$cart->id) {\n            $cart = new Cart();\n            $cart->id_lang = (int) $this->context->cookie->id_lang;\n            $cart->id_currency = (int) $this->context->cookie->id_currency;\n            $cart->id_guest = (int) $this->context->cookie->id_guest;\n            $cart->id_shop_group = (int) $this->context->shop->id_shop_group;\n            $cart->id_shop = $this->context->shop->id;\n            if ($this->context->cookie->id_customer) {\n                $cart->id_customer = (int) $this->context->cookie->id_customer;\n                $cart->id_address_delivery = (int) Address::getFirstCustomerAddressId($cart->id_customer);\n                $cart->id_address_invoice = (int) $cart->id_address_delivery;\n            } else {\n                $cart->id_address_delivery = 0;\n                $cart->id_address_invoice = 0;\n            }\n\n            // Needed if the merchant want to give a free product to every visitors\n            $this->context->cart = $cart;\n            CartRule::autoAddToCart($this->context);\n        } else {\n            $this->context->cart = $cart;\n            $this->context->cart->checkAndUpdateAddresses();\n        }\n\n        $this->context->smarty->assign('request_uri', Tools::safeOutput(urldecode($_SERVER['REQUEST_URI'])));\n\n        // Automatically redirect to the canonical URL if needed\n        if (!empty($this->php_self) && !Tools::getValue('ajax')) {\n            $this->canonicalRedirection($this->context->link->getPageLink($this->php_self, $this->ssl, $this->context->language->id));\n        }\n\n        Product::initPricesComputation();\n\n        if (isset($cart->{Configuration::get('PS_TAX_ADDRESS_TYPE')}) && $cart->{Configuration::get('PS_TAX_ADDRESS_TYPE')}) {\n            $infos = Address::getCountryAndState((int) $cart->{Configuration::get('PS_TAX_ADDRESS_TYPE')});\n            $country = new Country((int) $infos['id_country']);\n            $this->context->country = $country;\n        }\n\n        $this->displayMaintenancePage();\n\n        if (Country::GEOLOC_FORBIDDEN == $this->restrictedCountry) {\n            $this->displayRestrictedCountryPage();\n        }\n\n        $this->context->cart = $cart;\n\n        Hook::exec(\n            'actionFrontControllerInitAfter',\n            [\n                'controller' => $this,\n            ]\n        );\n    }\n\n    /**\n     * Method that is executed after init() and checkAccess().\n     * Used to process user input.\n     *\n     * @see Controller::run()\n     */\n    public function postProcess()\n    {\n    }\n\n    protected function assignGeneralPurposeVariables()\n    {\n        if (Validate::isLoadedObject($this->context->cart)) {\n            $cart = $this->context->cart;\n        } else {\n            $cart = new Cart();\n        }\n\n        $templateVars = [\n            'cart' => $this->cart_presenter->present($cart),\n            'currency' => $this->getTemplateVarCurrency(),\n            'customer' => $this->getTemplateVarCustomer(),\n            'country' => $this->objectPresenter->present($this->context->country),\n            'language' => $this->objectPresenter->present($this->context->language),\n            'page' => $this->getTemplateVarPage(),\n            'shop' => $this->getTemplateVarShop(),\n            'core_js_public_path' => $this->getCoreJsPublicPath(),\n            'urls' => $this->getTemplateVarUrls(),\n            'configuration' => $this->getTemplateVarConfiguration(),\n            'field_required' => $this->context->customer->validateFieldsRequiredDatabase(),\n            'breadcrumb' => $this->getBreadcrumb(),\n            'link' => $this->context->link,\n            'time' => time(),\n            'static_token' => Tools::getToken(false),\n            'token' => Tools::getToken(),\n            'debug' => _PS_MODE_DEV_,\n        ];\n\n        // An array [module_name => module_output] will be returned\n        $modulesVariables = Hook::exec(\n            'actionFrontControllerSetVariables',\n            [\n                'templateVars' => &$templateVars,\n            ],\n            null,\n            true\n        );\n\n        if (is_array($modulesVariables)) {\n            foreach ($modulesVariables as $moduleName => $variables) {\n                $templateVars['modules'][$moduleName] = $variables;\n            }\n        }\n\n        $this->context->smarty->assign($templateVars);\n\n        Media::addJsDef([\n            'prestashop' => $this->buildFrontEndObject($templateVars),\n        ]);\n    }\n\n    /**\n     * Builds the \"prestashop\" javascript object that will be sent to the front end.\n     *\n     * @param array $object Variables inserted in the template (see FrontController::assignGeneralPurposeVariables)\n     *\n     * @return array Variables to be inserted in the \"prestashop\" javascript object\n     *\n     * @throws \\PrestaShop\\PrestaShop\\Core\\Filter\\FilterException\n     * @throws PrestaShopException\n     */\n    protected function buildFrontEndObject($object)\n    {\n        $object = $this->get('prestashop.core.filter.front_end_object.main')\n            ->filter($object);\n\n        Hook::exec('actionBuildFrontEndObject', [\n            'obj' => &$object,\n        ]);\n\n        return $object;\n    }\n\n    /**\n     * Initializes common front page content: header, footer and side columns.\n     */\n    public function initContent()\n    {\n        $this->assignGeneralPurposeVariables();\n        $this->process();\n\n        if (!isset($this->context->cart)) {\n            $this->context->cart = new Cart();\n        }\n\n        $this->context->smarty->assign([\n            'HOOK_HEADER' => Hook::exec('displayHeader'),\n        ]);\n    }\n\n    public function initFooter()\n    {\n    }\n\n    /**\n     * Initialize the invalid doom page of death.\n     */\n    public function initCursedPage()\n    {\n        header('HTTP/1.1 403 Forbidden');\n\n        $this->registerStylesheet('theme-error', '/assets/css/error.css', ['media' => 'all', 'priority' => 50]);\n        $this->context->smarty->assign([\n            'layout' => 'layouts/layout-error.tpl',\n            'urls' => $this->getTemplateVarUrls(),\n            'shop' => $this->getTemplateVarShop(),\n            'stylesheets' => $this->getStylesheets(),\n        ]);\n        $this->layout = 'errors/forbidden.tpl';\n    }\n\n    /**\n     * Called before compiling common page sections (header, footer, columns).\n     * Good place to modify smarty variables.\n     *\n     * @see FrontController::initContent()\n     */\n    public function process()\n    {\n    }\n\n    /**\n     * @return mixed\n     */\n    public function getStylesheets()\n    {\n        $cssFileList = $this->stylesheetManager->getList();\n\n        if (Configuration::get('PS_CSS_THEME_CACHE')) {\n            $cssFileList = $this->cccReducer->reduceCss($cssFileList);\n        }\n\n        return $cssFileList;\n    }\n\n    /**\n     * @return mixed\n     */\n    public function getJavascript()\n    {\n        $jsFileList = $this->javascriptManager->getList();\n\n        if (Configuration::get('PS_JS_THEME_CACHE')) {\n            $jsFileList = $this->cccReducer->reduceJs($jsFileList);\n        }\n\n        return $jsFileList;\n    }\n\n    /**\n     * Redirects to redirect_after link.\n     *\n     * @see $redirect_after\n     */\n    protected function redirect()\n    {\n        Tools::redirect($this->redirect_after);\n    }\n\n    public function redirectWithNotifications()\n    {\n        $notifications = json_encode([\n            'error' => $this->errors,\n            'warning' => $this->warning,\n            'success' => $this->success,\n            'info' => $this->info,\n        ]);\n\n        if (session_status() == PHP_SESSION_ACTIVE) {\n            $_SESSION['notifications'] = $notifications;\n        } elseif (session_status() == PHP_SESSION_NONE) {\n            session_start();\n            $_SESSION['notifications'] = $notifications;\n        } else {\n            setcookie('notifications', $notifications);\n        }\n\n        return call_user_func_array(['Tools', 'redirect'], func_get_args());\n    }\n\n    /**\n     * Renders page content.\n     * Used for retrocompatibility with PS 1.4.\n     */\n    public function displayContent()\n    {\n    }\n\n    /**\n     * Compiles and outputs full page content.\n     *\n     * @return bool\n     *\n     * @throws Exception\n     * @throws SmartyException\n     */\n    public function display()\n    {\n        $this->context->smarty->assign([\n            'layout' => $this->getLayout(),\n            'stylesheets' => $this->getStylesheets(),\n            'javascript' => $this->getJavascript(),\n            'js_custom_vars' => Media::getJsDef(),\n            'notifications' => $this->prepareNotifications(),\n        ]);\n\n        $this->smartyOutputContent($this->template);\n\n        return true;\n    }\n\n    protected function smartyOutputContent($content)\n    {\n        $this->context->cookie->write();\n\n        $html = '';\n\n        $theme = $this->context->shop->theme->getName();\n\n        if (is_array($content)) {\n            foreach ($content as $tpl) {\n                $html .= $this->context->smarty->fetch($tpl, null, $theme . $this->getLayout());\n            }\n        } else {\n            $html = $this->context->smarty->fetch($content, null, $theme . $this->getLayout());\n        }\n\n        Hook::exec('actionOutputHTMLBefore', ['html' => &$html]);\n        echo trim($html);\n    }\n\n    protected function prepareNotifications()\n    {\n        $notifications = [\n            'error' => $this->errors,\n            'warning' => $this->warning,\n            'success' => $this->success,\n            'info' => $this->info,\n        ];\n\n        if (session_status() == PHP_SESSION_NONE) {\n            session_start();\n        }\n\n        if (session_status() == PHP_SESSION_ACTIVE && isset($_SESSION['notifications'])) {\n            $notifications = array_merge_recursive($notifications, json_decode($_SESSION['notifications'], true));\n            unset($_SESSION['notifications']);\n        } elseif (isset($_COOKIE['notifications'])) {\n            $notifications = array_merge_recursive($notifications, json_decode($_COOKIE['notifications'], true));\n            unset($_COOKIE['notifications']);\n        }\n\n        return $notifications;\n    }\n\n    /**\n     * Displays maintenance page if shop is closed.\n     */\n    protected function displayMaintenancePage()\n    {\n        if ($this->maintenance == true || !(int) Configuration::get('PS_SHOP_ENABLE')) {\n            $this->maintenance = true;\n\n            $is_admin = (int) (new Cookie('psAdmin'))->id_employee;\n            $maintenance_allow_admins = (bool) Configuration::get('PS_MAINTENANCE_ALLOW_ADMINS');\n            if ($is_admin && $maintenance_allow_admins) {\n                return;\n            }\n\n            $allowed_ips = array_map('trim', explode(',', Configuration::get('PS_MAINTENANCE_IP')));\n            if (!IpUtils::checkIp(Tools::getRemoteAddr(), $allowed_ips)) {\n                header('HTTP/1.1 503 Service Unavailable');\n                header('Retry-After: 3600');\n\n                $this->registerStylesheet('theme-error', '/assets/css/error.css', ['media' => 'all', 'priority' => 50]);\n                $this->context->smarty->assign([\n                    'urls' => $this->getTemplateVarUrls(),\n                    'shop' => $this->getTemplateVarShop(),\n                    'HOOK_MAINTENANCE' => Hook::exec('displayMaintenance', []),\n                    'maintenance_text' => Configuration::get('PS_MAINTENANCE_TEXT', (int) $this->context->language->id),\n                    'stylesheets' => $this->getStylesheets(),\n                ]);\n                $this->smartyOutputContent('errors/maintenance.tpl');\n\n                exit;\n            }\n        }\n    }\n\n    /**\n     * Displays 'country restricted' page if user's country is not allowed.\n     */\n    protected function displayRestrictedCountryPage()\n    {\n        header('HTTP/1.1 403 Forbidden');\n\n        $this->registerStylesheet('theme-error', '/assets/css/error.css', ['media' => 'all', 'priority' => 50]);\n        $this->context->smarty->assign([\n            'urls' => $this->getTemplateVarUrls(),\n            'shop' => $this->getTemplateVarShop(),\n            'stylesheets' => $this->getStylesheets(),\n        ]);\n        $this->smartyOutputContent('errors/restricted-country.tpl');\n\n        exit;\n    }\n\n    /**\n     * Redirects to correct protocol if settings and request methods don't match.\n     */\n    protected function sslRedirection()\n    {\n        // If we call a SSL controller without SSL or a non SSL controller with SSL, we redirect with the right protocol\n        if (Configuration::get('PS_SSL_ENABLED') && $_SERVER['REQUEST_METHOD'] != 'POST' && $this->ssl != Tools::usingSecureMode()) {\n            $this->context->cookie->disallowWriting();\n            header('HTTP/1.1 301 Moved Permanently');\n            header('Cache-Control: no-cache');\n            if ($this->ssl) {\n                header('Location: ' . Tools::getShopDomainSsl(true) . $_SERVER['REQUEST_URI']);\n            } else {\n                header('Location: ' . Tools::getShopDomain(true) . $_SERVER['REQUEST_URI']);\n            }\n            exit();\n        }\n    }\n\n    /**\n     * Redirects to canonical URL.\n     *\n     * @param string $canonical_url\n     */\n    protected function canonicalRedirection($canonical_url = '')\n    {\n        if (!$canonical_url || !Configuration::get('PS_CANONICAL_REDIRECT') || strtoupper($_SERVER['REQUEST_METHOD']) != 'GET') {\n            return;\n        }\n\n        $canonical_url = preg_replace('/#.*$/', '', $canonical_url);\n\n        $match_url = rawurldecode(Tools::getCurrentUrlProtocolPrefix() . $_SERVER['HTTP_HOST'] . $_SERVER['REQUEST_URI']);\n        if (!preg_match('/^' . Tools::pRegexp(rawurldecode($canonical_url), '/') . '([&?].*)?$/', $match_url)) {\n            $final_url = $this->sanitizeUrl($canonical_url);\n\n            // Don't send any cookie\n            Context::getContext()->cookie->disallowWriting();\n            if (defined('_PS_MODE_DEV_') && _PS_MODE_DEV_ && $_SERVER['REQUEST_URI'] != __PS_BASE_URI__) {\n                die('[Debug] This page has moved<br />Please use the following URL instead: <a href=\"' . $final_url . '\">' . $final_url . '</a>');\n            }\n\n            $redirect_type = Configuration::get('PS_CANONICAL_REDIRECT') == 2 ? '301' : '302';\n            header('HTTP/1.0 ' . $redirect_type . ' Moved');\n            header('Cache-Control: no-cache');\n            Tools::redirect($final_url);\n        }\n    }\n\n    /**\n     * Geolocation management.\n     *\n     * @param Country $defaultCountry\n     *\n     * @return Country|false\n     */\n    protected function geolocationManagement($defaultCountry)\n    {\n        if (!in_array(Tools::getRemoteAddr(), ['127.0.0.1', '::1'])) {\n            /* Check if Maxmind Database exists */\n            if (@filemtime(_PS_GEOIP_DIR_ . _PS_GEOIP_CITY_FILE_)) {\n                if (!isset($this->context->cookie->iso_code_country) || (isset($this->context->cookie->iso_code_country) && !in_array(strtoupper($this->context->cookie->iso_code_country), explode(';', Configuration::get('PS_ALLOWED_COUNTRIES'))))) {\n                    $reader = new GeoIp2\\Database\\Reader(_PS_GEOIP_DIR_ . _PS_GEOIP_CITY_FILE_);\n\n                    try {\n                        $record = $reader->city(Tools::getRemoteAddr());\n                    } catch (\\GeoIp2\\Exception\\AddressNotFoundException $e) {\n                        $record = null;\n                    }\n\n                    if (is_object($record) && Validate::isLanguageIsoCode($record->country->isoCode) && (int) Country::getByIso(strtoupper($record->country->isoCode)) != 0) {\n                        if (!in_array(strtoupper($record->country->isoCode), explode(';', Configuration::get('PS_ALLOWED_COUNTRIES'))) && !FrontController::isInWhitelistForGeolocation()) {\n                            if (Configuration::get('PS_GEOLOCATION_BEHAVIOR') == _PS_GEOLOCATION_NO_CATALOG_) {\n                                $this->restrictedCountry = Country::GEOLOC_FORBIDDEN;\n                            } elseif (Configuration::get('PS_GEOLOCATION_BEHAVIOR') == _PS_GEOLOCATION_NO_ORDER_) {\n                                $this->restrictedCountry = Country::GEOLOC_CATALOG_MODE;\n                                $this->warning[] = $this->trans('You cannot place a new order from your country (%s).', [$record->country->name], 'Shop.Notifications.Warning');\n                            }\n                        } else {\n                            $hasBeenSet = !isset($this->context->cookie->iso_code_country);\n                            $this->context->cookie->iso_code_country = strtoupper($record->country->isoCode);\n                        }\n                    }\n                }\n\n                if (isset($this->context->cookie->iso_code_country) && $this->context->cookie->iso_code_country && !Validate::isLanguageIsoCode($this->context->cookie->iso_code_country)) {\n                    $this->context->cookie->iso_code_country = Country::getIsoById((int) Configuration::get('PS_COUNTRY_DEFAULT'));\n                }\n\n                if (isset($this->context->cookie->iso_code_country) && ($idCountry = (int) Country::getByIso(strtoupper($this->context->cookie->iso_code_country)))) {\n                    /* Update defaultCountry */\n                    if ($defaultCountry->iso_code != $this->context->cookie->iso_code_country) {\n                        $defaultCountry = new Country($idCountry);\n                    }\n                    if (isset($hasBeenSet) && $hasBeenSet) {\n                        $this->context->cookie->id_currency = (int) ($defaultCountry->id_currency ? (int) $defaultCountry->id_currency : Currency::getDefaultCurrencyId());\n                    }\n\n                    return $defaultCountry;\n                } elseif (Configuration::get('PS_GEOLOCATION_NA_BEHAVIOR') == _PS_GEOLOCATION_NO_CATALOG_ && !FrontController::isInWhitelistForGeolocation()) {\n                    $this->restrictedCountry = Country::GEOLOC_FORBIDDEN;\n                } elseif (Configuration::get('PS_GEOLOCATION_NA_BEHAVIOR') == _PS_GEOLOCATION_NO_ORDER_ && !FrontController::isInWhitelistForGeolocation()) {\n                    $this->restrictedCountry = Country::GEOLOC_CATALOG_MODE;\n                    $countryName = $this->trans('Undefined', [], 'Shop.Theme.Global');\n                    if (isset($record->country->name) && $record->country->name) {\n                        $countryName = $record->country->name;\n                    }\n                    $this->warning[] = $this->trans(\n                        'You cannot place a new order from your country (%s).',\n                        [$countryName],\n                        'Shop.Notifications.Warning'\n                    );\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Sets controller CSS and JS files.\n     *\n     * @return bool\n     */\n    public function setMedia()\n    {\n        $this->registerStylesheet('theme-main', '/assets/css/theme.css', ['media' => 'all', 'priority' => 50]);\n        $this->registerStylesheet('theme-custom', '/assets/css/custom.css', ['media' => 'all', 'priority' => 1000]);\n\n        if ($this->context->language->is_rtl) {\n            $this->registerStylesheet('theme-rtl', '/assets/css/rtl.css', ['media' => 'all', 'priority' => 900]);\n        }\n\n        if ($this->context->shop->theme->requiresCoreScripts()) {\n            $this->registerJavascript('corejs', '/themes/core.js', ['position' => 'bottom', 'priority' => 0]);\n        }\n        $this->registerJavascript('theme-main', '/assets/js/theme.js', ['position' => 'bottom', 'priority' => 50]);\n        $this->registerJavascript('theme-custom', '/assets/js/custom.js', ['position' => 'bottom', 'priority' => 1000]);\n\n        $assets = $this->context->shop->theme->getPageSpecificAssets($this->php_self);\n        if (!empty($assets)) {\n            foreach ($assets['css'] as $css) {\n                $this->registerStylesheet($css['id'], $css['path'], $css);\n            }\n            foreach ($assets['js'] as $js) {\n                $this->registerJavascript($js['id'], $js['path'], $js);\n            }\n        }\n\n        // Execute Hook FrontController SetMedia\n        Hook::exec('actionFrontControllerSetMedia', []);\n\n        return true;\n    }\n\n    /**\n     * Initializes page header variables.\n     */\n    public function initHeader()\n    {\n    }\n\n    /**\n     * Sets and returns customer groups that the current customer(visitor) belongs to.\n     *\n     * @return array\n     *\n     * @throws PrestaShopDatabaseException\n     */\n    public static function getCurrentCustomerGroups()\n    {\n        if (!Group::isFeatureActive()) {\n            return [];\n        }\n\n        $context = Context::getContext();\n        if (!isset($context->customer) || !$context->customer->id) {\n            return [];\n        }\n\n        if (!is_array(self::$currentCustomerGroups)) {\n            self::$currentCustomerGroups = [];\n            $result = Db::getInstance()->executeS('SELECT id_group FROM ' . _DB_PREFIX_ . 'customer_group WHERE id_customer = ' . (int) $context->customer->id);\n            foreach ($result as $row) {\n                self::$currentCustomerGroups[] = $row['id_group'];\n            }\n        }\n\n        return self::$currentCustomerGroups;\n    }\n\n    /**\n     * Checks if user's location is whitelisted.\n     *\n     * @staticvar bool|null $allowed\n     *\n     * @return bool\n     */\n    protected static function isInWhitelistForGeolocation()\n    {\n        static $allowed = null;\n\n        if ($allowed !== null) {\n            return $allowed;\n        }\n\n        $allowed = false;\n        $user_ip = Tools::getRemoteAddr();\n        $ips = [];\n\n        // retrocompatibility\n        $ips_old = explode(';', Configuration::get('PS_GEOLOCATION_WHITELIST'));\n        foreach ($ips_old as $ip) {\n            $ips = array_merge($ips, explode(\"\\n\", $ip));\n        }\n\n        $ips = array_map('trim', $ips);\n        foreach ($ips as $ip) {\n            if (!empty($ip) && preg_match('/^' . $ip . '.*/', $user_ip)) {\n                $allowed = true;\n            }\n        }\n\n        return $allowed;\n    }\n\n    /**\n     * Checks if token is valid.\n     *\n     * @since 1.5.0.1\n     *\n     * @return bool\n     */\n    public function isTokenValid()\n    {\n        if (!Configuration::get('PS_TOKEN_ENABLE')) {\n            return true;\n        }\n\n        return strcasecmp(Tools::getToken(false), Tools::getValue('token')) == 0;\n    }\n\n    public function registerStylesheet($id, $relativePath, $params = [])\n    {\n        if (!is_array($params)) {\n            $params = [];\n        }\n\n        $default_params = [\n            'media' => AbstractAssetManager::DEFAULT_MEDIA,\n            'priority' => AbstractAssetManager::DEFAULT_PRIORITY,\n            'inline' => false,\n            'server' => 'local',\n            'version' => null,\n            'needRtl' => true,\n        ];\n        $params = array_merge($default_params, $params);\n\n        if (Tools::hasMediaServer() && !Configuration::get('PS_CSS_THEME_CACHE')) {\n            $relativePath = Tools::getCurrentUrlProtocolPrefix() . Tools::getMediaServer($relativePath)\n                . ($this->stylesheetManager->getFullPath($relativePath) ?? $relativePath);\n            $params['server'] = 'remote';\n        }\n\n        $this->stylesheetManager->register($id, $relativePath, $params['media'], $params['priority'], $params['inline'], $params['server'], $params['needRtl'], $params['version']);\n    }\n\n    public function unregisterStylesheet($id)\n    {\n        $this->stylesheetManager->unregisterById($id);\n    }\n\n    public function registerJavascript($id, $relativePath, $params = [])\n    {\n        if (!is_array($params)) {\n            $params = [];\n        }\n\n        $default_params = [\n            'position' => AbstractAssetManager::DEFAULT_JS_POSITION,\n            'priority' => AbstractAssetManager::DEFAULT_PRIORITY,\n            'inline' => false,\n            'attributes' => null,\n            'server' => 'local',\n            'version' => null,\n        ];\n        $params = array_merge($default_params, $params);\n\n        if (Tools::hasMediaServer() && !Configuration::get('PS_JS_THEME_CACHE')) {\n            $relativePath = Tools::getCurrentUrlProtocolPrefix() . Tools::getMediaServer($relativePath)\n                . ($this->javascriptManager->getFullPath($relativePath) ?? $relativePath);\n            $params['server'] = 'remote';\n        }\n        $this->javascriptManager->register($id, $relativePath, $params['position'], $params['priority'], $params['inline'], $params['attributes'], $params['server'], $params['version']);\n    }\n\n    public function unregisterJavascript($id)\n    {\n        $this->javascriptManager->unregisterById($id);\n    }\n\n    /**\n     * @deprecated 1.7 This function shouldn't be used, use $this->registerStylesheet() instead\n     */\n    public function addCSS($css_uri, $css_media_type = 'all', $offset = null, $check_path = true)\n    {\n        /*\n        This is deprecated in PrestaShop 1.7 and has no effect in PrestaShop 1.7 theme.\n        You should use registerStylesheet($id, $path, $params)\n        */\n\n        if (!is_array($css_uri)) {\n            $css_uri = (array) $css_uri;\n        }\n\n        foreach ($css_uri as $legacy_uri) {\n            if ($uri = $this->getAssetUriFromLegacyDeprecatedMethod($legacy_uri)) {\n                $this->registerStylesheet(sha1($uri), $uri, ['media' => $css_media_type, 'priority' => 80]);\n            }\n        }\n    }\n\n    /**\n     * @deprecated 1.7 This function has no effect in PrestaShop 1.7 theme, use $this->unregisterStylesheet() instead\n     */\n    public function removeCSS($css_uri, $css_media_type = 'all', $check_path = true)\n    {\n        /*\n        This is deprecated in PrestaShop 1.7 and has no effect in PrestaShop 1.7 theme.\n        You should use unregisterStylesheet($id)\n        */\n\n        if (!is_array($css_uri)) {\n            $css_uri = (array) $css_uri;\n        }\n\n        foreach ($css_uri as $legacy_uri) {\n            if ($uri = $this->getAssetUriFromLegacyDeprecatedMethod($legacy_uri)) {\n                $this->unregisterStylesheet(sha1($uri));\n            }\n        }\n    }\n\n    /**\n     * @deprecated 1.7 This function has no effect in PrestaShop 1.7 theme, use $this->registerJavascript() instead\n     */\n    public function addJS($js_uri, $check_path = true)\n    {\n        /*\n        This is deprecated in PrestaShop 1.7 and has no effect in PrestaShop 1.7 theme.\n        You should use registerJavascript($id, $path, $params)\n        */\n\n        if (!is_array($js_uri)) {\n            $js_uri = (array) $js_uri;\n        }\n\n        foreach ($js_uri as $legacy_uri) {\n            if ($uri = $this->getAssetUriFromLegacyDeprecatedMethod($legacy_uri)) {\n                $this->registerJavascript(sha1($uri), $uri, ['position' => 'bottom', 'priority' => 80]);\n            }\n        }\n    }\n\n    /**\n     * @deprecated 1.7 This function has no effect in PrestaShop 1.7 theme, use $this->unregisterJavascript() instead\n     */\n    public function removeJS($js_uri, $check_path = true)\n    {\n        /*\n        This is deprecated in PrestaShop 1.7 and has no effect in PrestaShop 1.7 theme.\n        You should use unregisterJavascript($id)\n        */\n\n        if (!is_array($js_uri)) {\n            $js_uri = (array) $js_uri;\n        }\n\n        foreach ($js_uri as $legacy_uri) {\n            if ($uri = $this->getAssetUriFromLegacyDeprecatedMethod($legacy_uri)) {\n                $this->unregisterJavascript(sha1($uri));\n            }\n        }\n    }\n\n    /**\n     * Adds jQuery UI component(s) to queued JS file list.\n     *\n     * @param string|array $component\n     * @param string $theme\n     * @param bool $check_dependencies\n     */\n    public function addJqueryUI($component, $theme = 'base', $check_dependencies = true)\n    {\n        $css_theme_path = '/js/jquery/ui/themes/' . $theme . '/minified/jquery.ui.theme.min.css';\n        $css_path = '/js/jquery/ui/themes/' . $theme . '/minified/jquery-ui.min.css';\n        $js_path = '/js/jquery/ui/jquery-ui.min.js';\n\n        $this->registerStylesheet('jquery-ui-theme', $css_theme_path, ['media' => 'all', 'priority' => 95]);\n        $this->registerStylesheet('jquery-ui', $css_path, ['media' => 'all', 'priority' => 90]);\n        $this->registerJavascript('jquery-ui', $js_path, ['position' => 'bottom', 'priority' => 49]);\n    }\n\n    /**\n     * Add Library not included with classic theme.\n     */\n    public function requireAssets(array $libraries)\n    {\n        foreach ($libraries as $library) {\n            if ($assets = PrestashopAssetsLibraries::getAssetsLibraries($library)) {\n                foreach ($assets as $asset) {\n                    $this->{$asset['type']}($library, $asset['path'], $asset['params']);\n                }\n            }\n        }\n    }\n\n    /**\n     * Adds jQuery plugin(s) to queued JS file list.\n     *\n     * @param string|array $name\n     * @param string|null $folder\n     * @param bool $css\n     */\n    public function addJqueryPlugin($name, $folder = null, $css = true)\n    {\n        if (!is_array($name)) {\n            $name = [$name];\n        }\n\n        foreach ($name as $plugin) {\n            $plugin_path = Media::getJqueryPluginPath($plugin, $folder);\n\n            if (!empty($plugin_path['js'])) {\n                $this->registerJavascript(\n                    str_replace(_PS_JS_DIR_ . 'jquery/plugins/', '', $plugin_path['js']),\n                    str_replace(_PS_JS_DIR_, 'js/', $plugin_path['js']),\n                    ['position' => 'bottom', 'priority' => 100]\n                );\n            }\n            if ($css && !empty($plugin_path['css'])) {\n                $this->registerStylesheet(\n                    str_replace(_PS_JS_DIR_ . 'jquery/plugins/', '', key($plugin_path['css'])),\n                    str_replace(_PS_JS_DIR_, 'js/', key($plugin_path['css'])),\n                    ['media' => 'all', 'priority' => 100]\n                );\n            }\n        }\n    }\n\n    /**\n     * Recovers cart information.\n     *\n     * @return int|false\n     */\n    protected function recoverCart()\n    {\n        if (!Tools::isSubmit('recover_cart')) {\n            return false;\n        }\n\n        // Get ID cart from URL\n        $id_cart = (int) Tools::getValue('recover_cart');\n\n        // Check if token in URL matches, otherwise, ignore it, probably malicious intentions\n        if (Tools::getValue('token_cart') != md5(_COOKIE_KEY_ . 'recover_cart_' . $id_cart)) {\n            return false;\n        }\n\n        // Create cart object and check if it's still valid. It can be deleted by automated cleaners or manually.\n        $cart = new Cart($id_cart);\n        if (!Validate::isLoadedObject($cart)) {\n            $this->errors[] = $this->trans('This cart has expired.', [], 'Shop.Notifications.Error');\n\n            return false;\n        }\n\n        // Customer - same scenario. It can be deleted by automated cleaners or manually.\n        $customer = new Customer((int) $cart->id_customer);\n        if (!Validate::isLoadedObject($customer)) {\n            $this->errors[] = $this->trans('This cart has expired.', [], 'Shop.Notifications.Error');\n\n            return false;\n        }\n\n        // Check if there is already a finished order with this cart, we notify the customer nicely\n        if ($cart->orderExists()) {\n            $this->errors[] = $this->trans('This cart was already used in an order and has expired.', [], 'Shop.Notifications.Error');\n\n            return false;\n        }\n\n        // Initialize this data into cookie, FrontController will use it later\n        $customer->logged = true;\n        $this->context->customer = $customer;\n        $this->context->cookie->id_customer = (int) $customer->id;\n        $this->context->cookie->customer_lastname = $customer->lastname;\n        $this->context->cookie->customer_firstname = $customer->firstname;\n        $this->context->cookie->logged = true;\n        $this->context->cookie->check_cgv = 1;\n        $this->context->cookie->is_guest = $customer->isGuest();\n        $this->context->cookie->passwd = $customer->passwd;\n        $this->context->cookie->email = $customer->email;\n        $this->context->cookie->id_guest = (int) $cart->id_guest;\n        $this->context->cookie->id_cart = $id_cart;\n\n        // Return the value for backward compatibility\n        return $id_cart;\n    }\n\n    /**\n     * Sets template file for page content output.\n     *\n     * @param string $template\n     */\n    public function setTemplate($template, $params = [], $locale = null)\n    {\n        parent::setTemplate(\n            $this->getTemplateFile($template, $params, $locale)\n        );\n    }\n\n    /**\n     * Removed in PrestaShop 1.7.\n     *\n     * @return bool\n     */\n    protected function useMobileTheme()\n    {\n        return false;\n    }\n\n    /**\n     * Returns theme directory (regular or mobile).\n     *\n     * @return string\n     */\n    protected function getThemeDir()\n    {\n        return _PS_THEME_DIR_;\n    }\n\n    /**\n     * Returns the layout's full path corresponding to the current page by using the override system\n     * Ex:\n     * On the url: http://localhost/index.php?id_product=1&controller=product, this method will\n     * check if the layout exists in the following files (in that order), and return the first found:\n     * - /themes/default/override/layout-product-1.tpl\n     * - /themes/default/override/layout-product.tpl\n     * - /themes/default/layout.tpl.\n     *\n     * @since 1.5.0.13\n     *\n     * @return bool|string\n     */\n    public function getLayout()\n    {\n        // Primary identifier to search for a template is php_self property,\n        // For modules, we will use page_name\n        $entity = $this->php_self;\n        if (empty($entity)) {\n            $entity = $this->getPageName();\n        }\n\n        // Get layout set in prestashop configuration\n        $layout = $this->context->shop->theme->getLayoutNameForPage($entity);\n\n        // Check if we are in content_only mode (used for displaying terms and conditions in a popup for example)\n        $content_only = (int) Tools::getValue('content_only');\n\n        // If a module provides its own custom layout, we ignore what is set in configuration\n        if ($overridden_layout = Hook::exec(\n            'overrideLayoutTemplate',\n            [\n                'default_layout' => $layout,\n                'entity' => $entity,\n                'locale' => $this->context->language->locale,\n                'controller' => $this,\n                'content_only' => $content_only,\n            ]\n        )) {\n            return $overridden_layout;\n        }\n\n        // When using content_only, there will be no header, footer and sidebars\n        if ($content_only) {\n            $layout = 'layout-content-only';\n        }\n\n        return $this->context->shop->theme->getLayoutPath($layout);\n    }\n\n    /**\n     * Returns layout name for the current controller. Used to display layout name in <body> tag.\n     *\n     * @return string layout name\n     */\n    protected function getLayoutName()\n    {\n        return str_replace(['.tpl'], '', basename($this->getLayout()));\n    }\n\n    /**\n     * Returns template path.\n     *\n     * @param string $template\n     *\n     * @return string\n     */\n    public function getTemplatePath($template)\n    {\n        return $template;\n    }\n\n    public function getTemplateFile($template, $params = [], $locale = null)\n    {\n        if (!isset($params['entity'])) {\n            $params['entity'] = null;\n        }\n        if (!isset($params['id'])) {\n            $params['id'] = null;\n        }\n\n        if (null === $locale) {\n            $locale = $this->context->language->locale;\n        }\n\n        if ($overridden_template = Hook::exec(\n            'displayOverrideTemplate',\n            [\n                'controller' => $this,\n                'template_file' => $template,\n                'entity' => $params['entity'],\n                'id' => $params['id'],\n                'locale' => $locale,\n            ]\n        )) {\n            return $overridden_template;\n        }\n\n        return $this->getTemplateFinder()->getTemplate(\n            $template,\n            $params['entity'],\n            $params['id'],\n            $locale\n        );\n    }\n\n    /**\n     * Renders and adds color list HTML for each product in a list.\n     *\n     * @deprecated since 8.1 and will be removed in next major version.\n     *\n     * @param array $products\n     */\n    public function addColorsToProductList(&$products)\n    {\n        if (!is_array($products) || !count($products) || !file_exists(_PS_THEME_DIR_ . 'product-list-colors.tpl')) {\n            return;\n        }\n\n        $products_need_cache = [];\n        foreach ($products as $product) {\n            if (!$this->isCached(_PS_THEME_DIR_ . 'product-list-colors.tpl', $this->getColorsListCacheId($product['id_product']))) {\n                $products_need_cache[] = (int) $product['id_product'];\n            }\n        }\n\n        $colors = false;\n        if (count($products_need_cache)) {\n            $colors = Product::getAttributesColorList($products_need_cache);\n        }\n\n        Tools::enableCache();\n        foreach ($products as &$product) {\n            $tpl = $this->context->smarty->createTemplate(_PS_THEME_DIR_ . 'product-list-colors.tpl', $this->getColorsListCacheId($product['id_product']));\n            $tpl->assign([\n                'id_product' => $product['id_product'],\n                'colors_list' => isset($colors[$product['id_product']]) ? $colors[$product['id_product']] : null,\n                'link' => Context::getContext()->link,\n                'img_col_dir' => _THEME_COL_DIR_,\n                'col_img_dir' => _PS_COL_IMG_DIR_,\n            ]);\n            $product['color_list'] = $tpl->fetch(_PS_THEME_DIR_ . 'product-list-colors.tpl', $this->getColorsListCacheId($product['id_product']));\n        }\n        Tools::restoreCacheSettings();\n    }\n\n    /**\n     * Returns cache ID for product color list.\n     *\n     * @deprecated since 8.1 and will be removed in next major version.\n     *\n     * @param int $id_product\n     *\n     * @return string\n     */\n    protected function getColorsListCacheId($id_product)\n    {\n        return Product::getColorsListCacheId($id_product);\n    }\n\n    public function getTemplateVarUrls()\n    {\n        if ($this->urls === null) {\n            $http = Tools::getCurrentUrlProtocolPrefix();\n            $base_url = $this->context->shop->getBaseURL(true, true);\n\n            $urls = [\n                'base_url' => $base_url,\n                'current_url' => $this->context->shop->getBaseURL(true, false) . $_SERVER['REQUEST_URI'],\n                'shop_domain_url' => $this->context->shop->getBaseURL(true, false),\n            ];\n\n            $assign_array = [\n                'img_ps_url' => _PS_IMG_,\n                'img_cat_url' => _THEME_CAT_DIR_,\n                'img_lang_url' => _THEME_LANG_DIR_,\n                'img_prod_url' => _THEME_PROD_DIR_,\n                'img_manu_url' => _THEME_MANU_DIR_,\n                'img_sup_url' => _THEME_SUP_DIR_,\n                'img_ship_url' => _THEME_SHIP_DIR_,\n                'img_store_url' => _THEME_STORE_DIR_,\n                'img_col_url' => _THEME_COL_DIR_,\n                'img_url' => _THEME_IMG_DIR_,\n                'css_url' => _THEME_CSS_DIR_,\n                'js_url' => _THEME_JS_DIR_,\n                'pic_url' => _THEME_PROD_PIC_DIR_,\n                'theme_assets' => _THEME_DIR_ . 'assets/',\n                'theme_dir' => $this->getThemeDir(),\n            ];\n\n            $themeAssetsConfig = $this->context->shop->theme->get('assets', false);\n\n            if (!empty($themeAssetsConfig['use_parent_assets'])) {\n                $assign_array['theme_assets'] = _PS_PARENT_THEME_URI_ . 'assets/';\n                $assign_array['img_url'] = $assign_array['theme_assets'] . 'img/';\n                $assign_array['css_url'] = $assign_array['theme_assets'] . 'css/';\n                $assign_array['js_url'] = $assign_array['theme_assets'] . 'js/';\n                $assign_array['child_theme_assets'] = _THEME_DIR_ . 'assets/';\n                $assign_array['child_img_url'] = $assign_array['child_theme_assets'] . 'img/';\n                $assign_array['child_css_url'] = $assign_array['child_theme_assets'] . 'css/';\n                $assign_array['child_js_url'] = $assign_array['child_theme_assets'] . 'js/';\n            }\n\n            foreach ($assign_array as $assign_key => $assign_value) {\n                $urls[$assign_key] = $http . Tools::getMediaServer($assign_value) . $assign_value;\n            }\n\n            $pages = [];\n            $p = [\n                'address', 'addresses', 'authentication', 'manufacturer', 'cart', 'category', 'cms', 'contact',\n                'discount', 'guest-tracking', 'history', 'identity', 'index', 'my-account',\n                'order-confirmation', 'order-detail', 'order-follow', 'order', 'order-return',\n                'order-slip', 'pagenotfound', 'password', 'pdf-invoice', 'pdf-order-return', 'pdf-order-slip',\n                'prices-drop', 'product', 'registration', 'search', 'sitemap', 'stores', 'supplier', 'new-products',\n            ];\n            foreach ($p as $page_name) {\n                $index = str_replace('-', '_', $page_name);\n                $pages[$index] = $this->context->link->getPageLink($page_name, $this->ssl);\n            }\n            $pages['brands'] = $pages['manufacturer'];\n            $pages['register'] = $this->context->link->getPageLink('registration', true);\n            $pages['order_login'] = $this->context->link->getPageLink('order', true, null, ['login' => '1']);\n            $urls['pages'] = $pages;\n\n            $urls['alternative_langs'] = $this->getAlternativeLangsUrl();\n\n            $urls['actions'] = [\n                'logout' => $this->context->link->getPageLink('index', true, null, 'mylogout'),\n            ];\n\n            $imageRetriever = new ImageRetriever($this->context->link);\n            $urls['no_picture_image'] = $imageRetriever->getNoPictureImage($this->context->language);\n\n            $this->urls = $urls;\n        }\n\n        return $this->urls;\n    }\n\n    public function getTemplateVarConfiguration()\n    {\n        $quantity_discount_price = Configuration::get('PS_DISPLAY_DISCOUNT_PRICE');\n\n        return [\n            'display_taxes_label' => $this->getDisplayTaxesLabel(),\n            'display_prices_tax_incl' => (bool) (new TaxConfiguration())->includeTaxes(),\n            'taxes_enabled' => (bool) Configuration::get('PS_TAX'),\n            'low_quantity_threshold' => (int) Configuration::get('PS_LAST_QTIES'),\n            'is_b2b' => (bool) Configuration::get('PS_B2B_ENABLE'),\n            'is_catalog' => (bool) Configuration::isCatalogMode(),\n            'show_prices' => (bool) Configuration::showPrices(),\n            'opt_in' => [\n                'partner' => (bool) Configuration::get('PS_CUSTOMER_OPTIN'),\n            ],\n            'quantity_discount' => [\n                'type' => ($quantity_discount_price) ? 'price' : 'discount',\n                'label' => ($quantity_discount_price)\n                    ? $this->getTranslator()->trans('Unit price', [], 'Shop.Theme.Catalog')\n                    : $this->getTranslator()->trans('Unit discount', [], 'Shop.Theme.Catalog'),\n            ],\n            'voucher_enabled' => (int) CartRule::isFeatureActive(),\n            'return_enabled' => (int) Configuration::get('PS_ORDER_RETURN'),\n            'number_of_days_for_return' => (int) Configuration::get('PS_ORDER_RETURN_NB_DAYS'),\n            'password_policy' => [\n                'minimum_length' => (int) Configuration::get(PasswordPolicyConfiguration::CONFIGURATION_MINIMUM_LENGTH),\n                'maximum_length' => (int) Configuration::get(PasswordPolicyConfiguration::CONFIGURATION_MAXIMUM_LENGTH),\n                'minimum_score' => (int) Configuration::get(PasswordPolicyConfiguration::CONFIGURATION_MINIMUM_SCORE),\n            ],\n        ];\n    }\n\n    protected function getDisplayTaxesLabel()\n    {\n        return (Module::isEnabled('ps_legalcompliance') && (bool) Configuration::get('AEUC_LABEL_TAX_INC_EXC')) || $this->context->country->display_tax_label;\n    }\n\n    public function getTemplateVarCurrency()\n    {\n        $curr = [];\n        $fields = ['id', 'name', 'iso_code', 'iso_code_num', 'sign'];\n        foreach ($fields as $field_name) {\n            $curr[$field_name] = $this->context->currency->{$field_name};\n        }\n\n        return $curr;\n    }\n\n    public function getTemplateVarCustomer($customer = null)\n    {\n        if (Validate::isLoadedObject($customer)) {\n            $cust = $this->objectPresenter->present($customer);\n        } else {\n            $cust = $this->objectPresenter->present($this->context->customer);\n        }\n\n        unset(\n            $cust['secure_key'],\n            $cust['passwd'],\n            $cust['show_public_prices'],\n            $cust['deleted'],\n            $cust['id_lang']\n        );\n\n        $cust['id'] = $this->context->customer->id;\n        $cust['is_logged'] = $this->context->customer->isLogged();\n\n        $cust['gender'] = $this->objectPresenter->present(new Gender($cust['id_gender']));\n        unset($cust['id_gender']);\n\n        $cust['risk'] = $this->objectPresenter->present(new Risk($cust['id_risk']));\n        unset($cust['id_risk']);\n\n        $addresses = $this->context->customer->getSimpleAddresses();\n        foreach ($addresses as &$a) {\n            $a['formatted'] = AddressFormat::generateAddress(new Address($a['id']), [], '<br>');\n        }\n        $cust['addresses'] = $addresses;\n\n        return $cust;\n    }\n\n    /**\n     * Get the shop logo with its dimensions\n     *\n     * @return array<string, string|int>\n     */\n    public function getShopLogo(): array\n    {\n        if (!Configuration::hasKey('PS_LOGO')) {\n            return [];\n        }\n\n        $logoFileName = Configuration::get('PS_LOGO');\n        $logoFileDir = _PS_IMG_DIR_ . $logoFileName;\n\n        if (!file_exists($logoFileDir)) {\n            return [];\n        }\n\n        list($logoWidth, $logoHeight) = getimagesize($logoFileDir);\n\n        return [\n            'src' => ($this->getTemplateVarUrls()['img_ps_url'] ?? _PS_IMG_) . $logoFileName,\n            'width' => $logoWidth,\n            'height' => $logoHeight,\n        ];\n    }\n\n    public function getCoreJsPublicPath()\n    {\n        return $this->context->shop->physical_uri . 'themes/';\n    }\n\n    public function getTemplateVarShop()\n    {\n        $address = $this->context->shop->getAddress();\n\n        $urls = $this->getTemplateVarUrls();\n        $psImageUrl = $urls['img_ps_url'] ?? _PS_IMG_;\n\n        $shop = [\n            'id' => $this->context->shop->id,\n            'name' => Configuration::get('PS_SHOP_NAME'),\n            'email' => Configuration::get('PS_SHOP_EMAIL'),\n            'registration_number' => Configuration::get('PS_SHOP_DETAILS'),\n\n            'long' => Configuration::get('PS_STORES_CENTER_LONG'),\n            'lat' => Configuration::get('PS_STORES_CENTER_LAT'),\n\n            'logo' => Configuration::hasKey('PS_LOGO') ? $psImageUrl . Configuration::get('PS_LOGO') : '',\n            'logo_details' => $this->getShopLogo(),\n            'stores_icon' => Configuration::hasKey('PS_STORES_ICON') ? $psImageUrl . Configuration::get('PS_STORES_ICON') : '',\n            'favicon' => Configuration::hasKey('PS_FAVICON') ? $psImageUrl . Configuration::get('PS_FAVICON') : '',\n            'favicon_update_time' => Configuration::get('PS_IMG_UPDATE_TIME'),\n\n            'address' => [\n                'formatted' => AddressFormat::generateAddress($address, [], '<br>'),\n                'address1' => $address->address1,\n                'address2' => $address->address2,\n                'postcode' => $address->postcode,\n                'city' => $address->city,\n                'state' => (new State($address->id_state))->name,\n                'country' => (new Country($address->id_country))->name[$this->context->language->id],\n            ],\n            'phone' => Configuration::get('PS_SHOP_PHONE'),\n            'fax' => Configuration::get('PS_SHOP_FAX'),\n        ];\n\n        return $shop;\n    }\n\n    public function getTemplateVarPage()\n    {\n        $page_name = $this->getPageName();\n        $meta_tags = Meta::getMetaTags($this->context->language->id, $page_name);\n\n        $my_account_controllers = [\n            'address',\n            'authentication',\n            'discount',\n            'history',\n            'identity',\n            'order-follow',\n            'order-slip',\n            'password',\n            'registration',\n            'guest-tracking',\n        ];\n\n        $body_classes = [\n            'lang-' . $this->context->language->iso_code => true,\n            'lang-rtl' => (bool) $this->context->language->is_rtl,\n            'country-' . $this->context->country->iso_code => true,\n            'currency-' . $this->context->currency->iso_code => true,\n            $this->getLayoutName() => true,\n            'page-' . $this->php_self => true,\n            'tax-display-' . ($this->getDisplayTaxesLabel() ? 'enabled' : 'disabled') => true,\n            'page-customer-account' => false,\n        ];\n\n        $page = [\n            'title' => '',\n            'canonical' => $this->getCanonicalURL(),\n            'meta' => [\n                'title' => $meta_tags['meta_title'],\n                'description' => $meta_tags['meta_description'],\n                'keywords' => $meta_tags['meta_keywords'],\n                'robots' => 'index',\n            ],\n            'page_name' => $page_name,\n            'body_classes' => $body_classes,\n            'admin_notifications' => [],\n            'password-policy' => [\n                'feedbacks' => [\n                    0 => $this->getTranslator()->trans('Very weak', [], 'Shop.Theme.Global'),\n                    1 => $this->getTranslator()->trans('Weak', [], 'Shop.Theme.Global'),\n                    2 => $this->getTranslator()->trans('Average', [], 'Shop.Theme.Global'),\n                    3 => $this->getTranslator()->trans('Strong', [], 'Shop.Theme.Global'),\n                    4 => $this->getTranslator()->trans('Very strong', [], 'Shop.Theme.Global'),\n                    'Straight rows of keys are easy to guess' => $this->getTranslator()->trans('Straight rows of keys are easy to guess', [], 'Shop.Theme.Global'),\n                    'Short keyboard patterns are easy to guess' => $this->getTranslator()->trans('Short keyboard patterns are easy to guess', [], 'Shop.Theme.Global'),\n                    'Use a longer keyboard pattern with more turns' => $this->getTranslator()->trans('Use a longer keyboard pattern with more turns', [], 'Shop.Theme.Global'),\n                    'Repeats like \"aaa\" are easy to guess' => $this->getTranslator()->trans('Repeats like \"aaa\" are easy to guess', [], 'Shop.Theme.Global'),\n                    'Repeats like \"abcabcabc\" are only slightly harder to guess than \"abc\"' => $this->getTranslator()->trans('Repeats like \"abcabcabc\" are only slightly harder to guess than \"abc\"', [], 'Shop.Theme.Global'),\n                    'Sequences like abc or 6543 are easy to guess' => $this->getTranslator()->trans('Sequences like \"abc\" or \"6543\" are easy to guess', [], 'Shop.Theme.Global'),\n                    'Recent years are easy to guess' => $this->getTranslator()->trans('Recent years are easy to guess', [], 'Shop.Theme.Global'),\n                    'Dates are often easy to guess' => $this->getTranslator()->trans('Dates are often easy to guess', [], 'Shop.Theme.Global'),\n                    'This is a top-10 common password' => $this->getTranslator()->trans('This is a top-10 common password', [], 'Shop.Theme.Global'),\n                    'This is a top-100 common password' => $this->getTranslator()->trans('This is a top-100 common password', [], 'Shop.Theme.Global'),\n                    'This is a very common password' => $this->getTranslator()->trans('This is a very common password', [], 'Shop.Theme.Global'),\n                    'This is similar to a commonly used password' => $this->getTranslator()->trans('This is similar to a commonly used password', [], 'Shop.Theme.Global'),\n                    'A word by itself is easy to guess' => $this->getTranslator()->trans('A word by itself is easy to guess', [], 'Shop.Theme.Global'),\n                    'Names and surnames by themselves are easy to guess' => $this->getTranslator()->trans('Names and surnames by themselves are easy to guess', [], 'Shop.Theme.Global'),\n                    'Common names and surnames are easy to guess' => $this->getTranslator()->trans('Common names and surnames are easy to guess', [], 'Shop.Theme.Global'),\n                    'Use a few words, avoid common phrases' => $this->getTranslator()->trans('Use a few words, avoid common phrases', [], 'Shop.Theme.Global'),\n                    'No need for symbols, digits, or uppercase letters' => $this->getTranslator()->trans('No need for symbols, digits, or uppercase letters', [], 'Shop.Theme.Global'),\n                    'Avoid repeated words and characters' => $this->getTranslator()->trans('Avoid repeated words and characters', [], 'Shop.Theme.Global'),\n                    'Avoid sequences' => $this->getTranslator()->trans('Avoid sequences', [], 'Shop.Theme.Global'),\n                    'Avoid recent years' => $this->getTranslator()->trans('Avoid recent years', [], 'Shop.Theme.Global'),\n                    'Avoid years that are associated with you' => $this->getTranslator()->trans('Avoid years that are associated with you', [], 'Shop.Theme.Global'),\n                    'Avoid dates and years that are associated with you' => $this->getTranslator()->trans('Avoid dates and years that are associated with you', [], 'Shop.Theme.Global'),\n                    'Capitalization doesn\\'t help very much' => $this->getTranslator()->trans('Capitalization doesn\\'t help very much', [], 'Shop.Theme.Global'),\n                    'All-uppercase is almost as easy to guess as all-lowercase' => $this->getTranslator()->trans('All-uppercase is almost as easy to guess as all-lowercase', [], 'Shop.Theme.Global'),\n                    'Reversed words aren\\'t much harder to guess' => $this->getTranslator()->trans('Reversed words aren\\'t much harder to guess', [], 'Shop.Theme.Global'),\n                    'Predictable substitutions like \\'@\\' instead of \\'a\\' don\\'t help very much' => $this->getTranslator()->trans('Predictable substitutions like \"@\" instead of \"a\" don\\'t help very much', [], 'Shop.Theme.Global'),\n                    'Add another word or two. Uncommon words are better.' => $this->getTranslator()->trans('Add another word or two. Uncommon words are better.', [], 'Shop.Theme.Global'),\n                ],\n            ],\n        ];\n\n        if (in_array($this->php_self, $my_account_controllers)) {\n            $page['body_classes']['page-customer-account'] = true;\n        }\n\n        return $page;\n    }\n\n    public function getBreadcrumb()\n    {\n        $breadcrumb = $this->getBreadcrumbLinks();\n        $breadcrumb['count'] = count($breadcrumb['links']);\n\n        return $breadcrumb;\n    }\n\n    protected function getBreadcrumbLinks()\n    {\n        $breadcrumb = [];\n\n        $breadcrumb['links'][] = [\n            'title' => $this->getTranslator()->trans('Home', [], 'Shop.Theme.Global'),\n            'url' => $this->context->link->getPageLink('index', true),\n        ];\n\n        return $breadcrumb;\n    }\n\n    protected function getCategoryPath($category)\n    {\n        if ($category->id_parent != 0 && !$category->is_root_category) {\n            return [\n                'title' => $category->name,\n                'url' => $this->context->link->getCategoryLink($category),\n            ];\n        }\n    }\n\n    protected function addMyAccountToBreadcrumb()\n    {\n        return [\n            'title' => $this->getTranslator()->trans('Your account', [], 'Shop.Theme.Customeraccount'),\n            'url' => $this->context->link->getPageLink('my-account', true),\n        ];\n    }\n\n    /**\n     * Generate the canonical URL of the current page\n     *\n     * Mainly used for ProductController and CategoryController\n     * but can be implemented by other classes inheriting from FrontController\n     *\n     * @return string|void\n     */\n    public function getCanonicalURL()\n    {\n    }\n\n    /**\n     * Generate a URL corresponding to the current page but\n     * with the query string altered.\n     *\n     * If $extraParams is set to NULL, then all query params are stripped.\n     *\n     * Otherwise, params from $extraParams that have a null value are stripped,\n     * and other params are added. Params not in $extraParams are unchanged.\n     */\n    protected function updateQueryString(array $extraParams = null)\n    {\n        $uriWithoutParams = explode('?', $_SERVER['REQUEST_URI'])[0];\n        $url = Tools::getCurrentUrlProtocolPrefix() . $_SERVER['HTTP_HOST'] . $uriWithoutParams;\n        $params = [];\n        $paramsFromUri = '';\n        if (strpos($_SERVER['REQUEST_URI'], '?') !== false) {\n            $paramsFromUri = explode('?', $_SERVER['REQUEST_URI'])[1];\n        }\n        parse_str($paramsFromUri, $params);\n\n        if (null !== $extraParams) {\n            foreach ($extraParams as $key => $value) {\n                if (null === $value) {\n                    unset($params[$key]);\n                } else {\n                    $params[$key] = $value;\n                }\n            }\n        }\n\n        if (null !== $extraParams) {\n            foreach ($params as $key => $param) {\n                if ('' === $param) {\n                    unset($params[$key]);\n                }\n            }\n        } else {\n            $params = [];\n        }\n\n        $queryString = str_replace('%2F', '/', http_build_query($params, '', '&'));\n\n        return $url . ($queryString ? \"?$queryString\" : '');\n    }\n\n    protected function getCurrentURL()\n    {\n        return Tools::getCurrentUrl();\n    }\n\n    public function getPageName()\n    {\n        // Are we in a payment module\n        $module_name = '';\n        if (Validate::isModuleName(Tools::getValue('module'))) {\n            $module_name = Tools::getValue('module');\n        }\n\n        if (!empty($this->page_name)) {\n            $page_name = $this->page_name;\n        } elseif (!empty($this->php_self)) {\n            $page_name = $this->php_self;\n        } elseif (Tools::getValue('fc') == 'module' && $module_name != '' && (Module::getInstanceByName($module_name) instanceof PaymentModule)) {\n            $page_name = 'module-payment-submit';\n        } elseif (preg_match('#^' . preg_quote($this->context->shop->physical_uri, '#') . 'modules/([a-zA-Z0-9_-]+?)/(.*)$#', $_SERVER['REQUEST_URI'], $m)) {\n            /** @retrocompatibility Are we in a module ? */\n            $page_name = 'module-' . $m[1] . '-' . str_replace(['.php', '/'], ['', '-'], $m[2]);\n        } else {\n            $page_name = Dispatcher::getInstance()->getController();\n            $page_name = (preg_match('/^[0-9]/', $page_name) ? 'page_' . $page_name : $page_name);\n        }\n\n        return $page_name;\n    }\n\n    protected function render($template, array $params = [])\n    {\n        $templateContent = '';\n        $scope = $this->context->smarty->createData(\n            $this->context->smarty\n        );\n\n        $scope->assign($params);\n\n        try {\n            $tpl = $this->context->smarty->createTemplate(\n                $this->getTemplateFile($template),\n                $scope\n            );\n\n            $templateContent = $tpl->fetch();\n        } catch (PrestaShopException $e) {\n            PrestaShopLogger::addLog($e->getMessage());\n\n            if (defined('_PS_MODE_DEV_') && _PS_MODE_DEV_) {\n                $this->warning[] = $e->getMessage();\n                $scope->assign(['notifications' => $this->prepareNotifications()]);\n\n                $tpl = $this->context->smarty->createTemplate(\n                    $this->getTemplateFile('_partials/notifications'),\n                    $scope\n                );\n\n                $templateContent = $tpl->fetch();\n            }\n        }\n\n        return $templateContent;\n    }\n\n    protected function getTranslator()\n    {\n        return $this->translator;\n    }\n\n    protected function makeLoginForm()\n    {\n        $form = new CustomerLoginForm(\n            $this->context->smarty,\n            $this->context,\n            $this->getTranslator(),\n            new CustomerLoginFormatter($this->getTranslator()),\n            $this->getTemplateVarUrls()\n        );\n\n        $form->setAction($this->getCurrentURL());\n\n        return $form;\n    }\n\n    protected function makeCustomerFormatter()\n    {\n        $formatter = new CustomerFormatter(\n            $this->getTranslator(),\n            $this->context->language\n        );\n\n        $customer = new Customer();\n\n        $formatter\n            ->setAskForPartnerOptin(Configuration::get('PS_CUSTOMER_OPTIN'))\n            ->setAskForBirthdate(Configuration::get('PS_CUSTOMER_BIRTHDATE'))\n            ->setPartnerOptinRequired($customer->isFieldRequired('optin'));\n\n        return $formatter;\n    }\n\n    protected function makeCustomerForm()\n    {\n        $guestAllowedCheckout = Configuration::get('PS_GUEST_CHECKOUT_ENABLED');\n        $form = new CustomerForm(\n            $this->context->smarty,\n            $this->context,\n            $this->getTranslator(),\n            $this->makeCustomerFormatter(),\n            new CustomerPersister(\n                $this->context,\n                $this->get('hashing'),\n                $this->getTranslator(),\n                $guestAllowedCheckout\n            ),\n            $this->getTemplateVarUrls()\n        );\n\n        $form->setGuestAllowed($guestAllowedCheckout);\n\n        $form->setAction($this->getCurrentURL());\n\n        return $form;\n    }\n\n    protected function makeAddressPersister()\n    {\n        return new CustomerAddressPersister(\n            $this->context->customer,\n            $this->context->cart,\n            Tools::getToken(true, $this->context)\n        );\n    }\n\n    protected function makeAddressForm()\n    {\n        if (Configuration::get('PS_RESTRICT_DELIVERED_COUNTRIES')) {\n            $availableCountries = Carrier::getDeliveredCountries($this->context->language->id, true, true);\n        } else {\n            $availableCountries = Country::getCountries($this->context->language->id, true);\n        }\n\n        $form = new CustomerAddressForm(\n            $this->context->smarty,\n            $this->context->language,\n            $this->getTranslator(),\n            $this->makeAddressPersister(),\n            new CustomerAddressFormatter(\n                $this->context->country,\n                $this->getTranslator(),\n                $availableCountries\n            )\n        );\n\n        $form->setAction($this->getCurrentURL());\n\n        return $form;\n    }\n\n    /**\n     * Get templateFinder.\n     *\n     * @return object\n     */\n    public function getTemplateFinder()\n    {\n        return $this->templateFinder;\n    }\n\n    public function getRestrictedCountry()\n    {\n        return $this->restrictedCountry;\n    }\n\n    public function getAssetUriFromLegacyDeprecatedMethod($legacy_uri)\n    {\n        $success = preg_match('/modules\\/.*/', $legacy_uri, $matches);\n        if (!$success) {\n            Tools::displayAsDeprecated(\n                'Backward compatibility for this method couldn\\'t be handled. Use $this->registerJavascript() instead'\n            );\n\n            return false;\n        } else {\n            return $matches[0];\n        }\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function buildContainer()\n    {\n        return ContainerBuilder::getContainer('front', _PS_MODE_DEV_);\n    }\n\n    /**\n     * @return array containing the URLs of the same page but for different languages\n     */\n    protected function getAlternativeLangsUrl()\n    {\n        $alternativeLangs = [];\n        $languages = Language::getLanguages(true, $this->context->shop->id);\n\n        if (count($languages) < 2) {\n            // No need to display alternative lang if there is only one enabled\n            return $alternativeLangs;\n        }\n\n        foreach ($languages as $lang) {\n            $langUrl = $this->context->link->getLanguageLink($lang['id_lang']);\n            $alternativeLangs[$lang['language_code']] = $this->sanitizeUrl($langUrl);\n        }\n\n        return $alternativeLangs;\n    }\n\n    /**\n     * Sanitize / Clean params of an URL\n     *\n     * @param string $url URL to clean\n     *\n     * @return string cleaned URL\n     */\n    protected function sanitizeUrl(string $url): string\n    {\n        $params = [];\n\n        // Extract all parts of the URL\n        $url_details = parse_url($url);\n        if (!empty($url_details['query'])) {\n            parse_str($url_details['query'], $query);\n            $params = $this->sanitizeQueryOutput($query);\n        }\n\n        // Build a list of parameters we won't be sanitizing\n        $excludedKeys = array_merge(\n            ['isolang', 'id_lang', 'controller', 'fc', 'id_product', 'id_category', 'id_manufacturer', 'id_supplier', 'id_cms'],\n            $this->redirectionExtraExcludedKeys\n        );\n\n        // Go through each parameter we got from dispatcher and sanitize it\n        foreach ($params as $key => $value) {\n            if (\n                in_array($key, $excludedKeys)\n                || !Validate::isUrl($key)\n                || !$this->validateInputAsUrl($value)\n            ) {\n                continue;\n            }\n\n            $params[Tools::safeOutput($key)] = is_array($value) ? array_walk_recursive($value, 'Tools::safeOutput') : Tools::safeOutput($value);\n        }\n\n        // Build back the query\n        $str_params = http_build_query($params, '', '&');\n        $sanitizedUrl = preg_replace('/^([^?]*)?.*$/', '$1', $url) . (!empty($str_params) ? '?' . $str_params : '');\n\n        return $sanitizedUrl;\n    }\n\n    /**\n     * Recursively sanitize output query\n     *\n     * @param array $query URL query\n     *\n     * @return array\n     */\n    protected function sanitizeQueryOutput(array $query): array\n    {\n        $params = [];\n        foreach ($query as $key => $value) {\n            if (is_array($value)) {\n                $params[Tools::safeOutput($key)] = $this->sanitizeQueryOutput($value);\n            } else {\n                $params[Tools::safeOutput($key)] = Tools::safeOutput($value);\n            }\n        }\n\n        return $params;\n    }\n\n    /**\n     * Validate data recursively to be sure it's URL compliant\n     *\n     * @return bool\n     */\n    protected function validateInputAsUrl($data): bool\n    {\n        if (is_array($data)) {\n            $returnStatement = true;\n            foreach ($data as $value) {\n                $returnStatement = $returnStatement && $this->validateInputAsUrl($value);\n            }\n\n            return $returnStatement;\n        }\n\n        return Validate::isUrl($data);\n    }\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2024-26148", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "import React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\n\nimport { sleep } from 'lib/utils';\nimport { reduxStore } from 'redux/store';\nimport { overlayRoot } from 'ui/Overlay/Overlay';\n\nimport {\n    CodeMirrorTooltip,\n    ICodeMirrorTooltipProps,\n} from './CodeMirrorTooltip';\n\nfunction mountTooltip(\n    node: Element,\n    props: Omit<ICodeMirrorTooltipProps, 'hide'>,\n    hide: () => void,\n    direction: 'up' | 'down' = null\n) {\n    const tooltipContainer = document.createElement('div');\n    tooltipContainer.id = 'Codemirror-tooltip-container';\n    overlayRoot.appendChild(tooltipContainer);\n\n    const rect = node.getBoundingClientRect();\n    const windowHeight = window.innerHeight;\n    if (direction == null) {\n        // node is at top half of the screen\n        // Show tooltip on bottom\n        direction = windowHeight / 2 > rect.top ? 'down' : 'up';\n    }\n\n    if (direction === 'down') {\n        tooltipContainer.style.top = `${rect.bottom}px`;\n    } else {\n        // up direction\n        tooltipContainer.style.bottom = `${windowHeight - rect.top}px`;\n    }\n\n    tooltipContainer.style.left = `${rect.left}px`;\n    tooltipContainer.style.opacity = '1';\n\n    const mergedProps = {\n        ...props,\n        ...{\n            hide,\n        },\n    };\n    // Init the react stuff\n    ReactDOM.render(\n        <Provider store={reduxStore}>\n            <CodeMirrorTooltip {...mergedProps} />\n        </Provider>,\n        tooltipContainer\n    );\n\n    return tooltipContainer;\n}\n\nfunction unmountTooltip(tooltipContainer: HTMLDivElement) {\n    if (!tooltipContainer.parentNode) {\n        return;\n    }\n    ReactDOM.unmountComponentAtNode(tooltipContainer);\n    tooltipContainer.parentNode.removeChild(tooltipContainer);\n}\n\nfunction isHovered(e: Element) {\n    return e.parentElement.querySelector(':hover') === e;\n}\n\nexport async function showTooltipFor(\n    nodes: Element[],\n    props: Omit<ICodeMirrorTooltipProps, 'hide'>,\n    onNodeHide?: () => void,\n    direction: 'up' | 'down' = null\n) {\n    // This sleep is needed to put this code in eventpool which allosw\n    // the node itself to actually appear in the browser\n    await sleep(1);\n\n    if (!nodes.some((node) => isHovered(node))) {\n        if (onNodeHide) {\n            onNodeHide();\n        }\n        return;\n    }\n    const hoveredNode = nodes.find((node) => isHovered(node));\n    let tooltip = null;\n\n    const hideTooltip = () => {\n        if (tooltip) {\n            tooltip.removeEventListener('mouseenter', onMouseEnter);\n            tooltip.removeEventListener('mouseleave', onMouseOut);\n            unmountTooltip(tooltip);\n            tooltip = null;\n        }\n    };\n    let hideTooltipTimeout: number;\n\n    const hideTooltipAndNode = () => {\n        nodes.forEach((node) => {\n            node.removeEventListener('mouseenter', onMouseEnter);\n            node.removeEventListener('mouseleave', onMouseOut);\n        });\n\n        hideTooltip();\n        if (onNodeHide) {\n            onNodeHide();\n        }\n    };\n\n    const onMouseOut = () => {\n        if (hideTooltipTimeout) {\n            clearTimeout(hideTooltipTimeout);\n        }\n        hideTooltipTimeout = setTimeout(hideTooltipAndNode, 300);\n    };\n\n    const onMouseEnter = () => {\n        if (hideTooltipTimeout) {\n            clearTimeout(hideTooltipTimeout);\n            hideTooltipTimeout = null;\n        }\n    };\n\n    tooltip = mountTooltip(hoveredNode, props, hideTooltipAndNode, direction);\n\n    tooltip.addEventListener('mouseenter', onMouseEnter);\n    tooltip.addEventListener('mouseleave', onMouseOut);\n\n    const poll = setInterval(() => {\n        if (tooltip) {\n            // if node no longer exists in body, remove both\n            let n: Node & ParentNode = hoveredNode;\n            while (true) {\n                if (n === document.body) {\n                    break;\n                }\n\n                if (!n) {\n                    // no parent\n                    hideTooltipAndNode();\n                    break;\n                } else {\n                    n = n.parentNode;\n                }\n            }\n        }\n\n        if (!tooltip) {\n            clearInterval(poll);\n        }\n    }, 400);\n\n    nodes.forEach((node) => {\n        node.addEventListener('mouseenter', onMouseEnter);\n        node.addEventListener('mouseleave', onMouseOut);\n    });\n\n    return tooltip;\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2024-27083", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "<!-- extend base layout -->\n{% extends \"appbuilder/base.html\" %}\n\n{% block content %}\n\n<script type=\"text/javascript\">\n    var baseLoginUrl = \"{{appbuilder.get_url_for_login}}\";\n    var baseRegisterUrl = \"{{appbuilder.get_url_for_login}}\";\n    var next = \"?next=\" + encodeURIComponent(\"{{request.args.get('next', '') | safe}}\");\n\n    function signin(provider) {\n        window.location.href = baseLoginUrl + provider + next;\n    }\n</script>\n\n<div class=\"container\">\n    <div id=\"loginbox\" style=\"margin-top:50px;\" class=\"mainbox col-md-6 col-md-offset-3 col-sm-8 col-sm-offset-2\">\n        <div class=\"panel panel-primary\">\n            <div class=\"panel-heading\">\n                <div class=\"panel-title\">{{ title }}</div>\n            </div>\n            <div style=\"padding-top:30px\" class=\"panel-body\">\n                <div>\n                    {% for provider in providers %}\n                    <a\n                        onclick=\"signin('{{ provider.name }}');\"\n                        class=\"btn btn-primary btn-block\"\n                        type=\"submit\"\n                    >\n                        {{_('Sign In with ')}}{{ provider.name }}\n                        <i id=\"{{provider.name}}\" class=\"provider-select fa {{provider.icon}} fa-1x\"></i>\n                    </a>\n                    {% endfor %}\n                </div>\n            </div>\n        </div>\n    </div>\n</div>\n\n{% endblock %}", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2024-27104", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "<?php\n\n/**\n * ---------------------------------------------------------------------\n *\n * GLPI - Gestionnaire Libre de Parc Informatique\n *\n * http://glpi-project.org\n *\n * @copyright 2015-2023 Teclib' and contributors.\n * @copyright 2003-2014 by the INDEPNET Development Team.\n * @licence   https://www.gnu.org/licenses/gpl-3.0.html\n *\n * ---------------------------------------------------------------------\n *\n * LICENSE\n *\n * This file is part of GLPI.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n * ---------------------------------------------------------------------\n */\n\nnamespace Glpi\\Dashboard;\n\nuse Glpi\\Plugin\\Hooks;\nuse Glpi\\RichText\\RichText;\nuse Html;\nuse Mexitek\\PHPColors\\Color;\nuse Michelf\\MarkdownExtra;\nuse Plugin;\nuse ScssPhp\\ScssPhp\\Compiler;\nuse Symfony\\Component\\DomCrawler\\Crawler;\nuse Search;\nuse Toolbox;\n\n/**\n * Widget class\n **/\nclass Widget\n{\n    public static $animation_duration = 1000; // in millseconds\n\n\n    /**\n     * Define all possible widget types with their $labels/\n     * This is used when adding a new card to display optgroups\n     * This array can be hooked by plugins to add their own definitions.\n     *\n     * @return array\n     */\n    public static function getAllTypes(): array\n    {\n        /** @var array $CFG_GLPI */\n        global $CFG_GLPI;\n\n        $types = [\n            'pie' => [\n                'label'    => __(\"Pie\"),\n                'function' => 'Glpi\\\\Dashboard\\\\Widget::pie',\n                'image'    => $CFG_GLPI['root_doc'] . '/pics/charts/pie.png',\n                'gradient' => true,\n                'limit'    => true,\n                'width'    => 3,\n                'height'   => 3,\n            ],\n            'donut' => [\n                'label'    => __(\"Donut\"),\n                'function' => 'Glpi\\\\Dashboard\\\\Widget::donut',\n                'image'    => $CFG_GLPI['root_doc'] . '/pics/charts/donut.png',\n                'gradient' => true,\n                'limit'    => true,\n                'width'    => 3,\n                'height'   => 3,\n            ],\n            'halfpie' => [\n                'label'    => __(\"Half pie\"),\n                'function' => 'Glpi\\\\Dashboard\\\\Widget::halfPie',\n                'image'    => $CFG_GLPI['root_doc'] . '/pics/charts/halfpie.png',\n                'gradient' => true,\n                'limit'    => true,\n                'width'    => 3,\n                'height'   => 2,\n            ],\n            'halfdonut' => [\n                'label'    => __(\"Half donut\"),\n                'function' => 'Glpi\\\\Dashboard\\\\Widget::halfDonut',\n                'image'    => $CFG_GLPI['root_doc'] . '/pics/charts/halfdonut.png',\n                'gradient' => true,\n                'limit'    => true,\n                'width'    => 3,\n                'height'   => 2,\n            ],\n            'bar' => [\n                'label'    => __(\"Bars\"),\n                'function' => 'Glpi\\\\Dashboard\\\\Widget::simpleBar',\n                'image'    => $CFG_GLPI['root_doc'] . '/pics/charts/bar.png',\n                'gradient' => true,\n                'limit'    => true,\n                'pointlbl' => true,\n                'width'    => 4,\n                'height'   => 3,\n            ],\n            'line' => [\n                'label'    => \\Line::getTypeName(1),\n                'function' => 'Glpi\\\\Dashboard\\\\Widget::simpleLine',\n                'image'    => $CFG_GLPI['root_doc'] . '/pics/charts/line.png',\n                'limit'    => true,\n                'pointlbl' => true,\n                'width'    => 4,\n                'height'   => 3,\n            ],\n            'lines' => [\n                'label'    => __(\"Multiple lines\"),\n                'function' => 'Glpi\\\\Dashboard\\\\Widget::multipleLines',\n                'image'    => $CFG_GLPI['root_doc'] . '/pics/charts/line.png',\n                'gradient' => true,\n                'limit'    => true,\n                'pointlbl' => true,\n                'width'    => 4,\n                'height'   => 3,\n            ],\n            'area' => [\n                'label'    => __(\"Area\"),\n                'function' => 'Glpi\\\\Dashboard\\\\Widget::simpleArea',\n                'image'    => $CFG_GLPI['root_doc'] . '/pics/charts/area.png',\n                'limit'    => true,\n                'pointlbl' => true,\n                'width'    => 4,\n                'height'   => 3,\n            ],\n            'areas' => [\n                'label'    => __(\"Multiple areas\"),\n                'function' => 'Glpi\\\\Dashboard\\\\Widget::multipleAreas',\n                'image'    => $CFG_GLPI['root_doc'] . '/pics/charts/area.png',\n                'gradient' => true,\n                'limit'    => true,\n                'pointlbl' => true,\n                'width'    => 5,\n                'height'   => 3,\n            ],\n            'bars' => [\n                'label'    => __(\"Multiple bars\"),\n                'function' => 'Glpi\\\\Dashboard\\\\Widget::multipleBars',\n                'image'    => $CFG_GLPI['root_doc'] . '/pics/charts/bar.png',\n                'gradient' => true,\n                'limit'    => true,\n                'pointlbl' => true,\n                'width'    => 5,\n                'height'   => 3,\n            ],\n            'hBars' => [\n                'label'    => __(\"Multiple horizontal bars\"),\n                'function' => 'Glpi\\\\Dashboard\\\\Widget::multipleHBars',\n                'image'    => $CFG_GLPI['root_doc'] . '/pics/charts/hbar.png',\n                'gradient' => true,\n                'limit'    => true,\n                'pointlbl' => true,\n                'width'    => 5,\n                'height'   => 3,\n            ],\n            'stackedbars' => [\n                'label'    => __(\"Stacked bars\"),\n                'function' => 'Glpi\\\\Dashboard\\\\Widget::StackedBars',\n                'image'    => $CFG_GLPI['root_doc'] . '/pics/charts/stacked.png',\n                'gradient' => true,\n                'limit'    => true,\n                'pointlbl' => true,\n                'width'    => 4,\n                'height'   => 3,\n            ],\n            'stackedHBars' => [\n                'label'    => __(\"Horizontal stacked bars\"),\n                'function' => 'Glpi\\\\Dashboard\\\\Widget::stackedHBars',\n                'image'    => $CFG_GLPI['root_doc'] . '/pics/charts/hstacked.png',\n                'gradient' => true,\n                'limit'    => true,\n                'pointlbl' => true,\n                'width'    => 4,\n                'height'   => 3,\n            ],\n            'hbar' => [\n                'label'    => __(\"Horizontal bars\"),\n                'function' => 'Glpi\\\\Dashboard\\\\Widget::simpleHbar',\n                'image'    => $CFG_GLPI['root_doc'] . '/pics/charts/hbar.png',\n                'gradient' => true,\n                'limit'    => true,\n                'pointlbl' => true,\n                'width'    => 3,\n                'height'   => 4,\n            ],\n            'bigNumber' => [\n                'label'    => __(\"Big number\"),\n                'function' => 'Glpi\\\\Dashboard\\\\Widget::bigNumber',\n                'image'    => $CFG_GLPI['root_doc'] . '/pics/charts/bignumber.png',\n            ],\n            'multipleNumber' => [\n                'label'    => __(\"Multiple numbers\"),\n                'function' => 'Glpi\\\\Dashboard\\\\Widget::multipleNumber',\n                'image'    => $CFG_GLPI['root_doc'] . '/pics/charts/multiplenumbers.png',\n                'limit'    => true,\n                'gradient' => true,\n                'width'    => 3,\n                'height'   => 3,\n            ],\n            'markdown' => [\n                'label'    => __(\"Editable markdown\"),\n                'function' => 'Glpi\\\\Dashboard\\\\Widget::markdown',\n                'image'    => $CFG_GLPI['root_doc'] . '/pics/charts/markdown.png',\n                'width'    => 4,\n                'height'   => 4,\n            ],\n            'searchShowList' => [\n                'label'    => __(\"Search result\"),\n                'function' => 'Glpi\\\\Dashboard\\\\Widget::searchShowList',\n                'image'    => $CFG_GLPI['root_doc'] . '/pics/charts/table.png',\n                'limit'    => true,\n                'width'    => 5,\n                'height'   => 4,\n            ],\n            'summaryNumbers' => [\n                'label'    => __(\"Summary numbers\"),\n                'function' => 'Glpi\\\\Dashboard\\\\Widget::summaryNumber',\n                'image'    => $CFG_GLPI['root_doc'] . '/pics/charts/summarynumber.png',\n                'limit'    => true,\n                'gradient' => true,\n                'width'    => 4,\n                'height'   => 2,\n            ],\n            'articleList' => [\n                'label'    => __(\"List of articles\"),\n                'function' => 'Glpi\\\\Dashboard\\\\Widget::articleList',\n                'image'    => $CFG_GLPI['root_doc'] . '/pics/charts/articles.png',\n                'limit'    => true,\n                'width'    => 3,\n                'height'   => 4,\n            ],\n        ];\n\n        $more_types = Plugin::doHookFunction(Hooks::DASHBOARD_TYPES);\n        if (is_array($more_types)) {\n            $types = array_merge($types, $more_types);\n        }\n\n        return $types;\n    }\n\n\n    /**\n     * Display a big number widget.\n     *\n     * @param array $params contains these keys:\n     * - int    'number': the number to display\n     * - string 'url': url to redirect when clicking on the widget\n     * - string 'label': title of the widget\n     * - string 'alt': tooltip\n     * - string 'color': hex color of the widget\n     * - string 'icon': font awesome class to display an icon side of the label\n     * - string 'id': unique dom identifier\n     * - array  'filters': array of filter's id to apply classes on widget html\n     *\n     * @return string html of the widget\n     */\n    public static function bigNumber(array $params = []): string\n    {\n        $default = [\n            'number'  => 0,\n            'url'     => '',\n            'label'   => '',\n            'alt'     => '',\n            'color'   => '',\n            'icon'    => '',\n            'id'      => 'bn_' . mt_rand(),\n            'filters' => [],\n        ];\n        $p = array_merge($default, $params);\n\n        $formatted_number = Toolbox::shortenNumber($p['number']);\n        $fg_color         = Toolbox::getFgColor($p['color']);\n        $fg_hover_color   = Toolbox::getFgColor($p['color'], 15);\n        $fg_hover_border  = Toolbox::getFgColor($p['color'], 30);\n\n        $class = count($p['filters']) > 0 ? \" filter-\" . implode(' filter-', $p['filters']) : \"\";\n\n        $href = strlen($p['url'])\n         ? \"href='{$p['url']}'\"\n         : \"\";\n\n        $label = $p['label'];\n        $html = <<<HTML\n      <style>\n         #{$p['id']} {\n            background-color: {$p['color']};\n            color: {$fg_color};\n         }\n\n         #{$p['id']}:hover {\n            background-color: {$fg_hover_color};\n            border: 1px solid {$fg_hover_border};\n         }\n\n         .theme-dark #{$p['id']} {\n            background-color: {$fg_color};\n            color: {$p['color']};\n         }\n\n         .theme-dark #{$p['id']}:hover {\n            background-color: {$fg_hover_color};\n            color: {$fg_color};\n            border: 1px solid {$fg_hover_border};\n         }\n      </style>\n      <a {$href}\n         id=\"{$p['id']}\"\n         class=\"card big-number $class\"\n         title=\"{$p['alt']}\">\n         <span class=\"content\">$formatted_number</span>\n         <div class=\"label\" title=\"{$label}\">{$label}</div>\n         <i class=\"main-icon {$p['icon']}\"></i>\n      </a>\nHTML;\n\n        return $html;\n    }\n\n\n    public static function summaryNumber(array $params = []): string\n    {\n        $params['class'] = 'summary-numbers';\n        return self::multipleNumber($params);\n    }\n\n\n    /**\n     * Display a multiple big number widget.\n     *\n     * @param array $params contains these keys:\n     * - array  'data': represents the lines to display\n     *    - int    'number': the number to display in the line\n     *    - string 'url': url to redirect when clicking on the line\n     *    - string 'label': title of the line\n     *    - string 'number': number to display in the line\n     *    - string 'icon': font awesome class to display an icon side of the line\n     *    - int    'limit': the numbers of lines diplayed\n     * - string 'label': global title of the widget\n     * - string 'alt': tooltip\n     * - string 'color': hex color of the widget\n     * - string 'icon': font awesome class to display an icon side of the label\n     * - string 'id': unique dom identifier\n     * - array  'filters': array of filter's id to apply classes on widget html\n     *\n     * @return string html of the widget\n     */\n    public static function multipleNumber(array $params = []): string\n    {\n        $default = [\n            'data'         => [],\n            'label'        => '',\n            'alt'          => '',\n            'color'        => '',\n            'icon'         => '',\n            'limit'        => 99999,\n            'use_gradient' => false,\n            'class'        => \"multiple-numbers\",\n            'filters'      => [],\n            'rand'         => mt_rand(),\n        ];\n        $p = array_merge($default, $params);\n        $default_entry = [\n            'url'    => '',\n            'icon'   => '',\n            'label'  => '',\n            'number' => '',\n        ];\n\n        $nb_lines = min($p['limit'], count($p['data']));\n        array_splice($p['data'], $nb_lines);\n\n        $fg_color = Toolbox::getFgColor($p['color']);\n\n        $class = $p['class'];\n        $class .= count($p['filters']) > 0 ? \" filter-\" . implode(' filter-', $p['filters']) : \"\";\n\n        $numbers_html = \"\";\n        $i = 0;\n        foreach ($p['data'] as $entry) {\n            if (!is_array($entry)) {\n                continue;\n            }\n            $entry = array_merge($default_entry, $entry);\n\n            $href = strlen($entry['url'])\n            ? \"href='{$entry['url']}'\"\n            : \"\";\n\n            $color = isset($entry['color'])\n            ? \"style=\\\"color: {$entry['color']};\\\"\"\n            : \"\";\n\n            $color2 = isset($entry['color'])\n            ? \"style=\\\"color: \" . Toolbox::getFgColor($entry['color'], 20) . \";\\\"\"\n            : \"\";\n\n            $formatted_number = Toolbox::shortenNumber($entry['number']);\n\n            $numbers_html .= <<<HTML\n            <a {$href} class=\"line line-{$i}\">\n               <span class=\"content\" {$color}>$formatted_number</span>\n               <i class=\"icon {$entry['icon']}\" {$color2}></i>\n               <span class=\"label\" {$color2}>{$entry['label']}</span>\n            </a>\nHTML;\n            $i++;\n        }\n\n        $nodata = isset($p['data']['nodata']) && $p['data']['nodata'];\n        if ($nodata) {\n            $numbers_html = \"<span class='line empty-card no-data'>\n               <span class='content'>\n                  <i class='icon fas fa-alert-triangle'></i>\n               </span>\n               <span class='label'>\" . __('No data found') . \"</span>\n            <span>\";\n        }\n\n        $palette_style = \"\";\n        if ($p['use_gradient']) {\n            $palette = self::getGradientPalette($p['color'], $i, false);\n            foreach ($palette['names'] as $index => $letter) {\n                $bgcolor   = $palette['colors'][$index];\n                $bgcolor_h = Toolbox::getFgColor($bgcolor, 10);\n                $color     = Toolbox::getFgColor($bgcolor);\n\n                $palette_style .= \"\n               #chart-{$p['rand']} .line-$letter {\n                  background-color: $bgcolor;\n                  color: $color;\n               }\n\n               #chart-{$p['rand']} .line-$letter:hover {\n                  background-color: $bgcolor_h;\n                  font-weight: bold;\n               }\n            \";\n            }\n        }\n\n        $html = <<<HTML\n      <style>\n         {$palette_style}\n\n         #chart-{$p['rand']} {\n            background-color: {$p['color']};\n            color: {$fg_color};\n         }\n\n         .theme-dark #chart-{$p['rand']} {\n            background-color: {$fg_color};\n            color: {$p['color']};\n         }\n      </style>\n\n      <div class=\"card $class\"\n           id=\"chart-{$p['rand']}\"\n           title=\"{$p['alt']}\">\n         <div class='scrollable'>\n            <div class='table'>\n            {$numbers_html}\n            </div>\n         </div>\n         <span class=\"main-label\">{$p['label']}</span>\n         <i class=\"main-icon {$p['icon']}\" style=\"color: {$fg_color}\"></i>\n      </div>\nHTML;\n\n        return $html;\n    }\n\n\n    /**\n     * Display a widget with a pie chart\n     *\n     * @param array $params contains these keys:\n     * - array  'data': represents the slices to display\n     *    - int    'number': number of the slice\n     *    - string 'url': url to redirect when clicking on the slice\n     *    - string 'label': title of the slice\n     * - string 'label': global title of the widget\n     * - string 'alt': tooltip\n     * - string 'color': hex color of the widget\n     * - string 'icon': font awesome class to display an icon side of the label\n     * - string 'id': unique dom identifier\n     * - bool   'use_gradient': gradient or generic palette\n     * - int    'limit': the number of slices\n     * - bool 'donut': do we want a \"holed\" pie\n     * - bool 'gauge': do we want an half pie\n     * - array  'filters': array of filter's id to apply classes on widget html\n     *\n     * @return string html of the widget\n     */\n    public static function pie(array $params = []): string\n    {\n        $default = [\n            'data'         => [],\n            'label'        => '',\n            'alt'          => '',\n            'color'        => '',\n            'icon'         => '',\n            'donut'        => false,\n            'half'         => false,\n            'use_gradient' => false,\n            'limit'        => 99999,\n            'filters'      => [],\n            'rand'         => mt_rand(),\n        ];\n        $p = array_merge($default, $params);\n        $p['cache_key'] = $p['cache_key'] ?? $p['rand'];\n        $default_entry = [\n            'url'    => '',\n            'icon'   => '',\n            'label'  => '',\n            'number' => '',\n        ];\n\n        $nb_slices = min($p['limit'], count($p['data']));\n        array_splice($p['data'], $nb_slices);\n\n        $nodata   = isset($p['data']['nodata']) && $p['data']['nodata'];\n\n        $fg_color      = Toolbox::getFgColor($p['color']);\n        $dark_bg_color = Toolbox::getFgColor($p['color'], 80);\n        $dark_fg_color = Toolbox::getFgColor($p['color'], 40);\n\n        $chart_id = \"chart-{$p['cache_key']}\";\n\n        $class = \"pie\";\n        $class .= $p['half'] ? \" half\" : \"\";\n        $class .= $p['donut'] ? \" donut\" : \"\";\n        $class .= count($p['filters']) > 0 ? \" filter-\" . implode(' filter-', $p['filters']) : \"\";\n\n        $no_data_html = \"\";\n        if ($nodata) {\n            $no_data_html = \"<span class='empty-card no-data'>\n               <div>\" . __('No data found') . \"</div>\n            <span>\";\n        }\n\n        $nb_series = min($p['limit'], count($p['data']));\n\n        $palette_style = \"\";\n        if ($p['use_gradient']) {\n            $palette_style = self::getCssGradientPalette(\n                $p['color'],\n                $nb_series,\n                \".dashboard #{$chart_id}\",\n                false\n            );\n        }\n\n        $html = <<<HTML\n      <style>\n         #{$chart_id} {\n            background-color: {$p['color']};\n            color: {$fg_color}\n         }\n\n         .theme-dark #{$chart_id} {\n            background-color: {$dark_bg_color};\n            color: {$dark_fg_color};\n         }\n\n         #{$chart_id} .ct-label {\n            fill: {$fg_color};\n            color: {$fg_color};\n         }\n\n         .theme-dark #{$chart_id} .ct-label {\n            fill: {$dark_fg_color};\n            color: {$dark_fg_color};\n         }\n\n         {$palette_style}\n      </style>\n      <div style=\"height: 100%\">\n         <div class=\"card g-chart {$class}\"\n            id=\"{$chart_id}\">\n            <div class=\"chart ct-chart\">{$no_data_html}</div>\n            <span class=\"main-label\">{$p['label']}</span>\n            <i class=\"main-icon {$p['icon']}\"></i>\n         </div>\n      </div>\nHTML;\n\n        if ($nodata) {\n            return $html;\n        }\n\n        $labels = [];\n        $series = [];\n        $total = 0;\n        foreach ($p['data'] as $entry) {\n            $entry = array_merge($default_entry, $entry);\n            $total += $entry['number'];\n\n            $labels[] = $entry['label'];\n            $series[] = [\n                'meta'  => $entry['label'],\n                'value' => $entry['number'],\n                'url'   => $entry['url'],\n            ];\n        }\n        $total_txt = Toolbox::shortenNumber($total, 1, false);\n\n        $labels = json_encode($labels);\n        $series = json_encode($series);\n\n        $chartPadding = 4;\n        $height_divider = 1;\n        $half_opts = \"\";\n        if ($p['half']) {\n            $half_opts = \"\n            startAngle: 270,\n            total: \" . ($total * 2) . \",\n         \";\n            $chartPadding = 9;\n            $height_divider = 2;\n        }\n\n        $donut_opts = \"\n         showLabel: false,\n      \";\n        if ($p['donut']) {\n            $donut_opts = \"\n            donutSolid: true,\n            showLabel: true,\n            labelInterpolationFnc: function(value) {\n               return '{$total_txt}';\n            },\n         \";\n        }\n\n        $donut  = $p['donut'] ? 'true' : 'false';\n        $animation_duration = self::$animation_duration;\n\n        $js = <<<JAVASCRIPT\n      $(function () {\n         if (Dashboard.getActiveDashboard()) {\n            var target = Dashboard.getActiveDashboard().element.find('#{$chart_id} .chart')[0];\n         } else {\n            var target = '#{$chart_id} .chart';\n         }\n         var chart = new Chartist.Pie(target, {\n            labels: {$labels},\n            series: {$series},\n         }, {\n            width: '100%',\n            chartPadding: {$chartPadding},\n            donut: {$donut},\n            $donut_opts\n            $half_opts\n            donutWidth: '50%',\n            plugins: [\n               Chartist.plugins.tooltip({\n                  appendToBody: true,\n                  class: 'dashboard-tooltip'\n               })\n            ]\n         });\n\n\n         chart.on('draw', function(data) {\n            // animate\n            if (data.type === 'slice') {\n               // set url redirecting on slice\n               var url = _.get(data, 'series.url') || \"\";\n               if (url.length > 0) {\n                  data.element.attr({\n                     'data-clickable': true\n                  });\n                  data.element._node.onclick = function() {\n                     if (!Dashboard.getActiveDashboard().edit_mode) {\n                        window.location = url;\n                     }\n                  }\n               }\n\n               // Get the total path length in order to use for dash array animation\n               var pathLength = data.element._node.getTotalLength();\n\n               // Set a dasharray that matches the path length as prerequisite to animate dashoffset\n               data.element.attr({\n                  'stroke-dasharray': pathLength + 'px ' + pathLength + 'px'\n               });\n\n               // Create animation definition while also assigning an ID to the animation for later sync usage\n               var animationDefinition = {\n                  'stroke-dashoffset': {\n                     id: 'anim' + data.index,\n                     dur: {$animation_duration},\n                     from: -pathLength + 'px',\n                     to:  '0px',\n                     easing: Chartist.Svg.Easing.easeOutQuint,\n                     // We need to use `fill: 'freeze'` otherwise our animation will fall back to initial (not visible)\n                     fill: 'freeze'\n                  }\n               };\n\n               // We need to set an initial value before the animation starts as we are not in guided mode which would do that for us\n               data.element.attr({\n                  'stroke-dashoffset': -pathLength + 'px'\n               });\n\n               // We can't use guided mode as the animations need to rely on setting begin manually\n               // See http://gionkunz.github.io/chartist-js/api-documentation.html#chartistsvg-function-animate\n               data.element.animate(animationDefinition, false);\n            }\n\n            // donut center label\n            if (data.type === 'label') {\n               if (data.index === 0) {\n                  var width = data.element.root().width() / 2;\n                  var height = data.element.root().height() / 2;\n                  var fontsize = ((height / {$height_divider}) / (1.3 * \"{$total_txt}\".length));\n                  data.element.attr({\n                     dx: width,\n                     dy: height - ($chartPadding / 2),\n                     'style': 'font-size: '+fontsize,\n                  });\n\n                  // apend real total\n                  var text = new Chartist.Svg('title');\n                  text.text(\"{$total}\");\n                  data.element.append(text);\n               } else {\n                  data.element.remove();\n               }\n            }\n\n            // fade others bars on one mouseouver\n            chart.on('created', function(bar) {\n               $('#{$chart_id} .ct-series')\n                  .mouseover(function() {\n                     $(this).parent().children().addClass('disable-animation');\n                     $(this).addClass('mouseover');\n                     $(this).siblings()\n                        .addClass('notmouseover');\n\n                     $('#{$chart_id} .ct-label')\n                        .addClass('fade');\n                  })\n                  .mouseout(function() {\n                     $(this).removeClass('mouseover');\n                     $(this).siblings()\n                        .removeClass('notmouseover');\n\n                     $('#{$chart_id} .ct-label')\n                        .removeClass('fade');\n                  });\n            });\n         });\n      });\nJAVASCRIPT;\n        $js = \\Html::scriptBlock($js);\n\n        return $html . $js;\n    }\n\n\n    /**\n     * Display a widget with a donut chart\n     * @see self::pie for params\n     *\n     * @return string html\n     */\n    public static function donut(array $params = []): string\n    {\n        return self::pie(array_merge($params, [\n            'donut' => true,\n        ]));\n    }\n\n\n    /**\n     * Display a widget with a half donut chart\n     * @see self::pie for params\n     *\n     * @return string html\n     */\n    public static function halfDonut(array $params = []): string\n    {\n        return self::donut(array_merge($params, [\n            'half' => true,\n        ]));\n    }\n\n    /**\n     * Display a widget with a half pie chart\n     * @see self::pie for params\n     *\n     * @return string html\n     */\n    public static function halfPie(array $params = []): string\n    {\n        return self::pie(array_merge($params, [\n            'half' => true,\n        ]));\n    }\n\n\n    /**\n     * Display a widget with a bar chart (with single series)\n     * @see self::getBarsGraph for params\n     *\n     * @return string html\n     */\n    public static function simpleBar(array $params = []): string\n    {\n        $default = [\n            'data'        => [],\n            'label'       => '',\n            'alt'         => '',\n            'color'       => '',\n            'icon'        => '',\n            'horizontal'  => false,\n            'distributed' => true,\n            'rand'        => mt_rand(),\n        ];\n        $params = array_merge($default, $params);\n        $default_entry = [\n            'url'    => '',\n            'icon'   => '',\n            'label'  => '',\n            'number' => '',\n        ];\n\n        $labels = [];\n        $series = [];\n        $total = 0;\n        foreach ($params['data'] as $entry) {\n            if (!is_array($entry)) {\n                continue;\n            }\n            $entry = array_merge($default_entry, $entry);\n            $total += $entry['number'];\n\n            $labels[] = $entry['label'];\n            $series[] = [\n                'meta'  => $entry['label'],\n                'value' => $entry['number'],\n                'url'   => $entry['url'],\n            ];\n        }\n\n       // chartist bar graphs are always multiple lines\n        if (!$params['distributed']) {\n            $series = [$series];\n        }\n\n        return self::getBarsGraph($params, $labels, $series);\n    }\n\n\n    /**\n     * Display a widget with an horizontal bar chart\n     * @see self::getBarsGraph for params\n     *\n     * @return string html\n     */\n    public static function simpleHbar(array $params = []): string\n    {\n        return self::simpleBar(array_merge($params, [\n            'horizontal' => true,\n        ]));\n    }\n\n    /**\n     * @inheritdoc self::simpleHbar\n     */\n    public static function hbar(array $params = []): string\n    {\n        return self::simpleHbar($params);\n    }\n\n\n    /**\n     * Display a widget with a multiple bars chart\n     * @see self::getBarsGraph for params\n     *\n     * @return string html\n     */\n    public static function multipleBars(array $params = []): string\n    {\n        return self::getBarsGraph(\n            array_merge($params, [\n                'legend'   => true,\n                'multiple' => true,\n            ]),\n            $params['data']['labels'],\n            $params['data']['series']\n        );\n    }\n\n\n    /**\n     * Display a widget with a stacked multiple bars chart\n     * @see self::getBarsGraph for params\n     *\n     * @return string html\n     */\n    public static function StackedBars(array $params = []): string\n    {\n        return self::multipleBars(array_merge($params, [\n            'stacked' => true,\n        ]));\n    }\n\n\n    /**\n     * Display a widget with a horizontal stacked multiple bars chart\n     * @see self::getBarsGraph for params\n     *\n     * @return string html\n     */\n    public static function stackedHBars(array $params = []): string\n    {\n        return self::StackedBars(array_merge($params, [\n            'horizontal' => true,\n        ]));\n    }\n\n\n    /**\n     * Display a widget with a horizontal multiple bars chart\n     * @see self::getBarsGraph for params\n     *\n     * @return string html\n     */\n    public static function multipleHBars(array $params = []): string\n    {\n        return self::multipleBars(array_merge($params, [\n            'horizontal' => true,\n        ]));\n    }\n\n\n    /**\n     * Display a widget with a bars chart\n     *\n     * @param array $params contains these keys:\n     * - array  'data': represents the bars to display\n     *    - string 'url': url to redirect when clicking on the bar\n     *    - string 'label': title of the bar\n     *    - int     'number': number of the bar\n     * - string 'label': global title of the widget\n     * - string 'alt': tooltip\n     * - string 'color': hex color of the widget\n     * - string 'icon': font awesome class to display an icon side of the label\n     * - string 'id': unique dom identifier\n     * - bool   'horizontal': do we want an horizontal chart\n     * - bool   'distributed': do we want a distributed chart (see https://gionkunz.github.io/chartist-js/examples.html#example-bar-distributed-series)\n     * - bool   'legend': do we display a legend for the graph\n     * - bool   'stacked': do we display multiple bart stacked or grouped\n     * - bool   'use_gradient': gradient or generic palette\n     * - bool   'point_labels': display labels (for values) directly on graph\n     * - int    'limit': the number of bars\n     * - array  'filters': array of filter's id to apply classes on widget html\n     * @param array $labels title of the bars (if a single array is given, we have a single bar graph)\n     * @param array $series values of the bar (if a single array is given, we have a single bar graph)\n     *\n     * @return string html of the widget\n     */\n    private static function getBarsGraph(\n        array $params = [],\n        array $labels = [],\n        array $series = []\n    ): string {\n\n        $defaults = [\n            'label'        => '',\n            'alt'          => '',\n            'color'        => '',\n            'icon'         => '',\n            'legend'       => false,\n            'multiple'     => false,\n            'stacked'      => false,\n            'horizontal'   => false,\n            'distributed'  => false,\n            'use_gradient' => false,\n            'point_labels' => false,\n            'limit'        => 99999,\n            'filters'      => [],\n            'rand'         => mt_rand(),\n        ];\n        $p = array_merge($defaults, $params);\n\n        $p['cache_key'] = $p['cache_key'] ?? $p['rand'];\n        $nb_series = count($series);\n        $nb_labels = min($p['limit'], count($labels));\n        if ($p['distributed']) {\n            array_splice($labels, $nb_labels);\n        } else {\n            array_splice($labels, 0, -$nb_labels);\n        }\n        if ($p['multiple']) {\n            foreach ($series as &$serie) {\n                if (isset($serie['data'])) {\n                    array_splice($serie['data'], 0, -$nb_labels);\n                }\n            }\n        } else {\n            if ($p['distributed']) {\n                array_splice($series, $nb_labels);\n            } else {\n                array_splice($series[0], 0, -$nb_labels);\n            }\n        }\n\n        $json_labels = json_encode($labels);\n        $json_series = json_encode($series);\n\n        $fg_color        = Toolbox::getFgColor($p['color']);\n        $line_color      = Toolbox::getFgColor($p['color'], 10);\n        $dark_bg_color   = Toolbox::getFgColor($p['color'], 80);\n        $dark_fg_color   = Toolbox::getFgColor($p['color'], 40);\n        $dark_line_color = Toolbox::getFgColor($p['color'], 90);\n\n        $animation_duration = self::$animation_duration;\n\n        $chart_id = 'chart_' . $p['cache_key'];\n\n        $class = \"bar\";\n        $class .= $p['horizontal'] ? \" horizontal\" : \"\";\n        $class .= $p['distributed'] ? \" distributed\" : \"\";\n        $class .= $nb_series <= 10 ? \" tab10\" : \"\";\n        $class .= $nb_series > 10 ? \" tab20\" : \"\";\n        $class .= count($p['filters']) > 0 ? \" filter-\" . implode(' filter-', $p['filters']) : \"\";\n\n        $palette_style = \"\";\n        if ($p['use_gradient']) {\n            $nb_gradients = $p['distributed'] ? $nb_labels : $nb_series;\n            $palette_style = self::getCssGradientPalette($p['color'], $nb_gradients, \"#{$chart_id}\");\n        }\n\n        $nodata = isset($p['data']['nodata']) && $p['data']['nodata']\n                || count($series) == 0;\n        $no_data_html = \"\";\n        if ($nodata) {\n            $no_data_html = \"<span class='empty-card no-data'>\n               <div>\" . __('No data found') . \"</div>\n            <span>\";\n        }\n\n        $legend_options = \"\";\n        if ($p['legend']) {\n            $legend_options = \"\n            Chartist.plugins.legend(),\";\n        }\n\n        $html = <<<HTML\n      <style>\n      #{$chart_id} {\n         background-color: {$p['color']};\n         color: {$fg_color}\n      }\n\n      .theme-dark #{$chart_id} {\n         background-color: {$dark_bg_color};\n         color: {$dark_fg_color};\n      }\n\n      #{$chart_id} .ct-label {\n         color: {$fg_color};\n      }\n\n      .theme-dark #{$chart_id} .ct-label {\n         color: {$dark_fg_color};\n      }\n\n      #{$chart_id} .ct-grid {\n         stroke: {$line_color};\n      }\n\n      .theme-dark #{$chart_id} .ct-grid {\n         stroke: {$dark_line_color};\n      }\n\n      {$palette_style}\n      </style>\n\n      <div style=\"height: 100%\">\n         <div class=\"card g-chart $class\"\n               id=\"{$chart_id}\">\n            <div class=\"chart ct-chart\">$no_data_html</div>\n            <span class=\"main-label\">{$p['label']}</span>\n            <i class=\"main-icon {$p['icon']}\"></i>\n         </div>\n      </div>\nHTML;\n\n        $horizontal_options = \"\";\n        $vertical_options   = \"\";\n        $is_horizontal      = \"false\";\n        if ($p['horizontal']) {\n            $is_horizontal = \"true\";\n            $horizontal_options = \"\n            horizontalBars: true,\n            axisY: {\n               offset: 100\n            },\n            axisX: {\n               onlyInteger: true\n            },\n         \";\n        } else {\n            $vertical_options = \"\n            axisX: {\n               offset: 50,\n            },\n            axisY: {\n               onlyInteger: true\n            },\n         \";\n        }\n\n        $stack_options = \"\";\n        if ($p['stacked']) {\n            $stack_options = \"\n            stackBars: true,\";\n        }\n\n        $distributed_options = \"\";\n        if ($p['distributed']) {\n            $distributed_options = \"\n            distributeSeries: true,\";\n        }\n\n       // just to avoid issues with syntax coloring\n        $point_labels = $p['point_labels'] ? \"true\" : \"false;\";\n        $is_multiple  = $p['multiple'] ? \"true\" : \"false;\";\n\n        $js = <<<JAVASCRIPT\n      $(function () {\n         if (Dashboard.getActiveDashboard()) {\n            var target = Dashboard.getActiveDashboard().element.find('#{$chart_id} .chart')[0];\n         } else {\n            var target = '#{$chart_id} .chart';\n         }\n         var chart = new Chartist.Bar(target, {\n            labels: {$json_labels},\n            series: {$json_series},\n         }, {\n            width: '100%',\n            seriesBarDistance: 10,\n            chartPadding: 0,\n            $distributed_options\n            $horizontal_options\n            $vertical_options\n            $stack_options\n            plugins: [\n               $legend_options\n               Chartist.plugins.tooltip({\n                  appendToBody: true,\n                  class: 'dashboard-tooltip'\n               })\n            ]\n         });\n\n         var is_horizontal = chart.options.horizontalBars;\n         var is_vertical   = !is_horizontal;\n         var is_stacked    = chart.options.stackBars;\n         var nb_elements   = chart.data.labels.length;\n         var nb_series     = chart.data.series.length;\n         var bar_margin    = chart.options.seriesBarDistance;\n         var point_labels  = {$point_labels}\n         var is_multiple   = {$is_multiple}\n\n         if (!chart.options.stackBars\n             && chart.data.series.length > 0\n             && chart.data.series[0].hasOwnProperty('data')) {\n            nb_elements = nb_elements * chart.data.series.length;\n            bar_margin += 1;\n         }\n\n         chart.on('draw', function(data) {\n            if (data.type === 'bar') {\n               // set url redirecting on bar\n               var url = _.get(data, 'series['+data.index+'].url')\n                  || _.get(data, 'series.data['+data.index+'].url')\n                  || _.get(data, 'series.url')\n                  || \"\";\n               if (url.length > 0) {\n                  data.element.attr({\n                     'data-clickable': true\n                  });\n                  data.element._node.onclick = function() {\n                     if (!Dashboard.getActiveDashboard().edit_mode) {\n                        window.location = url;\n                     }\n                  }\n               }\n\n               var chart_height = data.chartRect.height();\n               var chart_width = data.chartRect.width();\n\n               var stroke_width = chart_width / nb_elements;\n               if (is_horizontal) {\n                  stroke_width = chart_height / nb_elements;\n               }\n\n               if (!chart.options.stackBars\n                  && chart.data.series.length > 0 && is_vertical) {\n                  stroke_width -= bar_margin * nb_elements;\n               } else {\n                  stroke_width -= bar_margin;\n               }\n               data.element.attr({\n                  'style': 'stroke-width: '+stroke_width+'px'\n               });\n\n               var axis_anim = 'y';\n               if ({$is_horizontal}) {\n                  axis_anim = 'x';\n               }\n\n               var animate_properties = {\n                  opacity: {\n                     dur: {$animation_duration},\n                     from: 0,\n                     to: 1,\n                     easing: Chartist.Svg.Easing.easeOutQuint\n                  }\n               };\n               animate_properties[axis_anim+'2'] = {\n                  dur: {$animation_duration},\n                  from: data[axis_anim+'1'],\n                  to: data[axis_anim+'2'],\n                  easing: Chartist.Svg.Easing.easeOutQuint\n               };\n               data.element.animate(animate_properties);\n\n               // append labels\n               var display_labels = true;\n               var labelX = 0;\n               var labelY = 0;\n               var value = data.element.attr('ct:value').toString();\n               var text_anchor = 'middle';\n\n               if (is_vertical) {\n                  labelX = data.x2;\n                  labelY = data.y2 + 15;\n\n                  if (is_multiple) {\n                     labelY = data.y2 - 5;\n                  } else if (data.y1 - data.y2 < 18) {\n                     display_labels = false;\n                  }\n               }\n\n               if (is_horizontal) {\n                  var word_width = value.length * 5 + 5;\n                  var bar_width = 0;\n\n                  if (value > 0) {\n                     labelX = data.x2 - word_width;\n                     bar_width = data.x2 - data.x1;\n                  } else {\n                     labelX = data.x2 + word_width;\n                     bar_width = data.x1 - data.x2;\n                  }\n                  labelY = data.y2;\n\n                  // don't display label if width too short\n                  if (bar_width < word_width) {\n                     display_labels = false;\n                  }\n               }\n\n               if (is_stacked) {\n                  labelY = data.y2 + 15;\n\n                  // don't display label if height too short\n                  if (is_horizontal) {\n                     if (data.x2 - data.x1 < 15) {\n                        display_labels = false;\n                     }\n                  } else {\n                     if (data.y1 - data.y2 < 15) {\n                        display_labels = false;\n                     }\n                  }\n               }\n\n               // don't display label if value is not relevant\n               if (value == 0 || !point_labels) {\n                  display_labels = false;\n               }\n\n               if (display_labels) {\n                  label = new Chartist.Svg('text');\n                  label.text(value);\n                  label.addClass(\"ct-barlabel\");\n                  label.attr({\n                     x: labelX,\n                     y: labelY,\n                     'text-anchor': text_anchor\n                  });\n                  return data.group.append(label);\n               }\n            }\n         });\n\n         chart.on('created', function(bar) {\n            $('#{$chart_id} .ct-series')\n               .mouseover(function() {\n                  $(this).siblings().children().css('stroke-opacity', \"0.2\");\n               })\n               .mouseout(function() {\n                  $(this).siblings().children().css('stroke-opacity', \"1\");\n               });\n         });\n      });\nJAVASCRIPT;\n        $js = \\Html::scriptBlock($js);\n\n        return $html . $js;\n    }\n\n\n    /**\n     * Display a widget with a line chart (with single series)\n     * @see self::getLinesGraph for params\n     *\n     * @return string html\n     */\n    public static function simpleLine(array $params = []): string\n    {\n        $default_entry = [\n            'url'    => '',\n            'icon'   => '',\n            'label'  => '',\n            'number' => '',\n        ];\n\n        $labels = [];\n        $series = [];\n        foreach ($params['data'] as $entry) {\n            $entry = array_merge($default_entry, $entry);\n\n            $labels[] = $entry['label'];\n            $series[] = [\n                'meta'  => $entry['label'],\n                'value' => $entry['number'],\n                'url'   => $entry['url'],\n            ];\n        }\n\n       // chartist line graphs are always multiple lines\n        $series = [$series];\n\n        return self::getLinesGraph($params, $labels, $series);\n    }\n\n\n    /**\n     * Display a widget with a area chart (with single serie)\n     * @see self::getLinesGraph for params\n     *\n     * @return string html\n     */\n    public static function simpleArea(array $params = []): string\n    {\n        return self::simpleLine(array_merge($params, [\n            'area' => true,\n        ]));\n    }\n\n\n    /**\n     * Display a widget with a multiple line chart (with multiple series)\n     * @see self::getLinesGraph for params\n     *\n     * @return string html\n     */\n    public static function multipleLines(array $params = []): string\n    {\n        return self::getLinesGraph(\n            array_merge($params, [\n                'legend'   => true,\n                'multiple' => true,\n            ]),\n            $params['data']['labels'],\n            $params['data']['series']\n        );\n    }\n\n\n    /**\n     * Display a widget with a multiple area chart (with multiple series)\n     * @see self::getLinesGraph for params\n     *\n     * @return string html\n     */\n    public static function multipleAreas(array $params = []): string\n    {\n        return self::multipleLines(array_merge($params, [\n            'area' => true,\n        ]));\n    }\n\n\n    /**\n     * Display a widget with a lines chart\n     *\n     * @param array $params contains these keys:\n     * - array  'data': represents the lines to display\n     *    - string 'url': url to redirect when clicking on the line\n     *    - string 'label': title of the line\n     *    - int     'number': number of the line\n     * - string 'label': global title of the widget\n     * - string 'alt': tooltip\n     * - string 'color': hex color of the widget\n     * - string 'icon': font awesome class to display an icon side of the label\n     * - string 'id': unique dom identifier\n     * - bool   'area': do we want an area chart\n     * - bool   'legend': do we display a legend for the graph\n     * - bool   'use_gradient': gradient or generic palette\n     * - bool   'point_labels': display labels (for values) directly on graph\n     * - int    'limit': the number of lines\n     * - array  'filters': array of filter's id to apply classes on widget html\n     * @param array $labels title of the lines (if a single array is given, we have a single line graph)\n     * @param array $series values of the line (if a single array is given, we have a single line graph)\n     *\n     * @return string html of the widget\n     */\n    private static function getLinesGraph(\n        array $params = [],\n        array $labels = [],\n        array $series = []\n    ): string {\n\n        $defaults = [\n            'data'         => [],\n            'label'        => '',\n            'alt'          => '',\n            'color'        => '',\n            'icon'         => '',\n            'area'         => false,\n            'legend'       => false,\n            'multiple'     => false,\n            'use_gradient' => false,\n            'point_labels' => false,\n            'limit'        => 99999,\n            'filters'      => [],\n            'rand'         => mt_rand(),\n        ];\n        $p = array_merge($defaults, $params);\n        $p['cache_key'] = $p['cache_key'] ?? $p['rand'];\n\n        $nb_series = count($series);\n        $nb_labels = min($p['limit'], count($labels));\n        array_splice($labels, 0, -$nb_labels);\n        if ($p['multiple']) {\n            foreach ($series as &$serie) {\n                if (isset($serie['data'])) {\n                    array_splice($serie['data'], 0, -$nb_labels);\n                }\n            }\n        } else {\n            array_splice($series[0], 0, -$nb_labels);\n        }\n\n        $json_labels = json_encode($labels);\n        $json_series = json_encode($series);\n\n        $chart_id = 'chart_' . $p['cache_key'];\n\n        $fg_color        = Toolbox::getFgColor($p['color']);\n        $line_color      = Toolbox::getFgColor($p['color'], 10);\n        $dark_bg_color   = Toolbox::getFgColor($p['color'], 80);\n        $dark_fg_color   = Toolbox::getFgColor($p['color'], 40);\n        $dark_line_color = Toolbox::getFgColor($p['color'], 90);\n\n        $class = \"line\";\n        $class .= $p['area'] ? \" area\" : \"\";\n        $class .= $p['multiple'] ? \" multiple\" : \"\";\n        $class .= count($p['filters']) > 0 ? \" filter-\" . implode(' filter-', $p['filters']) : \"\";\n\n        $animation_duration = self::$animation_duration;\n\n        $palette_style = \"\";\n        if (!$p['multiple'] || $p['use_gradient']) {\n            $palette_style = self::getCssGradientPalette($p['color'], $nb_series, \"#{$chart_id}\");\n        }\n\n        $pointlabels_plugins = \"\";\n        if ($p['point_labels']) {\n            $pointlabels_plugins = \",\n            Chartist.plugins.ctPointLabels({\n               textAnchor: 'middle',\n               labelInterpolationFnc: function(value) {\n                  if (value == undefined) {\n                     return ''\n                  }\n                  return value;\n               }\n            })\";\n        }\n\n        $legend_options = \"\";\n        if ($p['legend']) {\n            $legend_options = \"\n            Chartist.plugins.legend(),\";\n        }\n\n        // Adding a legend will add an \"<ul>\" element in a div that already have\n        // a <svg> child set to take 100% of the available height\n        // This will create some overflow that will impact the content below the\n        // graph (the label)\n        // We avoid that by adding some padding at the top of the label if a\n        // legend is defined\n        $label_class = $p['legend'] ? \"mt-4\" : \"\";\n\n        $html = <<<HTML\n      <style>\n\n      #{$chart_id} {\n         background-color: {$p['color']};\n         color: {$fg_color}\n      }\n\n      .theme-dark #{$chart_id} {\n         background-color: {$dark_bg_color};\n         color: {$dark_fg_color};\n      }\n\n      #{$chart_id} .ct-label {\n         color: {$fg_color};\n      }\n\n      .theme-dark #{$chart_id} .ct-label {\n         color: {$dark_fg_color};\n      }\n\n      #{$chart_id} .ct-grid {\n         stroke: {$line_color};\n      }\n\n      .theme-dark #{$chart_id} .ct-grid {\n         stroke: {$dark_line_color};\n      }\n\n      #{$chart_id} .ct-circle {\n         stroke: {$p['color']};\n         stroke-width: 3;\n      }\n      #{$chart_id} .ct-circle + .ct-label {\n         stroke: {$p['color']};\n      }\n      {$palette_style}\n      </style>\n\n      <div style=\"height: 100%\">\n          <div class=\"card g-chart $class\"\n               id=\"{$chart_id}\">\n             <div class=\"chart ct-chart\"></div>\n             <span class=\"main-label {$label_class}\">{$p['label']}</span>\n             <i class=\"main-icon {$p['icon']}\"></i>\n          </div>\n      </div>\nHTML;\n\n        $area_options = \"\";\n        if ($p['area']) {\n            $area_options = \"\n            showArea: true,\";\n        }\n\n        $js = <<<JAVASCRIPT\n      $(function () {\n         if (Dashboard.getActiveDashboard()) {\n            var target = Dashboard.getActiveDashboard().element.find('#{$chart_id} .chart')[0];\n         } else {\n            var target = '#{$chart_id} .chart';\n         }\n         var chart = new Chartist.Line(target, {\n            labels: {$json_labels},\n            series: {$json_series},\n         }, {\n            width: '100%',\n            fullWidth: true,\n            chartPadding: {\n               right: 40\n            },\n            axisY: {\n                labelInterpolationFnc: function(value) {\n                    let display_value = 0;\n                    let unit = \"\";\n                    if (value < 1e3) {\n                        // less than 1K\n                        display_value = value;\n                    } else if (value < 1e6) {\n                        // More than 1k, less than 1M\n                        display_value =  value / 1e3;\n                        unit = \"K\";\n                    } else {\n                        // More than 1M\n                        display_value = value / 1e6;\n                        unit = \"M\";\n                    }\n\n                    // 1 decimal max\n                    display_value = Math.round(display_value * 10) / 10;\n\n                    return display_value + unit;\n                },\n            },\n            {$area_options}\n            plugins: [\n               {$legend_options}\n               Chartist.plugins.tooltip({\n                  appendToBody: true,\n                  class: 'dashboard-tooltip',\n                  pointClass: 'ct-circle'\n               })\n               {$pointlabels_plugins}\n            ]\n         });\n\n         chart.on('draw', function(data) {\n            // animation\n            if (data.type === 'line' || data.type === 'area') {\n               data.element.animate({\n                  d: {\n                     begin: 300 * data.index,\n                     dur: $animation_duration,\n                     from: data.path.clone().scale(1, 0).translate(0, data.chartRect.height()).stringify(),\n                     to: data.path.clone().stringify(),\n                     easing: Chartist.Svg.Easing.easeOutQuint\n                  }\n               });\n            }\n\n            if (data.type === 'point') {\n               // set url redirecting on line\n               var url = _.get(data, 'series['+data.index+'].url')\n                      || _.get(data, 'series.data['+data.index+'].url')\n                      || _.get(data, 'series.url')\n                      || '';\n               var clickable = url.length > 0;\n\n               var circle = new Chartist.Svg('circle', {\n                  cx: [data.x],\n                  cy: [data.y],\n                  r: data.value.y > 0 ? [5] : [0],\n                  \"ct:value\": data.value.y,\n                  \"data-clickable\": clickable\n               }, 'ct-circle');\n               var circle = data.element.replace(circle);\n\n               if (clickable) {\n                  circle.getNode().onclick = function() {\n                     if (!Dashboard.getActiveDashboard().edit_mode) {\n                        window.location = url;\n                     }\n                  }\n               }\n            }\n         });\n\n         // hide other lines when hovering a point\n         chart.on('created', function(bar) {\n            $('#{$chart_id} .ct-series .ct-circle, #{$chart_id} .ct-series .ct-circle + .ct-label')\n               .mouseover(function() {\n                  $(this)\n                     .attr('r', \"9\")\n                     .parent(\".ct-series\")\n                     .siblings().children()\n                     .css('stroke-opacity', \"0.05\")\n                     .filter(\".ct-circle, .ct-label\").css('fill-opacity', \"0.1\");\n               })\n               .mouseout(function() {\n                  $(this)\n                     .attr('r', \"5\")\n                     .parent(\".ct-series\")\n                     .siblings().children()\n                     .css('stroke-opacity', \"1\")\n                     .filter(\".ct-circle, .ct-label\").css('fill-opacity', \"1\");\n               });\n         });\n      });\nJAVASCRIPT;\n        $js = Html::scriptBlock($js);\n\n        return $html . $js;\n    }\n\n\n    /**\n     * Display an editable markdown widget\n     *\n     * @param array $params with these keys:\n     * - string 'color': hex color\n     * - string 'markdown_content': text content formatted with warkdown\n     *\n     * @return string html\n     */\n    public static function markdown(array $params = []): string\n    {\n        $default = [\n            'color'             => '',\n            'markdown_content'  => '',\n        ];\n        $p = array_merge($default, $params);\n\n       // fix auto-escaping\n        if (isset($p['markdown_content'])) {\n            $p['markdown_content'] = \\Html::cleanPostForTextArea($p['markdown_content']);\n        }\n\n        $ph           = __(\"Type markdown text here\");\n        $fg_color     = Toolbox::getFgColor($p['color']);\n        $border_color = Toolbox::getFgColor($p['color'], 10);\n        $md           = new MarkdownExtra();\n       // Prevent escaping as code is already escaped by GLPI sanityze\n        $md->code_span_content_func  = function ($code) {\n            return $code;\n        };\n        $md->code_block_content_func = function ($code) {\n            return $code;\n        };\n\n        $html = <<<HTML\n      <div\n         class=\"card markdown\"\n         style=\"background-color: {$p['color']}; color: {$fg_color}; border-color: {$border_color}\">\n\n         <div class=\"html_content\">{$md->transform($p['markdown_content'])}</div>\n         <textarea\n            class=\"markdown_content\"\n            placeholder=\"{$ph}\">{$p['markdown_content']}</textarea>\n\n      </div>\nHTML;\n\n        return $html;\n    }\n\n\n    /**\n     * Display an html table from a \\Search result\n     *\n     * @param array $params contains these keys:\n     * - string 'itemtype': Glpi oObject to search\n     * - array  's_criteria': parameters to pass to the search engine (@see \\Search::manageParams)\n     * - string 'label': global title of the widget\n     * - string 'url': link to the full search result\n     * - string 'alt': tooltip\n     * - string 'color': hex color of the widget\n     * - string 'icon': font awesome class to display an icon side of the label\n     * - string 'id': unique dom identifier\n     * - int    'limit': the number of displayed lines\n     * - array  'filters': array of filter's id to apply classes on widget html\n     *\n     * @return string html of the widget\n     */\n    public static function searchShowList(array $params = []): string\n    {\n        $default = [\n            'url'        => '',\n            'label'      => '',\n            'alt'        => '',\n            'color'      => '',\n            'icon'       => '',\n            's_criteria' => '',\n            'itemtype'   => '',\n            'limit'      => $_SESSION['glpilist_limit'],\n            'rand'       => mt_rand(),\n            'filters'      => [],\n        ];\n        $p = array_merge($default, $params);\n\n        $id = \"search-table-\" . $p['rand'];\n\n        $color = new Color($p['color']);\n        $is_light = $color->isLight();\n\n        $fg_color  = Toolbox::getFgColor($p['color'], $is_light ? 65 : 40);\n        $fg_color2 = Toolbox::getFgColor($p['color'], 5);\n\n        $href = strlen($p['url'])\n         ? \"href='{$p['url']}'\"\n         : \"\";\n\n        $class = count($p['filters']) > 0 ? \" filter-\" . implode(' filter-', $p['filters']) : \"\";\n\n       // prepare search data\n        $_GET['_in_modal'] = true;\n        $params = [\n            'criteria' => $p['s_criteria'],\n            'reset'    => 'reset',\n        ];\n\n        ob_start();\n        $params = Search::manageParams($p['itemtype'], $params, false);\n       // remove parts of search list\n        $params = array_merge($params, [\n            'showmassiveactions' => false,\n            'dont_flush'         => true,\n            'show_pager'         => false,\n            'show_footer'        => false,\n            'no_sort'            => true,\n            'list_limit'         => $p['limit']\n        ]);\n        Search::showList($p['itemtype'], $params);\n\n        $crawler = new Crawler(ob_get_clean());\n        $search_result = $crawler->filter('.search-results')->outerHtml();\n\n        $html = <<<HTML\n      <style>\n         #{$id} .tab_cadrehov th {\n            background: {$fg_color2};\n         }\n      </style>\n      <div\n         class=\"card search-table {$class}\"\n         id=\"{$id}\"\n         style=\"background-color: {$p['color']}; color: {$fg_color}\">\n         <div class='table-container'>\n            $search_result\n         </div>\n         <span class=\"main-label\">\n            <a {$href}>{$p['label']}</a>\n         </span>\n         <i class=\"main-icon {$p['icon']}\"></i>\n      </div>\nHTML;\n\n        return $html;\n    }\n\n\n    public static function articleList(array $params): string\n    {\n        $default = [\n            'data'         => [],\n            'label'        => '',\n            'alt'          => '',\n            'url'          => '',\n            'color'        => '',\n            'icon'         => '',\n            'limit'        => 99999,\n            'class'        => \"articles-list\",\n            'rand'         => mt_rand(),\n            'filters'      => [],\n        ];\n        $p = array_merge($default, $params);\n        $default_entry = [\n            'url'    => '',\n            'icon'   => '',\n            'label'  => '',\n            'number' => '',\n        ];\n\n        $nb_lines = min($p['limit'], count($p['data']));\n        array_splice($p['data'], $nb_lines);\n        $fg_color = Toolbox::getFgColor($p['color']);\n        $bg_color_2 = Toolbox::getFgColor($p['color'], 5);\n\n        $class = $p['class'];\n        $class .= count($p['filters']) > 0 ? \" filter-\" . implode(' filter-', $p['filters']) : \"\";\n\n        $i = 0;\n        $list_html = \"\";\n        foreach ($p['data'] as $entry) {\n            if (!is_array($entry)) {\n                continue;\n            }\n\n            $entry = array_merge($default_entry, $entry);\n\n            $href = strlen($entry['url'])\n            ? \"href='{$entry['url']}'\"\n            : \"\";\n\n            $author = strlen($entry['author'])\n            ? \"<i class='fas fa-user'></i>&nbsp;{$entry['author']}\"\n            : \"\";\n\n            $content_size = strlen($entry['content']);\n            $content = strlen($entry['content'])\n            ? RichText::getEnhancedHtml($entry['content']) .\n              ($content_size > 300\n               ? \"<p class='read_more'><span class='read_more_button'>...</span></p>\"\n               : \"\"\n              )\n             : \"\";\n\n            $list_html .= <<<HTML\n            <li class=\"line\"><a {$href}>\n               <span class=\"label\">{$entry['label']}</span>\n               <div class=\"content long_text\">{$content}</div>\n               <span class=\"author\">$author</span>\n               <span class=\"date\">{$entry['date']}</span>\n            </a></li>\nHTML;\n            $i++;\n        }\n\n        $nodata = isset($p['data']['nodata']) && $p['data']['nodata'];\n        if ($nodata) {\n            $list_html = \"<span class='line empty-card no-data'>\n            <span class='content'>\n               <i class='icon fas fa-exclamation-triangle'></i>\n            </span>\n            <span class='label'>\" . __('No data found') . \"</span>\n         <span>\";\n        }\n\n        $view_all = strlen($p['url'])\n         ? \"<a href='{$p['url']}'><i class='fas fa-eye' title='\" . __(\"See all\") . \"'></i></a>\"\n         : \"\";\n\n        $html = <<<HTML\n      <style>\n         #chart-{$p['rand']} .line {\n            background-color: $bg_color_2;\n         }\n\n         #chart-{$p['rand']} .fa-eye {\n            color: {$fg_color};\n         }\n      </style>\n\n      <div class=\"card {$class}\"\n           id=\"chart-{$p['rand']}\"\n           title=\"{$p['alt']}\"\n           style=\"background-color: {$p['color']}; color: {$fg_color}\">\n         <div class='scrollable'>\n            <ul class='list'>\n            {$list_html}\n   </ul>\n         </div>\n         <span class=\"main-label\">\n            {$p['label']}\n            $view_all\n         </span>\n         <i class=\"main-icon {$p['icon']}\" style=\"color: {$fg_color}\"></i>\n      </div>\nHTML;\n\n        $js = <<<JAVASCRIPT\n      $(function () {\n         // init readmore controls\n         read_more();\n\n         // set dates in relative format\n         $('#chart-{$p['rand']} .date').each(function() {\n            var line_date = $(this).html();\n            var rel_date = relativeDate(line_date);\n\n            $(this).html(rel_date).attr('title', line_date);\n         });\n      });\nJAVASCRIPT;\n        $js = \\Html::scriptBlock($js);\n\n        return $html . $js;\n    }\n\n    /**\n     * Get a gradient palette for a given background color\n     *\n     * @param string $bgcolor the background color in hexadecimal format (Ex: #FFFFFF)\n     * @param int $nb_series how much step in gradient we need\n     * @param bool $revert direction of the gradient\n     *\n     * @return array with [\n     *    'names' => [...]\n     *    'colors' => [...]\n     * ]\n     */\n    public static function getGradientPalette(\n        string $bgcolor = \"\",\n        int $nb_series = 1,\n        bool $revert = true\n    ) {\n        if ($nb_series == 0) {\n            return [\n                'names'  => [],\n                'colors' => [],\n            ];\n        }\n\n        if ($nb_series == 1) {\n            return [\n                'names'  => ['a'],\n                'colors' => [Toolbox::getFgColor($bgcolor)],\n            ];\n        }\n\n        $min_l = 20; // min for luminosity\n        $max_l = 20; // max ...\n        $min_s = 30; // min for saturation\n        $max_s = 50; // max ...\n        $step_l = (100 - ($min_l + $max_l)) / ($nb_series * 100);\n        $step_s = (100 - ($min_s + $max_s)) / ($nb_series * 100);\n\n        $color_instance = new Color($bgcolor);\n        $hsl = $color_instance->getHsl();\n\n        $names  = [];\n        $colors = [];\n\n        for ($i = 1; $i <= $nb_series; $i++) {\n            $names[$i - 1] = $i - 1;\n\n           // adjust luminosity\n            $i_l_step = $i * $step_l + $min_l / 100;\n            $hsl['L'] = min(1, $revert\n            ? 1 - $i_l_step\n            : $i_l_step);\n           // adjust saturation\n            if ($hsl['H'] != 0 && $hsl['H'] != 1) {\n                $i_s_step = $i * $step_s + $min_s / 100;\n                $hsl['S'] = min(1, $revert\n                 ? $i_s_step\n                 : 1 - $i_s_step);\n            }\n\n            $colors[$i - 1] = \"#\" . Color::hslToHex($hsl);\n        }\n\n        return [\n            'names'  => $names,\n            'colors' => $colors,\n        ];\n    }\n\n\n    /**\n     * Generate a css ruleset for chartist given a starting background color\n     * Based on @see self::getGradientPalette\n     */\n    public static function getCssGradientPalette(\n        string $bgcolor = \"\",\n        int $nb_series = 1,\n        string $css_dom_parent = \"\",\n        bool $revert = true\n    ) {\n        /** @var \\Psr\\SimpleCache\\CacheInterface $GLPI_CACHE */\n        global $GLPI_CACHE;\n\n        $palette = self::getGradientPalette($bgcolor, $nb_series, $revert);\n\n        $series_names  = implode(',', $palette['names']);\n        $series_colors = implode(',', $palette['colors']);\n\n        $hash = sha1($css_dom_parent . $series_names . $series_colors);\n        if (($palette_css = $GLPI_CACHE->get($hash)) !== null) {\n            return $palette_css;\n        }\n\n        $scss = new Compiler();\n        $generate_scss_path = str_replace(\n            DIRECTORY_SEPARATOR,\n            '/',\n            realpath(GLPI_ROOT . '/css/includes/components/chartist/_generate.scss')\n        );\n        $result = $scss->compileString(\n            \"{$css_dom_parent} {\n            \\$ct-series-names: ({$series_names});\n            \\$ct-series-colors: ({$series_colors});\n\n            @import '{$generate_scss_path}';\n         }\",\n            dirname($generate_scss_path)\n        );\n        $palette_css = $result->getCss();\n\n        $GLPI_CACHE->set($hash, $palette_css);\n\n        return $palette_css;\n    }\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2024-27285", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"<%= charset %>\">\n\t<title><%= options.title %></title>\n</head>\n<script type=\"text/javascript\">\nvar mainUrl = '<%= url_for_main %>'\ntry {\n    var match = decodeURIComponent(window.location.hash).match(/^#!(.+)/);\n    var name = match ? match[1] : mainUrl;\n    var url = new URL(name, location.href);\n    window.top.location.replace(url.origin === location.origin ? name : mainUrl);\n} catch (e) {\n    window.top.location.replace(mainUrl);\n}\n</script>\n<noscript>\n  <h1>Oops!</h1>\n  <h2>YARD requires JavaScript!</h2>\n</noscript>\n</html>\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2024-27300", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "<?php\n\n/**\n * Displays the user management frontend.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public License,\n * v. 2.0. If a copy of the MPL was not distributed with this file, You can\n * obtain one at https://mozilla.org/MPL/2.0/.\n *\n * @package   phpMyFAQ\n * @author    Lars Tiedemann <php@larstiedemann.de>\n * @author    Uwe Pries <uwe.pries@digartis.de>\n * @author    Sarah Hermann <sayh@gmx.de>\n * @author    Thorsten Rinne <thorsten@phpmyfaq.de>\n * @copyright 2005-2024 phpMyFAQ Team\n * @license   https://www.mozilla.org/MPL/2.0/ Mozilla Public License Version 2.0\n * @link      https://www.phpmyfaq.de\n * @since     2005-12-15\n */\n\nuse phpMyFAQ\\Category;\nuse phpMyFAQ\\Component\\Alert;\nuse phpMyFAQ\\Enums\\PermissionType;\nuse phpMyFAQ\\Filter;\nuse phpMyFAQ\\Pagination;\nuse phpMyFAQ\\Permission;\nuse phpMyFAQ\\Session\\Token;\nuse phpMyFAQ\\Strings;\nuse phpMyFAQ\\Translation;\nuse phpMyFAQ\\User;\nuse phpMyFAQ\\User\\CurrentUser;\n\nif (!defined('IS_VALID_PHPMYFAQ')) {\n    http_response_code(400);\n    exit();\n}\n\nif (\n    $user->perm->hasPermission($user->getUserId(), PermissionType::USER_EDIT->value) ||\n    $user->perm->hasPermission($user->getUserId(), PermissionType::USER_DELETE->value) ||\n    $user->perm->hasPermission($user->getUserId(), PermissionType::USER_ADD->value)\n) {\n    $userId = Filter::filterInput(INPUT_GET, 'user_id', FILTER_VALIDATE_INT);\n\n    // set some parameters\n    $selectSize = 10;\n    $defaultUserAction = 'list';\n    $defaultUserStatus = 'active';\n    $userActionList = [\n        'update_rights',\n        'update_data',\n        'delete_confirm',\n        'delete',\n        'addsave',\n        'list',\n        'listallusers'\n    ];\n\n    // what shall we do?\n    // actions defined by url: user_action=\n    $userAction = Filter::filterInput(INPUT_GET, 'user_action', FILTER_SANITIZE_SPECIAL_CHARS, $defaultUserAction);\n\n    $currentUser = new CurrentUser($faqConfig);\n\n    // actions defined by submit button\n    if (isset($_POST['user_action_deleteConfirm'])) {\n        $userAction = 'delete_confirm';\n    }\n    if (isset($_POST['cancel'])) {\n        $userAction = $defaultUserAction;\n    }\n\n    // update user rights\n    if (\n        $userAction == 'update_rights' &&\n        $user->perm->hasPermission($user->getUserId(), PermissionType::USER_EDIT->value)\n    ) {\n        $message = '';\n        $userAction = $defaultUserAction;\n        $userId = Filter::filterInput(INPUT_POST, 'user_id', FILTER_VALIDATE_INT, 0);\n        $csrfOkay = true;\n        $csrfToken = Filter::filterInput(INPUT_POST, 'pmf-csrf-token', FILTER_SANITIZE_SPECIAL_CHARS);\n        if (!Token::getInstance()->verifyToken('update-user-rights', $csrfToken)) {\n            $csrfOkay = false;\n        }\n\n        if (0 === (int)$userId || !$csrfOkay) {\n            $message .= Alert::danger('ad_user_error_noId');\n        } else {\n            $user = new User($faqConfig);\n            $perm = $user->perm;\n            // @todo: Add Filter::filterInput[]\n            $userRights = $_POST['user_rights'] ?? [];\n            if (!$perm->refuseAllUserRights($userId)) {\n                $message .= Alert::danger('ad_msg_mysqlerr');\n            }\n            foreach ($userRights as $rightId) {\n                $perm->grantUserRight($userId, $rightId);\n            }\n\n            $idUser = $user->getUserById($userId, true);\n            // Terminate session in case of different permissions after the update\n            $user->terminateSessionId();\n            $message .= sprintf(\n                '<p class=\"alert alert-success\">%s <strong>%s</strong> %s</p>',\n                Translation::get('ad_msg_savedsuc_1'),\n                Strings::htmlentities($user->getLogin(), ENT_QUOTES),\n                Translation::get('ad_msg_savedsuc_2')\n            );\n            $user = new CurrentUser($faqConfig);\n        }\n    }\n\n    // update user data\n    if (\n        $userAction == 'update_data' &&\n        $user->perm->hasPermission($user->getUserId(), PermissionType::USER_EDIT->value)\n    ) {\n        $message = '';\n        $userAction = $defaultUserAction;\n        $userId = Filter::filterInput(INPUT_POST, 'user_id', FILTER_VALIDATE_INT, 0);\n        if ($userId === 0) {\n            $message .= Alert::danger('ad_user_error_noId');\n        } else {\n            $userData = [];\n            $userData['display_name'] = Filter::filterInput(INPUT_POST, 'display_name', FILTER_SANITIZE_SPECIAL_CHARS);\n            $userData['email'] = Filter::filterInput(INPUT_POST, 'email', FILTER_VALIDATE_EMAIL);\n            $userData['last_modified'] = Filter::filterInput(INPUT_POST, 'last_modified', FILTER_SANITIZE_SPECIAL_CHARS);\n            $userStatus = Filter::filterInput(INPUT_POST, 'user_status', FILTER_SANITIZE_SPECIAL_CHARS, $defaultUserStatus);\n            $isSuperAdmin = Filter::filterInput(INPUT_POST, 'is_superadmin', FILTER_SANITIZE_SPECIAL_CHARS);\n            $isSuperAdmin = $isSuperAdmin === 'on';\n            $deleteTwofactor = Filter::filterInput(INPUT_POST, 'overwrite_twofactor', FILTER_SANITIZE_SPECIAL_CHARS);\n            $deleteTwofactor = $deleteTwofactor === 'on';\n\n            $user = new User($faqConfig);\n            $user->getUserById($userId, true);\n\n            $stats = $user->getStatus();\n\n            // reset two-factor authentication if required\n            if ($deleteTwofactor) {\n                $user->setUserData(['secret' => '', 'twofactor_enabled' => 0]);\n            }\n\n            // set new password and sent email if a user is switched to active\n            if ($stats == 'blocked' && $userStatus == 'active') {\n                if (!$user->activateUser()) {\n                    $userStatus = 'invalid_status';\n                }\n            }\n\n            // Set super-admin flag\n            $user->setSuperAdmin($isSuperAdmin);\n\n            if (\n                !$user->userdata->set(array_keys($userData), array_values($userData)) || !$user->setStatus(\n                    $userStatus\n                )\n            ) {\n                $message .= Alert::danger('ad_msg_mysqlerr');\n            } else {\n                $message .= sprintf(\n                    '<p class=\"alert alert-success\">%s <strong>%s</strong> %s</p>',\n                    Translation::get('ad_msg_savedsuc_1'),\n                    Strings::htmlentities($user->getLogin(), ENT_QUOTES),\n                    Translation::get('ad_msg_savedsuc_2')\n                );\n            }\n        }\n    }\n\n    // delete user confirmation\n    if (\n        $userAction == 'delete_confirm' &&\n        $user->perm->hasPermission($user->getUserId(), PermissionType::USER_DELETE->value)\n    ) {\n        $message = '';\n        $user = new CurrentUser($faqConfig);\n\n        $userId = Filter::filterInput(INPUT_GET, 'user_delete_id', FILTER_VALIDATE_INT, 0);\n        if ($userId == 0) {\n            $message .= Alert::danger('ad_user_error_noId');\n            $userAction = $defaultUserAction;\n        } else {\n            $user->getUserById($userId, true);\n            // account is protected\n            if ($user->getStatus() == 'protected' || $userId == 1) {\n                $message .= Alert::danger('ad_user_error_protectedAccount');\n                $userAction = $defaultUserAction;\n            } else {\n                ?>\n\n                <div\n                    class=\"d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom\">\n                    <h1 class=\"h2\">\n                        <i aria-hidden=\"true\" class=\"bi bi-person\"></i>\n                        <?= Translation::get('ad_user_deleteUser') ?>\n                        <?= Strings::htmlentities($user->getLogin(), ENT_QUOTES) ?>\n                    </h1>\n                </div>\n\n                <p class=\"alert alert-danger\">\n                    <?= Translation::get('ad_user_del_3') . ' ' . Translation::get(\n                        'ad_user_del_1'\n                    ) . ' ' . Translation::get('ad_user_del_2') ?>\n                </p>\n                <form action=\"?action=user&amp;user_action=delete\" method=\"post\" accept-charset=\"utf-8\">\n                    <input type=\"hidden\" name=\"user_id\" value=\"<?= $userId ?>\">\n                    <?= Token::getInstance()->getTokenInput('delete-user') ?>\n                    <p class=\"text-center\">\n                        <button class=\"btn btn-danger\" type=\"submit\">\n                            <?= Translation::get('ad_gen_yes') ?>\n                        </button>\n                        <a class=\"btn btn-info\" href=\"?action=user\">\n                            <?= Translation::get('ad_gen_no') ?>\n                        </a>\n                    </p>\n                </form>\n                <?php\n            }\n        }\n    }\n\n    // delete user\n    if ($userAction == 'delete' && $user->perm->hasPermission($user->getUserId(), PermissionType::USER_DELETE->value)) {\n        $message = '';\n        $user = new User($faqConfig);\n        $userId = Filter::filterInput(INPUT_POST, 'user_id', FILTER_VALIDATE_INT, 0);\n        $csrfOkay = true;\n        $csrfToken = Filter::filterInput(INPUT_POST, 'pmf-csrf-token', FILTER_SANITIZE_SPECIAL_CHARS);\n        $userAction = $defaultUserAction;\n\n        if (!Token::getInstance()->verifyToken('delete-user', $csrfToken)) {\n            $csrfOkay = false;\n        }\n\n        if (0 === (int)$userId || !$csrfOkay) {\n            $message .= Alert::danger('ad_user_error_noId');\n        } else {\n            if (!$user->getUserById($userId, true)) {\n                $message .= Alert::danger('ad_user_error_noId');\n            }\n            if (!$user->deleteUser()) {\n                $message .= Alert::danger('ad_user_error_delete');\n            } else {\n                // Move the category ownership to admin (id == 1)\n                $oCat = new Category($faqConfig, [], false);\n                $oCat->setUser($currentAdminUser);\n                $oCat->setGroups($currentAdminGroups);\n                $oCat->moveOwnership((int)$userId, 1);\n\n                // Remove the user from groups\n                if ('basic' !== $faqConfig->get('security.permLevel')) {\n                    $oPerm = Permission::selectPerm('medium', $faqConfig);\n                    $oPerm->removeFromAllGroups($userId);\n                }\n\n                $message .= Alert::success('ad_user_deleted');\n            }\n            $userError = $user->error();\n            if ($userError != '') {\n                $message .= sprintf('<p class=\"alert alert-danger\">%s</p>', $userError);\n            }\n        }\n    }\n\n    if (!isset($message)) {\n        $message = '';\n    }\n\n    // show a list of users\n    if ($userAction === 'list') { ?>\n        <div\n            class=\"d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom\">\n            <h1 class=\"h2\">\n                <i aria-hidden=\"true\" class=\"bi bi-person\"></i>\n                <?= Translation::get('ad_user') ?>\n            </h1>\n            <div class=\"btn-toolbar mb-2 mb-md-0\">\n                <div class=\"btn-group mr-2\">\n                    <?php\n                    if ($currentUser->perm->hasPermission($user->getUserId(), PermissionType::USER_ADD->value)) : ?>\n                        <button type=\"button\" class=\"btn btn-outline-primary\" data-bs-toggle=\"modal\"\n                                data-bs-target=\"#addUserModal\">\n                            <i class=\"bi bi-person-add\" aria-label=\"true\"></i> <?= Translation::get('ad_user_add') ?>\n                        </button>\n                        <?php\n                    endif ?>\n                    <?php\n                    if ($currentUser->perm->hasPermission($user->getUserId(), PermissionType::USER_EDIT->value)) : ?>\n                        <a class=\"btn btn-outline-info\" href=\"?action=user&amp;user_action=listallusers\">\n                            <i class=\"bi bi-people\" aria-label=\"true\"></i> <?= Translation::get('list_all_users') ?>\n                        </a>\n                        <?php\n                    endif ?>\n                </div>\n            </div>\n        </div>\n\n        <div id=\"pmf-user-message\"><?= $message ?></div>\n\n        <div class=\"row mb-2\">\n            <div class=\"col-6 offset-3\">\n                <form name=\"user_select\" id=\"user_select\" action=\"?action=user&amp;user_action=delete_confirm\"\n                      method=\"post\" role=\"form\" class=\"form_inline\">\n                    <input type=\"hidden\" id=\"current_user_id\" value=\"<?= $userId ?>\">\n                    <div class=\"card shadow mb-4\">\n                        <h5 class=\"card-header py-3\">\n                            <i aria-hidden=\"true\" class=\"bi bi-search\"></i> <?= Translation::get('msgSearch') ?>\n                        </h5>\n                        <div class=\"card-body\">\n                            <div class=\"form-floating\">\n                                <input type=\"text\" class=\"form-control\" id=\"pmf-user-list-autocomplete\" aria-controls=\"\"\n                                       name=\"user_list_search\" placeholder=\"<?= Translation::get('ad_auth_user') ?>\"\n                                       spellcheck=\"false\" autocomplete=\"off\" autocapitalize=\"off\" maxlength=\"2048\">\n                                <label for=\"pmf-user-list-autocomplete\"><?= Translation::get('ad_auth_user') ?></label>\n                            </div>\n                        </div>\n                    </div>\n                </form>\n            </div>\n        </div>\n\n        <div class=\"row mb-2\">\n\n            <div class=\"col-lg-8\">\n                <div class=\"card shadow mb-4\">\n                    <h5 class=\"card-header py-3\" id=\"user_data_legend\">\n                        <i aria-hidden=\"true\" class=\"bi bi-person\"></i> <?= Translation::get('ad_user_profou') ?>\n                    </h5>\n                    <form action=\"?action=user&amp;user_action=update_data\" method=\"post\">\n                        <div class=\"card-body\">\n                            <input type=\"hidden\" id=\"last_modified\" name=\"last_modified\" value=\"\">\n                            <input id=\"update_user_id\" type=\"hidden\" name=\"user_id\" value=\"0\">\n                            <?= Token::getInstance()->getTokenInput('update-user-data') ?>\n\n                            <div class=\"row mb-2\">\n                                <label for=\"auth_source\" class=\"col-lg-4 col-form-label\">\n                                    <?= Translation::get('msgAuthenticationSource') ?>\n                                </label>\n                                <div class=\"col-lg-8\">\n                                    <input id=\"auth_source\" class=\"form-control-plaintext\" type=\"text\" value=\"n/a\"\n                                           readonly>\n                                </div>\n                            </div>\n\n                            <div class=\"row mb-2\">\n                                <label for=\"user_status\" class=\"col-lg-4 col-form-label\">\n                                    <?= Translation::get('ad_user_status') ?>\n                                </label>\n                                <div class=\"col-lg-8\">\n                                    <select id=\"user_status\" class=\"form-select\" name=\"user_status\" disabled>\n                                        <option value=\"active\"><?= Translation::get('ad_user_active') ?></option>\n                                        <option value=\"blocked\"><?= Translation::get('ad_user_blocked') ?></option>\n                                        <option value=\"protected\"><?= Translation::get('ad_user_protected') ?></option>\n                                    </select>\n                                </div>\n                            </div>\n\n                            <div class=\"row mb-2\">\n                                <label class=\"col-lg-4 col-form-label\" for=\"display_name\">\n                                    <?= Translation::get('ad_user_realname') ?>\n                                </label>\n                                <div class=\"col-lg-8\">\n                                    <input type=\"text\" id=\"display_name\" name=\"display_name\" value=\"\"\n                                           class=\"form-control\" required disabled>\n                                </div>\n                            </div>\n\n                            <div class=\"row mb-2\">\n                                <label class=\"col-lg-4 col-form-label\" for=\"email\">\n                                    <?= Translation::get('ad_entry_email') ?>\n                                </label>\n                                <div class=\"col-lg-8\">\n                                    <input type=\"email\" id=\"email\" name=\"email\" value=\"\" class=\"form-control\" required\n                                           disabled>\n                                </div>\n                            </div>\n\n                            <div class=\"row mb-2\">\n                                <div class=\"offset-lg-4 col-lg-8\">\n                                    <div class=\"form-check\">\n                                        <input class=\"form-check-input\" type=\"checkbox\" id=\"is_superadmin\"\n                                               name=\"is_superadmin\">\n                                        <label class=\"form-check-label\" for=\"is_superadmin\">\n                                            <?= Translation::get('ad_user_is_superadmin') ?>\n                                        </label>\n                                    </div>\n                                </div>\n                            </div>\n\n                            <div class=\"row mb-2\">\n                                <div class=\"offset-lg-4 col-lg-8\">\n                                    <a class=\"btn btn-danger pmf-admin-overwrite-password\" data-bs-toggle=\"modal\"\n                                       href=\"#pmf-modal-user-password-overwrite\">\n                                        <?= Translation::get('ad_user_overwrite_passwd') ?>\n                                    </a>\n                                </div>\n                            </div>\n\n                            <div class=\"row mb-2\">\n                                <div class=\"offset-lg-4 col-lg-8\">\n                                    <div class=\"form-check\">\n                                        <input class=\"form-check-input\" type=\"checkbox\" id=\"overwrite_twofactor\"\n                                               name=\"overwrite_twofactor\" disabled>\n                                        <label class=\"form-check-label\" for=\"overwrite_twofactor\">\n                                            <?= Translation::get('ad_user_overwrite_twofactor') ?>\n                                        </label>\n                                    </div>\n                                </div>\n                            </div>\n\n                        </div>\n                        <div class=\"card-footer text-end\">\n                            <?php if ($userId > 0) : ?>\n                            <a class=\"btn btn-danger\"\n                               href=\"?action=user&amp;user_action=delete_confirm&user_delete_id=<?= $userId ?>\">\n                                <?= Translation::get('ad_user_delete') ?>\n                            </a>\n                            <?php endif; ?>\n                            <button class=\"btn btn-success\" type=\"submit\">\n                                <?= Translation::get('ad_gen_save') ?>\n                            </button>\n                        </div>\n                    </form>\n                </div>\n            </div>\n\n            <div class=\"col-lg-4\" id=\"userRights\">\n                <form id=\"rightsForm\" action=\"?action=user&amp;user_action=update_rights\" method=\"post\"\n                      accept-charset=\"utf-8\">\n                    <input type=\"hidden\" name=\"user_id\" id=\"rights_user_id\" value=\"0\">\n                    <?= Token::getInstance()->getTokenInput('update-user-rights') ?>\n\n                    <div class=\"card shadow h-50 mb-4\">\n                        <div class=\"card-header d-flex justify-content-between flex-wrap align-items-center py-3\">\n                            <h5 class=\"\" id=\"user_rights_legend\">\n                                <i aria-hidden=\"true\" class=\"bi bi-lock\"></i> <?= Translation::get('ad_user_rights') ?>\n                            </h5>\n                            <div class=\"card-button\">\n                                <button class=\"btn btn-success\" type=\"submit\">\n                                    <?= Translation::get('ad_gen_save') ?>\n                                </button>\n                            </div>\n                        </div>\n                        <div class=\"card-body\">\n                            <div class=\"text-center mb-3\">\n                                <button type=\"button\" class=\"btn btn-primary btn-sm\" id=\"checkAll\">\n                                    <?= Translation::get('ad_user_checkall') ?>\n                                    /\n                                    <?= Translation::get('ad_user_uncheckall') ?>\n                                </button>\n                            </div>\n                            <?php\n                            foreach ($user->perm->getAllRightsData() as $right) : ?>\n                                <div class=\"form-check\">\n                                    <input id=\"user_right_<?= $right['right_id'] ?>\" type=\"checkbox\"\n                                           name=\"user_rights[]\" value=\"<?= $right['right_id'] ?>\"\n                                           class=\"form-check-input permission\">\n                                    <label class=\"form-check-label\" for=\"user_right_<?= $right['right_id'] ?>\">\n                                        <?= Translation::get('permission::' . $right['name']) ?>\n                                    </label>\n                                </div>\n                                <?php\n                            endforeach; ?>\n                        </div>\n                        <div class=\"card-footer\">\n                            <div class=\"card-button text-end\">\n                                <button class=\"btn btn-success\" type=\"submit\">\n                                    <?= Translation::get('ad_gen_save') ?>\n                                </button>\n                            </div>\n                        </div>\n                    </div>\n                </form>\n            </div>\n        </div>\n\n        <?php\n    }\n\n    // show a list of all users\n    if (\n        $userAction == 'listallusers' &&\n        $user->perm->hasPermission($user->getUserId(), PermissionType::USER_EDIT->value)\n    ) {\n        $allUsers = $user->getAllUsers(false);\n        $numUsers = is_countable($allUsers) ? count($allUsers) : 0;\n        $page = Filter::filterInput(INPUT_GET, 'page', FILTER_VALIDATE_INT, 0);\n        $perPage = 10;\n        $numPages = ceil($numUsers / $perPage);\n        $lastPage = $page * $perPage;\n        $firstPage = $lastPage - $perPage;\n\n        $baseUrl = sprintf(\n            '%sadmin/?action=user&amp;user_action=listallusers&amp;page=%d',\n            $faqConfig->getDefaultUrl(),\n            $page\n        );\n\n        // Pagination options\n        $options = [\n            'baseUrl' => $baseUrl,\n            'total' => $numUsers,\n            'perPage' => $perPage,\n            'pageParamName' => 'page',\n        ];\n        $pagination = new Pagination($options);\n        ?>\n\n<div class=\"d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom\">\n    <h1 class=\"h2\">\n        <i aria-hidden=\"true\" class=\"bi bi-people-fill\"></i>\n        <?= Translation::get('ad_user') ?>\n    </h1>\n    <div class=\"btn-toolbar mb-2 mb-md-0\">\n        <div class=\"btn-group mr-2\">\n            <?php\n            if ($currentUser->perm->hasPermission($user->getUserId(), PermissionType::USER_ADD->value)) : ?>\n                <button type=\"button\" class=\"btn btn-outline-success\" data-bs-toggle=\"modal\"\n                        data-bs-target=\"#addUserModal\">\n                    <i class=\"bi bi-person-add\" aria-label=\"true\"></i> <?= Translation::get('ad_user_add') ?>\n                </button>\n                <?php\n            endif ?>\n            <button type=\"button\" class=\"btn btn-outline-info\" id=\"pmf-button-export-users\">\n                <i class=\"bi bi-download\" aria-label=\"true\"></i> Export users as CSV\n            </button>\n        </div>\n    </div>\n</div>\n\n        <div id=\"pmf-user-message\"><?= $message ?></div>\n\n        <table class=\"table table-striped align-middle\" id=\"pmf-admin-user-table\">\n            <thead class=\"thead-dark\">\n            <tr>\n                <th><?= Translation::get('msgNewContentName') ?></th>\n                <th><?= Translation::get('msgNewContentMail') ?></th>\n                <th><?= Translation::get('ad_auth_user') ?></th>\n                <th><?= Translation::get('ad_user_status') ?></th>\n                <th><?= Translation::get('ad_user_is_superadmin') ?></th>\n                <th><?= Translation::get('ad_user_is_visible') ?></th>\n                <th>Actions</th>\n            </tr>\n            </thead>\n            <?php\n            if ($perPage < $numUsers) : ?>\n                <tfoot>\n                <tr>\n                    <td colspan=\"8\"><?= $pagination->render() ?></td>\n                </tr>\n                </tfoot>\n                <?php\n            endif;\n            ?>\n        <tbody>\n        <?php\n        $counter = $displayedCounter = 0;\n        foreach ($allUsers as $listedUserId) {\n            $user->getUserById($listedUserId, true);\n\n            if ($displayedCounter >= $perPage) {\n                continue;\n            }\n                ++$counter;\n            if ($counter <= $firstPage) {\n                continue;\n            }\n                ++$displayedCounter;\n\n            ?>\n                <tr class=\"row_user_id_<?= $user->getUserId() ?>\">\n                    <td><?= Strings::htmlentities($user->getUserData('display_name')) ?></td>\n                    <td>\n                        <a href=\"mailto:<?= $user->getUserData('email') ?>\">\n                            <?= $user->getUserData('email') ?>\n                        </a>\n                    </td>\n                    <td><?= Strings::htmlentities($user->getLogin()) ?></td>\n\n                    <td class=\"text-center\"><i class=\"fa <?php\n                    switch ($user->getStatus()) {\n                        case 'active':\n                            echo 'bi-person-fill-check text-success';\n                            break;\n                        case 'blocked':\n                            echo 'bi-person-fill-slash text-danger';\n                            break;\n                        case 'protected':\n                            echo 'bi-person-fill-lock text-warning';\n                            break;\n                    }\n                    ?> icon_user_id_<?= $user->getUserId() ?>\"></i></td>\n                    <td class=\"text-center\">\n                        <i class=\"fa <?= $user->isSuperAdmin() ? 'bi-person-fill-check text-success' : 'bi-person' ?>\"></i>\n                    </td>\n                    <td class=\"text-center\">\n                        <i class=\"fa <?= $user->getUserData('is_visible') ? 'bi-person-fill' : 'bi-person' ?>\"></i>\n                    </td>\n\n                    <td>\n                        <a href=\"?action=user&amp;user_id=<?= $user->getUserData('user_id') ?>\"\n                           class=\"btn\">\n                            <i class=\"bi bi-pencil text-info\"></i> <?= Translation::get('ad_user_edit') ?>\n                        </a>\n                        <?php\n                        if ($user->getStatus() === 'blocked') : ?>\n                            <button type=\"button\" class=\"btn btn-activate-user\"\n                                    id=\"btn_activate_user_id_<?= $user->getUserData('user_id') ?>\"\n                                    data-csrf-token=\"<?= Token::getInstance()->getTokenString('activate-user') ?>\"\n                                    data-user-id=\"<?= $user->getUserData('user_id') ?>\">\n                                <i class=\"bi bi-unlock-fill text-success\"\n                                   data-csrf-token=\"<?= Token::getInstance()->getTokenString('activate-user') ?>\"\n                                   data-user-id=\"<?= $user->getUserData('user_id') ?>\"></i>\n                                <?= Translation::get('ad_news_set_active') ?>\n                            </button>\n                            <?php\n                        endif;\n                        ?>\n                        <?php\n                        if (\n                            $user->getStatus() !== 'protected' &&\n                            $currentUser->perm->hasPermission(\n                                $currentUser->getUserId(),\n                                PermissionType::USER_DELETE->value\n                            )\n                        ) {\n                            $csrfToken = Token::getInstance()->getTokenString('delete-user');\n                            ?>\n                            <button type=\"button\" class=\"btn btn-delete-user\"\n                                    id=\"btn_user_id_<?= $user->getUserData('user_id') ?>\"\n                                    data-csrf-token=\"<?= $csrfToken ?>\"\n                                    data-user-id=\"<?= $user->getUserData('user_id') ?>\">\n                                <i class=\"bi bi-trash text-danger\" data-csrf-token=\"<?= $csrfToken ?>\"\n                                   data-user-id=\"<?= $user->getUserData('user_id') ?>\"></i>\n                                <?= Translation::get('ad_user_delete') ?>\n                            </button>\n                            <?php } ?>\n                     </td>\n                </tr>\n                <?php\n        }\n        ?>\n            </tbody>\n        </table>\n        <?php\n    }\n\n    $user = CurrentUser::getCurrentUser($faqConfig);\n    ?>\n\n    <!-- Modal to add a new user -->\n    <div class=\"modal fade\" id=\"addUserModal\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"addUserModalLabel\"\n         aria-hidden=\"true\">\n        <div class=\"modal-dialog modal-lg\" role=\"document\">\n            <div class=\"modal-content\">\n                <div class=\"modal-header\">\n                    <h5 class=\"modal-title\" id=\"addUserModalLabel\">\n                        <i aria-hidden=\"true\" class=\"bi bi-person-plus\"></i> <?= Translation::get('ad_adus_adduser') ?>\n                    </h5>\n                    <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\" aria-label=\"Close\"></button>\n                </div>\n                <div class=\"modal-body\">\n                    <form action=\"#\" method=\"post\" role=\"form\" id=\"pmf-add-user-form\" class=\"needs-validation\"\n                          autocomplete=\"off\"\n                          novalidate>\n\n                        <input type=\"hidden\" id=\"add_user_csrf\" name=\"add_user_csrf\"\n                               value=\"<?= Token::getInstance()->getTokenString('add-user') ?>\">\n\n                        <div class=\"alert alert-danger d-none\" id=\"pmf-add-user-error-message\"></div>\n\n                        <div class=\"row mb-2\">\n                            <label class=\"col-lg-4 col-form-label\" for=\"add_user_name\">\n                                <?= Translation::get('ad_adus_name') ?>\n                            </label>\n                            <div class=\"col-lg-8\">\n                                <input type=\"text\" name=\"add_user_name\" id=\"add_user_name\" required tabindex=\"1\"\n                                       class=\"form-control\">\n                            </div>\n                        </div>\n\n                        <div class=\"row mb-2\">\n                            <label class=\"col-lg-4 col-form-label\"\n                                   for=\"add_user_realname\"><?= Translation::get('ad_user_realname') ?></label>\n                            <div class=\"col-lg-8\">\n                                <input type=\"text\" name=\"add_user_realname\" id=\"add_user_realname\" required tabindex=\"2\"\n                                       class=\"form-control\">\n                            </div>\n                        </div>\n\n                        <div class=\"row mb-2\">\n                            <label class=\"col-lg-4 col-form-label\" for=\"add_user_email\">\n                                <?= Translation::get('ad_entry_email') ?>\n                            </label>\n                            <div class=\"col-lg-8\">\n                                <input type=\"email\" name=\"user_email\" id=\"add_user_email\" required tabindex=\"3\"\n                                       class=\"form-control\">\n                            </div>\n                        </div>\n\n                        <div class=\"row mb-2\">\n                            <div class=\"col-lg-4\"></div>\n                            <div class=\"col-lg-8\">\n                                <div class=\"form-check\">\n                                    <input class=\"form-check-input\" type=\"checkbox\" id=\"add_user_automatic_password\"\n                                           name=\"add_user_automatic_password\" value=\"\">\n                                    <label class=\"form-check-label\" for=\"add_user_automatic_password\">\n                                        <?= Translation::get('ad_add_user_change_password') ?>\n                                    </label>\n                                </div>\n                            </div>\n                        </div>\n\n                        <div id=\"add_user_show_password_inputs\">\n                            <div class=\"row mb-2\">\n                                <label class=\"col-lg-4 col-form-label\"\n                                       for=\"add_user_password\"><?= Translation::get('ad_adus_password') ?></label>\n                                <div class=\"col-lg-8\">\n                                    <div class=\"input-group\">\n                                        <input type=\"password\" name=\"add_user_password\" id=\"add_user_password\"\n                                            class=\"form-control\" minlength=\"8\"\n                                            autocomplete=\"off\" tabindex=\"4\"\n                                               data-pmf-toggle=\"add_user_password_togglePassword\">\n                                        <span class=\"input-group-text\" id=\"add_user_password_togglePassword\">\n                                            <i class=\"bi bi-eye-slash\" id=\"add_user_password_togglePassword_icon\"></i>\n                                        </span>\n                                    </div>\n                                </div>\n                            </div>\n\n                            <div class=\"row mb-2\">\n                                <label class=\"col-lg-4 col-form-label\"\n                                       for=\"add_user_password_confirm\"><?= Translation::get('ad_passwd_con') ?></label>\n                               <div class=\"col-lg-8\">\n                                    <div class=\"input-group\">\n                                        <input type=\"password\" name=\"add_user_password_confirm\"\n                                            id=\"add_user_password_confirm\" minlength=\"8\"\n                                            class=\"form-control\" autocomplete=\"off\" tabindex=\"5\"\n                                               data-pmf-toggle=\"add_user_password_confirm_togglePassword\">\n                                        <span class=\"input-group-text\" id=\"add_user_password_confirm_togglePassword\">\n                                            <i class=\"bi bi-eye-slash\"\n                                               id=\"add_user_password_confirm_togglePassword_icon\"></i>\n                                        </span>\n                                    </div>\n                                </div>\n                            </div>\n                        </div>\n\n                        <?php if ($user->isSuperAdmin()) { ?>\n                        <div class=\"row mb-2\">\n                            <div class=\"col-lg-4\"></div>\n                            <div class=\"col-lg-8\">\n                                <div class=\"form-check\">\n                                    <input class=\"form-check-input\" type=\"checkbox\" id=\"add_user_is_superadmin\"\n                                           name=\"user_is_superadmin\">\n                                    <label class=\"form-check-label\" for=\"add_user_is_superadmin\">\n                                        <?= Translation::get('ad_user_is_superadmin') ?>\n                                    </label>\n                                </div>\n                            </div>\n                        </div>\n                        <?php } ?>\n\n                    </form>\n                </div>\n                <div class=\"modal-footer\">\n                    <button type=\"button\" class=\"btn btn-secondary\" data-bs-dismiss=\"modal\">\n                        <?= Translation::get('ad_gen_cancel') ?>\n                    </button>\n                    <button type=\"button\" class=\"btn btn-primary\" id=\"pmf-add-user-action\">\n                        <?= Translation::get('ad_gen_save') ?>\n                    </button>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <!-- Modal to overwrite password -->\n    <div class=\"modal fade\" id=\"pmf-modal-user-password-overwrite\">\n        <div class=\"modal-dialog\">\n            <div class=\"modal-content\">\n                <div class=\"modal-header\">\n                    <h4><?= Translation::get('ad_menu_passwd') ?></h4>\n                    <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\" aria-label=\"Close\"></button>\n                </div>\n                <div class=\"modal-body\">\n                    <form action=\"#\" method=\"post\" accept-charset=\"utf-8\" autocomplete=\"off\">\n                        <input type=\"hidden\" name=\"csrf\" id=\"modal_csrf\"\n                               value=\"<?= Token::getInstance()->getTokenString('overwrite-password') ?>\">\n                        <input type=\"hidden\" name=\"user_id\" id=\"modal_user_id\" value=\"<?= $userId ?>\">\n\n                        <div class=\"row mb-2\">\n                            <label class=\"col-5 col-form-label\" for=\"npass\">\n                                <?= Translation::get('ad_passwd_new') ?>\n                            </label>\n                            <div class=\"col-7\">\n                              <div class=\"input-group\">\n                                <input type=\"password\" autocomplete=\"off\" name=\"npass\" id=\"npass\"\n                                       class=\"form-control\" data-pmf-toggle=\"npass_togglePassword\" required>\n                                <span class=\"input-group-text\" id=\"npass_togglePassword\">\n                                    <i class=\"bi bi-eye-slash\" id=\"npass_togglePassword_icon\"></i>\n                                </span>\n                               </div>\n                            </div>\n                        </div>\n\n                        <div class=\"row mb-2\">\n                            <label class=\"col-5 col-form-label\" for=\"bpass\">\n                                <?= Translation::get('ad_passwd_con') ?>\n                            </label>\n                            <div class=\"col-7\">\n                              <div class=\"input-group\">\n                                <input type=\"password\" autocomplete=\"off\" name=\"bpass\" id=\"bpass\"\n                                       class=\"form-control\" data-pmf-toggle=\"bpass_togglePassword\" required>\n                                <span class=\"input-group-text\" id=\"bpass_togglePassword\">\n                                    <i class=\"bi bi-eye-slash\" id=\"bpass_togglePassword_icon\"></i>\n                                </span>\n                               </div>\n                            </div>\n                        </div>\n                    </form>\n                </div>\n                <div class=\"modal-footer\">\n                    <button class=\"btn btn-primary\" id=\"pmf-user-password-overwrite-action\">\n                        <?= Translation::get('ad_user_overwrite_passwd') ?>\n                    </button>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <?php\n} else {\n    require __DIR__ . '/no-permission.php';\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2024-27932", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n\nuse base64::prelude::BASE64_STANDARD;\nuse base64::Engine;\nuse deno_core::ModuleSpecifier;\nuse log::debug;\nuse log::error;\nuse std::fmt;\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum AuthTokenData {\n  Bearer(String),\n  Basic { username: String, password: String },\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct AuthToken {\n  host: String,\n  token: AuthTokenData,\n}\n\nimpl fmt::Display for AuthToken {\n  fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n    match &self.token {\n      AuthTokenData::Bearer(token) => write!(f, \"Bearer {token}\"),\n      AuthTokenData::Basic { username, password } => {\n        let credentials = format!(\"{username}:{password}\");\n        write!(f, \"Basic {}\", BASE64_STANDARD.encode(credentials))\n      }\n    }\n  }\n}\n\n/// A structure which contains bearer tokens that can be used when sending\n/// requests to websites, intended to authorize access to private resources\n/// such as remote modules.\n#[derive(Debug, Clone)]\npub struct AuthTokens(Vec<AuthToken>);\n\nimpl AuthTokens {\n  /// Create a new set of tokens based on the provided string. It is intended\n  /// that the string be the value of an environment variable and the string is\n  /// parsed for token values.  The string is expected to be a semi-colon\n  /// separated string, where each value is `{token}@{hostname}`.\n  pub fn new(maybe_tokens_str: Option<String>) -> Self {\n    let mut tokens = Vec::new();\n    if let Some(tokens_str) = maybe_tokens_str {\n      for token_str in tokens_str.split(';') {\n        if token_str.contains('@') {\n          let pair: Vec<&str> = token_str.rsplitn(2, '@').collect();\n          let token = pair[1];\n          let host = pair[0].to_lowercase();\n          if token.contains(':') {\n            let pair: Vec<&str> = token.rsplitn(2, ':').collect();\n            let username = pair[1].to_string();\n            let password = pair[0].to_string();\n            tokens.push(AuthToken {\n              host,\n              token: AuthTokenData::Basic { username, password },\n            })\n          } else {\n            tokens.push(AuthToken {\n              host,\n              token: AuthTokenData::Bearer(token.to_string()),\n            });\n          }\n        } else {\n          error!(\"Badly formed auth token discarded.\");\n        }\n      }\n      debug!(\"Parsed {} auth token(s).\", tokens.len());\n    }\n\n    Self(tokens)\n  }\n\n  /// Attempt to match the provided specifier to the tokens in the set.  The\n  /// matching occurs from the right of the hostname plus port, irrespective of\n  /// scheme.  For example `https://www.deno.land:8080/` would match a token\n  /// with a host value of `deno.land:8080` but not match `www.deno.land`.  The\n  /// matching is case insensitive.\n  pub fn get(&self, specifier: &ModuleSpecifier) -> Option<AuthToken> {\n    self.0.iter().find_map(|t| {\n      let hostname = if let Some(port) = specifier.port() {\n        format!(\"{}:{}\", specifier.host_str()?, port)\n      } else {\n        specifier.host_str()?.to_string()\n      };\n      if hostname.to_lowercase().ends_with(&t.host) {\n        Some(t.clone())\n      } else {\n        None\n      }\n    })\n  }\n}\n\n#[cfg(test)]\nmod tests {\n  use super::*;\n  use deno_core::resolve_url;\n\n  #[test]\n  fn test_auth_token() {\n    let auth_tokens = AuthTokens::new(Some(\"abc123@deno.land\".to_string()));\n    let fixture = resolve_url(\"https://deno.land/x/mod.ts\").unwrap();\n    assert_eq!(\n      auth_tokens.get(&fixture).unwrap().to_string(),\n      \"Bearer abc123\"\n    );\n    let fixture = resolve_url(\"https://www.deno.land/x/mod.ts\").unwrap();\n    assert_eq!(\n      auth_tokens.get(&fixture).unwrap().to_string(),\n      \"Bearer abc123\".to_string()\n    );\n    let fixture = resolve_url(\"http://127.0.0.1:8080/x/mod.ts\").unwrap();\n    assert_eq!(auth_tokens.get(&fixture), None);\n    let fixture =\n      resolve_url(\"https://deno.land.example.com/x/mod.ts\").unwrap();\n    assert_eq!(auth_tokens.get(&fixture), None);\n    let fixture = resolve_url(\"https://deno.land:8080/x/mod.ts\").unwrap();\n    assert_eq!(auth_tokens.get(&fixture), None);\n  }\n\n  #[test]\n  fn test_auth_tokens_multiple() {\n    let auth_tokens =\n      AuthTokens::new(Some(\"abc123@deno.land;def456@example.com\".to_string()));\n    let fixture = resolve_url(\"https://deno.land/x/mod.ts\").unwrap();\n    assert_eq!(\n      auth_tokens.get(&fixture).unwrap().to_string(),\n      \"Bearer abc123\".to_string()\n    );\n    let fixture = resolve_url(\"http://example.com/a/file.ts\").unwrap();\n    assert_eq!(\n      auth_tokens.get(&fixture).unwrap().to_string(),\n      \"Bearer def456\".to_string()\n    );\n  }\n\n  #[test]\n  fn test_auth_tokens_port() {\n    let auth_tokens =\n      AuthTokens::new(Some(\"abc123@deno.land:8080\".to_string()));\n    let fixture = resolve_url(\"https://deno.land/x/mod.ts\").unwrap();\n    assert_eq!(auth_tokens.get(&fixture), None);\n    let fixture = resolve_url(\"http://deno.land:8080/x/mod.ts\").unwrap();\n    assert_eq!(\n      auth_tokens.get(&fixture).unwrap().to_string(),\n      \"Bearer abc123\".to_string()\n    );\n  }\n\n  #[test]\n  fn test_auth_tokens_contain_at() {\n    let auth_tokens = AuthTokens::new(Some(\"abc@123@deno.land\".to_string()));\n    let fixture = resolve_url(\"https://deno.land/x/mod.ts\").unwrap();\n    assert_eq!(\n      auth_tokens.get(&fixture).unwrap().to_string(),\n      \"Bearer abc@123\".to_string()\n    );\n  }\n\n  #[test]\n  fn test_auth_token_basic() {\n    let auth_tokens = AuthTokens::new(Some(\"abc:123@deno.land\".to_string()));\n    let fixture = resolve_url(\"https://deno.land/x/mod.ts\").unwrap();\n    assert_eq!(\n      auth_tokens.get(&fixture).unwrap().to_string(),\n      \"Basic YWJjOjEyMw==\"\n    );\n    let fixture = resolve_url(\"https://www.deno.land/x/mod.ts\").unwrap();\n    assert_eq!(\n      auth_tokens.get(&fixture).unwrap().to_string(),\n      \"Basic YWJjOjEyMw==\".to_string()\n    );\n    let fixture = resolve_url(\"http://127.0.0.1:8080/x/mod.ts\").unwrap();\n    assert_eq!(auth_tokens.get(&fixture), None);\n    let fixture =\n      resolve_url(\"https://deno.land.example.com/x/mod.ts\").unwrap();\n    assert_eq!(auth_tokens.get(&fixture), None);\n    let fixture = resolve_url(\"https://deno.land:8080/x/mod.ts\").unwrap();\n    assert_eq!(auth_tokens.get(&fixture), None);\n  }\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2024-27933", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "// Copyright 2018-2023 the Deno authors. All rights reserved. MIT license.\n\n#[cfg(unix)]\npub use unix::*;\n\n#[cfg(windows)]\npub use windows::*;\n\npub struct ChildPipeFd(pub i32);\n\n#[cfg(unix)]\nmod unix {\n  use std::cell::RefCell;\n  use std::future::Future;\n  use std::io;\n  use std::mem;\n  use std::os::fd::FromRawFd;\n  use std::os::fd::RawFd;\n  use std::pin::Pin;\n  use std::rc::Rc;\n  use std::task::Context;\n  use std::task::Poll;\n\n  use deno_core::error::bad_resource_id;\n  use deno_core::error::AnyError;\n  use deno_core::op2;\n  use deno_core::serde_json;\n  use deno_core::AsyncRefCell;\n  use deno_core::CancelFuture;\n  use deno_core::CancelHandle;\n  use deno_core::OpState;\n  use deno_core::RcRef;\n  use deno_core::ResourceId;\n  use pin_project_lite::pin_project;\n  use tokio::io::AsyncBufRead;\n  use tokio::io::AsyncWriteExt;\n  use tokio::io::BufReader;\n  use tokio::net::unix::OwnedReadHalf;\n  use tokio::net::unix::OwnedWriteHalf;\n  use tokio::net::UnixStream;\n\n  #[op2(fast)]\n  #[smi]\n  pub fn op_node_ipc_pipe(\n    state: &mut OpState,\n    #[smi] fd: i32,\n  ) -> Result<ResourceId, AnyError> {\n    Ok(state.resource_table.add(IpcJsonStreamResource::new(fd)?))\n  }\n\n  // Open IPC pipe from bootstrap options.\n  #[op2]\n  #[smi]\n  pub fn op_node_child_ipc_pipe(\n    state: &mut OpState,\n  ) -> Result<Option<ResourceId>, AnyError> {\n    let fd = match state.try_borrow_mut::<crate::ChildPipeFd>() {\n      Some(child_pipe_fd) => child_pipe_fd.0,\n      None => return Ok(None),\n    };\n\n    Ok(Some(\n      state.resource_table.add(IpcJsonStreamResource::new(fd)?),\n    ))\n  }\n\n  #[op2(async)]\n  pub async fn op_node_ipc_write(\n    state: Rc<RefCell<OpState>>,\n    #[smi] rid: ResourceId,\n    #[serde] value: serde_json::Value,\n  ) -> Result<(), AnyError> {\n    let stream = state\n      .borrow()\n      .resource_table\n      .get::<IpcJsonStreamResource>(rid)\n      .map_err(|_| bad_resource_id())?;\n    stream.write_msg(value).await?;\n    Ok(())\n  }\n\n  #[op2(async)]\n  #[serde]\n  pub async fn op_node_ipc_read(\n    state: Rc<RefCell<OpState>>,\n    #[smi] rid: ResourceId,\n  ) -> Result<serde_json::Value, AnyError> {\n    let stream = state\n      .borrow()\n      .resource_table\n      .get::<IpcJsonStreamResource>(rid)\n      .map_err(|_| bad_resource_id())?;\n\n    let cancel = stream.cancel.clone();\n    let mut stream = RcRef::map(stream, |r| &r.read_half).borrow_mut().await;\n    let msgs = stream.read_msg().or_cancel(cancel).await??;\n    Ok(msgs)\n  }\n\n  struct IpcJsonStreamResource {\n    read_half: AsyncRefCell<IpcJsonStream>,\n    write_half: AsyncRefCell<OwnedWriteHalf>,\n    cancel: Rc<CancelHandle>,\n  }\n\n  impl deno_core::Resource for IpcJsonStreamResource {\n    fn close(self: Rc<Self>) {\n      self.cancel.cancel();\n    }\n  }\n\n  impl IpcJsonStreamResource {\n    fn new(stream: RawFd) -> Result<Self, std::io::Error> {\n      // Safety: The fd is part of a pair of connected sockets create by child process\n      // implementation.\n      let unix_stream = UnixStream::from_std(unsafe {\n        std::os::unix::net::UnixStream::from_raw_fd(stream)\n      })?;\n      let (read_half, write_half) = unix_stream.into_split();\n      Ok(Self {\n        read_half: AsyncRefCell::new(IpcJsonStream::new(read_half)),\n        write_half: AsyncRefCell::new(write_half),\n        cancel: Default::default(),\n      })\n    }\n\n    #[cfg(test)]\n    fn from_unix_stream(stream: UnixStream) -> Self {\n      let (read_half, write_half) = stream.into_split();\n      Self {\n        read_half: AsyncRefCell::new(IpcJsonStream::new(read_half)),\n        write_half: AsyncRefCell::new(write_half),\n        cancel: Default::default(),\n      }\n    }\n\n    async fn write_msg(\n      self: Rc<Self>,\n      msg: serde_json::Value,\n    ) -> Result<(), AnyError> {\n      let mut write_half =\n        RcRef::map(self, |r| &r.write_half).borrow_mut().await;\n      // Perf note: We do not benefit from writev here because\n      // we are always allocating a buffer for serialization anyways.\n      let mut buf = Vec::new();\n      serde_json::to_writer(&mut buf, &msg)?;\n      buf.push(b'\\n');\n      write_half.write_all(&buf).await?;\n      Ok(())\n    }\n  }\n\n  #[inline]\n  fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n    #[cfg(all(target_os = \"macos\", target_arch = \"aarch64\"))]\n    // Safety: haystack of valid length. neon_memchr can handle unaligned\n    // data.\n    return unsafe { neon::neon_memchr(haystack, needle, haystack.len()) };\n\n    #[cfg(not(all(target_os = \"macos\", target_arch = \"aarch64\")))]\n    return haystack.iter().position(|&b| b == needle);\n  }\n\n  // Initial capacity of the buffered reader and the JSON backing buffer.\n  //\n  // This is a tradeoff between memory usage and performance on large messages.\n  //\n  // 64kb has been chosen after benchmarking 64 to 66536 << 6 - 1 bytes per message.\n  const INITIAL_CAPACITY: usize = 1024 * 64;\n\n  // JSON serialization stream over IPC pipe.\n  //\n  // `\\n` is used as a delimiter between messages.\n  struct IpcJsonStream {\n    pipe: BufReader<OwnedReadHalf>,\n    buffer: Vec<u8>,\n  }\n\n  impl IpcJsonStream {\n    fn new(pipe: OwnedReadHalf) -> Self {\n      Self {\n        pipe: BufReader::with_capacity(INITIAL_CAPACITY, pipe),\n        buffer: Vec::with_capacity(INITIAL_CAPACITY),\n      }\n    }\n\n    async fn read_msg(&mut self) -> Result<serde_json::Value, AnyError> {\n      let mut json = None;\n      let nread =\n        read_msg_inner(&mut self.pipe, &mut self.buffer, &mut json).await?;\n      if nread == 0 {\n        // EOF.\n        return Ok(serde_json::Value::Null);\n      }\n\n      let json = match json {\n        Some(v) => v,\n        None => {\n          // Took more than a single read and some buffering.\n          simd_json::from_slice(&mut self.buffer[..nread])?\n        }\n      };\n\n      // Safety: Same as `Vec::clear` but without the `drop_in_place` for\n      // each element (nop for u8). Capacity remains the same.\n      unsafe {\n        self.buffer.set_len(0);\n      }\n\n      Ok(json)\n    }\n  }\n\n  pin_project! {\n      #[must_use = \"futures do nothing unless you `.await` or poll them\"]\n      struct ReadMsgInner<'a, R: ?Sized> {\n          reader: &'a mut R,\n          buf: &'a mut Vec<u8>,\n          json: &'a mut Option<serde_json::Value>,\n          // The number of bytes appended to buf. This can be less than buf.len() if\n          // the buffer was not empty when the operation was started.\n          read: usize,\n      }\n  }\n\n  fn read_msg_inner<'a, R>(\n    reader: &'a mut R,\n    buf: &'a mut Vec<u8>,\n    json: &'a mut Option<serde_json::Value>,\n  ) -> ReadMsgInner<'a, R>\n  where\n    R: AsyncBufRead + ?Sized + Unpin,\n  {\n    ReadMsgInner {\n      reader,\n      buf,\n      json,\n      read: 0,\n    }\n  }\n\n  fn read_msg_internal<R: AsyncBufRead + ?Sized>(\n    mut reader: Pin<&mut R>,\n    cx: &mut Context<'_>,\n    buf: &mut Vec<u8>,\n    json: &mut Option<serde_json::Value>,\n    read: &mut usize,\n  ) -> Poll<io::Result<usize>> {\n    loop {\n      let (done, used) = {\n        let available = match reader.as_mut().poll_fill_buf(cx) {\n          std::task::Poll::Ready(t) => t?,\n          std::task::Poll::Pending => return std::task::Poll::Pending,\n        };\n\n        if let Some(i) = memchr(b'\\n', available) {\n          if *read == 0 {\n            // Fast path: parse and put into the json slot directly.\n            //\n            // Safety: It is ok to overwrite the  contents because\n            // we don't need to copy it into the buffer and the length will be reset.\n            let available = unsafe {\n              std::slice::from_raw_parts_mut(\n                available.as_ptr() as *mut u8,\n                available.len(),\n              )\n            };\n            json.replace(\n              simd_json::from_slice(&mut available[..i + 1])\n                .map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))?,\n            );\n          } else {\n            // This is not the first read, so we have to copy the data\n            // to make it contiguous.\n            buf.extend_from_slice(&available[..=i]);\n          }\n          (true, i + 1)\n        } else {\n          buf.extend_from_slice(available);\n          (false, available.len())\n        }\n      };\n\n      reader.as_mut().consume(used);\n      *read += used;\n      if done || used == 0 {\n        return Poll::Ready(Ok(mem::replace(read, 0)));\n      }\n    }\n  }\n\n  impl<R: AsyncBufRead + ?Sized + Unpin> Future for ReadMsgInner<'_, R> {\n    type Output = io::Result<usize>;\n\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n      let me = self.project();\n      read_msg_internal(Pin::new(*me.reader), cx, me.buf, me.json, me.read)\n    }\n  }\n\n  #[cfg(all(target_os = \"macos\", target_arch = \"aarch64\"))]\n  mod neon {\n    use std::arch::aarch64::*;\n\n    pub unsafe fn neon_memchr(\n      str: &[u8],\n      c: u8,\n      length: usize,\n    ) -> Option<usize> {\n      let end = str.as_ptr().wrapping_add(length);\n\n      // Alignment handling\n      let mut ptr = str.as_ptr();\n      while ptr < end && (ptr as usize) & 0xF != 0 {\n        if *ptr == c {\n          return Some(ptr as usize - str.as_ptr() as usize);\n        }\n        ptr = ptr.wrapping_add(1);\n      }\n\n      let search_char = vdupq_n_u8(c);\n\n      while ptr.wrapping_add(16) <= end {\n        let chunk = vld1q_u8(ptr);\n        let comparison = vceqq_u8(chunk, search_char);\n\n        // Check first 64 bits\n        let result0 = vgetq_lane_u64(vreinterpretq_u64_u8(comparison), 0);\n        if result0 != 0 {\n          return Some(\n            (ptr as usize - str.as_ptr() as usize)\n              + result0.trailing_zeros() as usize / 8,\n          );\n        }\n\n        // Check second 64 bits\n        let result1 = vgetq_lane_u64(vreinterpretq_u64_u8(comparison), 1);\n        if result1 != 0 {\n          return Some(\n            (ptr as usize - str.as_ptr() as usize)\n              + 8\n              + result1.trailing_zeros() as usize / 8,\n          );\n        }\n\n        ptr = ptr.wrapping_add(16);\n      }\n\n      // Handle remaining unaligned characters\n      while ptr < end {\n        if *ptr == c {\n          return Some(ptr as usize - str.as_ptr() as usize);\n        }\n        ptr = ptr.wrapping_add(1);\n      }\n\n      None\n    }\n  }\n\n  #[cfg(test)]\n  mod tests {\n    use super::IpcJsonStreamResource;\n    use deno_core::serde_json;\n    use deno_core::serde_json::json;\n    use deno_core::RcRef;\n    use std::rc::Rc;\n\n    #[tokio::test]\n    async fn bench_ipc() -> Result<(), Box<dyn std::error::Error>> {\n      // A simple round trip benchmark for quick dev feedback.\n      //\n      // Only ran when the env var is set.\n      if std::env::var_os(\"BENCH_IPC_DENO\").is_none() {\n        return Ok(());\n      }\n\n      let (fd1, mut fd2) = tokio::net::UnixStream::pair()?;\n      let child = tokio::spawn(async move {\n        use tokio::io::AsyncWriteExt;\n\n        let size = 1024 * 1024;\n\n        let stri = \"x\".repeat(size);\n        let data = format!(\"\\\"{}\\\"\\n\", stri);\n        for _ in 0..100 {\n          fd2.write_all(data.as_bytes()).await?;\n        }\n        Ok::<_, std::io::Error>(())\n      });\n\n      let ipc = Rc::new(IpcJsonStreamResource::from_unix_stream(fd1));\n\n      let start = std::time::Instant::now();\n      let mut bytes = 0;\n\n      let mut ipc = RcRef::map(ipc, |r| &r.read_half).borrow_mut().await;\n      loop {\n        let msgs = ipc.read_msg().await?;\n        if msgs == serde_json::Value::Null {\n          break;\n        }\n        bytes += msgs.as_str().unwrap().len();\n        if start.elapsed().as_secs() > 5 {\n          break;\n        }\n      }\n      let elapsed = start.elapsed();\n      let mb = bytes as f64 / 1024.0 / 1024.0;\n      println!(\"{} mb/s\", mb / elapsed.as_secs_f64());\n\n      child.await??;\n\n      Ok(())\n    }\n\n    #[tokio::test]\n    async fn unix_ipc_json() -> Result<(), Box<dyn std::error::Error>> {\n      let (fd1, mut fd2) = tokio::net::UnixStream::pair()?;\n      let child = tokio::spawn(async move {\n        use tokio::io::AsyncReadExt;\n        use tokio::io::AsyncWriteExt;\n\n        let mut buf = [0u8; 1024];\n        let n = fd2.read(&mut buf).await?;\n        assert_eq!(&buf[..n], b\"\\\"hello\\\"\\n\");\n        fd2.write_all(b\"\\\"world\\\"\\n\").await?;\n        Ok::<_, std::io::Error>(())\n      });\n\n      /* Similar to how ops would use the resource */\n      let ipc = Rc::new(IpcJsonStreamResource::from_unix_stream(fd1));\n\n      ipc.clone().write_msg(json!(\"hello\")).await?;\n\n      let mut ipc = RcRef::map(ipc, |r| &r.read_half).borrow_mut().await;\n      let msgs = ipc.read_msg().await?;\n      assert_eq!(msgs, json!(\"world\"));\n\n      child.await??;\n\n      Ok(())\n    }\n\n    #[tokio::test]\n    async fn unix_ipc_json_multi() -> Result<(), Box<dyn std::error::Error>> {\n      let (fd1, mut fd2) = tokio::net::UnixStream::pair()?;\n      let child = tokio::spawn(async move {\n        use tokio::io::AsyncReadExt;\n        use tokio::io::AsyncWriteExt;\n\n        let mut buf = [0u8; 1024];\n        let n = fd2.read(&mut buf).await?;\n        assert_eq!(&buf[..n], b\"\\\"hello\\\"\\n\\\"world\\\"\\n\");\n        fd2.write_all(b\"\\\"foo\\\"\\n\\\"bar\\\"\\n\").await?;\n        Ok::<_, std::io::Error>(())\n      });\n\n      let ipc = Rc::new(IpcJsonStreamResource::from_unix_stream(fd1));\n      ipc.clone().write_msg(json!(\"hello\")).await?;\n      ipc.clone().write_msg(json!(\"world\")).await?;\n\n      let mut ipc = RcRef::map(ipc, |r| &r.read_half).borrow_mut().await;\n      let msgs = ipc.read_msg().await?;\n      assert_eq!(msgs, json!(\"foo\"));\n\n      child.await??;\n\n      Ok(())\n    }\n\n    #[tokio::test]\n    async fn unix_ipc_json_invalid() -> Result<(), Box<dyn std::error::Error>> {\n      let (fd1, mut fd2) = tokio::net::UnixStream::pair()?;\n      let child = tokio::spawn(async move {\n        tokio::io::AsyncWriteExt::write_all(&mut fd2, b\"\\n\\n\").await?;\n        Ok::<_, std::io::Error>(())\n      });\n\n      let ipc = Rc::new(IpcJsonStreamResource::from_unix_stream(fd1));\n      let mut ipc = RcRef::map(ipc, |r| &r.read_half).borrow_mut().await;\n      let _err = ipc.read_msg().await.unwrap_err();\n\n      child.await??;\n\n      Ok(())\n    }\n\n    #[test]\n    fn memchr() {\n      let str = b\"hello world\";\n      assert_eq!(super::memchr(b'h', str), Some(0));\n      assert_eq!(super::memchr(b'w', str), Some(6));\n      assert_eq!(super::memchr(b'd', str), Some(10));\n      assert_eq!(super::memchr(b'x', str), None);\n\n      let empty = b\"\";\n      assert_eq!(super::memchr(b'\\n', empty), None);\n    }\n  }\n}\n\n#[cfg(windows)]\nmod windows {\n  use deno_core::error::AnyError;\n  use deno_core::op2;\n\n  #[op2(fast)]\n  pub fn op_node_ipc_pipe() -> Result<(), AnyError> {\n    Err(deno_core::error::not_supported())\n  }\n\n  #[op2(fast)]\n  #[smi]\n  pub fn op_node_child_ipc_pipe() -> Result<i32, AnyError> {\n    Ok(-1)\n  }\n\n  #[op2(async)]\n  pub async fn op_node_ipc_write() -> Result<(), AnyError> {\n    Err(deno_core::error::not_supported())\n  }\n\n  #[op2(async)]\n  pub async fn op_node_ipc_read() -> Result<(), AnyError> {\n    Err(deno_core::error::not_supported())\n  }\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2024-27935", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "// Copyright 2018-2023 the Deno authors. All rights reserved. MIT license.\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// This module ports:\n// - https://github.com/nodejs/node/blob/master/src/stream_base-inl.h\n// - https://github.com/nodejs/node/blob/master/src/stream_base.h\n// - https://github.com/nodejs/node/blob/master/src/stream_base.cc\n// - https://github.com/nodejs/node/blob/master/src/stream_wrap.h\n// - https://github.com/nodejs/node/blob/master/src/stream_wrap.cc\n\n// TODO(petamoriken): enable prefer-primordials for node polyfills\n// deno-lint-ignore-file prefer-primordials\n\nimport { TextEncoder } from \"ext:deno_web/08_text_encoding.js\";\nimport { Buffer } from \"node:buffer\";\nimport { notImplemented } from \"ext:deno_node/_utils.ts\";\nimport { HandleWrap } from \"ext:deno_node/internal_binding/handle_wrap.ts\";\nimport {\n  AsyncWrap,\n  providerType,\n} from \"ext:deno_node/internal_binding/async_wrap.ts\";\nimport { codeMap } from \"ext:deno_node/internal_binding/uv.ts\";\n\nconst core = globalThis.Deno.core;\nconst { ops } = core;\n\ninterface Reader {\n  read(p: Uint8Array): Promise<number | null>;\n}\n\ninterface Writer {\n  write(p: Uint8Array): Promise<number>;\n}\n\nexport interface Closer {\n  close(): void;\n}\n\ntype Ref = { ref(): void; unref(): void };\n\nconst enum StreamBaseStateFields {\n  kReadBytesOrError,\n  kArrayBufferOffset,\n  kBytesWritten,\n  kLastWriteWasAsync,\n  kNumStreamBaseStateFields,\n}\n\nexport const kReadBytesOrError = StreamBaseStateFields.kReadBytesOrError;\nexport const kArrayBufferOffset = StreamBaseStateFields.kArrayBufferOffset;\nexport const kBytesWritten = StreamBaseStateFields.kBytesWritten;\nexport const kLastWriteWasAsync = StreamBaseStateFields.kLastWriteWasAsync;\nexport const kNumStreamBaseStateFields =\n  StreamBaseStateFields.kNumStreamBaseStateFields;\n\nexport const streamBaseState = new Uint8Array(5);\n\n// This is Deno, it always will be async.\nstreamBaseState[kLastWriteWasAsync] = 1;\n\nexport class WriteWrap<H extends HandleWrap> extends AsyncWrap {\n  handle!: H;\n  oncomplete!: (status: number) => void;\n  async!: boolean;\n  bytes!: number;\n  buffer!: unknown;\n  callback!: unknown;\n  _chunks!: unknown[];\n\n  constructor() {\n    super(providerType.WRITEWRAP);\n  }\n}\n\nexport class ShutdownWrap<H extends HandleWrap> extends AsyncWrap {\n  handle!: H;\n  oncomplete!: (status: number) => void;\n  callback!: () => void;\n\n  constructor() {\n    super(providerType.SHUTDOWNWRAP);\n  }\n}\n\nexport const kStreamBaseField = Symbol(\"kStreamBaseField\");\n\nconst SUGGESTED_SIZE = 64 * 1024;\n\nexport class LibuvStreamWrap extends HandleWrap {\n  [kStreamBaseField]?: Reader & Writer & Closer & Ref;\n\n  reading!: boolean;\n  #reading = false;\n  destroyed = false;\n  writeQueueSize = 0;\n  bytesRead = 0;\n  bytesWritten = 0;\n\n  onread!: (_arrayBuffer: Uint8Array, _nread: number) => Uint8Array | undefined;\n\n  constructor(\n    provider: providerType,\n    stream?: Reader & Writer & Closer & Ref,\n  ) {\n    super(provider);\n    this.#attachToObject(stream);\n  }\n\n  /**\n   * Start the reading of the stream.\n   * @return An error status code.\n   */\n  readStart(): number {\n    if (!this.#reading) {\n      this.#reading = true;\n      this.#read();\n    }\n\n    return 0;\n  }\n\n  /**\n   * Stop the reading of the stream.\n   * @return An error status code.\n   */\n  readStop(): number {\n    this.#reading = false;\n\n    return 0;\n  }\n\n  /**\n   * Shutdown the stream.\n   * @param req A shutdown request wrapper.\n   * @return An error status code.\n   */\n  shutdown(req: ShutdownWrap<LibuvStreamWrap>): number {\n    const status = this._onClose();\n\n    try {\n      req.oncomplete(status);\n    } catch {\n      // swallow callback error.\n    }\n\n    return 0;\n  }\n\n  /**\n   * @param userBuf\n   * @return An error status code.\n   */\n  useUserBuffer(_userBuf: unknown): number {\n    // TODO(cmorten)\n    notImplemented(\"LibuvStreamWrap.prototype.useUserBuffer\");\n  }\n\n  /**\n   * Write a buffer to the stream.\n   * @param req A write request wrapper.\n   * @param data The Uint8Array buffer to write to the stream.\n   * @return An error status code.\n   */\n  writeBuffer(req: WriteWrap<LibuvStreamWrap>, data: Uint8Array): number {\n    this.#write(req, data);\n\n    return 0;\n  }\n\n  /**\n   * Write multiple chunks at once.\n   * @param req A write request wrapper.\n   * @param chunks\n   * @param allBuffers\n   * @return An error status code.\n   */\n  writev(\n    req: WriteWrap<LibuvStreamWrap>,\n    chunks: Buffer[] | (string | Buffer)[],\n    allBuffers: boolean,\n  ): number {\n    const supportsWritev = this.provider === providerType.TCPSERVERWRAP;\n    const rid = this[kStreamBaseField]!.rid;\n    // Fast case optimization: two chunks, and all buffers.\n    if (\n      chunks.length === 2 && allBuffers && supportsWritev &&\n      ops.op_can_write_vectored(rid)\n    ) {\n      // String chunks.\n      if (typeof chunks[0] === \"string\") chunks[0] = Buffer.from(chunks[0]);\n      if (typeof chunks[1] === \"string\") chunks[1] = Buffer.from(chunks[1]);\n\n      ops.op_raw_write_vectored(\n        rid,\n        chunks[0],\n        chunks[1],\n      ).then((nwritten) => {\n        try {\n          req.oncomplete(0);\n        } catch {\n          // swallow callback errors.\n        }\n\n        streamBaseState[kBytesWritten] = nwritten;\n        this.bytesWritten += nwritten;\n      });\n\n      return 0;\n    }\n\n    const count = allBuffers ? chunks.length : chunks.length >> 1;\n    const buffers: Buffer[] = new Array(count);\n\n    if (!allBuffers) {\n      for (let i = 0; i < count; i++) {\n        const chunk = chunks[i * 2];\n\n        if (Buffer.isBuffer(chunk)) {\n          buffers[i] = chunk;\n        }\n\n        // String chunk\n        const encoding: string = chunks[i * 2 + 1] as string;\n        buffers[i] = Buffer.from(chunk as string, encoding);\n      }\n    } else {\n      for (let i = 0; i < count; i++) {\n        buffers[i] = chunks[i] as Buffer;\n      }\n    }\n\n    return this.writeBuffer(req, Buffer.concat(buffers));\n  }\n\n  /**\n   * Write an ASCII string to the stream.\n   * @return An error status code.\n   */\n  writeAsciiString(req: WriteWrap<LibuvStreamWrap>, data: string): number {\n    const buffer = new TextEncoder().encode(data);\n\n    return this.writeBuffer(req, buffer);\n  }\n\n  /**\n   * Write an UTF8 string to the stream.\n   * @return An error status code.\n   */\n  writeUtf8String(req: WriteWrap<LibuvStreamWrap>, data: string): number {\n    const buffer = new TextEncoder().encode(data);\n\n    return this.writeBuffer(req, buffer);\n  }\n\n  /**\n   * Write an UCS2 string to the stream.\n   * @return An error status code.\n   */\n  writeUcs2String(_req: WriteWrap<LibuvStreamWrap>, _data: string): number {\n    notImplemented(\"LibuvStreamWrap.prototype.writeUcs2String\");\n  }\n\n  /**\n   * Write an LATIN1 string to the stream.\n   * @return An error status code.\n   */\n  writeLatin1String(req: WriteWrap<LibuvStreamWrap>, data: string): number {\n    const buffer = Buffer.from(data, \"latin1\");\n    return this.writeBuffer(req, buffer);\n  }\n\n  override _onClose(): number {\n    let status = 0;\n    this.#reading = false;\n\n    try {\n      this[kStreamBaseField]?.close();\n    } catch {\n      status = codeMap.get(\"ENOTCONN\")!;\n    }\n\n    return status;\n  }\n\n  /**\n   * Attaches the class to the underlying stream.\n   * @param stream The stream to attach to.\n   */\n  #attachToObject(stream?: Reader & Writer & Closer & Ref) {\n    this[kStreamBaseField] = stream;\n  }\n\n  /** Internal method for reading from the attached stream. */\n  async #read() {\n    let buf = BUF;\n\n    let nread: number | null;\n    const ridBefore = this[kStreamBaseField]!.rid;\n    try {\n      nread = await this[kStreamBaseField]!.read(buf);\n    } catch (e) {\n      // Try to read again if the underlying stream resource\n      // changed. This can happen during TLS upgrades (eg. STARTTLS)\n      if (ridBefore != this[kStreamBaseField]!.rid) {\n        return this.#read();\n      }\n\n      if (\n        e instanceof Deno.errors.Interrupted ||\n        e instanceof Deno.errors.BadResource\n      ) {\n        nread = codeMap.get(\"EOF\")!;\n      } else if (\n        e instanceof Deno.errors.ConnectionReset ||\n        e instanceof Deno.errors.ConnectionAborted\n      ) {\n        nread = codeMap.get(\"ECONNRESET\")!;\n      } else {\n        nread = codeMap.get(\"UNKNOWN\")!;\n      }\n\n      buf = new Uint8Array(0);\n    }\n\n    nread ??= codeMap.get(\"EOF\")!;\n\n    streamBaseState[kReadBytesOrError] = nread;\n\n    if (nread > 0) {\n      this.bytesRead += nread;\n    }\n\n    buf = buf.slice(0, nread);\n\n    streamBaseState[kArrayBufferOffset] = 0;\n\n    try {\n      this.onread!(buf, nread);\n    } catch {\n      // swallow callback errors.\n    }\n\n    if (nread >= 0 && this.#reading) {\n      this.#read();\n    }\n  }\n\n  /**\n   * Internal method for writing to the attached stream.\n   * @param req A write request wrapper.\n   * @param data The Uint8Array buffer to write to the stream.\n   */\n  async #write(req: WriteWrap<LibuvStreamWrap>, data: Uint8Array) {\n    const { byteLength } = data;\n\n    const ridBefore = this[kStreamBaseField]!.rid;\n\n    let nwritten = 0;\n    try {\n      // TODO(crowlKats): duplicate from runtime/js/13_buffer.js\n      while (nwritten < data.length) {\n        nwritten += await this[kStreamBaseField]!.write(\n          data.subarray(nwritten),\n        );\n      }\n    } catch (e) {\n      // Try to read again if the underlying stream resource\n      // changed. This can happen during TLS upgrades (eg. STARTTLS)\n      if (ridBefore != this[kStreamBaseField]!.rid) {\n        return this.#write(req, data.subarray(nwritten));\n      }\n\n      let status: number;\n\n      // TODO(cmorten): map err to status codes\n      if (\n        e instanceof Deno.errors.BadResource ||\n        e instanceof Deno.errors.BrokenPipe\n      ) {\n        status = codeMap.get(\"EBADF\")!;\n      } else {\n        status = codeMap.get(\"UNKNOWN\")!;\n      }\n\n      try {\n        req.oncomplete(status);\n      } catch {\n        // swallow callback errors.\n      }\n\n      return;\n    }\n\n    streamBaseState[kBytesWritten] = byteLength;\n    this.bytesWritten += byteLength;\n\n    try {\n      req.oncomplete(0);\n    } catch {\n      // swallow callback errors.\n    }\n\n    return;\n  }\n}\n\nconst BUF = new Uint8Array(SUGGESTED_SIZE);\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2024-27936", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n\nuse bytes::Bytes;\nuse deno_core::serde_json::json;\nuse deno_core::url;\nuse deno_fetch::reqwest;\nuse pretty_assertions::assert_eq;\nuse std::io::Read;\nuse std::io::Write;\nuse std::process::Command;\nuse std::process::Stdio;\nuse std::time::Duration;\nuse test_util as util;\nuse test_util::itest;\nuse test_util::TempDir;\nuse trust_dns_client::serialize::txt::Lexer;\nuse trust_dns_client::serialize::txt::Parser;\nuse util::assert_contains;\nuse util::assert_not_contains;\nuse util::env_vars_for_npm_tests;\nuse util::PathRef;\nuse util::TestContext;\nuse util::TestContextBuilder;\n\nitest!(stdout_write_all {\n  args: \"run --quiet run/stdout_write_all.ts\",\n  output: \"run/stdout_write_all.out\",\n});\n\nitest!(stdin_read_all {\n  args: \"run --quiet run/stdin_read_all.ts\",\n  output: \"run/stdin_read_all.out\",\n  input: Some(\"01234567890123456789012345678901234567890123456789\"),\n});\n\nitest!(stdout_write_sync_async {\n  args: \"run --quiet run/stdout_write_sync_async.ts\",\n  output: \"run/stdout_write_sync_async.out\",\n});\n\nitest!(_001_hello {\n  args: \"run --reload run/001_hello.js\",\n  output: \"run/001_hello.js.out\",\n});\n\nitest!(_002_hello {\n  args: \"run --quiet --reload run/002_hello.ts\",\n  output: \"run/002_hello.ts.out\",\n});\n\nitest!(_003_relative_import {\n  args: \"run --quiet --reload run/003_relative_import.ts\",\n  output: \"run/003_relative_import.ts.out\",\n});\n\nitest!(_004_set_timeout {\n  args: \"run --quiet --reload run/004_set_timeout.ts\",\n  output: \"run/004_set_timeout.ts.out\",\n});\n\nitest!(_005_more_imports {\n  args: \"run --quiet --reload run/005_more_imports.ts\",\n  output: \"run/005_more_imports.ts.out\",\n});\n\nitest!(_006_url_imports {\n  args: \"run --quiet --reload run/006_url_imports.ts\",\n  output: \"run/006_url_imports.ts.out\",\n  http_server: true,\n});\n\nitest!(_012_async {\n  args: \"run --quiet --reload run/012_async.ts\",\n  output: \"run/012_async.ts.out\",\n});\n\nitest!(_013_dynamic_import {\n  args: \"run --quiet --reload --allow-read run/013_dynamic_import.ts\",\n  output: \"run/013_dynamic_import.ts.out\",\n});\n\nitest!(_014_duplicate_import {\n  args: \"run --quiet --reload --allow-read run/014_duplicate_import.ts \",\n  output: \"run/014_duplicate_import.ts.out\",\n});\n\nitest!(_015_duplicate_parallel_import {\n  args:\n    \"run --quiet --reload --allow-read run/015_duplicate_parallel_import.js\",\n  output: \"run/015_duplicate_parallel_import.js.out\",\n});\n\nitest!(_016_double_await {\n  args: \"run --quiet --allow-read --reload run/016_double_await.ts\",\n  output: \"run/016_double_await.ts.out\",\n});\n\nitest!(_017_import_redirect {\n  args: \"run --quiet --reload run/017_import_redirect.ts\",\n  output: \"run/017_import_redirect.ts.out\",\n});\n\nitest!(_017_import_redirect_check {\n  args: \"run --quiet --reload --check run/017_import_redirect.ts\",\n  output: \"run/017_import_redirect.ts.out\",\n});\n\nitest!(_017_import_redirect_vendor_dir {\n  args:\n    \"run --quiet --reload --vendor --check $TESTDATA/run/017_import_redirect.ts\",\n  output: \"run/017_import_redirect.ts.out\",\n  temp_cwd: true,\n});\n\nitest!(_017_import_redirect_info {\n  args: \"info --quiet --reload run/017_import_redirect.ts\",\n  output: \"run/017_import_redirect_info.out\",\n});\n\nitest!(_018_async_catch {\n  args: \"run --quiet --reload run/018_async_catch.ts\",\n  output: \"run/018_async_catch.ts.out\",\n});\n\nitest!(_019_media_types {\n  args: \"run --reload run/019_media_types.ts\",\n  output: \"run/019_media_types.ts.out\",\n  http_server: true,\n});\n\nitest!(_020_json_modules {\n  args: \"run --reload run/020_json_modules.ts\",\n  output: \"run/020_json_modules.ts.out\",\n  exit_code: 1,\n});\n\nitest!(_021_mjs_modules {\n  args: \"run --quiet --reload run/021_mjs_modules.ts\",\n  output: \"run/021_mjs_modules.ts.out\",\n});\n\nitest!(_023_no_ext {\n  args: \"run --reload --check run/023_no_ext\",\n  output: \"run/023_no_ext.out\",\n});\n\nitest!(_025_hrtime {\n  args: \"run --quiet --allow-hrtime --reload run/025_hrtime.ts\",\n  output: \"run/025_hrtime.ts.out\",\n});\n\nitest!(_025_reload_js_type_error {\n  args: \"run --quiet --reload run/025_reload_js_type_error.js\",\n  output: \"run/025_reload_js_type_error.js.out\",\n});\n\nitest!(_026_redirect_javascript {\n  args: \"run --quiet --reload run/026_redirect_javascript.js\",\n  output: \"run/026_redirect_javascript.js.out\",\n  http_server: true,\n});\n\nitest!(_027_redirect_typescript {\n  args: \"run --quiet --reload run/027_redirect_typescript.ts\",\n  output: \"run/027_redirect_typescript.ts.out\",\n  http_server: true,\n});\n\nitest!(_027_redirect_typescript_vendor_dir {\n  args:\n    \"run --quiet --reload --vendor $TESTDATA/run/027_redirect_typescript.ts\",\n  output: \"run/027_redirect_typescript.ts.out\",\n  http_server: true,\n  temp_cwd: true,\n});\n\nitest!(_028_args {\n  args:\n    \"run --quiet --reload run/028_args.ts --arg1 val1 --arg2=val2 -- arg3 arg4\",\n  output: \"run/028_args.ts.out\",\n});\n\nitest!(_033_import_map {\n  args:\n    \"run --quiet --reload --import-map=import_maps/import_map.json import_maps/test.ts\",\n  output: \"run/033_import_map.out\",\n});\n\nitest!(_033_import_map_in_config_file {\n  args: \"run --reload --config=import_maps/config.json import_maps/test.ts\",\n  output: \"run/033_import_map_in_config_file.out\",\n});\n\nitest!(_033_import_map_in_flag_has_precedence {\n  args: \"run --quiet --reload --import-map=import_maps/import_map_invalid.json --config=import_maps/config.json import_maps/test.ts\",\n  output: \"run/033_import_map_in_flag_has_precedence.out\",\n  exit_code: 1,\n});\n\nitest!(_033_import_map_remote {\n  args:\n    \"run --quiet --reload --import-map=http://127.0.0.1:4545/import_maps/import_map_remote.json import_maps/test_remote.ts\",\n  output: \"run/033_import_map_remote.out\",\n  http_server: true,\n});\n\nitest!(_033_import_map_vendor_dir_remote {\n  args:\n    \"run --quiet --reload --import-map=http://127.0.0.1:4545/import_maps/import_map_remote.json --vendor $TESTDATA/import_maps/test_remote.ts\",\n  output: \"run/033_import_map_remote.out\",\n  http_server: true,\n  temp_cwd: true,\n});\n\nitest!(_033_import_map_data_uri {\n  args:\n    \"run --quiet --reload --import-map=data:application/json;charset=utf-8;base64,ewogICJpbXBvcnRzIjogewogICAgInRlc3Rfc2VydmVyLyI6ICJodHRwOi8vbG9jYWxob3N0OjQ1NDUvIgogIH0KfQ== run/import_maps/test_data.ts\",\n  output: \"run/import_maps/test_data.ts.out\",\n  http_server: true,\n});\n\nitest!(onload {\n  args: \"run --quiet --reload run/onload/main.ts\",\n  output: \"run/onload/main.out\",\n});\n\nitest!(_035_cached_only_flag {\n  args: \"run --reload --check --cached-only http://127.0.0.1:4545/run/019_media_types.ts\",\n  output: \"run/035_cached_only_flag.out\",\n  exit_code: 1,\n  http_server: true,\n});\n\nitest!(_038_checkjs {\n  // checking if JS file is run through TS compiler\n  args:\n    \"run --reload --config run/checkjs.tsconfig.json --check run/038_checkjs.js\",\n  exit_code: 1,\n  output: \"run/038_checkjs.js.out\",\n});\n\nitest!(_042_dyn_import_evalcontext {\n  args: \"run --quiet --allow-read --reload run/042_dyn_import_evalcontext.ts\",\n  output: \"run/042_dyn_import_evalcontext.ts.out\",\n});\n\nitest!(_044_bad_resource {\n  args: \"run --quiet --reload --allow-read run/044_bad_resource.ts\",\n  output: \"run/044_bad_resource.ts.out\",\n  exit_code: 1,\n});\n\nitest!(_045_proxy {\n  args: \"run -L debug --allow-net --allow-env --allow-run --allow-read --reload --quiet run/045_proxy_test.ts\",\n  output: \"run/045_proxy_test.ts.out\",\n  http_server: true,\n});\n\nitest!(_046_tsx {\n  args: \"run --quiet --reload run/046_jsx_test.tsx\",\n  output: \"run/046_jsx_test.tsx.out\",\n});\n\nitest!(_047_jsx {\n  args: \"run --quiet --reload run/047_jsx_test.jsx\",\n  output: \"run/047_jsx_test.jsx.out\",\n});\n\nitest!(_048_media_types_jsx {\n  args: \"run  --reload run/048_media_types_jsx.ts\",\n  output: \"run/048_media_types_jsx.ts.out\",\n  http_server: true,\n});\n\nitest!(_052_no_remote_flag {\n  args:\n    \"run --reload --check --no-remote http://127.0.0.1:4545/run/019_media_types.ts\",\n  output: \"run/052_no_remote_flag.out\",\n  exit_code: 1,\n  http_server: true,\n});\n\nitest!(_056_make_temp_file_write_perm {\n  args:\n    \"run --quiet --allow-read --allow-write=./subdir/ run/056_make_temp_file_write_perm.ts\",\n  output: \"run/056_make_temp_file_write_perm.out\",\n});\n\nitest!(_058_tasks_microtasks_close {\n  args: \"run --quiet run/058_tasks_microtasks_close.ts\",\n  output: \"run/058_tasks_microtasks_close.ts.out\",\n});\n\nitest!(_059_fs_relative_path_perm {\n  args: \"run run/059_fs_relative_path_perm.ts\",\n  output: \"run/059_fs_relative_path_perm.ts.out\",\n  exit_code: 1,\n});\n\nitest!(_070_location {\n  args: \"run --location https://foo/bar?baz#bat run/070_location.ts\",\n  output: \"run/070_location.ts.out\",\n});\n\nitest!(_071_location_unset {\n  args: \"run run/071_location_unset.ts\",\n  output: \"run/071_location_unset.ts.out\",\n});\n\nitest!(_072_location_relative_fetch {\n  args: \"run --location http://127.0.0.1:4545/ --allow-net run/072_location_relative_fetch.ts\",\n  output: \"run/072_location_relative_fetch.ts.out\",\n  http_server: true,\n});\n\n// tests the beforeunload event\nitest!(beforeunload_event {\n  args: \"run run/before_unload.js\",\n  output: \"run/before_unload.js.out\",\n});\n\n// tests the serialization of webstorage (both localStorage and sessionStorage)\nitest!(webstorage_serialization {\n  args: \"run run/webstorage/serialization.ts\",\n  output: \"run/webstorage/serialization.ts.out\",\n});\n\n// tests to ensure that when `--location` is set, all code shares the same\n// localStorage cache based on the origin of the location URL.\n#[test]\nfn webstorage_location_shares_origin() {\n  let deno_dir = util::new_deno_dir();\n\n  let output = util::deno_cmd_with_deno_dir(&deno_dir)\n    .current_dir(util::testdata_path())\n    .arg(\"run\")\n    .arg(\"--location\")\n    .arg(\"https://example.com/a.ts\")\n    .arg(\"run/webstorage/fixture.ts\")\n    .stdout(Stdio::piped())\n    .spawn()\n    .unwrap()\n    .wait_with_output()\n    .unwrap();\n  assert!(output.status.success());\n  assert_eq!(output.stdout, b\"Storage { length: 0 }\\n\");\n\n  let output = util::deno_cmd_with_deno_dir(&deno_dir)\n    .current_dir(util::testdata_path())\n    .arg(\"run\")\n    .arg(\"--location\")\n    .arg(\"https://example.com/b.ts\")\n    .arg(\"run/webstorage/logger.ts\")\n    .stdout(Stdio::piped())\n    .spawn()\n    .unwrap()\n    .wait_with_output()\n    .unwrap();\n  assert!(output.status.success());\n  assert_eq!(output.stdout, b\"Storage { hello: \\\"deno\\\", length: 1 }\\n\");\n}\n\n// test to ensure that when a --config file is set, but no --location, that\n// storage persists against unique configuration files.\n#[test]\nfn webstorage_config_file() {\n  let context = TestContext::default();\n\n  context\n    .new_command()\n    .args(\n      \"run --config run/webstorage/config_a.jsonc run/webstorage/fixture.ts\",\n    )\n    .run()\n    .assert_matches_text(\"Storage { length: 0 }\\n\");\n\n  context\n    .new_command()\n    .args(\"run --config run/webstorage/config_b.jsonc run/webstorage/logger.ts\")\n    .run()\n    .assert_matches_text(\"Storage { length: 0 }\\n\");\n\n  context\n    .new_command()\n    .args(\"run --config run/webstorage/config_a.jsonc run/webstorage/logger.ts\")\n    .run()\n    .assert_matches_text(\"Storage { hello: \\\"deno\\\", length: 1 }\\n\");\n}\n\n// tests to ensure `--config` does not effect persisted storage when a\n// `--location` is provided.\n#[test]\nfn webstorage_location_precedes_config() {\n  let context = TestContext::default();\n\n  context.new_command()\n    .args(\"run --location https://example.com/a.ts --config run/webstorage/config_a.jsonc run/webstorage/fixture.ts\")\n    .run()\n    .assert_matches_text(\"Storage { length: 0 }\\n\");\n\n  context.new_command()\n    .args(\"run --location https://example.com/b.ts --config run/webstorage/config_b.jsonc run/webstorage/logger.ts\")\n    .run()\n    .assert_matches_text(\"Storage { hello: \\\"deno\\\", length: 1 }\\n\");\n}\n\n// test to ensure that when there isn't a configuration or location, that the\n// main module is used to determine how to persist storage data.\n#[test]\nfn webstorage_main_module() {\n  let context = TestContext::default();\n\n  context\n    .new_command()\n    .args(\"run run/webstorage/fixture.ts\")\n    .run()\n    .assert_matches_text(\"Storage { length: 0 }\\n\");\n\n  context\n    .new_command()\n    .args(\"run run/webstorage/logger.ts\")\n    .run()\n    .assert_matches_text(\"Storage { length: 0 }\\n\");\n\n  context\n    .new_command()\n    .args(\"run run/webstorage/fixture.ts\")\n    .run()\n    .assert_matches_text(\"Storage { hello: \\\"deno\\\", length: 1 }\\n\");\n}\n\nitest!(_075_import_local_query_hash {\n  args: \"run run/075_import_local_query_hash.ts\",\n  output: \"run/075_import_local_query_hash.ts.out\",\n});\n\nitest!(_077_fetch_empty {\n  args: \"run -A run/077_fetch_empty.ts\",\n  output: \"run/077_fetch_empty.ts.out\",\n  exit_code: 1,\n});\n\nitest!(_078_unload_on_exit {\n  args: \"run run/078_unload_on_exit.ts\",\n  output: \"run/078_unload_on_exit.ts.out\",\n  exit_code: 1,\n});\n\nitest!(_079_location_authentication {\n  args:\n    \"run --location https://foo:bar@baz/qux run/079_location_authentication.ts\",\n  output: \"run/079_location_authentication.ts.out\",\n});\n\nitest!(_081_location_relative_fetch_redirect {\n    args: \"run --location http://127.0.0.1:4546/ --allow-net run/081_location_relative_fetch_redirect.ts\",\n    output: \"run/081_location_relative_fetch_redirect.ts.out\",\n    http_server: true,\n  });\n\nitest!(_082_prepare_stack_trace_throw {\n  args: \"run run/082_prepare_stack_trace_throw.js\",\n  output: \"run/082_prepare_stack_trace_throw.js.out\",\n  exit_code: 1,\n});\n\n#[test]\nfn _083_legacy_external_source_map() {\n  let _g = util::http_server();\n  let deno_dir = TempDir::new();\n  let module_url = url::Url::parse(\n    \"http://localhost:4545/run/083_legacy_external_source_map.ts\",\n  )\n  .unwrap();\n  // Write a faulty old external source map.\n  let faulty_map_path = deno_dir.path().join(\"gen/http/localhost_PORT4545/9576bd5febd0587c5c4d88d57cb3ac8ebf2600c529142abe3baa9a751d20c334.js.map\");\n  faulty_map_path.parent().create_dir_all();\n  faulty_map_path.write(r#\"{\\\"version\\\":3,\\\"file\\\":\\\"\\\",\\\"sourceRoot\\\":\\\"\\\",\\\"sources\\\":[\\\"http://localhost:4545/083_legacy_external_source_map.ts\\\"],\\\"names\\\":[],\\\"mappings\\\":\\\";AAAA,MAAM,IAAI,KAAK,CAAC,KAAK,CAAC,CAAC\\\"}\"#);\n  let output = Command::new(util::deno_exe_path())\n    .env(\"DENO_DIR\", deno_dir.path())\n    .current_dir(util::testdata_path())\n    .arg(\"run\")\n    .arg(module_url.to_string())\n    .output()\n    .unwrap();\n  // Before https://github.com/denoland/deno/issues/6965 was fixed, the faulty\n  // old external source map would cause a panic while formatting the error\n  // and the exit code would be 101. The external source map should be ignored\n  // in favor of the inline one.\n  assert_eq!(output.status.code(), Some(1));\n  let out = std::str::from_utf8(&output.stdout).unwrap();\n  assert_eq!(out, \"\");\n}\n\nitest!(dynamic_import_async_error {\n  args: \"run --allow-read run/dynamic_import_async_error/main.ts\",\n  output: \"run/dynamic_import_async_error/main.out\",\n});\n\nitest!(dynamic_import_already_rejected {\n  args: \"run --allow-read run/dynamic_import_already_rejected/main.ts\",\n  output: \"run/dynamic_import_already_rejected/main.out\",\n});\n\nitest!(dynamic_import_concurrent_non_statically_analyzable {\n  args: \"run --allow-read --allow-net --quiet run/dynamic_import_concurrent_non_statically_analyzable/main.ts\",\n  output: \"run/dynamic_import_concurrent_non_statically_analyzable/main.out\",\n  http_server: true,\n});\n\nitest!(no_check_imports_not_used_as_values {\n    args: \"run --config run/no_check_imports_not_used_as_values/preserve_imports.tsconfig.json --no-check run/no_check_imports_not_used_as_values/main.ts\",\n    output: \"run/no_check_imports_not_used_as_values/main.out\",\n  });\n\nitest!(_088_dynamic_import_already_evaluating {\n  args: \"run --allow-read run/088_dynamic_import_already_evaluating.ts\",\n  output: \"run/088_dynamic_import_already_evaluating.ts.out\",\n});\n\n// TODO(bartlomieju): remove --unstable once Deno.Command is stabilized\nitest!(_089_run_allow_list {\n  args: \"run --unstable --allow-run=curl run/089_run_allow_list.ts\",\n  output: \"run/089_run_allow_list.ts.out\",\n});\n\n#[test]\nfn _090_run_permissions_request() {\n  TestContext::default()\n    .new_command()\n    .args_vec([\"run\", \"--quiet\", \"run/090_run_permissions_request.ts\"])\n    .with_pty(|mut console| {\n      console.expect(concat!(\n        \"   Deno requests run access to \\\"ls\\\".\\r\\n\",\n        \" Requested by `Deno.permissions.request()` API.\\r\\n\",\n        \" Run again with --allow-run to bypass this prompt.\\r\\n\",\n        \" Allow? [y/n/A] (y = yes, allow; n = no, deny; A = allow all run permissions)\",\n      ));\n      console.write_line_raw(\"y\");\n      console.expect(\"Granted run access to \\\"ls\\\".\");\n      console.expect(concat!(\n        \"   Deno requests run access to \\\"cat\\\".\\r\\n\",\n        \" Requested by `Deno.permissions.request()` API.\\r\\n\",\n        \" Run again with --allow-run to bypass this prompt.\\r\\n\",\n        \" Allow? [y/n/A] (y = yes, allow; n = no, deny; A = allow all run permissions)\",\n      ));\n      console.write_line_raw(\"n\");\n      console.expect(\"Denied run access to \\\"cat\\\".\");\n      console.expect(\"granted\");\n      console.expect(\"denied\");\n    });\n}\n\n#[test]\nfn _090_run_permissions_request_sync() {\n  TestContext::default()\n    .new_command()\n    .args_vec([\"run\", \"--quiet\", \"run/090_run_permissions_request_sync.ts\"])\n    .with_pty(|mut console| {\n      console.expect(concat!(\n        \"   Deno requests run access to \\\"ls\\\".\\r\\n\",\n        \" Requested by `Deno.permissions.request()` API.\\r\\n\",\n        \" Run again with --allow-run to bypass this prompt.\\r\\n\",\n        \" Allow? [y/n/A] (y = yes, allow; n = no, deny; A = allow all run permissions)\",\n      ));\n      console.write_line_raw(\"y\");\n      console.expect(\"Granted run access to \\\"ls\\\".\");\n      console.expect(concat!(\n        \"   Deno requests run access to \\\"cat\\\".\\r\\n\",\n        \" Requested by `Deno.permissions.request()` API.\\r\\n\",\n        \" Run again with --allow-run to bypass this prompt.\\r\\n\",\n        \" Allow? [y/n/A] (y = yes, allow; n = no, deny; A = allow all run permissions)\",\n      ));\n      console.write_line_raw(\"n\");\n      console.expect(\"Denied run access to \\\"cat\\\".\");\n      console.expect(\"granted\");\n      console.expect(\"denied\");\n    });\n}\n\n#[test]\nfn permissions_prompt_allow_all() {\n  TestContext::default()\n    .new_command()\n    .args_vec([\"run\", \"--quiet\", \"run/permissions_prompt_allow_all.ts\"])\n    .with_pty(|mut console| {\n      // \"run\" permissions\n      console.expect(concat!(\n        \"   Deno requests run access to \\\"FOO\\\".\\r\\n\",\n        \" Requested by `Deno.permissions.request()` API.\\r\\n\",\n        \" Run again with --allow-run to bypass this prompt.\\r\\n\",\n        \" Allow? [y/n/A] (y = yes, allow; n = no, deny; A = allow all run permissions)\",\n      ));\n      console.write_line_raw(\"A\");\n      console.expect(\" Granted all run access.\");\n      // \"read\" permissions\n      console.expect(concat!(\n        \"   Deno requests read access to \\\"FOO\\\".\\r\\n\",\n        \" Requested by `Deno.permissions.request()` API.\\r\\n\",\n        \" Run again with --allow-read to bypass this prompt.\\r\\n\",\n        \" Allow? [y/n/A] (y = yes, allow; n = no, deny; A = allow all read permissions)\",\n      ));\n      console.write_line_raw(\"A\");\n      console.expect(\" Granted all read access.\");\n      // \"write\" permissions\n      console.expect(concat!(\n        \"   Deno requests write access to \\\"FOO\\\".\\r\\n\",\n        \" Requested by `Deno.permissions.request()` API.\\r\\n\",\n        \" Run again with --allow-write to bypass this prompt.\\r\\n\",\n        \" Allow? [y/n/A] (y = yes, allow; n = no, deny; A = allow all write permissions)\",\n      ));\n      console.write_line_raw(\"A\");\n      console.expect(\" Granted all write access.\");\n      // \"net\" permissions\n      console.expect(concat!(\n        \"   Deno requests net access to \\\"foo\\\".\\r\\n\",\n        \" Requested by `Deno.permissions.request()` API.\\r\\n\",\n        \" Run again with --allow-net to bypass this prompt.\\r\\n\",\n        \" Allow? [y/n/A] (y = yes, allow; n = no, deny; A = allow all net permissions)\",\n      ));\n      console.write_line_raw(\"A\\n\");\n      console.expect(\" Granted all net access.\");\n      // \"env\" permissions\n      console.expect(concat!(\n        \"   Deno requests env access to \\\"FOO\\\".\\r\\n\",\n        \" Requested by `Deno.permissions.request()` API.\\r\\n\",\n        \" Run again with --allow-env to bypass this prompt.\\r\\n\",\n        \" Allow? [y/n/A] (y = yes, allow; n = no, deny; A = allow all env permissions)\",\n      ));\n      console.write_line_raw(\"A\\n\");\n      console.expect(\" Granted all env access.\");\n      // \"sys\" permissions\n      console.expect(concat!(\n        \"   Deno requests sys access to \\\"loadavg\\\".\\r\\n\",\n        \" Requested by `Deno.permissions.request()` API.\\r\\n\",\n        \" Run again with --allow-sys to bypass this prompt.\\r\\n\",\n        \" Allow? [y/n/A] (y = yes, allow; n = no, deny; A = allow all sys permissions)\",\n      ));\n      console.write_line_raw(\"A\\n\");\n      console.expect(\" Granted all sys access.\");\n      // \"ffi\" permissions\n      console.expect(concat!(\n        \"   Deno requests ffi access to \\\"FOO\\\".\\r\\n\",\n        \" Requested by `Deno.permissions.request()` API.\\r\\n\",\n        \" Run again with --allow-ffi to bypass this prompt.\\r\\n\",\n        \" Allow? [y/n/A] (y = yes, allow; n = no, deny; A = allow all ffi permissions)\",\n      ));\n      console.write_line_raw(\"A\\n\");\n      console.expect(\" Granted all ffi access.\")\n    },\n  );\n}\n\n#[test]\nfn permissions_prompt_allow_all_2() {\n  TestContext::default()\n    .new_command()\n    .args_vec([\"run\", \"--quiet\", \"run/permissions_prompt_allow_all_2.ts\"])\n    .with_pty(|mut console| {\n      // \"env\" permissions\n      console.expect(concat!(\n        \"   Deno requests env access to \\\"FOO\\\".\\r\\n\",\n        \" Run again with --allow-env to bypass this prompt.\\r\\n\",\n        \" Allow? [y/n/A] (y = yes, allow; n = no, deny; A = allow all env permissions)\",\n      ));\n      console.write_line_raw(\"A\");\n      console.expect(\" Granted all env access.\");\n\n      // \"sys\" permissions\n      console.expect(concat!(\n        \"   Deno requests sys access to \\\"loadavg\\\".\\r\\n\",\n        \" Requested by `Deno.loadavg()` API.\\r\\n\",\n        \" Run again with --allow-sys to bypass this prompt.\\r\\n\",\n        \" Allow? [y/n/A] (y = yes, allow; n = no, deny; A = allow all sys permissions)\",\n      ));\n      console.write_line_raw(\"A\");\n      console.expect(\" Granted all sys access.\");\n\n      // \"read\" permissions\n      console.expect(concat!(\n        \"   Deno requests read access to <CWD>.\\r\\n\",\n        \" Requested by `Deno.cwd()` API.\\r\\n\",\n        \" Run again with --allow-read to bypass this prompt.\\r\\n\",\n        \" Allow? [y/n/A] (y = yes, allow; n = no, deny; A = allow all read permissions)\",\n      ));\n      console.write_line_raw(\"A\");\n      console.expect(\" Granted all read access.\");\n    });\n}\n\n#[test]\nfn permissions_prompt_allow_all_lowercase_a() {\n  TestContext::default()\n    .new_command()\n    .args_vec([\"run\", \"--quiet\", \"run/permissions_prompt_allow_all.ts\"])\n    .with_pty(|mut console| {\n      // \"run\" permissions\n      console.expect(concat!(\n        \"   Deno requests run access to \\\"FOO\\\".\\r\\n\",\n        \" Requested by `Deno.permissions.request()` API.\\r\\n\",\n        \" Run again with --allow-run to bypass this prompt.\\r\\n\",\n        \" Allow? [y/n/A] (y = yes, allow; n = no, deny; A = allow all run permissions)\",\n      ));\n      console.write_line_raw(\"a\");\n      console.expect(\"Unrecognized option.\");\n    });\n}\n\n#[test]\nfn permission_request_long() {\n  TestContext::default()\n    .new_command()\n    .args_vec([\"run\", \"--quiet\", \"run/permission_request_long.ts\"])\n    .with_pty(|mut console| {\n      console.expect(concat!(\n        \" Permission prompt length (100017 bytes) was larger than the configured maximum length (10240 bytes): denying request.\\r\\n\",\n        \" WARNING: This may indicate that code is trying to bypass or hide permission check requests.\\r\\n\",\n        \" Run again with --allow-read to bypass this check if this is really what you want to do.\\r\\n\",\n      ));\n    });\n}\n\nitest!(deny_all_permission_args {\n  args: \"run --deny-env --deny-read --deny-write --deny-ffi --deny-run --deny-sys --deny-net --deny-hrtime run/deny_all_permission_args.js\",\n  output: \"run/deny_all_permission_args.out\",\n});\n\nitest!(deny_some_permission_args {\n  args: \"run --allow-env --deny-env=FOO --allow-read --deny-read=/foo --allow-write --deny-write=/foo --allow-ffi --deny-ffi=/foo --allow-run --deny-run=foo --allow-sys --deny-sys=hostname --allow-net --deny-net=127.0.0.1 --allow-hrtime --deny-hrtime run/deny_some_permission_args.js\",\n  output: \"run/deny_some_permission_args.out\",\n});\n\n#[test]\nfn permissions_cache() {\n  TestContext::default()\n    .new_command()\n    .args_vec([\"run\", \"--quiet\", \"run/permissions_cache.ts\"])\n    .with_pty(|mut console| {\n      console.expect(concat!(\n        \"prompt\\r\\n\",\n        \"   Deno requests read access to \\\"foo\\\".\\r\\n\",\n        \" Requested by `Deno.permissions.request()` API.\\r\\n\",\n        \" Run again with --allow-read to bypass this prompt.\\r\\n\",\n        \" Allow? [y/n/A] (y = yes, allow; n = no, deny; A = allow all read permissions)\",\n      ));\n      console.write_line_raw(\"y\");\n      console.expect(\" Granted read access to \\\"foo\\\".\");\n      console.expect(\"granted\");\n      console.expect(\"prompt\");\n    });\n}\n\nitest!(env_file {\n  args: \"run --env=env --allow-env run/env_file.ts\",\n  output: \"run/env_file.out\",\n});\n\nitest!(env_file_missing {\n  args: \"run --env=missing --allow-env run/env_file.ts\",\n  output: \"run/env_file_missing.out\",\n});\n\nitest!(_091_use_define_for_class_fields {\n  args: \"run --check run/091_use_define_for_class_fields.ts\",\n  output: \"run/091_use_define_for_class_fields.ts.out\",\n  exit_code: 1,\n});\n\nitest!(_092_import_map_unmapped_bare_specifier {\n  args: \"run --import-map import_maps/import_map.json run/092_import_map_unmapped_bare_specifier.ts\",\n  output: \"run/092_import_map_unmapped_bare_specifier.ts.out\",\n  exit_code: 1,\n});\n\nitest!(js_import_detect {\n  args: \"run --quiet --reload run/js_import_detect.ts\",\n  output: \"run/js_import_detect.ts.out\",\n  exit_code: 0,\n});\n\nitest!(blob_gc_finalization {\n  args: \"run run/blob_gc_finalization.js\",\n  output: \"run/blob_gc_finalization.js.out\",\n  exit_code: 0,\n});\n\nitest!(fetch_response_finalization {\n  args:\n    \"run --v8-flags=--expose-gc --allow-net run/fetch_response_finalization.js\",\n  output: \"run/fetch_response_finalization.js.out\",\n  http_server: true,\n  exit_code: 0,\n});\n\nitest!(import_type {\n  args: \"run --reload run/import_type.ts\",\n  output: \"run/import_type.ts.out\",\n});\n\nitest!(import_type_no_check {\n  args: \"run --reload --no-check run/import_type.ts\",\n  output: \"run/import_type.ts.out\",\n});\n\nitest!(private_field_presence {\n  args: \"run --reload run/private_field_presence.ts\",\n  output: \"run/private_field_presence.ts.out\",\n});\n\nitest!(private_field_presence_no_check {\n  args: \"run --reload --no-check run/private_field_presence.ts\",\n  output: \"run/private_field_presence.ts.out\",\n});\n\nitest!(lock_write_fetch {\n  args:\n    \"run --quiet --allow-read --allow-write --allow-env --allow-run run/lock_write_fetch/main.ts\",\n  output: \"run/lock_write_fetch/main.out\",\n  http_server: true,\n  exit_code: 0,\n});\n\nitest!(lock_check_ok {\n  args:\n    \"run --quiet --lock=run/lock_check_ok.json http://127.0.0.1:4545/run/003_relative_import.ts\",\n  output: \"run/003_relative_import.ts.out\",\n  http_server: true,\n});\n\nitest!(lock_check_ok2 {\n  args: \"run --lock=run/lock_check_ok2.json run/019_media_types.ts\",\n  output: \"run/019_media_types.ts.out\",\n  http_server: true,\n});\n\nitest!(lock_dynamic_imports {\n  args: \"run --lock=run/lock_dynamic_imports.json --allow-read --allow-net http://127.0.0.1:4545/run/013_dynamic_import.ts\",\n  output: \"run/lock_dynamic_imports.out\",\n  exit_code: 10,\n  http_server: true,\n});\n\nitest!(lock_check_err {\n  args: \"run --lock=run/lock_check_err.json http://127.0.0.1:4545/run/003_relative_import.ts\",\n  output: \"run/lock_check_err.out\",\n  exit_code: 10,\n  http_server: true,\n});\n\nitest!(lock_check_err2 {\n  args: \"run --lock=run/lock_check_err2.json run/019_media_types.ts\",\n  output: \"run/lock_check_err2.out\",\n  exit_code: 10,\n  http_server: true,\n});\n\nitest!(config_file_lock_path {\n  args: \"run --config=run/config_file_lock_path.json run/019_media_types.ts\",\n  output: \"run/config_file_lock_path.out\",\n  exit_code: 10,\n  http_server: true,\n});\n\nitest!(lock_flag_overrides_config_file_lock_path {\n  args: \"run --lock=run/lock_check_ok2.json --config=run/config_file_lock_path.json run/019_media_types.ts\",\n  output: \"run/019_media_types.ts.out\",\n  http_server: true,\n});\n\nitest!(lock_v2_check_ok {\n  args:\n    \"run --quiet --lock=run/lock_v2_check_ok.json http://127.0.0.1:4545/run/003_relative_import.ts\",\n  output: \"run/003_relative_import.ts.out\",\n  http_server: true,\n});\n\nitest!(lock_v2_check_ok2 {\n  args: \"run --lock=run/lock_v2_check_ok2.json run/019_media_types.ts\",\n  output: \"run/019_media_types.ts.out\",\n  http_server: true,\n});\n\nitest!(lock_v2_dynamic_imports {\n  args: \"run --lock=run/lock_v2_dynamic_imports.json --allow-read --allow-net http://127.0.0.1:4545/run/013_dynamic_import.ts\",\n  output: \"run/lock_v2_dynamic_imports.out\",\n  exit_code: 10,\n  http_server: true,\n});\n\nitest!(lock_v2_check_err {\n  args: \"run --lock=run/lock_v2_check_err.json http://127.0.0.1:4545/run/003_relative_import.ts\",\n  output: \"run/lock_v2_check_err.out\",\n  exit_code: 10,\n  http_server: true,\n});\n\nitest!(lock_v2_check_err2 {\n  args: \"run --lock=run/lock_v2_check_err2.json run/019_media_types.ts\",\n  output: \"run/lock_v2_check_err2.out\",\n  exit_code: 10,\n  http_server: true,\n});\n\nitest!(lock_only_http_and_https {\n  args: \"run --lock=run/lock_only_http_and_https/deno.lock run/lock_only_http_and_https/main.ts\",\n  output: \"run/lock_only_http_and_https/main.out\",\n  http_server: true,\n});\n\n#[test]\nfn lock_no_declaration_files() {\n  let context = TestContextBuilder::new()\n    .use_temp_cwd()\n    .use_http_server()\n    .build();\n  let output = context\n    .new_command()\n    .args(\"cache --lock --lock-write $TESTDATA/lockfile/no_dts/main.ts\")\n    .run();\n  output.assert_matches_file(\"lockfile/no_dts/main.cache.out\");\n  let lockfile = context.temp_dir().path().join(\"deno.lock\");\n  lockfile.assert_matches_file(\"lockfile/no_dts/deno.lock.out\");\n}\n\n#[test]\nfn lock_redirects() {\n  let context = TestContextBuilder::new()\n    .use_temp_cwd()\n    .use_http_server()\n    .add_npm_env_vars()\n    .build();\n  let temp_dir = context.temp_dir();\n  temp_dir.write(\"deno.json\", \"{}\"); // cause a lockfile to be created\n  temp_dir.write(\n    \"main.ts\",\n    \"import 'http://localhost:4546/run/001_hello.js';\",\n  );\n  context\n    .new_command()\n    .args(\"run main.ts\")\n    .run()\n    .skip_output_check();\n  let initial_lockfile_text = r#\"{\n  \"version\": \"3\",\n  \"redirects\": {\n    \"http://localhost:4546/run/001_hello.js\": \"http://localhost:4545/run/001_hello.js\"\n  },\n  \"remote\": {\n    \"http://localhost:4545/run/001_hello.js\": \"c479db5ea26965387423ca438bb977d0b4788d5901efcef52f69871e4c1048c5\"\n  }\n}\n\"#;\n  assert_eq!(temp_dir.read_to_string(\"deno.lock\"), initial_lockfile_text);\n  context\n    .new_command()\n    .args(\"run main.ts\")\n    .run()\n    .assert_matches_text(\"Hello World\\n\");\n  assert_eq!(temp_dir.read_to_string(\"deno.lock\"), initial_lockfile_text);\n\n  // now try changing where the redirect occurs in the lockfile\n  temp_dir.write(\"deno.lock\", r#\"{\n  \"version\": \"3\",\n  \"redirects\": {\n    \"http://localhost:4546/run/001_hello.js\": \"http://localhost:4545/echo.ts\"\n  },\n  \"remote\": {\n    \"http://localhost:4545/run/001_hello.js\": \"c479db5ea26965387423ca438bb977d0b4788d5901efcef52f69871e4c1048c5\"\n  }\n}\n\"#);\n\n  // also, add some npm dependency to ensure it doesn't end up in\n  // the redirects as they're currently stored separately\n  temp_dir.write(\n    \"main.ts\",\n    \"import 'http://localhost:4546/run/001_hello.js';\\n import 'npm:@denotest/esm-basic';\\n\",\n  );\n\n  // it should use the echo script instead\n  context\n    .new_command()\n    .args(\"run main.ts Hi there\")\n    .run()\n    .assert_matches_text(\n      concat!(\n        \"Download http://localhost:4545/echo.ts\\n\",\n        \"Download http://localhost:4545/npm/registry/@denotest/esm-basic\\n\",\n        \"Download http://localhost:4545/npm/registry/@denotest/esm-basic/1.0.0.tgz\\n\",\n        \"Hi, there\",\n    ));\n  util::assertions::assert_wildcard_match(\n    &temp_dir.read_to_string(\"deno.lock\"),\n    r#\"{\n  \"version\": \"3\",\n  \"packages\": {\n    \"specifiers\": {\n      \"npm:@denotest/esm-basic\": \"npm:@denotest/esm-basic@1.0.0\"\n    },\n    \"npm\": {\n      \"@denotest/esm-basic@1.0.0\": {\n        \"integrity\": \"sha512-[WILDCARD]\",\n        \"dependencies\": {}\n      }\n    }\n  },\n  \"redirects\": {\n    \"http://localhost:4546/run/001_hello.js\": \"http://localhost:4545/echo.ts\"\n  },\n  \"remote\": {\n    \"http://localhost:4545/echo.ts\": \"829eb4d67015a695d70b2a33c78b631b29eea1dbac491a6bfcf394af2a2671c2\",\n    \"http://localhost:4545/run/001_hello.js\": \"c479db5ea26965387423ca438bb977d0b4788d5901efcef52f69871e4c1048c5\"\n  }\n}\n\"#,\n  );\n}\n\n#[test]\nfn lock_deno_json_package_json_deps() {\n  let context = TestContextBuilder::new()\n    .use_temp_cwd()\n    .use_http_server()\n    .add_npm_env_vars()\n    .add_jsr_env_vars()\n    .build();\n  let temp_dir = context.temp_dir().path();\n  let deno_json = temp_dir.join(\"deno.json\");\n  let package_json = temp_dir.join(\"package.json\");\n\n  // add a jsr and npm dependency\n  deno_json.write_json(&json!({\n    \"imports\": {\n      \"esm-basic\": \"npm:@denotest/esm-basic\",\n      \"module_graph\": \"jsr:@denotest/module_graph@1.4\",\n    }\n  }));\n  let main_ts = temp_dir.join(\"main.ts\");\n  main_ts.write(\"import 'esm-basic'; import 'module_graph';\");\n  context\n    .new_command()\n    .args(\"cache main.ts\")\n    .run()\n    .skip_output_check();\n  let lockfile = temp_dir.join(\"deno.lock\");\n  let esm_basic_integrity =\n    get_lockfile_npm_package_integrity(&lockfile, \"@denotest/esm-basic@1.0.0\");\n  lockfile.assert_matches_json(json!({\n    \"version\": \"3\",\n    \"packages\": {\n      \"specifiers\": {\n        \"jsr:@denotest/module_graph@1.4\": \"jsr:@denotest/module_graph@1.4.0\",\n        \"npm:@denotest/esm-basic\": \"npm:@denotest/esm-basic@1.0.0\"\n      },\n      \"jsr\": {\n        \"@denotest/module_graph@1.4.0\": {\n          \"integrity\": \"555bbe259f55a4a2e7a39e8bf4bcbf25da4c874a313c3e98771eddceedac050b\"\n        }\n      },\n      \"npm\": {\n        \"@denotest/esm-basic@1.0.0\": {\n          \"integrity\": esm_basic_integrity,\n          \"dependencies\": {}\n        }\n      }\n    },\n    \"remote\": {},\n    \"workspace\": {\n      \"dependencies\": [\n        \"jsr:@denotest/module_graph@1.4\",\n        \"npm:@denotest/esm-basic\"\n      ]\n    }\n  }));\n\n  // now remove the npm dependency from the deno.json and move\n  // it to a package.json that uses an alias\n  deno_json.write_json(&json!({\n    \"imports\": {\n      \"module_graph\": \"jsr:@denotest/module_graph@1.4\",\n    }\n  }));\n  package_json.write_json(&json!({\n    \"dependencies\": {\n      \"esm-basic\": \"npm:@denotest/esm-basic\"\n    }\n  }));\n  context\n    .new_command()\n    .args(\"cache main.ts\")\n    .run()\n    .skip_output_check();\n  main_ts.write(\"import 'module_graph';\");\n  context\n    .new_command()\n    // ensure this doesn't clear out packageJson below\n    .args(\"cache --no-npm main.ts\")\n    .run()\n    .skip_output_check();\n  lockfile.assert_matches_json(json!({\n    \"version\": \"3\",\n    \"packages\": {\n      \"specifiers\": {\n        \"jsr:@denotest/module_graph@1.4\": \"jsr:@denotest/module_graph@1.4.0\",\n        \"npm:@denotest/esm-basic\": \"npm:@denotest/esm-basic@1.0.0\"\n      },\n      \"jsr\": {\n        \"@denotest/module_graph@1.4.0\": {\n          \"integrity\": \"555bbe259f55a4a2e7a39e8bf4bcbf25da4c874a313c3e98771eddceedac050b\"\n        }\n      },\n      \"npm\": {\n        \"@denotest/esm-basic@1.0.0\": {\n          \"integrity\": esm_basic_integrity,\n          \"dependencies\": {}\n        }\n      }\n    },\n    \"remote\": {},\n    \"workspace\": {\n      \"dependencies\": [\n        \"jsr:@denotest/module_graph@1.4\"\n      ],\n      \"packageJson\": {\n        \"dependencies\": [\n          \"npm:@denotest/esm-basic\"\n        ]\n      }\n    }\n  }));\n\n  // now remove the package.json\n  package_json.remove_file();\n\n  // cache and it will remove the package.json\n  context\n    .new_command()\n    .args(\"cache main.ts\")\n    .run()\n    .skip_output_check();\n  lockfile.assert_matches_json(json!({\n    \"version\": \"3\",\n    \"packages\": {\n      \"specifiers\": {\n        \"jsr:@denotest/module_graph@1.4\": \"jsr:@denotest/module_graph@1.4.0\",\n      },\n      \"jsr\": {\n        \"@denotest/module_graph@1.4.0\": {\n          \"integrity\": \"555bbe259f55a4a2e7a39e8bf4bcbf25da4c874a313c3e98771eddceedac050b\"\n        }\n      }\n    },\n    \"remote\": {},\n    \"workspace\": {\n      \"dependencies\": [\n        \"jsr:@denotest/module_graph@1.4\"\n      ]\n    }\n  }));\n\n  // now remove the deps from the deno.json\n  deno_json.write(\"{}\");\n  main_ts.write(\"\");\n  context\n    .new_command()\n    .args(\"cache main.ts\")\n    .run()\n    .skip_output_check();\n\n  lockfile.assert_matches_json(json!({\n    \"version\": \"3\",\n    \"remote\": {}\n  }));\n}\n\n#[test]\nfn lock_deno_json_package_json_deps_workspace() {\n  let context = TestContextBuilder::new()\n    .use_temp_cwd()\n    .use_http_server()\n    .add_npm_env_vars()\n    .add_jsr_env_vars()\n    .build();\n  let temp_dir = context.temp_dir().path();\n\n  // deno.json\n  let deno_json = temp_dir.join(\"deno.json\");\n  deno_json.write_json(&json!({}));\n\n  // package.json\n  let package_json = temp_dir.join(\"package.json\");\n  package_json.write_json(&json!({\n    \"workspaces\": [\"package-a\"],\n    \"dependencies\": {\n      \"@denotest/cjs-default-export\": \"1\"\n    }\n  }));\n  // main.ts\n  let main_ts = temp_dir.join(\"main.ts\");\n  main_ts.write(\"import '@denotest/cjs-default-export';\");\n\n  // package-a/package.json\n  let a_package = temp_dir.join(\"package-a\");\n  a_package.create_dir_all();\n  let a_package_json = a_package.join(\"package.json\");\n  a_package_json.write_json(&json!({\n    \"dependencies\": {\n      \"@denotest/esm-basic\": \"1\"\n    }\n  }));\n  // package-a/main.ts\n  let main_ts = a_package.join(\"main.ts\");\n  main_ts.write(\"import '@denotest/esm-basic';\");\n  context\n    .new_command()\n    .args(\"run package-a/main.ts\")\n    .run()\n    .skip_output_check();\n  let lockfile = temp_dir.join(\"deno.lock\");\n  let esm_basic_integrity =\n    get_lockfile_npm_package_integrity(&lockfile, \"@denotest/esm-basic@1.0.0\");\n\n  // no \"workspace\" because deno isn't smart enough to figure this out yet\n  // since it discovered the package.json in a folder different from the lockfile\n  lockfile.assert_matches_json(json!({\n    \"version\": \"3\",\n    \"packages\": {\n      \"specifiers\": {\n        \"npm:@denotest/esm-basic@1\": \"npm:@denotest/esm-basic@1.0.0\"\n      },\n      \"npm\": {\n        \"@denotest/esm-basic@1.0.0\": {\n          \"integrity\": esm_basic_integrity,\n          \"dependencies\": {}\n        }\n      }\n    },\n    \"remote\": {},\n  }));\n\n  // run a command that causes discovery of the root package.json beside the lockfile\n  context\n    .new_command()\n    .args(\"run main.ts\")\n    .run()\n    .skip_output_check();\n  // now we should see the dependencies\n  let cjs_default_export_integrity = get_lockfile_npm_package_integrity(\n    &lockfile,\n    \"@denotest/cjs-default-export@1.0.0\",\n  );\n  let expected_lockfile = json!({\n    \"version\": \"3\",\n    \"packages\": {\n      \"specifiers\": {\n        \"npm:@denotest/cjs-default-export@1\": \"npm:@denotest/cjs-default-export@1.0.0\",\n        \"npm:@denotest/esm-basic@1\": \"npm:@denotest/esm-basic@1.0.0\"\n      },\n      \"npm\": {\n        \"@denotest/cjs-default-export@1.0.0\": {\n          \"integrity\": cjs_default_export_integrity,\n          \"dependencies\": {}\n        },\n        \"@denotest/esm-basic@1.0.0\": {\n          \"integrity\": esm_basic_integrity,\n          \"dependencies\": {}\n        }\n      }\n    },\n    \"remote\": {},\n    \"workspace\": {\n      \"packageJson\": {\n        \"dependencies\": [\n          \"npm:@denotest/cjs-default-export@1\"\n        ]\n      }\n    }\n  });\n  lockfile.assert_matches_json(expected_lockfile.clone());\n\n  // now run the command again in the package with the nested package.json\n  context\n    .new_command()\n    .args(\"run package-a/main.ts\")\n    .run()\n    .skip_output_check();\n  // the lockfile should stay the same as the above because the package.json\n  // was found in a different directory\n  lockfile.assert_matches_json(expected_lockfile.clone());\n}\n\nfn get_lockfile_npm_package_integrity(\n  lockfile: &PathRef,\n  package_name: &str,\n) -> String {\n  // todo(dsherret): it would be nice if the test server didn't produce\n  // different hashes depending on what operating system it's running on\n  lockfile\n    .read_json_value()\n    .get(\"packages\")\n    .unwrap()\n    .get(\"npm\")\n    .unwrap()\n    .get(package_name)\n    .unwrap()\n    .get(\"integrity\")\n    .unwrap()\n    .as_str()\n    .unwrap()\n    .to_string()\n}\n\nitest!(mts_dmts_mjs {\n  args: \"run subdir/import.mts\",\n  output: \"run/mts_dmts_mjs.out\",\n});\n\nitest!(mts_dmts_mjs_no_check {\n  args: \"run --no-check subdir/import.mts\",\n  output: \"run/mts_dmts_mjs.out\",\n});\n\nitest!(async_error {\n  exit_code: 1,\n  args: \"run --reload run/async_error.ts\",\n  output: \"run/async_error.ts.out\",\n});\n\nitest!(config {\n  args:\n    \"run --reload --config run/config/tsconfig.json --check run/config/main.ts\",\n  output: \"run/config/main.out\",\n});\n\nitest!(config_types {\n  args:\n    \"run --reload --quiet --check=all --config run/config_types/tsconfig.json run/config_types/main.ts\",\n  output: \"run/config_types/main.out\",\n});\n\nitest!(config_types_remote {\n  http_server: true,\n  args: \"run --reload --quiet --check=all --config run/config_types/remote.tsconfig.json run/config_types/main.ts\",\n  output: \"run/config_types/main.out\",\n});\n\nitest!(empty_typescript {\n  args: \"run --reload --check run/empty.ts\",\n  output_str: Some(\"Check file:[WILDCARD]/run/empty.ts\\n\"),\n});\n\nitest!(error_001 {\n  args: \"run --reload run/error_001.ts\",\n  exit_code: 1,\n  output: \"run/error_001.ts.out\",\n});\n\nitest!(error_002 {\n  args: \"run --reload run/error_002.ts\",\n  exit_code: 1,\n  output: \"run/error_002.ts.out\",\n});\n\nitest!(error_003_typescript {\n  args: \"run --reload --check run/error_003_typescript.ts\",\n  exit_code: 1,\n  output: \"run/error_003_typescript.ts.out\",\n});\n\n// Supposing that we've already attempted to run error_003_typescript.ts\n// we want to make sure that JS wasn't emitted. Running again without reload flag\n// should result in the same output.\n// https://github.com/denoland/deno/issues/2436\nitest!(error_003_typescript2 {\n  args: \"run --check run/error_003_typescript.ts\",\n  exit_code: 1,\n  output: \"run/error_003_typescript.ts.out\",\n});\n\nitest!(error_004_missing_module {\n  args: \"run --reload run/error_004_missing_module.ts\",\n  exit_code: 1,\n  output: \"run/error_004_missing_module.ts.out\",\n});\n\nitest!(error_005_missing_dynamic_import {\n  args:\n    \"run --reload --allow-read --quiet run/error_005_missing_dynamic_import.ts\",\n  exit_code: 1,\n  output: \"run/error_005_missing_dynamic_import.ts.out\",\n});\n\nitest!(error_006_import_ext_failure {\n  args: \"run --reload run/error_006_import_ext_failure.ts\",\n  exit_code: 1,\n  output: \"run/error_006_import_ext_failure.ts.out\",\n});\n\nitest!(error_007_any {\n  args: \"run --reload run/error_007_any.ts\",\n  exit_code: 1,\n  output: \"run/error_007_any.ts.out\",\n});\n\nitest!(error_008_checkjs {\n  args: \"run --reload run/error_008_checkjs.js\",\n  exit_code: 1,\n  output: \"run/error_008_checkjs.js.out\",\n});\n\nitest!(error_009_extensions_error {\n  args: \"run run/error_009_extensions_error.js\",\n  output: \"run/error_009_extensions_error.js.out\",\n  exit_code: 1,\n});\n\nitest!(error_011_bad_module_specifier {\n  args: \"run --reload run/error_011_bad_module_specifier.ts\",\n  exit_code: 1,\n  output: \"run/error_011_bad_module_specifier.ts.out\",\n});\n\nitest!(error_012_bad_dynamic_import_specifier {\n  args: \"run --reload --check run/error_012_bad_dynamic_import_specifier.ts\",\n  exit_code: 1,\n  output: \"run/error_012_bad_dynamic_import_specifier.ts.out\",\n});\n\nitest!(error_013_missing_script {\n  args: \"run --reload missing_file_name\",\n  exit_code: 1,\n  output: \"run/error_013_missing_script.out\",\n});\n\nitest!(error_014_catch_dynamic_import_error {\n  args:\n    \"run  --reload --allow-read run/error_014_catch_dynamic_import_error.js\",\n  output: \"run/error_014_catch_dynamic_import_error.js.out\",\n});\n\nitest!(error_015_dynamic_import_permissions {\n  args: \"run --reload --quiet run/error_015_dynamic_import_permissions.js\",\n  output: \"run/error_015_dynamic_import_permissions.out\",\n  exit_code: 1,\n  http_server: true,\n});\n\n// We have an allow-net flag but not allow-read, it should still result in error.\nitest!(error_016_dynamic_import_permissions2 {\n  args: \"run --reload --allow-net run/error_016_dynamic_import_permissions2.js\",\n  output: \"run/error_016_dynamic_import_permissions2.out\",\n  exit_code: 1,\n  http_server: true,\n});\n\nitest!(error_017_hide_long_source_ts {\n  args: \"run --reload --check run/error_017_hide_long_source_ts.ts\",\n  output: \"run/error_017_hide_long_source_ts.ts.out\",\n  exit_code: 1,\n});\n\nitest!(error_018_hide_long_source_js {\n  args: \"run run/error_018_hide_long_source_js.js\",\n  output: \"run/error_018_hide_long_source_js.js.out\",\n  exit_code: 1,\n});\n\nitest!(error_019_stack_function {\n  args: \"run run/error_019_stack_function.ts\",\n  output: \"run/error_019_stack_function.ts.out\",\n  exit_code: 1,\n});\n\nitest!(error_020_stack_constructor {\n  args: \"run run/error_020_stack_constructor.ts\",\n  output: \"run/error_020_stack_constructor.ts.out\",\n  exit_code: 1,\n});\n\nitest!(error_021_stack_method {\n  args: \"run run/error_021_stack_method.ts\",\n  output: \"run/error_021_stack_method.ts.out\",\n  exit_code: 1,\n});\n\nitest!(error_022_stack_custom_error {\n  args: \"run run/error_022_stack_custom_error.ts\",\n  output: \"run/error_022_stack_custom_error.ts.out\",\n  exit_code: 1,\n});\n\nitest!(error_023_stack_async {\n  args: \"run run/error_023_stack_async.ts\",\n  output: \"run/error_023_stack_async.ts.out\",\n  exit_code: 1,\n});\n\nitest!(error_024_stack_promise_all {\n  args: \"run run/error_024_stack_promise_all.ts\",\n  output: \"run/error_024_stack_promise_all.ts.out\",\n  exit_code: 1,\n});\n\nitest!(error_025_tab_indent {\n  args: \"run run/error_025_tab_indent\",\n  output: \"run/error_025_tab_indent.out\",\n  exit_code: 1,\n});\n\nitest!(error_026_remote_import_error {\n  args: \"run run/error_026_remote_import_error.ts\",\n  output: \"run/error_026_remote_import_error.ts.out\",\n  exit_code: 1,\n  http_server: true,\n});\n\nitest!(error_for_await {\n  args: \"run --reload --check run/error_for_await.ts\",\n  output: \"run/error_for_await.ts.out\",\n  exit_code: 1,\n});\n\nitest!(error_missing_module_named_import {\n  args: \"run --reload run/error_missing_module_named_import.ts\",\n  output: \"run/error_missing_module_named_import.ts.out\",\n  exit_code: 1,\n});\n\nitest!(error_no_check {\n  args: \"run --reload --no-check run/error_no_check.ts\",\n  output: \"run/error_no_check.ts.out\",\n  exit_code: 1,\n});\n\nitest!(error_syntax {\n  args: \"run --reload run/error_syntax.js\",\n  exit_code: 1,\n  output: \"run/error_syntax.js.out\",\n});\n\nitest!(error_syntax_empty_trailing_line {\n  args: \"run --reload run/error_syntax_empty_trailing_line.mjs\",\n  exit_code: 1,\n  output: \"run/error_syntax_empty_trailing_line.mjs.out\",\n});\n\nitest!(error_type_definitions {\n  args: \"run --reload --check run/error_type_definitions.ts\",\n  exit_code: 1,\n  output: \"run/error_type_definitions.ts.out\",\n});\n\nitest!(error_local_static_import_from_remote_ts {\n    args: \"run --reload http://localhost:4545/run/error_local_static_import_from_remote.ts\",\n    exit_code: 1,\n    http_server: true,\n    output: \"run/error_local_static_import_from_remote.ts.out\",\n  });\n\nitest!(error_local_static_import_from_remote_js {\n    args: \"run --reload http://localhost:4545/run/error_local_static_import_from_remote.js\",\n    exit_code: 1,\n    http_server: true,\n    output: \"run/error_local_static_import_from_remote.js.out\",\n  });\n\nitest!(exit_error42 {\n  exit_code: 42,\n  args: \"run --quiet --reload run/exit_error42.ts\",\n  output: \"run/exit_error42.ts.out\",\n});\n\nitest!(set_exit_code_0 {\n  args: \"run --no-check run/set_exit_code_0.ts\",\n  output_str: Some(\"\"),\n  exit_code: 0,\n});\n\nitest!(set_exit_code_1 {\n  args: \"run --no-check run/set_exit_code_1.ts\",\n  output_str: Some(\"\"),\n  exit_code: 42,\n});\n\nitest!(set_exit_code_2 {\n  args: \"run --no-check run/set_exit_code_2.ts\",\n  output_str: Some(\"\"),\n  exit_code: 42,\n});\n\nitest!(op_exit_op_set_exit_code_in_worker {\n  args: \"run --no-check --allow-read run/op_exit_op_set_exit_code_in_worker.ts\",\n  exit_code: 21,\n  output_str: Some(\"\"),\n});\n\nitest!(deno_exit_tampering {\n  args: \"run --no-check run/deno_exit_tampering.ts\",\n  output_str: Some(\"\"),\n  exit_code: 42,\n});\n\nitest!(heapstats {\n  args: \"run --quiet --v8-flags=--expose-gc run/heapstats.js\",\n  output: \"run/heapstats.js.out\",\n});\n\nitest!(finalization_registry {\n  args: \"run --quiet --v8-flags=--expose-gc run/finalization_registry.js\",\n  output: \"run/finalization_registry.js.out\",\n});\n\nitest!(https_import {\n  args: \"run --quiet --reload --cert tls/RootCA.pem run/https_import.ts\",\n  output: \"run/https_import.ts.out\",\n  http_server: true,\n});\n\nitest!(if_main {\n  args: \"run --quiet --reload run/if_main.ts\",\n  output: \"run/if_main.ts.out\",\n});\n\nitest!(import_meta {\n  args: \"run --quiet --reload --import-map=run/import_meta/importmap.json run/import_meta/main.ts\",\n  output: \"run/import_meta/main.out\",\n  http_server: true,\n});\n\nitest!(main_module {\n  args: \"run --quiet --allow-read --reload run/main_module/main.ts\",\n  output: \"run/main_module/main.out\",\n});\n\nitest!(no_check {\n  args: \"run --quiet --reload --no-check run/006_url_imports.ts\",\n  output: \"run/006_url_imports.ts.out\",\n  http_server: true,\n});\n\nitest!(no_check_decorators {\n  args: \"run --quiet --reload --no-check run/decorators/experimental/no_check/main.ts\",\n  output: \"run/decorators/experimental/no_check/main.out\",\n});\n\nitest!(decorators_tc39_proposal {\n  args: \"run --quiet --reload --check run/decorators/tc39_proposal/main.ts\",\n  output: \"run/decorators/tc39_proposal/main.out\",\n});\n\nitest!(check_remote {\n  args: \"run --quiet --reload --check=all run/no_check_remote.ts\",\n  output: \"run/no_check_remote.ts.disabled.out\",\n  exit_code: 1,\n  http_server: true,\n});\n\nitest!(no_check_remote {\n  args: \"run --quiet --reload --no-check=remote run/no_check_remote.ts\",\n  output: \"run/no_check_remote.ts.enabled.out\",\n  http_server: true,\n});\n\nitest!(runtime_decorators {\n  args: \"run --quiet --reload --no-check run/decorators/experimental/runtime/main.ts\",\n  output: \"run/decorators/experimental/runtime/main.out\",\n});\n\nitest!(seed_random {\n  args: \"run --seed=100 run/seed_random.js\",\n  output: \"run/seed_random.js.out\",\n});\n\nitest!(type_definitions {\n  args: \"run --reload run/type_definitions.ts\",\n  output: \"run/type_definitions.ts.out\",\n});\n\nitest!(type_definitions_for_export {\n  args: \"run --reload --check run/type_definitions_for_export.ts\",\n  output: \"run/type_definitions_for_export.ts.out\",\n  exit_code: 1,\n});\n\nitest!(type_directives_01 {\n  args: \"run --reload --check=all -L debug run/type_directives_01.ts\",\n  output: \"run/type_directives_01.ts.out\",\n  http_server: true,\n});\n\nitest!(type_directives_02 {\n  args: \"run --reload --check=all -L debug run/type_directives_02.ts\",\n  output: \"run/type_directives_02.ts.out\",\n});\n\n#[test]\nfn type_directives_js_main() {\n  let context = TestContext::default();\n  let output = context\n    .new_command()\n    .args(\"run --reload -L debug --check run/type_directives_js_main.js\")\n    .run();\n  output.assert_matches_text(\"[WILDCARD] - FileFetcher::fetch() - specifier: file:///[WILDCARD]/subdir/type_reference.d.ts[WILDCARD]\");\n  let output = context\n    .new_command()\n    .args(\"run --reload -L debug run/type_directives_js_main.js\")\n    .run();\n  assert_not_contains!(output.combined_output(), \"type_reference.d.ts\");\n}\n\n#[test]\nfn test_deno_futures_env() {\n  let context = TestContextBuilder::new().add_future_env_vars().build();\n  let output = context\n    .new_command()\n    .args(\"run --quiet --reload run/deno_futures_env.ts\")\n    .run();\n  output.assert_exit_code(0);\n}\n\nitest!(type_directives_redirect {\n  args: \"run --reload --check run/type_directives_redirect.ts\",\n  output: \"run/type_directives_redirect.ts.out\",\n  http_server: true,\n});\n\nitest!(type_headers_deno_types {\n  args: \"run --reload --check run/type_headers_deno_types.ts\",\n  output: \"run/type_headers_deno_types.ts.out\",\n  http_server: true,\n});\n\nitest!(ts_type_imports {\n  args: \"run --reload --check run/ts_type_imports.ts\",\n  output: \"run/ts_type_imports.ts.out\",\n  exit_code: 1,\n});\n\nitest!(ts_decorators {\n  args: \"run --reload --check run/decorators/experimental/ts/main.ts\",\n  output: \"run/decorators/experimental/ts/main.out\",\n});\n\nitest!(ts_type_only_import {\n  args: \"run --reload --check run/ts_type_only_import.ts\",\n  output: \"run/ts_type_only_import.ts.out\",\n});\n\nitest!(swc_syntax_error {\n  args: \"run --reload --check run/swc_syntax_error.ts\",\n  output: \"run/swc_syntax_error.ts.out\",\n  exit_code: 1,\n});\n\nitest!(unbuffered_stderr {\n  args: \"run --reload run/unbuffered_stderr.ts\",\n  output: \"run/unbuffered_stderr.ts.out\",\n});\n\nitest!(unbuffered_stdout {\n  args: \"run --quiet --reload run/unbuffered_stdout.ts\",\n  output: \"run/unbuffered_stdout.ts.out\",\n});\n\nitest!(v8_flags_run {\n  args: \"run --v8-flags=--expose-gc run/v8_flags.js\",\n  output: \"run/v8_flags.js.out\",\n});\n\nitest!(v8_flags_env_run {\n  envs: vec![(\"DENO_V8_FLAGS\".to_string(), \"--expose-gc\".to_string())],\n  args: \"run run/v8_flags.js\",\n  output: \"run/v8_flags.js.out\",\n});\n\nitest!(v8_flags_unrecognized {\n  args: \"repl --v8-flags=--foo,bar,--trace-gc,-baz\",\n  output: \"run/v8_flags_unrecognized.out\",\n  exit_code: 1,\n});\n\nitest!(v8_help {\n  args: \"repl --v8-flags=--help\",\n  output: \"run/v8_help.out\",\n});\n\nitest!(unsupported_dynamic_import_scheme {\n  args: \"eval import('xxx:')\",\n  output: \"run/unsupported_dynamic_import_scheme.out\",\n  exit_code: 1,\n});\n\nitest!(wasm {\n  args: \"run --quiet run/wasm.ts\",\n  output: \"run/wasm.ts.out\",\n});\n\nitest!(wasm_shared {\n  args: \"run --quiet run/wasm_shared.ts\",\n  output: \"run/wasm_shared.out\",\n});\n\nitest!(wasm_async {\n  args: \"run run/wasm_async.js\",\n  output: \"run/wasm_async.out\",\n});\n\nitest!(wasm_unreachable {\n  args: \"run --allow-read run/wasm_unreachable.js\",\n  output: \"run/wasm_unreachable.out\",\n  exit_code: 1,\n});\n\nitest!(wasm_url {\n  args: \"run --quiet --allow-net=localhost:4545 run/wasm_url.js\",\n  output: \"run/wasm_url.out\",\n  exit_code: 1,\n  http_server: true,\n});\n\nitest!(weakref {\n  args: \"run --quiet --reload run/weakref.ts\",\n  output: \"run/weakref.ts.out\",\n});\n\nitest!(top_level_await_order {\n  args: \"run --allow-read run/top_level_await/order.js\",\n  output: \"run/top_level_await/order.out\",\n});\n\nitest!(top_level_await_loop {\n  args: \"run --allow-read run/top_level_await/loop.js\",\n  output: \"run/top_level_await/loop.out\",\n});\n\nitest!(top_level_await_circular {\n  args: \"run --allow-read run/top_level_await/circular.js\",\n  output: \"run/top_level_await/circular.out\",\n  exit_code: 1,\n});\n\n// Regression test for https://github.com/denoland/deno/issues/11238.\nitest!(top_level_await_nested {\n  args: \"run --allow-read run/top_level_await/nested/main.js\",\n  output: \"run/top_level_await/nested.out\",\n});\n\nitest!(top_level_await_unresolved {\n  args: \"run run/top_level_await/unresolved.js\",\n  output: \"run/top_level_await/unresolved.out\",\n  exit_code: 1,\n});\n\nitest!(top_level_await {\n  args: \"run --allow-read run/top_level_await/top_level_await.js\",\n  output: \"run/top_level_await/top_level_await.out\",\n});\n\nitest!(top_level_await_ts {\n  args: \"run --quiet --allow-read run/top_level_await/top_level_await.ts\",\n  output: \"run/top_level_await/top_level_await.out\",\n});\n\nitest!(top_level_for_await {\n  args: \"run --quiet run/top_level_await/top_level_for_await.js\",\n  output: \"run/top_level_await/top_level_for_await.out\",\n});\n\nitest!(top_level_for_await_ts {\n  args: \"run --quiet run/top_level_await/top_level_for_await.ts\",\n  output: \"run/top_level_await/top_level_for_await.out\",\n});\n\nitest!(unstable_disabled_js {\n  args: \"run --reload run/unstable.js\",\n  output: \"run/unstable_disabled_js.out\",\n});\n\nitest!(unstable_enabled_js {\n  args: \"run --quiet --reload --unstable-fs run/unstable.ts\",\n  output: \"run/unstable_enabled_js.out\",\n});\n\nitest!(unstable_worker {\n  args: \"run --reload --quiet --allow-read run/unstable_worker.ts\",\n  output: \"run/unstable_worker.ts.out\",\n});\n\nitest!(unstable_worker_options_disabled {\n  args: \"run --quiet --reload --allow-read run/unstable_worker_options.js\",\n  output: \"run/unstable_worker_options.disabled.out\",\n  exit_code: 70,\n});\n\nitest!(unstable_worker_options_enabled {\n  args: \"run --quiet --reload --allow-read --unstable-worker-options run/unstable_worker_options.js\",\n  output: \"run/unstable_worker_options.enabled.out\",\n});\n\nitest!(unstable_broadcast_channel_disabled {\n  args: \"run --quiet --reload --allow-read run/unstable_broadcast_channel.js\",\n  output: \"run/unstable_broadcast_channel.disabled.out\",\n});\n\nitest!(unstable_broadcast_channel_enabled {\n  args: \"run --quiet --reload --allow-read --unstable-broadcast-channel run/unstable_broadcast_channel.js\",\n  output: \"run/unstable_broadcast_channel.enabled.out\",\n});\n\nitest!(unstable_cron_disabled {\n  args: \"run --quiet --reload --allow-read run/unstable_cron.js\",\n  output: \"run/unstable_cron.disabled.out\",\n});\n\nitest!(unstable_cron_enabled {\n  args:\n    \"run --quiet --reload --allow-read --unstable-cron run/unstable_cron.js\",\n  output: \"run/unstable_cron.enabled.out\",\n});\n\nitest!(unstable_ffi_disabled {\n  args: \"run --quiet --reload --allow-read run/unstable_ffi.js\",\n  output: \"run/unstable_ffi.disabled.out\",\n});\n\nitest!(unstable_ffi_enabled {\n  args: \"run --quiet --reload --allow-read --unstable-ffi run/unstable_ffi.js\",\n  output: \"run/unstable_ffi.enabled.out\",\n});\n\nitest!(unstable_fs_disabled {\n  args: \"run --quiet --reload --allow-read run/unstable_fs.js\",\n  output: \"run/unstable_fs.disabled.out\",\n});\n\nitest!(unstable_fs_enabled {\n  args: \"run --quiet --reload --allow-read --unstable-fs run/unstable_fs.js\",\n  output: \"run/unstable_fs.enabled.out\",\n});\n\nitest!(unstable_http_disabled {\n  args: \"run --quiet --reload --allow-read run/unstable_http.js\",\n  output: \"run/unstable_http.disabled.out\",\n});\n\nitest!(unstable_http_enabled {\n  args:\n    \"run --quiet --reload --allow-read --unstable-http run/unstable_http.js\",\n  output: \"run/unstable_http.enabled.out\",\n});\n\nitest!(unstable_net_disabled {\n  args: \"run --quiet --reload --allow-read run/unstable_net.js\",\n  output: \"run/unstable_net.disabled.out\",\n});\n\nitest!(unstable_net_enabled {\n  args: \"run --quiet --reload --allow-read --unstable-net run/unstable_net.js\",\n  output: \"run/unstable_net.enabled.out\",\n});\n\nitest!(unstable_kv_disabled {\n  args: \"run --quiet --reload --allow-read run/unstable_kv.js\",\n  output: \"run/unstable_kv.disabled.out\",\n});\n\nitest!(unstable_kv_enabled {\n  args: \"run --quiet --reload --allow-read --unstable-kv run/unstable_kv.js\",\n  output: \"run/unstable_kv.enabled.out\",\n});\n\nitest!(unstable_webgpu_disabled {\n  args: \"run --quiet --reload --allow-read run/unstable_webgpu.js\",\n  output: \"run/unstable_webgpu.disabled.out\",\n});\n\nitest!(unstable_webgpu_enabled {\n  args:\n    \"run --quiet --reload --allow-read --unstable-webgpu run/unstable_webgpu.js\",\n  output: \"run/unstable_webgpu.enabled.out\",\n});\n\nitest!(import_compression {\n  args: \"run --quiet --reload --allow-net run/import_compression/main.ts\",\n  output: \"run/import_compression/main.out\",\n  http_server: true,\n});\n\nitest!(disallow_http_from_https_js {\n  args: \"run --quiet --reload --cert tls/RootCA.pem https://localhost:5545/run/disallow_http_from_https.js\",\n  output: \"run/disallow_http_from_https_js.out\",\n  http_server: true,\n  exit_code: 1,\n});\n\nitest!(disallow_http_from_https_ts {\n  args: \"run --quiet --reload --cert tls/RootCA.pem https://localhost:5545/run/disallow_http_from_https.ts\",\n  output: \"run/disallow_http_from_https_ts.out\",\n  http_server: true,\n  exit_code: 1,\n});\n\nitest!(dynamic_import_conditional {\n  args: \"run --quiet --reload run/dynamic_import_conditional.js\",\n  output: \"run/dynamic_import_conditional.js.out\",\n});\n\nitest!(tsx_imports {\n  args: \"run --reload --check run/tsx_imports/tsx_imports.ts\",\n  output: \"run/tsx_imports/tsx_imports.ts.out\",\n});\n\nitest!(fix_dynamic_import_errors {\n  args: \"run --reload run/fix_dynamic_import_errors.js\",\n  output: \"run/fix_dynamic_import_errors.js.out\",\n});\n\nitest!(fix_emittable_skipped {\n  args: \"run --reload run/fix_emittable_skipped.js\",\n  output: \"run/fix_emittable_skipped.ts.out\",\n});\n\nitest!(fix_js_import_js {\n  args: \"run --quiet --reload run/fix_js_import_js.ts\",\n  output: \"run/fix_js_import_js.ts.out\",\n});\n\nitest!(fix_js_imports {\n  args: \"run --quiet --reload run/fix_js_imports.ts\",\n  output: \"run/fix_js_imports.ts.out\",\n});\n\nitest!(fix_tsc_file_exists {\n  args: \"run --quiet --reload tsc/test.js\",\n  output: \"run/fix_tsc_file_exists.out\",\n});\n\nitest!(fix_worker_dispatchevent {\n  args: \"run --quiet --reload run/fix_worker_dispatchevent.ts\",\n  output: \"run/fix_worker_dispatchevent.ts.out\",\n});\n\nitest!(es_private_fields {\n  args: \"run --quiet --reload run/es_private_fields.js\",\n  output: \"run/es_private_fields.js.out\",\n});\n\nitest!(cjs_imports {\n  args: \"run --quiet --reload run/cjs_imports/main.ts\",\n  output: \"run/cjs_imports/main.out\",\n});\n\nitest!(ts_import_from_js {\n  args: \"run --quiet --reload run/ts_import_from_js/main.js\",\n  output: \"run/ts_import_from_js/main.out\",\n  http_server: true,\n});\n\nitest!(jsx_import_from_ts {\n  args: \"run --quiet --reload run/jsx_import_from_ts.ts\",\n  output: \"run/jsx_import_from_ts.ts.out\",\n});\n\nitest!(jsx_import_source_pragma {\n  args: \"run --reload run/jsx_import_source_pragma.tsx\",\n  output: \"run/jsx_import_source.out\",\n  http_server: true,\n});\n\nitest!(jsx_import_source_pragma_with_config {\n  args:\n    \"run --reload --config jsx/deno-jsx.jsonc --no-lock run/jsx_import_source_pragma.tsx\",\n  output: \"run/jsx_import_source.out\",\n  http_server: true,\n});\n\nitest!(jsx_import_source_pragma_with_dev_config {\n  args:\n    \"run --reload --config jsx/deno-jsxdev.jsonc --no-lock run/jsx_import_source_pragma.tsx\",\n  output: \"run/jsx_import_source_dev.out\",\n  http_server: true,\n});\n\nitest!(jsx_import_source_no_pragma {\n  args:\n    \"run --reload --config jsx/deno-jsx.jsonc --no-lock run/jsx_import_source_no_pragma.tsx\",\n  output: \"run/jsx_import_source.out\",\n  http_server: true,\n});\n\nitest!(jsx_import_source_no_pragma_dev {\n  args: \"run --reload --config jsx/deno-jsxdev.jsonc --no-lock run/jsx_import_source_no_pragma.tsx\",\n  output: \"run/jsx_import_source_dev.out\",\n  http_server: true,\n});\n\nitest!(jsx_import_source_pragma_import_map {\n  args: \"run --reload --import-map jsx/import-map.json run/jsx_import_source_pragma_import_map.tsx\",\n  output: \"run/jsx_import_source_import_map.out\",\n  http_server: true,\n});\n\nitest!(jsx_import_source_pragma_import_map_dev {\n  args: \"run --reload --import-map jsx/import-map.json --config jsx/deno-jsxdev-import-map.jsonc run/jsx_import_source_pragma_import_map.tsx\",\n  output: \"run/jsx_import_source_import_map_dev.out\",\n  http_server: true,\n});\n\nitest!(jsx_import_source_precompile_import_map {\n  args: \"run --reload --check --import-map jsx/import-map.json --no-lock --config jsx/deno-jsx-precompile.jsonc run/jsx_precompile/no_pragma.tsx\",\n  output: \"run/jsx_precompile/no_pragma.out\",\n  http_server: true,\n});\n\nitest!(jsx_import_source_import_map {\n  args: \"run --reload --import-map jsx/import-map.json --no-lock --config jsx/deno-jsx-import-map.jsonc run/jsx_import_source_no_pragma.tsx\",\n  output: \"run/jsx_import_source_import_map.out\",\n  http_server: true,\n});\n\nitest!(jsx_import_source_import_map_dev {\n  args: \"run --reload --import-map jsx/import-map.json --no-lock --config jsx/deno-jsxdev-import-map.jsonc run/jsx_import_source_no_pragma.tsx\",\n  output: \"run/jsx_import_source_import_map_dev.out\",\n  http_server: true,\n});\n\nitest!(jsx_import_source_import_map_scoped {\n  args: \"run --reload --import-map jsx/import-map-scoped.json --no-lock --config jsx/deno-jsx-import-map.jsonc subdir/jsx_import_source_no_pragma.tsx\",\n  output: \"run/jsx_import_source_import_map.out\",\n  http_server: true,\n});\n\nitest!(jsx_import_source_import_map_scoped_dev {\n  args: \"run --reload --import-map jsx/import-map-scoped.json --no-lock --config jsx/deno-jsxdev-import-map.jsonc subdir/jsx_import_source_no_pragma.tsx\",\n  output: \"run/jsx_import_source_import_map_dev.out\",\n  http_server: true,\n});\n\nitest!(jsx_import_source_pragma_no_check {\n  args: \"run --reload --no-check run/jsx_import_source_pragma.tsx\",\n  output: \"run/jsx_import_source.out\",\n  http_server: true,\n});\n\nitest!(jsx_import_source_pragma_with_config_no_check {\n  args: \"run --reload --config jsx/deno-jsx.jsonc --no-lock --no-check run/jsx_import_source_pragma.tsx\",\n  output: \"run/jsx_import_source.out\",\n  http_server: true,\n});\n\nitest!(jsx_import_source_pragma_with_config_vendor_dir {\n  args: \"run --reload --config jsx/deno-jsx.jsonc --no-lock --vendor $TESTDATA/run/jsx_import_source_pragma.tsx\",\n  output: \"run/jsx_import_source.out\",\n  http_server: true,\n  temp_cwd: true,\n  copy_temp_dir: Some(\"jsx/\"),\n});\n\nitest!(jsx_import_source_no_pragma_no_check {\n  args:\n    \"run --reload --config jsx/deno-jsx.jsonc --no-lock --no-check run/jsx_import_source_no_pragma.tsx\",\n  output: \"run/jsx_import_source.out\",\n  http_server: true,\n});\n\nitest!(jsx_import_source_pragma_import_map_no_check {\n  args: \"run --reload --import-map jsx/import-map.json --no-check run/jsx_import_source_pragma_import_map.tsx\",\n  output: \"run/jsx_import_source_import_map.out\",\n  http_server: true,\n});\n\nitest!(jsx_import_source_import_map_no_check {\n  args: \"run --reload --import-map jsx/import-map.json --no-lock --config jsx/deno-jsx-import-map.jsonc --no-check run/jsx_import_source_no_pragma.tsx\",\n  output: \"run/jsx_import_source_import_map.out\",\n  http_server: true,\n});\n\nitest!(jsx_import_source_error {\n  args: \"run --config jsx/deno-jsx-error.jsonc --check run/jsx_import_source_no_pragma.tsx\",\n  output: \"run/jsx_import_source_error.out\",\n  exit_code: 1,\n});\n\nitest!(single_compile_with_reload {\n  args: \"run --reload --allow-read run/single_compile_with_reload.ts\",\n  output: \"run/single_compile_with_reload.ts.out\",\n});\n\nitest!(proto_exploit {\n  args: \"run run/proto_exploit.js\",\n  output: \"run/proto_exploit.js.out\",\n});\n\nitest!(reference_types {\n  args: \"run --reload --quiet run/reference_types.ts\",\n  output: \"run/reference_types.ts.out\",\n});\n\nitest!(references_types_remote {\n  http_server: true,\n  args: \"run --reload --quiet run/reference_types_remote.ts\",\n  output: \"run/reference_types_remote.ts.out\",\n});\n\nitest!(reference_types_error {\n  args:\n    \"run --config run/checkjs.tsconfig.json --check run/reference_types_error.js\",\n  output: \"run/reference_types_error.js.out\",\n  exit_code: 1,\n});\n\nitest!(reference_types_error_vendor_dir {\n  args:\n    \"run --config run/checkjs.tsconfig.json --check --vendor $TESTDATA/run/reference_types_error.js\",\n  output: \"run/reference_types_error.js.out\",\n  exit_code: 1,\n});\n\nitest!(reference_types_error_no_check {\n  args: \"run --no-check run/reference_types_error.js\",\n  output_str: Some(\"\"),\n});\n\nitest!(import_data_url_error_stack {\n  args: \"run --quiet --reload run/import_data_url_error_stack.ts\",\n  output: \"run/import_data_url_error_stack.ts.out\",\n  exit_code: 1,\n});\n\nitest!(import_data_url_import_relative {\n  args: \"run --quiet --reload run/import_data_url_import_relative.ts\",\n  output: \"run/import_data_url_import_relative.ts.out\",\n  exit_code: 1,\n});\n\nitest!(import_data_url_import_map {\n    args: \"run --quiet --reload --import-map import_maps/import_map.json run/import_data_url.ts\",\n    output: \"run/import_data_url.ts.out\",\n  });\n\nitest!(import_data_url_imports {\n  args: \"run --quiet --reload run/import_data_url_imports.ts\",\n  output: \"run/import_data_url_imports.ts.out\",\n  http_server: true,\n});\n\nitest!(import_data_url_jsx {\n  args: \"run --quiet --reload run/import_data_url_jsx.ts\",\n  output: \"run/import_data_url_jsx.ts.out\",\n});\n\nitest!(import_data_url {\n  args: \"run --quiet --reload run/import_data_url.ts\",\n  output: \"run/import_data_url.ts.out\",\n});\n\nitest!(import_dynamic_data_url {\n  args: \"run --quiet --reload run/import_dynamic_data_url.ts\",\n  output: \"run/import_dynamic_data_url.ts.out\",\n});\n\nitest!(import_blob_url_error_stack {\n  args: \"run --quiet --reload run/import_blob_url_error_stack.ts\",\n  output: \"run/import_blob_url_error_stack.ts.out\",\n  exit_code: 1,\n});\n\nitest!(import_blob_url_import_relative {\n  args: \"run --quiet --reload run/import_blob_url_import_relative.ts\",\n  output: \"run/import_blob_url_import_relative.ts.out\",\n  exit_code: 1,\n});\n\nitest!(import_blob_url_imports {\n  args:\n    \"run --quiet --reload --allow-net=localhost:4545 run/import_blob_url_imports.ts\",\n  output: \"run/import_blob_url_imports.ts.out\",\n  http_server: true,\n});\n\nitest!(import_blob_url_jsx {\n  args: \"run --quiet --reload run/import_blob_url_jsx.ts\",\n  output: \"run/import_blob_url_jsx.ts.out\",\n});\n\nitest!(import_blob_url {\n  args: \"run --quiet --reload run/import_blob_url.ts\",\n  output: \"run/import_blob_url.ts.out\",\n});\n\nitest!(import_file_with_colon {\n  args: \"run --quiet --reload run/import_file_with_colon.ts\",\n  output: \"run/import_file_with_colon.ts.out\",\n  http_server: true,\n});\n\nitest!(import_extensionless {\n  args: \"run --quiet --reload run/import_extensionless.ts\",\n  output: \"run/import_extensionless.ts.out\",\n  http_server: true,\n});\n\nitest!(classic_workers_event_loop {\n  args:\n    \"run --enable-testing-features-do-not-use run/classic_workers_event_loop.js\",\n  output: \"run/classic_workers_event_loop.js.out\",\n});\n\n// FIXME(bartlomieju): disabled, because this test is very flaky on CI\n// itest!(local_sources_not_cached_in_memory {\n//   args: \"run --allow-read --allow-write run/no_mem_cache.js\",\n//   output: \"run/no_mem_cache.js.out\",\n// });\n\n// This test checks that inline source map data is used. It uses a hand crafted\n// source map that maps to a file that exists, but is not loaded into the module\n// graph (inline_js_source_map_2.ts) (because there are no direct dependencies).\n// Source line is not remapped because no inline source contents are included in\n// the sourcemap and the file is not present in the dependency graph.\nitest!(inline_js_source_map_2 {\n  args: \"run --quiet run/inline_js_source_map_2.js\",\n  output: \"run/inline_js_source_map_2.js.out\",\n  exit_code: 1,\n});\n\n// This test checks that inline source map data is used. It uses a hand crafted\n// source map that maps to a file that exists, but is not loaded into the module\n// graph (inline_js_source_map_2.ts) (because there are no direct dependencies).\n// Source line remapped using th inline source contents that are included in the\n// inline source map.\nitest!(inline_js_source_map_2_with_inline_contents {\n  args: \"run --quiet run/inline_js_source_map_2_with_inline_contents.js\",\n  output: \"run/inline_js_source_map_2_with_inline_contents.js.out\",\n  exit_code: 1,\n});\n\n// This test checks that inline source map data is used. It uses a hand crafted\n// source map that maps to a file that exists, and is loaded into the module\n// graph because of a direct import statement (inline_js_source_map.ts). The\n// source map was generated from an earlier version of this file, where the throw\n// was not commented out. The source line is remapped using source contents that\n// from the module graph.\nitest!(inline_js_source_map_with_contents_from_graph {\n  args: \"run --quiet run/inline_js_source_map_with_contents_from_graph.js\",\n  output: \"run/inline_js_source_map_with_contents_from_graph.js.out\",\n  exit_code: 1,\n  http_server: true,\n});\n\n// This test ensures that a descriptive error is shown when we're unable to load\n// the import map. Even though this tests only the `run` subcommand, we can be sure\n// that the error message is similar for other subcommands as they all use\n// `program_state.maybe_import_map` to access the import map underneath.\nitest!(error_import_map_unable_to_load {\n  args: \"run --import-map=import_maps/does_not_exist.json import_maps/test.ts\",\n  output: \"run/error_import_map_unable_to_load.out\",\n  exit_code: 1,\n});\n\n// Test that setting `self` in the main thread to some other value doesn't break\n// the world.\nitest!(replace_self {\n  args: \"run run/replace_self.js\",\n  output: \"run/replace_self.js.out\",\n});\n\nitest!(worker_event_handler_test {\n  args: \"run --quiet --reload --allow-read run/worker_event_handler_test.js\",\n  output: \"run/worker_event_handler_test.js.out\",\n});\n\nitest!(worker_close_race {\n  args: \"run --quiet --reload --allow-read run/worker_close_race.js\",\n  output: \"run/worker_close_race.js.out\",\n});\n\nitest!(worker_drop_handle_race {\n  args: \"run --quiet --reload --allow-read run/worker_drop_handle_race.js\",\n  output: \"run/worker_drop_handle_race.js.out\",\n  exit_code: 1,\n});\n\nitest!(worker_drop_handle_race_terminate {\n  args: \"run run/worker_drop_handle_race_terminate.js\",\n  output: \"run/worker_drop_handle_race_terminate.js.out\",\n});\n\nitest!(worker_close_nested {\n  args: \"run --quiet --reload --allow-read run/worker_close_nested.js\",\n  output: \"run/worker_close_nested.js.out\",\n});\n\nitest!(worker_message_before_close {\n  args: \"run --quiet --reload --allow-read run/worker_message_before_close.js\",\n  output: \"run/worker_message_before_close.js.out\",\n});\n\nitest!(worker_close_in_wasm_reactions {\n  args:\n    \"run --quiet --reload --allow-read run/worker_close_in_wasm_reactions.js\",\n  output: \"run/worker_close_in_wasm_reactions.js.out\",\n});\n\nitest!(shebang_tsc {\n  args: \"run --quiet --check run/shebang.ts\",\n  output: \"run/shebang.ts.out\",\n});\n\nitest!(shebang_swc {\n  args: \"run --quiet run/shebang.ts\",\n  output: \"run/shebang.ts.out\",\n});\n\nitest!(shebang_with_json_imports_tsc {\n  args: \"run --quiet import_attributes/json_with_shebang.ts\",\n  output: \"import_attributes/json_with_shebang.ts.out\",\n  exit_code: 1,\n});\n\nitest!(shebang_with_json_imports_swc {\n  args: \"run --quiet --no-check import_attributes/json_with_shebang.ts\",\n  output: \"import_attributes/json_with_shebang.ts.out\",\n  exit_code: 1,\n});\n\n#[test]\nfn no_validate_asm() {\n  let output = util::deno_cmd()\n    .current_dir(util::testdata_path())\n    .arg(\"run\")\n    .arg(\"run/no_validate_asm.js\")\n    .piped_output()\n    .spawn()\n    .unwrap()\n    .wait_with_output()\n    .unwrap();\n  assert!(output.status.success());\n  assert!(output.stderr.is_empty());\n  assert!(output.stdout.is_empty());\n}\n\n#[test]\nfn exec_path() {\n  let output = util::deno_cmd()\n    .current_dir(util::testdata_path())\n    .arg(\"run\")\n    .arg(\"--allow-read\")\n    .arg(\"run/exec_path.ts\")\n    .stdout(Stdio::piped())\n    .spawn()\n    .unwrap()\n    .wait_with_output()\n    .unwrap();\n  assert!(output.status.success());\n  let stdout_str = std::str::from_utf8(&output.stdout).unwrap().trim();\n  let actual = PathRef::new(std::path::Path::new(stdout_str)).canonicalize();\n  let expected = util::deno_exe_path().canonicalize();\n  assert_eq!(expected, actual);\n}\n\n#[test]\nfn run_from_stdin_defaults_to_ts() {\n  let source_code = r#\"\ninterface Lollipop {\n  _: number;\n}\nconsole.log(\"executing typescript\");\n\"#;\n\n  let mut p = util::deno_cmd()\n    .arg(\"run\")\n    .arg(\"--check\")\n    .arg(\"-\")\n    .stdin(std::process::Stdio::piped())\n    .stdout_piped()\n    .spawn()\n    .unwrap();\n  let stdin = p.stdin.as_mut().unwrap();\n  stdin.write_all(source_code.as_bytes()).unwrap();\n  let result = p.wait_with_output().unwrap();\n  assert!(result.status.success());\n  let stdout_str = std::str::from_utf8(&result.stdout).unwrap().trim();\n  assert_eq!(stdout_str, \"executing typescript\");\n}\n\n#[test]\nfn run_from_stdin_ext() {\n  let source_code = r#\"\nlet i = 123;\ni = \"hello\"\nconsole.log(\"executing javascript\");\n\"#;\n\n  let mut p = util::deno_cmd()\n    .args(\"run --ext js --check -\")\n    .stdin(std::process::Stdio::piped())\n    .stdout_piped()\n    .spawn()\n    .unwrap();\n  let stdin = p.stdin.as_mut().unwrap();\n  stdin.write_all(source_code.as_bytes()).unwrap();\n  let result = p.wait_with_output().unwrap();\n  assert!(result.status.success());\n  let stdout_str = std::str::from_utf8(&result.stdout).unwrap().trim();\n  assert_eq!(stdout_str, \"executing javascript\");\n}\n\n#[cfg(windows)]\n// Clippy suggests to remove the `NoStd` prefix from all variants. I disagree.\n#[allow(clippy::enum_variant_names)]\nenum WinProcConstraints {\n  NoStdIn,\n  NoStdOut,\n  NoStdErr,\n}\n\n#[cfg(windows)]\nfn run_deno_script_constrained(\n  script_path: test_util::PathRef,\n  constraints: WinProcConstraints,\n) -> Result<(), i64> {\n  let file_path = \"assets/DenoWinRunner.ps1\";\n  let constraints = match constraints {\n    WinProcConstraints::NoStdIn => \"1\",\n    WinProcConstraints::NoStdOut => \"2\",\n    WinProcConstraints::NoStdErr => \"4\",\n  };\n  let deno_exe_path = util::deno_exe_path().to_string();\n  let deno_script_path = script_path.to_string();\n  let args = vec![&deno_exe_path[..], &deno_script_path[..], constraints];\n  util::run_powershell_script_file(file_path, args)\n}\n\n#[cfg(windows)]\n#[test]\nfn should_not_panic_on_no_stdin() {\n  let output = run_deno_script_constrained(\n    util::testdata_path().join(\"echo.ts\"),\n    WinProcConstraints::NoStdIn,\n  );\n  output.unwrap();\n}\n\n#[cfg(windows)]\n#[test]\nfn should_not_panic_on_no_stdout() {\n  let output = run_deno_script_constrained(\n    util::testdata_path().join(\"echo.ts\"),\n    WinProcConstraints::NoStdOut,\n  );\n  output.unwrap();\n}\n\n#[cfg(windows)]\n#[test]\nfn should_not_panic_on_no_stderr() {\n  let output = run_deno_script_constrained(\n    util::testdata_path().join(\"echo.ts\"),\n    WinProcConstraints::NoStdErr,\n  );\n  output.unwrap();\n}\n\n#[cfg(not(windows))]\n#[test]\nfn should_not_panic_on_undefined_home_environment_variable() {\n  let output = util::deno_cmd()\n    .current_dir(util::testdata_path())\n    .arg(\"run\")\n    .arg(\"echo.ts\")\n    .env_remove(\"HOME\")\n    .spawn()\n    .unwrap()\n    .wait_with_output()\n    .unwrap();\n  assert!(output.status.success());\n}\n\n#[test]\nfn should_not_panic_on_undefined_deno_dir_environment_variable() {\n  let output = util::deno_cmd()\n    .current_dir(util::testdata_path())\n    .arg(\"run\")\n    .arg(\"echo.ts\")\n    .env_remove(\"DENO_DIR\")\n    .spawn()\n    .unwrap()\n    .wait_with_output()\n    .unwrap();\n  assert!(output.status.success());\n}\n\n#[cfg(not(windows))]\n#[test]\nfn should_not_panic_on_undefined_deno_dir_and_home_environment_variables() {\n  let output = util::deno_cmd()\n    .current_dir(util::testdata_path())\n    .arg(\"run\")\n    .arg(\"echo.ts\")\n    .env_remove(\"DENO_DIR\")\n    .env_remove(\"HOME\")\n    .spawn()\n    .unwrap()\n    .wait_with_output()\n    .unwrap();\n  assert!(output.status.success());\n}\n\n#[test]\nfn rust_log() {\n  // Without RUST_LOG the stderr is empty.\n  let output = util::deno_cmd()\n    .current_dir(util::testdata_path())\n    .arg(\"run\")\n    .arg(\"run/001_hello.js\")\n    .stderr_piped()\n    .spawn()\n    .unwrap()\n    .wait_with_output()\n    .unwrap();\n  assert!(output.status.success());\n  assert!(output.stderr.is_empty());\n\n  // With RUST_LOG the stderr is not empty.\n  let output = util::deno_cmd()\n    .current_dir(util::testdata_path())\n    .arg(\"run\")\n    .arg(\"run/001_hello.js\")\n    .env(\"RUST_LOG\", \"debug\")\n    .stderr_piped()\n    .spawn()\n    .unwrap()\n    .wait_with_output()\n    .unwrap();\n  assert!(output.status.success());\n  assert!(!output.stderr.is_empty());\n}\n\n#[test]\nfn dont_cache_on_check_fail() {\n  let context = TestContext::default();\n  let output = context\n    .new_command()\n    .args(\"run --check=all --reload run/error_003_typescript.ts\")\n    .split_output()\n    .run();\n  assert!(!output.stderr().is_empty());\n  output.skip_stdout_check();\n  output.assert_exit_code(1);\n\n  let output = context\n    .new_command()\n    .args(\"run --check=all run/error_003_typescript.ts\")\n    .split_output()\n    .run();\n  assert!(!output.stderr().is_empty());\n  output.skip_stdout_check();\n  output.assert_exit_code(1);\n}\n\nmod permissions {\n  use test_util as util;\n  use test_util::itest;\n  use util::TestContext;\n\n  // TODO(bartlomieju): remove --unstable once Deno.Command is stabilized\n  #[test]\n  fn with_allow() {\n    for permission in &util::PERMISSION_VARIANTS {\n      let status = util::deno_cmd()\n        .current_dir(&util::testdata_path())\n        .arg(\"run\")\n        .arg(\"--unstable\")\n        .arg(format!(\"--allow-{permission}\"))\n        .arg(\"run/permission_test.ts\")\n        .arg(format!(\"{permission}Required\"))\n        .spawn()\n        .unwrap()\n        .wait()\n        .unwrap();\n      assert!(status.success());\n    }\n  }\n\n  // TODO(bartlomieju): remove --unstable once Deno.Command is stabilized\n  #[test]\n  fn without_allow() {\n    for permission in &util::PERMISSION_VARIANTS {\n      let (_, err) = util::run_and_collect_output(\n        false,\n        &format!(\"run --unstable run/permission_test.ts {permission}Required\"),\n        None,\n        None,\n        false,\n      );\n      assert!(err.contains(util::PERMISSION_DENIED_PATTERN));\n    }\n  }\n\n  #[test]\n  fn rw_inside_project_dir() {\n    const PERMISSION_VARIANTS: [&str; 2] = [\"read\", \"write\"];\n    for permission in &PERMISSION_VARIANTS {\n      let status = util::deno_cmd()\n        .current_dir(&util::testdata_path())\n        .arg(\"run\")\n        .arg(format!(\n          \"--allow-{0}={1}\",\n          permission,\n          util::testdata_path()\n        ))\n        .arg(\"run/complex_permissions_test.ts\")\n        .arg(permission)\n        .arg(\"run/complex_permissions_test.ts\")\n        .spawn()\n        .unwrap()\n        .wait()\n        .unwrap();\n      assert!(status.success());\n    }\n  }\n\n  #[test]\n  fn rw_outside_test_dir() {\n    const PERMISSION_VARIANTS: [&str; 2] = [\"read\", \"write\"];\n    for permission in &PERMISSION_VARIANTS {\n      let (_, err) = util::run_and_collect_output(\n        false,\n        &format!(\n          \"run --allow-{0}={1} run/complex_permissions_test.ts {0} {2}\",\n          permission,\n          util::testdata_path(),\n          util::root_path().join(\"Cargo.toml\"),\n        ),\n        None,\n        None,\n        false,\n      );\n      assert!(err.contains(util::PERMISSION_DENIED_PATTERN));\n    }\n  }\n\n  #[test]\n  fn rw_inside_test_dir() {\n    const PERMISSION_VARIANTS: [&str; 2] = [\"read\", \"write\"];\n    for permission in &PERMISSION_VARIANTS {\n      let status = util::deno_cmd()\n        .current_dir(&util::testdata_path())\n        .arg(\"run\")\n        .arg(format!(\n          \"--allow-{0}={1}\",\n          permission,\n          util::testdata_path(),\n        ))\n        .arg(\"run/complex_permissions_test.ts\")\n        .arg(permission)\n        .arg(\"run/complex_permissions_test.ts\")\n        .spawn()\n        .unwrap()\n        .wait()\n        .unwrap();\n      assert!(status.success());\n    }\n  }\n\n  #[test]\n  fn rw_outside_test_and_js_dir() {\n    const PERMISSION_VARIANTS: [&str; 2] = [\"read\", \"write\"];\n    let test_dir = util::testdata_path();\n    let js_dir = util::root_path().join(\"js\");\n    for permission in &PERMISSION_VARIANTS {\n      let (_, err) = util::run_and_collect_output(\n        false,\n        &format!(\n          \"run --allow-{0}={1},{2} run/complex_permissions_test.ts {0} {3}\",\n          permission,\n          test_dir,\n          js_dir,\n          util::root_path().join(\"Cargo.toml\"),\n        ),\n        None,\n        None,\n        false,\n      );\n      assert!(err.contains(util::PERMISSION_DENIED_PATTERN));\n    }\n  }\n\n  #[test]\n  fn rw_inside_test_and_js_dir() {\n    const PERMISSION_VARIANTS: [&str; 2] = [\"read\", \"write\"];\n    let test_dir = util::testdata_path();\n    let js_dir = util::root_path().join(\"js\");\n    for permission in &PERMISSION_VARIANTS {\n      let status = util::deno_cmd()\n        .current_dir(&util::testdata_path())\n        .arg(\"run\")\n        .arg(format!(\"--allow-{permission}={test_dir},{js_dir}\"))\n        .arg(\"run/complex_permissions_test.ts\")\n        .arg(permission)\n        .arg(\"run/complex_permissions_test.ts\")\n        .spawn()\n        .unwrap()\n        .wait()\n        .unwrap();\n      assert!(status.success());\n    }\n  }\n\n  #[test]\n  fn rw_relative() {\n    const PERMISSION_VARIANTS: [&str; 2] = [\"read\", \"write\"];\n    for permission in &PERMISSION_VARIANTS {\n      let status = util::deno_cmd()\n        .current_dir(&util::testdata_path())\n        .arg(\"run\")\n        .arg(format!(\"--allow-{permission}=.\"))\n        .arg(\"run/complex_permissions_test.ts\")\n        .arg(permission)\n        .arg(\"run/complex_permissions_test.ts\")\n        .spawn()\n        .unwrap()\n        .wait()\n        .unwrap();\n      assert!(status.success());\n    }\n  }\n\n  #[test]\n  fn rw_no_prefix() {\n    const PERMISSION_VARIANTS: [&str; 2] = [\"read\", \"write\"];\n    for permission in &PERMISSION_VARIANTS {\n      let status = util::deno_cmd()\n        .current_dir(&util::testdata_path())\n        .arg(\"run\")\n        .arg(format!(\"--allow-{permission}=tls/../\"))\n        .arg(\"run/complex_permissions_test.ts\")\n        .arg(permission)\n        .arg(\"run/complex_permissions_test.ts\")\n        .spawn()\n        .unwrap()\n        .wait()\n        .unwrap();\n      assert!(status.success());\n    }\n  }\n\n  #[test]\n  fn net_fetch_allow_localhost_4545() {\n    let (_, err) = util::run_and_collect_output(\n      true,\n        \"run --allow-net=localhost:4545 run/complex_permissions_test.ts netFetch http://localhost:4545/\",\n        None,\n        None,\n        true,\n      );\n    assert!(!err.contains(util::PERMISSION_DENIED_PATTERN));\n  }\n\n  #[test]\n  fn net_fetch_allow_deno_land() {\n    let (_, err) = util::run_and_collect_output(\n      false,\n        \"run --allow-net=deno.land run/complex_permissions_test.ts netFetch http://localhost:4545/\",\n        None,\n        None,\n        true,\n      );\n    assert!(err.contains(util::PERMISSION_DENIED_PATTERN));\n  }\n\n  #[test]\n  fn net_fetch_localhost_4545_fail() {\n    let (_, err) = util::run_and_collect_output(\n      false,\n        \"run --allow-net=localhost:4545 run/complex_permissions_test.ts netFetch http://localhost:4546/\",\n        None,\n        None,\n        true,\n      );\n    assert!(err.contains(util::PERMISSION_DENIED_PATTERN));\n  }\n\n  #[test]\n  fn net_fetch_localhost() {\n    let (_, err) = util::run_and_collect_output(\n      true,\n        \"run --allow-net=localhost run/complex_permissions_test.ts netFetch http://localhost:4545/ http://localhost:4546/ http://localhost:4547/\",\n        None,\n        None,\n        true,\n      );\n    assert!(!err.contains(util::PERMISSION_DENIED_PATTERN));\n  }\n\n  #[test]\n  fn net_connect_allow_localhost_ip_4555() {\n    let (_, err) = util::run_and_collect_output(\n      true,\n        \"run --allow-net=127.0.0.1:4545 run/complex_permissions_test.ts netConnect 127.0.0.1:4545\",\n        None,\n        None,\n        true,\n      );\n    assert!(!err.contains(util::PERMISSION_DENIED_PATTERN));\n  }\n\n  #[test]\n  fn net_connect_allow_deno_land() {\n    let (_, err) = util::run_and_collect_output(\n      false,\n        \"run --allow-net=deno.land run/complex_permissions_test.ts netConnect 127.0.0.1:4546\",\n        None,\n        None,\n        true,\n      );\n    assert!(err.contains(util::PERMISSION_DENIED_PATTERN));\n  }\n\n  #[test]\n  fn net_connect_allow_localhost_ip_4545_fail() {\n    let (_, err) = util::run_and_collect_output(\n      false,\n        \"run --allow-net=127.0.0.1:4545 run/complex_permissions_test.ts netConnect 127.0.0.1:4546\",\n        None,\n        None,\n        true,\n      );\n    assert!(err.contains(util::PERMISSION_DENIED_PATTERN));\n  }\n\n  #[test]\n  fn net_connect_allow_localhost_ip() {\n    let (_, err) = util::run_and_collect_output(\n      true,\n        \"run --allow-net=127.0.0.1 run/complex_permissions_test.ts netConnect 127.0.0.1:4545 127.0.0.1:4546 127.0.0.1:4547\",\n        None,\n        None,\n        true,\n      );\n    assert!(!err.contains(util::PERMISSION_DENIED_PATTERN));\n  }\n\n  #[test]\n  fn net_listen_allow_localhost_4555() {\n    let (_, err) = util::run_and_collect_output(\n      true,\n        \"run --allow-net=localhost:4558 run/complex_permissions_test.ts netListen localhost:4558\",\n        None,\n        None,\n        false,\n      );\n    assert!(!err.contains(util::PERMISSION_DENIED_PATTERN));\n  }\n\n  #[test]\n  fn net_listen_allow_deno_land() {\n    let (_, err) = util::run_and_collect_output(\n      false,\n        \"run --allow-net=deno.land run/complex_permissions_test.ts netListen localhost:4545\",\n        None,\n        None,\n        false,\n      );\n    assert!(err.contains(util::PERMISSION_DENIED_PATTERN));\n  }\n\n  #[test]\n  fn net_listen_allow_localhost_4555_fail() {\n    let (_, err) = util::run_and_collect_output(\n      false,\n        \"run --allow-net=localhost:4555 run/complex_permissions_test.ts netListen localhost:4556\",\n        None,\n        None,\n        false,\n      );\n    assert!(err.contains(util::PERMISSION_DENIED_PATTERN));\n  }\n\n  #[test]\n  fn net_listen_allow_localhost() {\n    // Port 4600 is chosen to not collide with those used by\n    // target/debug/test_server\n    let (_, err) = util::run_and_collect_output(\n      true,\n        \"run --allow-net=localhost run/complex_permissions_test.ts netListen localhost:4600\",\n        None,\n        None,\n        false,\n      );\n    assert!(!err.contains(util::PERMISSION_DENIED_PATTERN));\n  }\n\n  #[test]\n  fn _061_permissions_request() {\n    TestContext::default()\n      .new_command()\n      .args_vec([\"run\", \"--quiet\", \"run/061_permissions_request.ts\"])\n      .with_pty(|mut console| {\n        console.expect(concat!(\n          \"   Deno requests read access to \\\"foo\\\".\\r\\n\",\n          \" Requested by `Deno.permissions.request()` API.\\r\\n\",\n          \" Run again with --allow-read to bypass this prompt.\\r\\n\",\n          \" Allow? [y/n/A] (y = yes, allow; n = no, deny; A = allow all read permissions)\",\n        ));\n        console.write_line_raw(\"y\");\n        console.expect(concat!(\n          \"   Deno requests read access to \\\"bar\\\".\\r\\n\",\n          \" Requested by `Deno.permissions.request()` API.\\r\\n\",\n          \" Run again with --allow-read to bypass this prompt.\\r\\n\",\n          \" Allow? [y/n/A] (y = yes, allow; n = no, deny; A = allow all read permissions)\",\n        ));\n        console.write_line_raw(\"n\");\n        console.expect(\"granted\");\n        console.expect(\"prompt\");\n        console.expect(\"denied\");\n      });\n  }\n\n  #[test]\n  fn _061_permissions_request_sync() {\n    TestContext::default()\n      .new_command()\n      .args_vec([\"run\", \"--quiet\", \"run/061_permissions_request_sync.ts\"])\n      .with_pty(|mut console| {\n        console.expect(concat!(\n          \"   Deno requests read access to \\\"foo\\\".\\r\\n\",\n          \" Requested by `Deno.permissions.request()` API.\\r\\n\",\n          \" Run again with --allow-read to bypass this prompt.\\r\\n\",\n          \" Allow? [y/n/A] (y = yes, allow; n = no, deny; A = allow all read permissions)\",\n        ));\n        console.write_line_raw(\"y\");\n        console.expect(concat!(\n          \"   Deno requests read access to \\\"bar\\\".\\r\\n\",\n          \" Requested by `Deno.permissions.request()` API.\\r\\n\",\n          \" Run again with --allow-read to bypass this prompt.\\r\\n\",\n          \" Allow? [y/n/A] (y = yes, allow; n = no, deny; A = allow all read permissions)\",\n        ));\n        console.write_line_raw(\"n\");\n        console.expect(\"granted\");\n        console.expect(\"prompt\");\n        console.expect(\"denied\");\n      });\n  }\n\n  #[test]\n  fn _062_permissions_request_global() {\n    TestContext::default()\n      .new_command()\n      .args_vec([\"run\", \"--quiet\", \"run/062_permissions_request_global.ts\"])\n      .with_pty(|mut console| {\n        console.expect(concat!(\n          \"   Deno requests read access.\\r\\n\",\n          \" Requested by `Deno.permissions.request()` API.\\r\\n\",\n          \" Run again with --allow-read to bypass this prompt.\\r\\n\",\n          \" Allow? [y/n/A] (y = yes, allow; n = no, deny; A = allow all read permissions)\",\n        ));\n        console.write_line_raw(\"y\\n\");\n        console\n          .expect(\"PermissionStatus { state: \\\"granted\\\", onchange: null }\");\n        console\n          .expect(\"PermissionStatus { state: \\\"granted\\\", onchange: null }\");\n        console\n          .expect(\"PermissionStatus { state: \\\"granted\\\", onchange: null }\");\n      });\n  }\n\n  #[test]\n  fn _062_permissions_request_global_sync() {\n    TestContext::default()\n      .new_command()\n      .args_vec([\"run\", \"--quiet\", \"run/062_permissions_request_global_sync.ts\"])\n      .with_pty(|mut console| {\n        console.expect(concat!(\n          \"   Deno requests read access.\\r\\n\",\n          \" Requested by `Deno.permissions.request()` API.\\r\\n\",\n          \" Run again with --allow-read to bypass this prompt.\\r\\n\",\n          \" Allow? [y/n/A] (y = yes, allow; n = no, deny; A = allow all read permissions)\",\n        ));\n        console.write_line_raw(\"y\");\n        console\n          .expect(\"PermissionStatus { state: \\\"granted\\\", onchange: null }\");\n        console\n          .expect(\"PermissionStatus { state: \\\"granted\\\", onchange: null }\");\n        console\n          .expect(\"PermissionStatus { state: \\\"granted\\\", onchange: null }\");\n      });\n  }\n\n  itest!(_063_permissions_revoke {\n    args: \"run --allow-read=foo,bar run/063_permissions_revoke.ts\",\n    output: \"run/063_permissions_revoke.ts.out\",\n  });\n\n  itest!(_063_permissions_revoke_sync {\n    args: \"run --allow-read=foo,bar run/063_permissions_revoke_sync.ts\",\n    output: \"run/063_permissions_revoke.ts.out\",\n  });\n\n  itest!(_064_permissions_revoke_global {\n    args: \"run --allow-read=foo,bar run/064_permissions_revoke_global.ts\",\n    output: \"run/064_permissions_revoke_global.ts.out\",\n  });\n\n  itest!(_064_permissions_revoke_global_sync {\n    args: \"run --allow-read=foo,bar run/064_permissions_revoke_global_sync.ts\",\n    output: \"run/064_permissions_revoke_global.ts.out\",\n  });\n\n  itest!(_065_permissions_revoke_net {\n    args: \"run --allow-net run/065_permissions_revoke_net.ts\",\n    output: \"run/065_permissions_revoke_net.ts.out\",\n  });\n\n  #[test]\n  fn _066_prompt() {\n    TestContext::default()\n      .new_command()\n      .args_vec([\"run\", \"--quiet\", \"--unstable\", \"run/066_prompt.ts\"])\n      .with_pty(|mut console| {\n        console.expect(\"What is your name? Jane Doe\");\n        console.write_line_raw(\"\");\n        console.expect(\"Your name is Jane Doe.\");\n\n        console.expect(\"Prompt \");\n        console.write_line_raw(\"foo\");\n        console.expect(\"Your input is foo.\");\n        console.expect(\"Question 0 [y/N] \");\n        console.write_line_raw(\"Y\");\n        console.expect(\"Your answer is true\");\n        console.expect(\"Question 1 [y/N] \");\n        console.write_line_raw(\"N\");\n        console.expect(\"Your answer is false\");\n        console.expect(\"Question 2 [y/N] \");\n        console.write_line_raw(\"yes\");\n        console.expect(\"Your answer is false\");\n        console.expect(\"Confirm [y/N] \");\n        console.write_line(\"\");\n        console.expect(\"Your answer is false\");\n        console.expect(\"What is Windows EOL? \");\n        console.write_line(\"windows\");\n        console.expect(\"Your answer is \\\"windows\\\"\");\n        console.expect(\"Hi [Enter] \");\n        console.write_line(\"\");\n        console.expect(\"Alert [Enter] \");\n        console.write_line(\"\");\n        console.expect(\"The end of test\");\n      });\n  }\n\n  itest!(dynamic_import_static_analysis_no_permissions {\n    args: \"run --quiet --reload --no-prompt dynamic_import/static_analysis_no_permissions.ts\",\n    output: \"dynamic_import/static_analysis_no_permissions.ts.out\",\n  });\n\n  itest!(dynamic_import_permissions_remote_remote {\n    args: \"run --quiet --reload --allow-net=localhost:4545 dynamic_import/permissions_remote_remote.ts\",\n    output: \"dynamic_import/permissions_remote_remote.ts.out\",\n    http_server: true,\n    exit_code: 1,\n  });\n\n  itest!(dynamic_import_permissions_data_remote {\n    args: \"run --quiet --reload --allow-net=localhost:4545 dynamic_import/permissions_data_remote.ts\",\n    output: \"dynamic_import/permissions_data_remote.ts.out\",\n    http_server: true,\n    exit_code: 1,\n  });\n\n  itest!(dynamic_import_permissions_blob_remote {\n    args: \"run --quiet --reload --allow-net=localhost:4545 dynamic_import/permissions_blob_remote.ts\",\n    output: \"dynamic_import/permissions_blob_remote.ts.out\",\n    http_server: true,\n    exit_code: 1,\n  });\n\n  itest!(dynamic_import_permissions_data_local {\n    args: \"run --quiet --reload --allow-net=localhost:4545 dynamic_import/permissions_data_local.ts\",\n    output: \"dynamic_import/permissions_data_local.ts.out\",\n    http_server: true,\n    exit_code: 1,\n  });\n\n  itest!(dynamic_import_permissions_blob_local {\n    args: \"run --quiet --reload --allow-net=localhost:4545 dynamic_import/permissions_blob_local.ts\",\n    output: \"dynamic_import/permissions_blob_local.ts.out\",\n    http_server: true,\n    exit_code: 1,\n  });\n}\n\nitest!(tls_starttls {\n  args: \"run --quiet --reload --allow-net --allow-read --cert tls/RootCA.pem run/tls_starttls.js\",\n  output: \"run/tls.out\",\n});\n\nitest!(tls_connecttls {\n  args: \"run --quiet --reload --allow-net --allow-read --cert tls/RootCA.pem run/tls_connecttls.js\",\n  output: \"run/tls.out\",\n});\n\nitest!(byte_order_mark {\n  args: \"run --no-check run/byte_order_mark.ts\",\n  output: \"run/byte_order_mark.out\",\n});\n\n#[test]\nfn issue9750() {\n  TestContext::default()\n    .new_command()\n    .args_vec([\"run\", \"run/issue9750.js\"])\n    .with_pty(|mut console| {\n      console.expect(\"Enter 'yy':\");\n      console.write_line_raw(\"yy\");\n      console.expect(concat!(\n        \"   Deno requests env access.\\r\\n\",\n        \" Requested by `Deno.permissions.request()` API.\\r\\n\",\n        \" Run again with --allow-env to bypass this prompt.\\r\\n\",\n        \" Allow? [y/n/A] (y = yes, allow; n = no, deny; A = allow all env permissions)\",\n      ));\n      console.write_line_raw(\"n\");\n      console.expect(\"Denied env access.\");\n      console.expect(concat!(\n        \"   Deno requests env access to \\\"SECRET\\\".\\r\\n\",\n        \" Run again with --allow-env to bypass this prompt.\\r\\n\",\n        \" Allow? [y/n/A] (y = yes, allow; n = no, deny; A = allow all env permissions)\",\n      ));\n      console.write_line_raw(\"n\");\n      console.expect_all(&[\n        \"Denied env access to \\\"SECRET\\\".\",\n        \"PermissionDenied: Requires env access to \\\"SECRET\\\", run again with the --allow-env flag\",\n      ]);\n    });\n}\n\n// Regression test for https://github.com/denoland/deno/issues/11451.\nitest!(dom_exception_formatting {\n  args: \"run run/dom_exception_formatting.ts\",\n  output: \"run/dom_exception_formatting.ts.out\",\n  exit_code: 1,\n});\n\nitest!(long_data_url_formatting {\n  args: \"run run/long_data_url_formatting.ts\",\n  output: \"run/long_data_url_formatting.ts.out\",\n  exit_code: 1,\n});\n\nitest!(eval_context_throw_dom_exception {\n  args: \"run run/eval_context_throw_dom_exception.js\",\n  output: \"run/eval_context_throw_dom_exception.js.out\",\n});\n\n#[test]\n#[cfg(unix)]\nfn navigator_language_unix() {\n  let (res, _) = util::run_and_collect_output(\n    true,\n    \"run navigator_language.ts\",\n    None,\n    Some(vec![(\"LC_ALL\".to_owned(), \"pl_PL\".to_owned())]),\n    false,\n  );\n  assert_eq!(res, \"pl-PL\\n\")\n}\n\n#[test]\nfn navigator_language() {\n  let (res, _) = util::run_and_collect_output(\n    true,\n    \"run navigator_language.ts\",\n    None,\n    None,\n    false,\n  );\n  assert!(!res.is_empty())\n}\n\n#[test]\n#[cfg(unix)]\nfn navigator_languages_unix() {\n  let (res, _) = util::run_and_collect_output(\n    true,\n    \"run navigator_languages.ts\",\n    None,\n    Some(vec![\n      (\"LC_ALL\".to_owned(), \"pl_PL\".to_owned()),\n      (\"NO_COLOR\".to_owned(), \"1\".to_owned()),\n    ]),\n    false,\n  );\n  assert_eq!(res, \"[ \\\"pl-PL\\\" ]\\n\")\n}\n\n#[test]\nfn navigator_languages() {\n  let (res, _) = util::run_and_collect_output(\n    true,\n    \"run navigator_languages.ts\",\n    None,\n    None,\n    false,\n  );\n  assert!(!res.is_empty())\n}\n\n/// Regression test for https://github.com/denoland/deno/issues/12740.\n#[test]\nfn issue12740() {\n  let mod_dir = TempDir::new();\n  let mod1_path = mod_dir.path().join(\"mod1.ts\");\n  let mod2_path = mod_dir.path().join(\"mod2.ts\");\n  mod1_path.write(\"\");\n  let status = util::deno_cmd()\n    .current_dir(util::testdata_path())\n    .arg(\"run\")\n    .arg(&mod1_path)\n    .stderr(Stdio::null())\n    .stdout(Stdio::null())\n    .spawn()\n    .unwrap()\n    .wait()\n    .unwrap();\n  assert!(status.success());\n  mod1_path.write(\"export { foo } from \\\"./mod2.ts\\\";\");\n  mod2_path.write(\"(\");\n  let status = util::deno_cmd()\n    .current_dir(util::testdata_path())\n    .arg(\"run\")\n    .arg(&mod1_path)\n    .stderr(Stdio::null())\n    .stdout(Stdio::null())\n    .spawn()\n    .unwrap()\n    .wait()\n    .unwrap();\n  assert!(!status.success());\n}\n\n/// Regression test for https://github.com/denoland/deno/issues/12807.\n#[test]\nfn issue12807() {\n  let mod_dir = TempDir::new();\n  let mod1_path = mod_dir.path().join(\"mod1.ts\");\n  let mod2_path = mod_dir.path().join(\"mod2.ts\");\n  // With a fresh `DENO_DIR`, run a module with a dependency and a type error.\n  mod1_path.write(\"import './mod2.ts'; Deno.exit('0');\");\n  mod2_path.write(\"console.log('Hello, world!');\");\n  let status = util::deno_cmd()\n    .current_dir(util::testdata_path())\n    .arg(\"run\")\n    .arg(\"--check\")\n    .arg(&mod1_path)\n    .stderr(Stdio::null())\n    .stdout(Stdio::null())\n    .spawn()\n    .unwrap()\n    .wait()\n    .unwrap();\n  assert!(!status.success());\n  // Fix the type error and run again.\n  std::fs::write(&mod1_path, \"import './mod2.ts'; Deno.exit(0);\").unwrap();\n  let status = util::deno_cmd()\n    .current_dir(util::testdata_path())\n    .arg(\"run\")\n    .arg(\"--check\")\n    .arg(&mod1_path)\n    .stderr(Stdio::null())\n    .stdout(Stdio::null())\n    .spawn()\n    .unwrap()\n    .wait()\n    .unwrap();\n  assert!(status.success());\n}\n\nitest!(issue_13562 {\n  args: \"run run/issue13562.ts\",\n  output: \"run/issue13562.ts.out\",\n});\n\nitest!(import_attributes_static_import {\n  args: \"run --allow-read import_attributes/static_import.ts\",\n  output: \"import_attributes/static_import.out\",\n});\n\nitest!(import_attributes_static_export {\n  args: \"run --allow-read import_attributes/static_export.ts\",\n  output: \"import_attributes/static_export.out\",\n});\n\nitest!(import_attributes_static_error {\n  args: \"run --allow-read import_attributes/static_error.ts\",\n  output: \"import_attributes/static_error.out\",\n  exit_code: 1,\n});\n\nitest!(import_attributes_dynamic_import {\n  args: \"run --allow-read --check import_attributes/dynamic_import.ts\",\n  output: \"import_attributes/dynamic_import.out\",\n});\n\nitest!(import_attributes_dynamic_error {\n  args: \"run --allow-read import_attributes/dynamic_error.ts\",\n  output: \"import_attributes/dynamic_error.out\",\n  exit_code: 1,\n});\n\nitest!(import_attributes_type_check {\n  args: \"run --allow-read --check import_attributes/type_check.ts\",\n  output: \"import_attributes/type_check.out\",\n  exit_code: 1,\n});\n\nitest!(delete_window {\n  args: \"run run/delete_window.js\",\n  output_str: Some(\"true\\n\"),\n});\n\nitest!(colors_without_global_this {\n  args: \"run run/colors_without_globalThis.js\",\n  output_str: Some(\"true\\n\"),\n});\n\nitest!(config_auto_discovered_for_local_script {\n  args: \"run --quiet run/with_config/frontend_work.ts\",\n  output_str: Some(\"ok\\n\"),\n});\n\nitest!(config_auto_discovered_for_local_script_log {\n  args: \"run -L debug run/with_config/frontend_work.ts\",\n  output: \"run/with_config/auto_discovery_log.out\",\n});\n\nitest!(no_config_auto_discovery_for_local_script {\n  args: \"run --quiet --no-config --check run/with_config/frontend_work.ts\",\n  output: \"run/with_config/no_auto_discovery.out\",\n  exit_code: 1,\n});\n\nitest!(config_not_auto_discovered_for_remote_script {\n  args: \"run --quiet http://127.0.0.1:4545/run/with_config/server_side_work.ts\",\n  output_str: Some(\"ok\\n\"),\n  http_server: true,\n});\n\nitest!(package_json_auto_discovered_for_local_script_arg {\n  args: \"run -L debug -A no_deno_json/main.ts\",\n  output: \"run/with_package_json/no_deno_json/main.out\",\n  // notice this is not in no_deno_json\n  cwd: Some(\"run/with_package_json/\"),\n  // prevent creating a node_modules dir in the code directory\n  copy_temp_dir: Some(\"run/with_package_json/\"),\n  envs: env_vars_for_npm_tests(),\n  http_server: true,\n});\n\n// In this case we shouldn't discover `package.json` file, because it's in a\n// directory that is above the directory containing `deno.json` file.\nitest!(\n  package_json_auto_discovered_for_local_script_arg_with_stop {\n    args: \"run -L debug with_stop/some/nested/dir/main.ts\",\n    output: \"run/with_package_json/with_stop/main.out\",\n    cwd: Some(\"run/with_package_json/\"),\n    copy_temp_dir: Some(\"run/with_package_json/\"),\n    envs: env_vars_for_npm_tests(),\n    http_server: true,\n    exit_code: 1,\n  }\n);\n\nitest!(package_json_not_auto_discovered_no_config {\n  args: \"run -L debug -A --no-config noconfig.ts\",\n  output: \"run/with_package_json/no_deno_json/noconfig.out\",\n  cwd: Some(\"run/with_package_json/no_deno_json/\"),\n});\n\nitest!(package_json_not_auto_discovered_no_npm {\n  args: \"run -L debug -A --no-npm noconfig.ts\",\n  output: \"run/with_package_json/no_deno_json/noconfig.out\",\n  cwd: Some(\"run/with_package_json/no_deno_json/\"),\n});\n\nitest!(package_json_not_auto_discovered_env_var {\n  args: \"run -L debug -A noconfig.ts\",\n  output: \"run/with_package_json/no_deno_json/noconfig.out\",\n  cwd: Some(\"run/with_package_json/no_deno_json/\"),\n  envs: vec![(\"DENO_NO_PACKAGE_JSON\".to_string(), \"1\".to_string())],\n});\n\nitest!(\n  package_json_auto_discovered_node_modules_relative_package_json {\n    args: \"run -A main.js\",\n    output: \"run/with_package_json/no_deno_json/sub_dir/main.out\",\n    cwd: Some(\"run/with_package_json/no_deno_json/sub_dir\"),\n    copy_temp_dir: Some(\"run/with_package_json/no_deno_json/\"),\n    envs: env_vars_for_npm_tests(),\n    http_server: true,\n  }\n);\n\nitest!(package_json_auto_discovered_for_npm_binary {\n  args: \"run -L debug -A npm:@denotest/bin/cli-esm this is a test\",\n  output: \"run/with_package_json/npm_binary/main.out\",\n  cwd: Some(\"run/with_package_json/npm_binary/\"),\n  copy_temp_dir: Some(\"run/with_package_json/\"),\n  envs: env_vars_for_npm_tests(),\n  http_server: true,\n});\n\nitest!(package_json_auto_discovered_no_package_json_imports {\n  // this should not use --quiet because we should ensure no package.json install occurs\n  args: \"run -A no_package_json_imports.ts\",\n  output: \"run/with_package_json/no_deno_json/no_package_json_imports.out\",\n  cwd: Some(\"run/with_package_json/no_deno_json\"),\n  copy_temp_dir: Some(\"run/with_package_json/no_deno_json\"),\n});\n\n#[test]\nfn package_json_with_deno_json() {\n  let context = TestContextBuilder::for_npm()\n    .use_copy_temp_dir(\"package_json/deno_json/\")\n    .cwd(\"package_json/deno_json/\")\n    .build();\n  let output = context.new_command().args(\"run --quiet -A main.ts\").run();\n  output.assert_matches_file(\"package_json/deno_json/main.out\");\n\n  assert!(context\n    .temp_dir()\n    .path()\n    .join(\"package_json/deno_json/deno.lock\")\n    .exists());\n\n  // run again and ensure the top level install doesn't happen twice\n  let output = context\n    .new_command()\n    .args(\"run --log-level=debug -A main.ts\")\n    .run();\n  let output = output.combined_output();\n  assert_contains!(output, \"Skipping top level install.\");\n}\n\n#[test]\nfn package_json_error_dep_value_test() {\n  let context = TestContextBuilder::for_npm()\n    .use_copy_temp_dir(\"package_json/invalid_value\")\n    .cwd(\"package_json/invalid_value\")\n    .build();\n\n  // should run fine when not referencing a failing dep entry\n  context\n    .new_command()\n    .args(\"run ok.ts\")\n    .run()\n    .assert_matches_file(\"package_json/invalid_value/ok.ts.out\");\n\n  // should fail when referencing a failing dep entry\n  context\n    .new_command()\n    .args(\"run error.ts\")\n    .run()\n    .assert_exit_code(1)\n    .assert_matches_file(\"package_json/invalid_value/error.ts.out\");\n\n  // should output a warning about the failing dep entry\n  context\n    .new_command()\n    .args(\"task test\")\n    .run()\n    .assert_matches_file(\"package_json/invalid_value/task.out\");\n}\n\n#[test]\nfn package_json_no_node_modules_dir_created() {\n  // it should not create a node_modules directory\n  let context = TestContextBuilder::new()\n    .add_npm_env_vars()\n    .use_temp_cwd()\n    .build();\n  let temp_dir = context.temp_dir();\n\n  temp_dir.write(\"deno.json\", \"{}\");\n  temp_dir.write(\"package.json\", \"{}\");\n  temp_dir.write(\"main.ts\", \"\");\n\n  context.new_command().args(\"run main.ts\").run();\n\n  assert!(!temp_dir.path().join(\"node_modules\").exists());\n}\n\n#[test]\nfn node_modules_dir_no_npm_specifiers_no_dir_created() {\n  // it should not create a node_modules directory\n  let context = TestContextBuilder::new()\n    .add_npm_env_vars()\n    .use_temp_cwd()\n    .build();\n  let temp_dir = context.temp_dir();\n\n  temp_dir.write(\"deno.json\", \"{}\");\n  temp_dir.write(\"main.ts\", \"\");\n\n  context\n    .new_command()\n    .args(\"run --node-modules-dir main.ts\")\n    .run();\n\n  assert!(!temp_dir.path().join(\"node_modules\").exists());\n}\n\nitest!(wasm_streaming_panic_test {\n  args: \"run run/wasm_streaming_panic_test.js\",\n  output: \"run/wasm_streaming_panic_test.js.out\",\n  exit_code: 1,\n});\n\n// Regression test for https://github.com/denoland/deno/issues/13897.\nitest!(fetch_async_error_stack {\n  args: \"run --quiet -A run/fetch_async_error_stack.ts\",\n  output: \"run/fetch_async_error_stack.ts.out\",\n  exit_code: 1,\n});\n\nitest!(event_listener_error {\n  args: \"run --quiet run/event_listener_error.ts\",\n  output: \"run/event_listener_error.ts.out\",\n  exit_code: 1,\n});\n\nitest!(event_listener_error_handled {\n  args: \"run --quiet run/event_listener_error_handled.ts\",\n  output: \"run/event_listener_error_handled.ts.out\",\n});\n\n// https://github.com/denoland/deno/pull/14159#issuecomment-1092285446\nitest!(event_listener_error_immediate_exit {\n  args: \"run --quiet run/event_listener_error_immediate_exit.ts\",\n  output: \"run/event_listener_error_immediate_exit.ts.out\",\n  exit_code: 1,\n});\n\n// https://github.com/denoland/deno/pull/14159#issuecomment-1092285446\nitest!(event_listener_error_immediate_exit_worker {\n  args: \"run --quiet -A run/event_listener_error_immediate_exit_worker.ts\",\n  output: \"run/event_listener_error_immediate_exit_worker.ts.out\",\n  exit_code: 1,\n});\n\nitest!(set_timeout_error {\n  args: \"run --quiet run/set_timeout_error.ts\",\n  output: \"run/set_timeout_error.ts.out\",\n  exit_code: 1,\n});\n\nitest!(set_timeout_error_handled {\n  args: \"run --quiet run/set_timeout_error_handled.ts\",\n  output: \"run/set_timeout_error_handled.ts.out\",\n});\n\nitest!(aggregate_error {\n  args: \"run --quiet run/aggregate_error.ts\",\n  output: \"run/aggregate_error.out\",\n  exit_code: 1,\n});\n\nitest!(complex_error {\n  args: \"run --quiet run/complex_error.ts\",\n  output: \"run/complex_error.ts.out\",\n  exit_code: 1,\n});\n\n// Regression test for https://github.com/denoland/deno/issues/16340.\nitest!(error_with_errors_prop {\n  args: \"run --quiet run/error_with_errors_prop.js\",\n  output: \"run/error_with_errors_prop.js.out\",\n  exit_code: 1,\n});\n\n// Regression test for https://github.com/denoland/deno/issues/12143.\nitest!(js_root_with_ts_check {\n  args: \"run --quiet --check run/js_root_with_ts_check.js\",\n  output: \"run/js_root_with_ts_check.js.out\",\n  exit_code: 1,\n});\n\n#[test]\nfn check_local_then_remote() {\n  let _http_guard = util::http_server();\n  let deno_dir = util::new_deno_dir();\n  let output = util::deno_cmd_with_deno_dir(&deno_dir)\n    .current_dir(util::testdata_path())\n    .arg(\"run\")\n    .arg(\"--check\")\n    .arg(\"run/remote_type_error/main.ts\")\n    .spawn()\n    .unwrap()\n    .wait_with_output()\n    .unwrap();\n  assert!(output.status.success());\n  let output = util::deno_cmd_with_deno_dir(&deno_dir)\n    .current_dir(util::testdata_path())\n    .arg(\"run\")\n    .arg(\"--check=all\")\n    .arg(\"run/remote_type_error/main.ts\")\n    .env(\"NO_COLOR\", \"1\")\n    .stderr_piped()\n    .spawn()\n    .unwrap()\n    .wait_with_output()\n    .unwrap();\n  assert!(!output.status.success());\n  let stderr = std::str::from_utf8(&output.stderr).unwrap();\n  assert_contains!(stderr, \"Type 'string' is not assignable to type 'number'.\");\n}\n\n// Regression test for https://github.com/denoland/deno/issues/15163\nitest!(check_js_points_to_ts {\n  args: \"run --quiet --check --config run/checkjs.tsconfig.json run/check_js_points_to_ts/test.js\",\n  output: \"run/check_js_points_to_ts/test.js.out\",\n  exit_code: 1,\n});\n\nitest!(no_prompt_flag {\n  args: \"run --quiet --no-prompt run/no_prompt.ts\",\n  output_str: Some(\"\"),\n});\n\n#[test]\nfn deno_no_prompt_environment_variable() {\n  let output = util::deno_cmd()\n    .current_dir(util::testdata_path())\n    .arg(\"run\")\n    .arg(\"--unstable\")\n    .arg(\"run/no_prompt.ts\")\n    .env(\"DENO_NO_PROMPT\", \"1\")\n    .spawn()\n    .unwrap()\n    .wait_with_output()\n    .unwrap();\n  assert!(output.status.success());\n}\n\nitest!(report_error {\n  args: \"run --quiet run/report_error.ts\",\n  output: \"run/report_error.ts.out\",\n  exit_code: 1,\n});\n\nitest!(report_error_handled {\n  args: \"run --quiet run/report_error_handled.ts\",\n  output: \"run/report_error_handled.ts.out\",\n});\n\n// Regression test for https://github.com/denoland/deno/issues/15513.\nitest!(report_error_end_of_program {\n  args: \"run --quiet run/report_error_end_of_program.ts\",\n  output: \"run/report_error_end_of_program.ts.out\",\n  exit_code: 1,\n});\n\nitest!(queue_microtask_error {\n  args: \"run --quiet run/queue_microtask_error.ts\",\n  output: \"run/queue_microtask_error.ts.out\",\n  exit_code: 1,\n});\n\nitest!(queue_microtask_error_handled {\n  args: \"run --quiet run/queue_microtask_error_handled.ts\",\n  output: \"run/queue_microtask_error_handled.ts.out\",\n});\n\nitest!(spawn_stdout_inherit {\n  args: \"run --quiet -A run/spawn_stdout_inherit.ts\",\n  output: \"run/spawn_stdout_inherit.ts.out\",\n});\n\nitest!(error_name_non_string {\n  args: \"run --quiet run/error_name_non_string.js\",\n  output: \"run/error_name_non_string.js.out\",\n  exit_code: 1,\n});\n\nitest!(custom_inspect_url {\n  args: \"run run/custom_inspect_url.js\",\n  output: \"run/custom_inspect_url.js.out\",\n});\n\nitest!(config_json_import {\n  args: \"run --quiet -c jsx/deno-jsx.json run/config_json_import.ts\",\n  output: \"run/config_json_import.ts.out\",\n  http_server: true,\n});\n\n#[test]\nfn running_declaration_files() {\n  let context = TestContextBuilder::new().use_temp_cwd().build();\n  let temp_dir = context.temp_dir();\n  let files = vec![\"file.d.ts\", \"file.d.cts\", \"file.d.mts\"];\n\n  for file in files {\n    temp_dir.write(file, \"\");\n    context\n      .new_command()\n      .args_vec([\"run\", file])\n      .run()\n      .skip_output_check()\n      .assert_exit_code(0);\n  }\n}\n\nitest!(test_and_bench_are_noops_in_run {\n  args: \"run run/test_and_bench_in_run.js\",\n  output_str: Some(\"\"),\n});\n\n#[cfg(not(target_os = \"windows\"))]\nitest!(spawn_kill_permissions {\n  args: \"run --quiet --allow-run=cat spawn_kill_permissions.ts\",\n  output_str: Some(\"\"),\n});\n\nitest!(followup_dyn_import_resolved {\n  args: \"run --allow-read run/followup_dyn_import_resolves/main.ts\",\n  output: \"run/followup_dyn_import_resolves/main.ts.out\",\n});\n\nitest!(allow_run_allowlist_resolution {\n  args: \"run --quiet -A allow_run_allowlist_resolution.ts\",\n  output: \"allow_run_allowlist_resolution.ts.out\",\n});\n\nitest!(unhandled_rejection {\n  args: \"run --check run/unhandled_rejection.ts\",\n  output: \"run/unhandled_rejection.ts.out\",\n});\n\nitest!(unhandled_rejection_sync_error {\n  args: \"run --check run/unhandled_rejection_sync_error.ts\",\n  output: \"run/unhandled_rejection_sync_error.ts.out\",\n});\n\n// Regression test for https://github.com/denoland/deno/issues/15661\nitest!(unhandled_rejection_dynamic_import {\n  args: \"run --allow-read run/unhandled_rejection_dynamic_import/main.ts\",\n  output: \"run/unhandled_rejection_dynamic_import/main.ts.out\",\n  exit_code: 1,\n});\n\n// Regression test for https://github.com/denoland/deno/issues/16909\nitest!(unhandled_rejection_dynamic_import2 {\n  args: \"run --allow-read run/unhandled_rejection_dynamic_import2/main.ts\",\n  output: \"run/unhandled_rejection_dynamic_import2/main.ts.out\",\n});\n\nitest!(rejection_handled {\n  args: \"run --check run/rejection_handled.ts\",\n  output: \"run/rejection_handled.out\",\n});\n\nitest!(nested_error {\n  args: \"run run/nested_error/main.ts\",\n  output: \"run/nested_error/main.ts.out\",\n  exit_code: 1,\n});\n\nitest!(node_env_var_allowlist {\n  args: \"run --no-prompt run/node_env_var_allowlist.ts\",\n  output: \"run/node_env_var_allowlist.ts.out\",\n  exit_code: 1,\n});\n\n#[test]\nfn cache_test() {\n  let _g = util::http_server();\n  let deno_dir = TempDir::new();\n  let module_url =\n    url::Url::parse(\"http://localhost:4545/run/006_url_imports.ts\").unwrap();\n  let output = Command::new(util::deno_exe_path())\n    .env(\"DENO_DIR\", deno_dir.path())\n    .current_dir(util::testdata_path())\n    .arg(\"cache\")\n    .arg(\"--check=all\")\n    .arg(\"-L\")\n    .arg(\"debug\")\n    .arg(module_url.to_string())\n    .output()\n    .expect(\"Failed to spawn script\");\n  assert!(output.status.success());\n\n  let prg = util::deno_exe_path();\n  let output = Command::new(prg)\n    .env(\"DENO_DIR\", deno_dir.path())\n    .env(\"HTTP_PROXY\", \"http://nil\")\n    .env(\"NO_COLOR\", \"1\")\n    .current_dir(util::testdata_path())\n    .arg(\"run\")\n    .arg(module_url.to_string())\n    .output()\n    .expect(\"Failed to spawn script\");\n\n  let str_output = std::str::from_utf8(&output.stdout).unwrap();\n\n  let module_output_path =\n    util::testdata_path().join(\"run/006_url_imports.ts.out\");\n  let mut module_output = String::new();\n  let mut module_output_file = std::fs::File::open(module_output_path).unwrap();\n  module_output_file\n    .read_to_string(&mut module_output)\n    .unwrap();\n\n  assert_eq!(module_output, str_output);\n}\n\n#[test]\nfn cache_invalidation_test() {\n  let deno_dir = TempDir::new();\n  let fixture_path = deno_dir.path().join(\"fixture.ts\");\n  fixture_path.write(\"console.log(\\\"42\\\");\");\n  let output = Command::new(util::deno_exe_path())\n    .env(\"DENO_DIR\", deno_dir.path())\n    .current_dir(util::testdata_path())\n    .arg(\"run\")\n    .arg(&fixture_path)\n    .output()\n    .expect(\"Failed to spawn script\");\n  assert!(output.status.success());\n  let actual = std::str::from_utf8(&output.stdout).unwrap();\n  assert_eq!(actual, \"42\\n\");\n  fixture_path.write(\"console.log(\\\"43\\\");\");\n  let output = Command::new(util::deno_exe_path())\n    .env(\"DENO_DIR\", deno_dir.path())\n    .current_dir(util::testdata_path())\n    .arg(\"run\")\n    .arg(fixture_path)\n    .output()\n    .expect(\"Failed to spawn script\");\n  assert!(output.status.success());\n  let actual = std::str::from_utf8(&output.stdout).unwrap();\n  assert_eq!(actual, \"43\\n\");\n}\n\n#[test]\nfn cache_invalidation_test_no_check() {\n  let deno_dir = TempDir::new();\n  let fixture_path = deno_dir.path().join(\"fixture.ts\");\n  fixture_path.write(\"console.log(\\\"42\\\");\");\n  let output = Command::new(util::deno_exe_path())\n    .env(\"DENO_DIR\", deno_dir.path())\n    .current_dir(util::testdata_path())\n    .arg(\"run\")\n    .arg(\"--no-check\")\n    .arg(&fixture_path)\n    .output()\n    .expect(\"Failed to spawn script\");\n  assert!(output.status.success());\n  let actual = std::str::from_utf8(&output.stdout).unwrap();\n  assert_eq!(actual, \"42\\n\");\n  fixture_path.write(\"console.log(\\\"43\\\");\");\n  let output = Command::new(util::deno_exe_path())\n    .env(\"DENO_DIR\", deno_dir.path())\n    .current_dir(util::testdata_path())\n    .arg(\"run\")\n    .arg(\"--no-check\")\n    .arg(fixture_path)\n    .output()\n    .expect(\"Failed to spawn script\");\n  assert!(output.status.success());\n  let actual = std::str::from_utf8(&output.stdout).unwrap();\n  assert_eq!(actual, \"43\\n\");\n}\n\n#[test]\nfn ts_dependency_recompilation() {\n  let t = TempDir::new();\n  let ats = t.path().join(\"a.ts\");\n\n  std::fs::write(\n    &ats,\n    \"\n    import { foo } from \\\"./b.ts\\\";\n\n    function print(str: string): void {\n        console.log(str);\n    }\n\n    print(foo);\",\n  )\n  .unwrap();\n\n  let bts = t.path().join(\"b.ts\");\n  std::fs::write(\n    &bts,\n    \"\n    export const foo = \\\"foo\\\";\",\n  )\n  .unwrap();\n\n  let output = util::deno_cmd()\n    .current_dir(util::testdata_path())\n    .env(\"NO_COLOR\", \"1\")\n    .arg(\"run\")\n    .arg(\"--check\")\n    .arg(&ats)\n    .output()\n    .expect(\"failed to spawn script\");\n\n  let stdout_output = std::str::from_utf8(&output.stdout).unwrap().trim();\n  let stderr_output = std::str::from_utf8(&output.stderr).unwrap().trim();\n\n  assert!(stdout_output.ends_with(\"foo\"));\n  assert!(stderr_output.starts_with(\"Check\"));\n\n  // Overwrite contents of b.ts and run again\n  std::fs::write(\n    &bts,\n    \"\n    export const foo = 5;\",\n  )\n  .expect(\"error writing file\");\n\n  let output = util::deno_cmd()\n    .current_dir(util::testdata_path())\n    .env(\"NO_COLOR\", \"1\")\n    .arg(\"run\")\n    .arg(\"--check\")\n    .arg(&ats)\n    .output()\n    .expect(\"failed to spawn script\");\n\n  let stdout_output = std::str::from_utf8(&output.stdout).unwrap().trim();\n  let stderr_output = std::str::from_utf8(&output.stderr).unwrap().trim();\n\n  // error: TS2345 [ERROR]: Argument of type '5' is not assignable to parameter of type 'string'.\n  assert!(stderr_output.contains(\"TS2345\"));\n  assert!(!output.status.success());\n  assert!(stdout_output.is_empty());\n}\n\n#[test]\nfn basic_auth_tokens() {\n  let _g = util::http_server();\n\n  let output = util::deno_cmd()\n    .current_dir(util::root_path())\n    .arg(\"run\")\n    .arg(\"http://127.0.0.1:4554/run/001_hello.js\")\n    .piped_output()\n    .spawn()\n    .unwrap()\n    .wait_with_output()\n    .unwrap();\n\n  assert!(!output.status.success());\n\n  let stdout_str = std::str::from_utf8(&output.stdout).unwrap().trim();\n  assert!(stdout_str.is_empty());\n\n  let stderr_str = std::str::from_utf8(&output.stderr).unwrap().trim();\n  eprintln!(\"{stderr_str}\");\n\n  assert!(stderr_str\n    .contains(\"Module not found \\\"http://127.0.0.1:4554/run/001_hello.js\\\".\"));\n\n  let output = util::deno_cmd()\n    .current_dir(util::root_path())\n    .arg(\"run\")\n    .arg(\"http://127.0.0.1:4554/run/001_hello.js\")\n    .env(\"DENO_AUTH_TOKENS\", \"testuser123:testpassabc@127.0.0.1:4554\")\n    .piped_output()\n    .spawn()\n    .unwrap()\n    .wait_with_output()\n    .unwrap();\n\n  let stderr_str = std::str::from_utf8(&output.stderr).unwrap().trim();\n  eprintln!(\"{stderr_str}\");\n\n  assert!(output.status.success());\n\n  let stdout_str = std::str::from_utf8(&output.stdout).unwrap().trim();\n  assert_eq!(util::strip_ansi_codes(stdout_str), \"Hello World\");\n}\n\n#[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\nasync fn test_resolve_dns() {\n  use std::net::SocketAddr;\n  use std::str::FromStr;\n  use std::sync::Arc;\n  use std::time::Duration;\n  use tokio::net::TcpListener;\n  use tokio::net::UdpSocket;\n  use tokio::sync::oneshot;\n  use trust_dns_server::authority::Catalog;\n  use trust_dns_server::authority::ZoneType;\n  use trust_dns_server::proto::rr::Name;\n  use trust_dns_server::store::in_memory::InMemoryAuthority;\n  use trust_dns_server::ServerFuture;\n\n  const DNS_PORT: u16 = 4553;\n\n  // Setup DNS server for testing\n  async fn run_dns_server(tx: oneshot::Sender<()>) {\n    let zone_file = std::fs::read_to_string(\n      util::testdata_path().join(\"run/resolve_dns.zone.in\"),\n    )\n    .unwrap();\n    let lexer = Lexer::new(&zone_file);\n    let records = Parser::new().parse(\n      lexer,\n      Some(Name::from_str(\"example.com\").unwrap()),\n      None,\n    );\n    if records.is_err() {\n      panic!(\"failed to parse: {:?}\", records.err())\n    }\n    let (origin, records) = records.unwrap();\n    let authority = Box::new(Arc::new(\n      InMemoryAuthority::new(origin, records, ZoneType::Primary, false)\n        .unwrap(),\n    ));\n    let mut catalog: Catalog = Catalog::new();\n    catalog.upsert(Name::root().into(), authority);\n\n    let mut server_fut = ServerFuture::new(catalog);\n    let socket_addr = SocketAddr::from(([127, 0, 0, 1], DNS_PORT));\n    let tcp_listener = TcpListener::bind(socket_addr).await.unwrap();\n    let udp_socket = UdpSocket::bind(socket_addr).await.unwrap();\n    server_fut.register_socket(udp_socket);\n    server_fut.register_listener(tcp_listener, Duration::from_secs(2));\n\n    // Notifies that the DNS server is ready\n    tx.send(()).unwrap();\n\n    server_fut.block_until_done().await.unwrap();\n  }\n\n  let (ready_tx, ready_rx) = oneshot::channel();\n  let dns_server_fut = run_dns_server(ready_tx);\n  let handle = tokio::spawn(dns_server_fut);\n\n  // Waits for the DNS server to be ready\n  ready_rx.await.unwrap();\n\n  // Pass: `--allow-net`\n  {\n    let output = util::deno_cmd()\n      .current_dir(util::testdata_path())\n      .env(\"NO_COLOR\", \"1\")\n      .arg(\"run\")\n      .arg(\"--check\")\n      .arg(\"--allow-net\")\n      .arg(\"run/resolve_dns.ts\")\n      .piped_output()\n      .spawn()\n      .unwrap()\n      .wait_with_output()\n      .unwrap();\n    let err = String::from_utf8_lossy(&output.stderr);\n    let out = String::from_utf8_lossy(&output.stdout);\n    println!(\"{err}\");\n    assert!(output.status.success());\n    assert!(err.starts_with(\"Check file\"));\n\n    let expected = std::fs::read_to_string(\n      util::testdata_path().join(\"run/resolve_dns.ts.out\"),\n    )\n    .unwrap();\n    assert_eq!(expected, out);\n  }\n\n  // Pass: `--allow-net=127.0.0.1:4553`\n  {\n    let output = util::deno_cmd()\n      .current_dir(util::testdata_path())\n      .env(\"NO_COLOR\", \"1\")\n      .arg(\"run\")\n      .arg(\"--check\")\n      .arg(\"--allow-net=127.0.0.1:4553\")\n      .arg(\"run/resolve_dns.ts\")\n      .piped_output()\n      .spawn()\n      .unwrap()\n      .wait_with_output()\n      .unwrap();\n    let err = String::from_utf8_lossy(&output.stderr);\n    let out = String::from_utf8_lossy(&output.stdout);\n    if !output.status.success() {\n      eprintln!(\"stderr: {err}\");\n    }\n    assert!(output.status.success());\n    assert!(err.starts_with(\"Check file\"));\n\n    let expected = std::fs::read_to_string(\n      util::testdata_path().join(\"run/resolve_dns.ts.out\"),\n    )\n    .unwrap();\n    assert_eq!(expected, out);\n  }\n\n  // Permission error: `--allow-net=deno.land`\n  {\n    let output = util::deno_cmd()\n      .current_dir(util::testdata_path())\n      .env(\"NO_COLOR\", \"1\")\n      .arg(\"run\")\n      .arg(\"--check\")\n      .arg(\"--allow-net=deno.land\")\n      .arg(\"run/resolve_dns.ts\")\n      .piped_output()\n      .spawn()\n      .unwrap()\n      .wait_with_output()\n      .unwrap();\n    let err = String::from_utf8_lossy(&output.stderr);\n    let out = String::from_utf8_lossy(&output.stdout);\n    assert!(!output.status.success());\n    assert!(err.starts_with(\"Check file\"));\n    assert!(err.contains(r#\"error: Uncaught (in promise) PermissionDenied: Requires net access to \"127.0.0.1:4553\"\"#));\n    assert!(out.is_empty());\n  }\n\n  // Permission error: no permission specified\n  {\n    let output = util::deno_cmd()\n      .current_dir(util::testdata_path())\n      .env(\"NO_COLOR\", \"1\")\n      .arg(\"run\")\n      .arg(\"--check\")\n      .arg(\"run/resolve_dns.ts\")\n      .piped_output()\n      .spawn()\n      .unwrap()\n      .wait_with_output()\n      .unwrap();\n    let err = String::from_utf8_lossy(&output.stderr);\n    let out = String::from_utf8_lossy(&output.stdout);\n    assert!(!output.status.success());\n    assert!(err.starts_with(\"Check file\"));\n    assert!(err.contains(r#\"error: Uncaught (in promise) PermissionDenied: Requires net access to \"127.0.0.1:4553\"\"#));\n    assert!(out.is_empty());\n  }\n\n  handle.abort();\n}\n\n#[tokio::test]\nasync fn http2_request_url() {\n  let mut child = util::deno_cmd()\n    .current_dir(util::testdata_path())\n    .arg(\"run\")\n    .arg(\"--unstable\")\n    .arg(\"--quiet\")\n    .arg(\"--allow-net\")\n    .arg(\"--allow-read\")\n    .arg(\"./run/http2_request_url.ts\")\n    .arg(\"4506\")\n    .stdout_piped()\n    .spawn()\n    .unwrap();\n  let stdout = child.stdout.as_mut().unwrap();\n  let mut buffer = [0; 5];\n  let read = stdout.read(&mut buffer).unwrap();\n  assert_eq!(read, 5);\n  let msg = std::str::from_utf8(&buffer).unwrap();\n  assert_eq!(msg, \"READY\");\n\n  let cert = reqwest::Certificate::from_pem(include_bytes!(\n    \"../testdata/tls/RootCA.crt\"\n  ))\n  .unwrap();\n\n  let client = reqwest::Client::builder()\n    .add_root_certificate(cert)\n    .http2_prior_knowledge()\n    .build()\n    .unwrap();\n\n  let res = client.get(\"http://127.0.0.1:4506\").send().await.unwrap();\n  assert_eq!(200, res.status());\n\n  let body = res.text().await.unwrap();\n  assert_eq!(body, \"http://127.0.0.1:4506/\");\n\n  child.kill().unwrap();\n  child.wait().unwrap();\n}\n\n#[cfg(not(windows))]\n#[test]\nfn set_raw_should_not_panic_on_no_tty() {\n  let output = util::deno_cmd()\n    .arg(\"eval\")\n    .arg(\"Deno.stdin.setRaw(true)\")\n    // stdin set to piped so it certainly does not refer to TTY\n    .stdin(std::process::Stdio::piped())\n    // stderr is piped so we can capture output.\n    .stderr_piped()\n    .spawn()\n    .unwrap()\n    .wait_with_output()\n    .unwrap();\n  assert!(!output.status.success());\n  let stderr = std::str::from_utf8(&output.stderr).unwrap().trim();\n  assert!(stderr.contains(\"BadResource\"));\n}\n\n#[cfg(not(windows))]\n#[test]\nfn fsfile_set_raw_should_not_panic_on_no_tty() {\n  let output = util::deno_cmd()\n    .arg(\"eval\")\n    .arg(\"Deno.openSync(\\\"/dev/stdin\\\").setRaw(true)\")\n    // stdin set to piped so it certainly does not refer to TTY\n    .stdin(std::process::Stdio::piped())\n    // stderr is piped so we can capture output.\n    .stderr_piped()\n    .spawn()\n    .unwrap()\n    .wait_with_output()\n    .unwrap();\n  assert!(!output.status.success());\n  let stderr = std::str::from_utf8(&output.stderr).unwrap().trim();\n  assert!(stderr.contains(\"BadResource\"));\n}\n\n#[test]\nfn timeout_clear() {\n  // https://github.com/denoland/deno/issues/7599\n\n  use std::time::Duration;\n  use std::time::Instant;\n\n  let source_code = r#\"\nconst handle = setTimeout(() => {\n  console.log(\"timeout finish\");\n}, 10000);\nclearTimeout(handle);\nconsole.log(\"finish\");\n\"#;\n\n  let mut p = util::deno_cmd()\n    .current_dir(util::testdata_path())\n    .arg(\"run\")\n    .arg(\"-\")\n    .stdin(std::process::Stdio::piped())\n    .spawn()\n    .unwrap();\n  let stdin = p.stdin.as_mut().unwrap();\n  stdin.write_all(source_code.as_bytes()).unwrap();\n  let start = Instant::now();\n  let status = p.wait().unwrap();\n  let end = Instant::now();\n  assert!(status.success());\n  // check that program did not run for 10 seconds\n  // for timeout to clear\n  assert!(end - start < Duration::new(10, 0));\n}\n\n#[test]\nfn broken_stdout() {\n  let (reader, writer) = os_pipe::pipe().unwrap();\n  // drop the reader to create a broken pipe\n  drop(reader);\n\n  let output = util::deno_cmd()\n    .current_dir(util::testdata_path())\n    .arg(\"eval\")\n    .arg(\"console.log(3.14)\")\n    .stdout(writer)\n    .stderr_piped()\n    .spawn()\n    .unwrap()\n    .wait_with_output()\n    .unwrap();\n\n  assert!(!output.status.success());\n  let stderr = std::str::from_utf8(output.stderr.as_ref()).unwrap().trim();\n  assert!(stderr.contains(\"Uncaught (in promise) BrokenPipe\"));\n  assert!(!stderr.contains(\"panic\"));\n}\n\nitest!(error_cause {\n  args: \"run run/error_cause.ts\",\n  output: \"run/error_cause.ts.out\",\n  exit_code: 1,\n});\n\nitest!(error_cause_recursive_aggregate {\n  args: \"run error_cause_recursive_aggregate.ts\",\n  output: \"error_cause_recursive_aggregate.ts.out\",\n  exit_code: 1,\n});\n\nitest!(error_cause_recursive_tail {\n  args: \"run error_cause_recursive_tail.ts\",\n  output: \"error_cause_recursive_tail.ts.out\",\n  exit_code: 1,\n});\n\nitest!(error_cause_recursive {\n  args: \"run run/error_cause_recursive.ts\",\n  output: \"run/error_cause_recursive.ts.out\",\n  exit_code: 1,\n});\n\nitest!(default_file_extension_is_js {\n  args: \"run --check file_extensions/js_without_extension\",\n  output: \"file_extensions/js_without_extension.out\",\n  exit_code: 0,\n});\n\nitest!(js_without_extension {\n  args: \"run --ext js --check file_extensions/js_without_extension\",\n  output: \"file_extensions/js_without_extension.out\",\n  exit_code: 0,\n});\n\nitest!(ts_without_extension {\n  args: \"run --ext ts --check file_extensions/ts_without_extension\",\n  output: \"file_extensions/ts_without_extension.out\",\n  exit_code: 0,\n});\n\nitest!(ext_flag_takes_precedence_over_extension {\n  args: \"run --ext ts --check file_extensions/ts_with_js_extension.js\",\n  output: \"file_extensions/ts_with_js_extension.out\",\n  exit_code: 0,\n});\n\n#[tokio::test(flavor = \"multi_thread\")]\nasync fn websocketstream_ping() {\n  let _g = util::http_server();\n\n  let script = util::testdata_path().join(\"run/websocketstream_ping_test.ts\");\n  let root_ca = util::testdata_path().join(\"tls/RootCA.pem\");\n\n  let srv_fn = hyper::service::service_fn(|mut req| async move {\n    let (response, upgrade_fut) =\n      fastwebsockets::upgrade::upgrade(&mut req).unwrap();\n    tokio::spawn(async move {\n      let mut ws = upgrade_fut.await.unwrap();\n\n      ws.write_frame(fastwebsockets::Frame::text(b\"A\"[..].into()))\n        .await\n        .unwrap();\n      ws.write_frame(fastwebsockets::Frame::new(\n        true,\n        fastwebsockets::OpCode::Ping,\n        None,\n        vec![].into(),\n      ))\n      .await\n      .unwrap();\n      ws.write_frame(fastwebsockets::Frame::text(b\"B\"[..].into()))\n        .await\n        .unwrap();\n      let message = ws.read_frame().await.unwrap();\n      assert_eq!(message.opcode, fastwebsockets::OpCode::Pong);\n      ws.write_frame(fastwebsockets::Frame::text(b\"C\"[..].into()))\n        .await\n        .unwrap();\n      ws.write_frame(fastwebsockets::Frame::close_raw(vec![].into()))\n        .await\n        .unwrap();\n    });\n    Ok::<_, std::convert::Infallible>(response)\n  });\n\n  let child = util::deno_cmd()\n    .arg(\"test\")\n    .arg(\"--unstable\")\n    .arg(\"--allow-net\")\n    .arg(\"--cert\")\n    .arg(root_ca)\n    .arg(script)\n    .stdout_piped()\n    .spawn()\n    .unwrap();\n  let server = tokio::net::TcpListener::bind(\"127.0.0.1:4513\")\n    .await\n    .unwrap();\n  tokio::spawn(async move {\n    let (stream, _) = server.accept().await.unwrap();\n    let io = hyper_util::rt::TokioIo::new(stream);\n    let conn_fut = hyper::server::conn::http1::Builder::new()\n      .serve_connection(io, srv_fn)\n      .with_upgrades();\n\n    if let Err(e) = conn_fut.await {\n      eprintln!(\"websocket server error: {e:?}\");\n    }\n  });\n\n  let r = child.wait_with_output().unwrap();\n  assert!(r.status.success());\n}\n\nstruct SpawnExecutor;\n\nimpl<Fut> hyper::rt::Executor<Fut> for SpawnExecutor\nwhere\n  Fut: std::future::Future + Send + 'static,\n  Fut::Output: Send + 'static,\n{\n  fn execute(&self, fut: Fut) {\n    deno_core::unsync::spawn(fut);\n  }\n}\n\n#[tokio::test]\nasync fn websocket_server_multi_field_connection_header() {\n  let script = util::testdata_path()\n    .join(\"run/websocket_server_multi_field_connection_header_test.ts\");\n  let root_ca = util::testdata_path().join(\"tls/RootCA.pem\");\n  let mut child = util::deno_cmd()\n    .arg(\"run\")\n    .arg(\"--unstable\")\n    .arg(\"--allow-net\")\n    .arg(\"--cert\")\n    .arg(root_ca)\n    .arg(script)\n    .stdout_piped()\n    .spawn()\n    .unwrap();\n\n  let stdout = child.stdout.as_mut().unwrap();\n  let mut buffer = [0; 5];\n  let read = stdout.read(&mut buffer).unwrap();\n  assert_eq!(read, 5);\n  let msg = std::str::from_utf8(&buffer).unwrap();\n  assert_eq!(msg, \"READY\");\n\n  let stream = tokio::net::TcpStream::connect(\"localhost:4319\")\n    .await\n    .unwrap();\n  let req = http::Request::builder()\n    .header(http::header::UPGRADE, \"websocket\")\n    .header(http::header::CONNECTION, \"keep-alive, Upgrade\")\n    .header(\n      \"Sec-WebSocket-Key\",\n      fastwebsockets::handshake::generate_key(),\n    )\n    .header(\"Sec-WebSocket-Version\", \"13\")\n    .uri(\"ws://localhost:4319\")\n    .body(http_body_util::Empty::<Bytes>::new())\n    .unwrap();\n\n  let (mut socket, _) =\n    fastwebsockets::handshake::client(&SpawnExecutor, req, stream)\n      .await\n      .unwrap();\n\n  let message = socket.read_frame().await.unwrap();\n  assert_eq!(message.opcode, fastwebsockets::OpCode::Close);\n  assert!(message.payload.is_empty());\n  socket\n    .write_frame(fastwebsockets::Frame::close_raw(vec![].into()))\n    .await\n    .unwrap();\n  assert!(child.wait().unwrap().success());\n}\n\n// TODO(bartlomieju): this should use `deno run`, not `deno test`; but the\n// test hangs then. https://github.com/denoland/deno/issues/14283\n#[tokio::test]\nasync fn websocket_server_idletimeout() {\n  let script =\n    util::testdata_path().join(\"run/websocket_server_idletimeout.ts\");\n  let root_ca = util::testdata_path().join(\"tls/RootCA.pem\");\n  let mut child = util::deno_cmd()\n    .arg(\"test\")\n    .arg(\"--unstable\")\n    .arg(\"--allow-net\")\n    .arg(\"--cert\")\n    .arg(root_ca)\n    .arg(script)\n    .stdout_piped()\n    .spawn()\n    .unwrap();\n\n  let stdout = child.stdout.as_mut().unwrap();\n  let mut buffer = [0; 5];\n  let read = stdout.read(&mut buffer).unwrap();\n  assert_eq!(read, 5);\n  let msg = std::str::from_utf8(&buffer).unwrap();\n  assert_eq!(msg, \"READY\");\n\n  let stream = tokio::net::TcpStream::connect(\"localhost:4509\")\n    .await\n    .unwrap();\n  let req = http::Request::builder()\n    .header(http::header::UPGRADE, \"websocket\")\n    .header(http::header::CONNECTION, \"keep-alive, Upgrade\")\n    .header(\n      \"Sec-WebSocket-Key\",\n      fastwebsockets::handshake::generate_key(),\n    )\n    .header(\"Sec-WebSocket-Version\", \"13\")\n    .uri(\"ws://localhost:4509\")\n    .body(http_body_util::Empty::<Bytes>::new())\n    .unwrap();\n\n  let (_socket, _) =\n    fastwebsockets::handshake::client(&SpawnExecutor, req, stream)\n      .await\n      .unwrap();\n\n  assert!(child.wait().unwrap().success());\n}\n\nitest!(auto_discover_lockfile {\n  args: \"run run/auto_discover_lockfile/main.ts\",\n  output: \"run/auto_discover_lockfile/main.out\",\n  http_server: true,\n  exit_code: 10,\n});\n\nitest!(no_lock_flag {\n  args: \"run --no-lock run/no_lock_flag/main.ts\",\n  output: \"run/no_lock_flag/main.out\",\n  http_server: true,\n  exit_code: 0,\n});\n\nitest!(config_file_lock_false {\n  args: \"run --config=run/config_file_lock_boolean/false.json run/config_file_lock_boolean/main.ts\",\n  output: \"run/config_file_lock_boolean/false.main.out\",\n  http_server: true,\n  exit_code: 0,\n});\n\nitest!(config_file_lock_true {\n  args: \"run --config=run/config_file_lock_boolean/true.json run/config_file_lock_boolean/main.ts\",\n  output: \"run/config_file_lock_boolean/true.main.out\",\n  http_server: true,\n  exit_code: 10,\n});\n\nitest!(permission_args {\n  args: \"run run/001_hello.js --allow-net\",\n  output: \"run/permission_args.out\",\n  envs: vec![(\"NO_COLOR\".to_string(), \"1\".to_string())],\n});\n\nitest!(permission_args_quiet {\n  args: \"run --quiet run/001_hello.js --allow-net\",\n  output: \"run/001_hello.js.out\",\n});\n\n// Regression test for https://github.com/denoland/deno/issues/16772\n#[test]\nfn file_fetcher_preserves_permissions() {\n  let context = TestContext::with_http_server();\n  context\n    .new_command()\n    .args(\"repl --quiet\")\n    .with_pty(|mut console| {\n      console.write_line(\n      \"const a = await import('http://localhost:4545/run/019_media_types.ts');\",\n    );\n      console.expect(\"Allow?\");\n      console.write_line_raw(\"y\");\n      console.expect_all(&[\"success\", \"true\"]);\n    });\n}\n\n#[test]\nfn stdio_streams_are_locked_in_permission_prompt() {\n  if !util::pty::Pty::is_supported() {\n    // Don't deal with the logic below if the with_pty\n    // block doesn't even run (ex. on Windows CI)\n    return;\n  }\n\n  let context = TestContextBuilder::new()\n    .use_http_server()\n    .use_copy_temp_dir(\"run/stdio_streams_are_locked_in_permission_prompt\")\n    .build();\n  let mut passed_test = false;\n  let mut i = 0;\n  while !passed_test {\n    i += 1;\n    if i > 5 {\n      panic!(\"Output happened before permission prompt too many times\");\n    }\n\n    context\n      .new_command()\n      .args(\"repl --allow-read\")\n      .with_pty(|mut console| {\n        let malicious_output = r#\"Are you sure you want to continue?\"#;\n\n        console.write_line(r#\"const url = \"file://\" + Deno.cwd().replace(\"\\\\\", \"/\") + \"/run/stdio_streams_are_locked_in_permission_prompt/worker.js\";\"#);\n        console.expect(\"undefined\");\n        // ensure this file exists\n        console.write_line(r#\"const _file = Deno.readTextFileSync(\"./run/stdio_streams_are_locked_in_permission_prompt/worker.js\");\"#);\n        console.expect(\"undefined\");\n        console.write_line(r#\"new Worker(url, { type: \"module\" }); await Deno.writeTextFile(\"./text.txt\", \"some code\");\"#);\n        console.expect(\"Allow? [y/n/A] (y = yes, allow; n = no, deny; A = allow all write permissions)\");\n\n        // Due to the main thread being slow, it may occur that the worker thread outputs\n        // before the permission prompt is shown. This is not a bug and just a timing issue\n        // when dealing with multiple threads. If this occurs, detect such a case and then\n        // retry running the test.\n        if let Some(malicious_index) = console.all_output().find(malicious_output) {\n          let prompt_index = console.all_output().find(\"Allow?\").unwrap();\n          // Ensure the malicious output is shown before the prompt as we\n          // expect in this scenario. If not, that would indicate a bug.\n          assert!(malicious_index < prompt_index);\n          return;\n        }\n\n        std::thread::sleep(Duration::from_millis(50)); // give the other thread some time to output\n        console.write_line_raw(\"invalid\");\n        console.expect(\"Unrecognized option.\");\n        console.expect(\"Allow? [y/n/A] (y = yes, allow; n = no, deny; A = allow all write permissions)\");\n        console.write_line_raw(\"y\");\n        console.expect(\"Granted write access to\");\n\n        // this output should now be shown below and not above\n        console.expect(malicious_output);\n        passed_test = true;\n      });\n  }\n}\n\n#[test]\nfn permission_prompt_strips_ansi_codes_and_control_chars() {\n  util::with_pty(&[\"repl\"], |mut console| {\n    console.write_line(\n        r#\"Deno.permissions.request({ name: \"env\", variable: \"\\rDo you like ice cream? y/n\" });\"#\n      );\n    // will be uppercase on windows\n    let env_name = if cfg!(windows) {\n      \"DO YOU LIKE ICE CREAM? Y/N\"\n    } else {\n      \"Do you like ice cream? y/n\"\n    };\n    console.expect(format!(\n      \"   Deno requests env access to \\\"{}\\\".\",\n      env_name\n    ))\n  });\n\n  util::with_pty(&[\"repl\"], |mut console| {\n    console.write_line_raw(r#\"const boldANSI = \"\\u001b[1m\";\"#);\n    console.expect(\"undefined\");\n    console.write_line_raw(r#\"const unboldANSI = \"\\u001b[22m\";\"#);\n    console.expect(\"undefined\");\n    console.write_line_raw(r#\"const prompt = `   ${boldANSI}Deno requests run access to \"echo\"${unboldANSI}\\n  Requested by \\`Deno.Command().output()`\"#);\n    console.expect(\"undefined\");\n    console.write_line_raw(r#\"const moveANSIUp = \"\\u001b[1A\";\"#);\n    console.expect(\"undefined\");\n    console.write_line_raw(r#\"const clearANSI = \"\\u001b[2K\";\"#);\n    console.expect(\"undefined\");\n    console.write_line_raw(r#\"const moveANSIStart = \"\\u001b[1000D\";\"#);\n    console.expect(\"undefined\");\n  });\n}\n\nitest!(node_builtin_modules_ts {\n  args: \"run --quiet --allow-read run/node_builtin_modules/mod.ts hello there\",\n  output: \"run/node_builtin_modules/mod.ts.out\",\n  envs: env_vars_for_npm_tests(),\n  exit_code: 0,\n});\n\nitest!(node_builtin_modules_js {\n  args: \"run --quiet --allow-read run/node_builtin_modules/mod.js hello there\",\n  output: \"run/node_builtin_modules/mod.js.out\",\n  envs: env_vars_for_npm_tests(),\n  exit_code: 0,\n});\n\nitest!(node_prefix_missing {\n  args: \"run --quiet run/node_prefix_missing/main.ts\",\n  output: \"run/node_prefix_missing/main.ts.out\",\n  envs: env_vars_for_npm_tests(),\n  exit_code: 1,\n});\n\nitest!(node_prefix_missing_unstable_bare_node_builtins_enbaled {\n  args: \"run --unstable-bare-node-builtins run/node_prefix_missing/main.ts\",\n  output: \"run/node_prefix_missing/main.ts.out_feature_enabled\",\n  envs: env_vars_for_npm_tests(),\n  exit_code: 0,\n});\n\nitest!(\n  node_prefix_missing_unstable_bare_node_builtins_enbaled_by_env {\n    args: \"run run/node_prefix_missing/main.ts\",\n    output: \"run/node_prefix_missing/main.ts.out_feature_enabled\",\n    envs: [\n      env_vars_for_npm_tests(),\n      vec![(\n        \"DENO_UNSTABLE_BARE_NODE_BUILTINS\".to_string(),\n        \"1\".to_string()\n      )]\n    ]\n    .concat(),\n    exit_code: 0,\n  }\n);\n\nitest!(node_prefix_missing_unstable_bare_node_builtins_enbaled_by_config {\n  args: \"run --config=run/node_prefix_missing/config.json run/node_prefix_missing/main.ts\",\n  output: \"run/node_prefix_missing/main.ts.out_feature_enabled\",\n  envs: env_vars_for_npm_tests(),\n  exit_code: 0,\n});\n\nitest!(node_prefix_missing_unstable_bare_node_builtins_enbaled_with_import_map {\n  args: \"run --unstable-bare-node-builtins --import-map run/node_prefix_missing/import_map.json run/node_prefix_missing/main.ts\",\n  output: \"run/node_prefix_missing/main.ts.out_feature_enabled\",\n  envs: env_vars_for_npm_tests(),\n  exit_code: 0,\n});\n\nitest!(dynamic_import_syntax_error {\n  args: \"run -A run/dynamic_import_syntax_error.js\",\n  output: \"run/dynamic_import_syntax_error.js.out\",\n  exit_code: 1,\n});\n\nitest!(extension_import {\n  args: \"run run/extension_import.ts\",\n  output: \"run/extension_import.ts.out\",\n  exit_code: 1,\n});\n\nitest!(extension_dynamic_import {\n  args: \"run run/extension_dynamic_import.ts\",\n  output: \"run/extension_dynamic_import.ts.out\",\n  exit_code: 1,\n});\n\n#[test]\npub fn vendor_dir_config_file() {\n  let test_context = TestContextBuilder::new()\n    .use_http_server()\n    .use_temp_cwd()\n    .build();\n  let temp_dir = test_context.temp_dir();\n  let vendor_dir = temp_dir.path().join(\"vendor\");\n  let rm_vendor_dir = || std::fs::remove_dir_all(&vendor_dir).unwrap();\n\n  temp_dir.write(\"deno.json\", r#\"{ \"vendor\": true }\"#);\n  temp_dir.write(\n    \"main.ts\",\n    r#\"import { returnsHi } from 'http://localhost:4545/subdir/mod1.ts';\nconsole.log(returnsHi());\"#,\n  );\n\n  let deno_run_cmd = test_context.new_command().args(\"run --quiet main.ts\");\n  deno_run_cmd.run().assert_matches_text(\"Hi\\n\");\n\n  assert!(vendor_dir.exists());\n  rm_vendor_dir();\n  temp_dir.write(\"deno.json\", r#\"{ \"vendor\": false }\"#);\n\n  deno_run_cmd.run().assert_matches_text(\"Hi\\n\");\n  assert!(!vendor_dir.exists());\n  test_context\n    .new_command()\n    .args(\"cache --quiet --vendor main.ts\")\n    .run();\n  assert!(vendor_dir.exists());\n  rm_vendor_dir();\n\n  temp_dir.write(\"deno.json\", r#\"{ \"vendor\": true }\"#);\n  let cache_command = test_context.new_command().args(\"cache --quiet main.ts\");\n  cache_command.run();\n\n  assert!(vendor_dir.exists());\n  let mod1_file = vendor_dir\n    .join(\"http_localhost_4545\")\n    .join(\"subdir\")\n    .join(\"mod1.ts\");\n  mod1_file.write(\"export function returnsHi() { return 'bye bye bye'; }\");\n\n  // won't match the lockfile now\n  deno_run_cmd\n    .run()\n    .assert_matches_text(r#\"error: The source code is invalid, as it does not match the expected hash in the lock file.\n  Specifier: http://localhost:4545/subdir/mod1.ts\n  Lock file: [WILDCARD]deno.lock\n\"#)\n    .assert_exit_code(10);\n\n  // try updating by deleting the lockfile\n  let lockfile = temp_dir.path().join(\"deno.lock\");\n  lockfile.remove_file();\n  cache_command.run();\n\n  // now it should run\n  deno_run_cmd.run().assert_matches_text(\"bye bye bye\\n\");\n  assert!(lockfile.exists());\n\n  // ensure we can add and execute files in directories that have a hash in them\n  test_context\n    .new_command()\n    // http_localhost_4545/subdir/#capitals_c75d7/main.js\n    .args(\"cache http://localhost:4545/subdir/CAPITALS/main.js\")\n    .run()\n    .skip_output_check();\n  assert_eq!(\n    vendor_dir.join(\"manifest.json\").read_json_value(),\n    json!({\n      \"folders\": {\n        \"http://localhost:4545/subdir/CAPITALS/\": \"http_localhost_4545/subdir/#capitals_c75d7\"\n      }\n    })\n  );\n  vendor_dir\n    .join(\"http_localhost_4545/subdir/#capitals_c75d7/hello_there.ts\")\n    .write(\"console.log('hello there');\");\n  test_context\n    .new_command()\n    // todo(dsherret): seems wrong that we don't auto-discover the config file to get the vendor directory for this\n    .args(\"run --vendor http://localhost:4545/subdir/CAPITALS/hello_there.ts\")\n    .run()\n    .assert_matches_text(\"hello there\\n\");\n\n  // now try importing directly from the vendor folder\n  temp_dir.write(\n    \"main.ts\",\n    r#\"import { returnsHi } from './vendor/http_localhost_4545/subdir/mod1.ts';\nconsole.log(returnsHi());\"#,\n  );\n  deno_run_cmd\n    .run()\n    .assert_matches_text(\"error: Importing from the vendor directory is not permitted. Use a remote specifier instead or disable vendoring.\n    at [WILDCARD]/main.ts:1:27\n\")\n    .assert_exit_code(1);\n}\n\nitest!(explicit_resource_management {\n  args: \"run --quiet --check run/explicit_resource_management/main.ts\",\n  output: \"run/explicit_resource_management/main.out\",\n});\n\nitest!(workspaces_basic {\n  args: \"run -L debug -A main.ts\",\n  output: \"run/workspaces/basic/main.out\",\n  cwd: Some(\"run/workspaces/basic/\"),\n  copy_temp_dir: Some(\"run/workspaces/basic/\"),\n  envs: env_vars_for_npm_tests(),\n  http_server: true,\n});\n\nitest!(workspaces_member_outside_root_dir {\n  args: \"run -A main.ts\",\n  output: \"run/workspaces/member_outside_root_dir/main.out\",\n  cwd: Some(\"run/workspaces/member_outside_root_dir/\"),\n  copy_temp_dir: Some(\"run/workspaces/member_outside_root_dir/\"),\n  envs: env_vars_for_npm_tests(),\n  http_server: true,\n  exit_code: 1,\n});\n\nitest!(workspaces_nested_member {\n  args: \"run -A main.ts\",\n  output: \"run/workspaces/nested_member/main.out\",\n  cwd: Some(\"run/workspaces/nested_member/\"),\n  copy_temp_dir: Some(\"run/workspaces/nested_member/\"),\n  envs: env_vars_for_npm_tests(),\n  http_server: true,\n  exit_code: 1,\n});\n\nitest!(unsafe_proto {\n  args: \"run -A run/unsafe_proto/main.js\",\n  output: \"run/unsafe_proto/main.out\",\n  http_server: false,\n  exit_code: 0,\n});\n\nitest!(unsafe_proto_flag {\n  args: \"run -A --unstable-unsafe-proto run/unsafe_proto/main.js\",\n  output: \"run/unsafe_proto/main_with_unsafe_proto_flag.out\",\n  http_server: false,\n  exit_code: 0,\n});\n\n#[test]\nfn test_unstable_sloppy_imports() {\n  let context = TestContextBuilder::new().use_temp_cwd().build();\n  let temp_dir = context.temp_dir();\n  temp_dir.write(\"a.ts\", \"export class A {}\");\n  temp_dir.write(\"b.js\", \"export class B {}\");\n  temp_dir.write(\"c.mts\", \"export class C {}\");\n  temp_dir.write(\"d.mjs\", \"export class D {}\");\n  temp_dir.write(\"e.tsx\", \"export class E {}\");\n  temp_dir.write(\"f.jsx\", \"export class F {}\");\n  let dir = temp_dir.path().join(\"dir\");\n  dir.create_dir_all();\n  dir.join(\"index.tsx\").write(\"export class G {}\");\n  temp_dir.write(\n    \"main.ts\",\n    r#\"import * as a from \"./a.js\";\nimport * as b from \"./b\";\nimport * as c from \"./c\";\nimport * as d from \"./d\";\nimport * as e from \"./e\";\nimport * as e2 from \"./e.js\";\nimport * as f from \"./f\";\nimport * as g from \"./dir\";\nconsole.log(a.A);\nconsole.log(b.B);\nconsole.log(c.C);\nconsole.log(d.D);\nconsole.log(e.E);\nconsole.log(e2.E);\nconsole.log(f.F);\nconsole.log(g.G);\n\"#,\n  );\n\n  // run without sloppy imports\n  context\n    .new_command()\n    .args(\"run main.ts\")\n    .run()\n    .assert_matches_text(r#\"error: Module not found \"file:///[WILDCARD]/a.js\". Maybe change the extension to '.ts' or run with --unstable-sloppy-imports\n    at file:///[WILDCARD]/main.ts:1:20\n\"#)\n    .assert_exit_code(1);\n\n  // now run with sloppy imports\n  temp_dir.write(\"deno.json\", r#\"{ \"unstable\": [\"sloppy-imports\"] }\"#);\n  context\n    .new_command()\n    .args(\"run main.ts\")\n    .run()\n    .assert_matches_text(\n      \"Warning Sloppy imports are not recommended and have a negative impact on performance.\nWarning Sloppy module resolution (hint: update .js extension to .ts)\n    at file:///[WILDCARD]/main.ts:1:20\nWarning Sloppy module resolution (hint: add .js extension)\n    at file:///[WILDCARD]/main.ts:2:20\nWarning Sloppy module resolution (hint: add .mts extension)\n    at file:///[WILDCARD]/main.ts:3:20\nWarning Sloppy module resolution (hint: add .mjs extension)\n    at file:///[WILDCARD]/main.ts:4:20\nWarning Sloppy module resolution (hint: add .tsx extension)\n    at file:///[WILDCARD]/main.ts:5:20\nWarning Sloppy module resolution (hint: update .js extension to .tsx)\n    at file:///[WILDCARD]/main.ts:6:21\nWarning Sloppy module resolution (hint: add .jsx extension)\n    at file:///[WILDCARD]/main.ts:7:20\nWarning Sloppy module resolution (hint: specify path to index.tsx file in directory instead)\n    at file:///[WILDCARD]/main.ts:8:20\n[class A]\n[class B]\n[class C]\n[class D]\n[class E]\n[class E]\n[class F]\n[class G]\n\",\n    );\n}\n\nitest!(unstable_temporal_api {\n  args: \"run --unstable-temporal --check run/unstable_temporal_api/main.ts\",\n  output: \"run/unstable_temporal_api/main.out\",\n  http_server: false,\n  exit_code: 0,\n});\n\nitest!(unstable_temporal_api_missing_flag {\n  args: \"run run/unstable_temporal_api/missing_flag.js\",\n  output: \"run/unstable_temporal_api/missing_flag.out\",\n  http_server: false,\n  exit_code: 1,\n});\n\n// TODO(bartlomieju): temporary disabled\n// itest!(warn_on_deprecated_api {\n//   args: \"run -A run/warn_on_deprecated_api/main.js\",\n//   output: \"run/warn_on_deprecated_api/main.out\",\n//   http_server: true,\n//   exit_code: 0,\n// });\n\n// itest!(warn_on_deprecated_api_verbose {\n//   args: \"run -A run/warn_on_deprecated_api/main.js\",\n//   output: \"run/warn_on_deprecated_api/main.verbose.out\",\n//   envs: vec![(\"DENO_VERBOSE_WARNINGS\".to_string(), \"1\".to_string())],\n//   http_server: true,\n//   exit_code: 0,\n// });\n\n// itest!(warn_on_deprecated_api_with_flag {\n//   args: \"run -A --quiet run/warn_on_deprecated_api/main.js\",\n//   output: \"run/warn_on_deprecated_api/main_disabled_flag.out\",\n//   http_server: true,\n//   exit_code: 0,\n// });\n\n// itest!(warn_on_deprecated_api_with_env_var {\n//   args: \"run -A run/warn_on_deprecated_api/main.js\",\n//   envs: vec![(\"DENO_NO_DEPRECATION_WARNINGS\".to_string(), \"1\".to_string())],\n//   output: \"run/warn_on_deprecated_api/main_disabled_env.out\",\n//   http_server: true,\n//   exit_code: 0,\n// });\n\n#[test]\nfn deno_json_imports_expand() {\n  let test_context = TestContextBuilder::for_npm().use_temp_cwd().build();\n  let dir = test_context.temp_dir();\n  dir.write(\n    \"deno.json\",\n    r#\"{\n    \"imports\": {\n      \"basic\": \"npm:@denotest/esm-basic\"\n    }\n}\"#,\n  );\n\n  dir.write(\n    \"main.ts\",\n    r#\"\n// import map should resolve\nimport { setValue, getValue } from \"basic\";\n// this entry should have been added automatically\nimport { hello } from \"basic/other.mjs\";\n\nsetValue(5);\nconsole.log(getValue());\nconsole.log(hello());\n\"#,\n  );\n  let output = test_context.new_command().args(\"run main.ts\").run();\n  output.assert_matches_text(\"[WILDCARD]5\\nhello, world!\\n\");\n}\n\n#[test]\nfn deno_json_imports_expand_doesnt_overwrite_existing_entries() {\n  let test_context = TestContextBuilder::for_npm().use_temp_cwd().build();\n  let dir = test_context.temp_dir();\n  dir.write(\n    \"deno.json\",\n    r#\"{\n    \"imports\": {\n      \"basic\": \"npm:@denotest/esm-basic\",\n      \"basic/\": \"npm:/@denotest/sub-folders/folder_index_js/\"\n    }\n}\"#,\n  );\n\n  dir.write(\n    \"main.ts\",\n    r#\"\n// import map should resolve\nimport { setValue, getValue } from \"basic\";\n// this entry should map to explicitly specified \"basic/\" mapping\nimport { add } from \"basic/index.js\";\n\nsetValue(5);\nconsole.log(getValue());\nconsole.log(add(3, 4));\n\"#,\n  );\n  let output = test_context.new_command().args(\"run main.ts\").run();\n  output.assert_matches_text(\"[WILDCARD]5\\n7\\n\");\n}\n\n#[test]\nfn inspect_color_overwrite() {\n  let test_context = TestContextBuilder::new().build();\n  let output = test_context\n    .new_command()\n    .skip_strip_ansi()\n    .split_output()\n    .env(\"NO_COLOR\", \"1\")\n    .args(\"run run/inspect_color_overwrite.ts\")\n    .run();\n\n  assert_eq!(output.stdout(), \"foo\\u{1b}[31mbar\\u{1b}[0m\\n\");\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2024-28244", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "// @flow\n/* eslint no-constant-condition:0 */\nimport functions from \"./functions\";\nimport MacroExpander, {implicitCommands} from \"./MacroExpander\";\nimport symbols, {ATOMS, extraLatin} from \"./symbols\";\nimport {validUnit} from \"./units\";\nimport {supportedCodepoint} from \"./unicodeScripts\";\nimport ParseError from \"./ParseError\";\nimport {combiningDiacriticalMarksEndRegex} from \"./Lexer\";\nimport Settings from \"./Settings\";\nimport SourceLocation from \"./SourceLocation\";\nimport {uSubsAndSups, unicodeSubRegEx} from \"./unicodeSupOrSub\";\nimport {Token} from \"./Token\";\n\n// Pre-evaluate both modules as unicodeSymbols require String.normalize()\nimport unicodeAccents from /*preval*/ \"./unicodeAccents\";\nimport unicodeSymbols from /*preval*/ \"./unicodeSymbols\";\n\nimport type {ParseNode, AnyParseNode, SymbolParseNode, UnsupportedCmdParseNode}\n    from \"./parseNode\";\nimport type {Atom, Group} from \"./symbols\";\nimport type {Mode, ArgType, BreakToken} from \"./types\";\nimport type {FunctionContext, FunctionSpec} from \"./defineFunction\";\nimport type {EnvSpec} from \"./defineEnvironment\";\n\n/**\n * This file contains the parser used to parse out a TeX expression from the\n * input. Since TeX isn't context-free, standard parsers don't work particularly\n * well.\n *\n * The strategy of this parser is as such:\n *\n * The main functions (the `.parse...` ones) take a position in the current\n * parse string to parse tokens from. The lexer (found in Lexer.js, stored at\n * this.gullet.lexer) also supports pulling out tokens at arbitrary places. When\n * individual tokens are needed at a position, the lexer is called to pull out a\n * token, which is then used.\n *\n * The parser has a property called \"mode\" indicating the mode that\n * the parser is currently in. Currently it has to be one of \"math\" or\n * \"text\", which denotes whether the current environment is a math-y\n * one or a text-y one (e.g. inside \\text). Currently, this serves to\n * limit the functions which can be used in text mode.\n *\n * The main functions then return an object which contains the useful data that\n * was parsed at its given point, and a new position at the end of the parsed\n * data. The main functions can call each other and continue the parsing by\n * using the returned position as a new starting point.\n *\n * There are also extra `.handle...` functions, which pull out some reused\n * functionality into self-contained functions.\n *\n * The functions return ParseNodes.\n */\n\nexport default class Parser {\n    mode: Mode;\n    gullet: MacroExpander;\n    settings: Settings;\n    leftrightDepth: number;\n    nextToken: ?Token;\n\n    constructor(input: string, settings: Settings) {\n        // Start in math mode\n        this.mode = \"math\";\n        // Create a new macro expander (gullet) and (indirectly via that) also a\n        // new lexer (mouth) for this parser (stomach, in the language of TeX)\n        this.gullet = new MacroExpander(input, settings, this.mode);\n        // Store the settings for use in parsing\n        this.settings = settings;\n        // Count leftright depth (for \\middle errors)\n        this.leftrightDepth = 0;\n    }\n\n    /**\n     * Checks a result to make sure it has the right type, and throws an\n     * appropriate error otherwise.\n     */\n    expect(text: string, consume?: boolean = true) {\n        if (this.fetch().text !== text) {\n            throw new ParseError(\n                `Expected '${text}', got '${this.fetch().text}'`, this.fetch()\n            );\n        }\n        if (consume) {\n            this.consume();\n        }\n    }\n\n    /**\n     * Discards the current lookahead token, considering it consumed.\n     */\n    consume() {\n        this.nextToken = null;\n    }\n\n    /**\n     * Return the current lookahead token, or if there isn't one (at the\n     * beginning, or if the previous lookahead token was consume()d),\n     * fetch the next token as the new lookahead token and return it.\n     */\n    fetch(): Token {\n        if (this.nextToken == null) {\n            this.nextToken = this.gullet.expandNextToken();\n        }\n        return this.nextToken;\n    }\n\n    /**\n     * Switches between \"text\" and \"math\" modes.\n     */\n    switchMode(newMode: Mode) {\n        this.mode = newMode;\n        this.gullet.switchMode(newMode);\n    }\n\n    /**\n     * Main parsing function, which parses an entire input.\n     */\n    parse(): AnyParseNode[] {\n        if (!this.settings.globalGroup) {\n            // Create a group namespace for the math expression.\n            // (LaTeX creates a new group for every $...$, $$...$$, \\[...\\].)\n            this.gullet.beginGroup();\n        }\n\n        // Use old \\color behavior (same as LaTeX's \\textcolor) if requested.\n        // We do this within the group for the math expression, so it doesn't\n        // pollute settings.macros.\n        if (this.settings.colorIsTextColor) {\n            this.gullet.macros.set(\"\\\\color\", \"\\\\textcolor\");\n        }\n\n        try {\n            // Try to parse the input\n            const parse = this.parseExpression(false);\n\n            // If we succeeded, make sure there's an EOF at the end\n            this.expect(\"EOF\");\n\n            // End the group namespace for the expression\n            if (!this.settings.globalGroup) {\n                this.gullet.endGroup();\n            }\n\n            return parse;\n\n        // Close any leftover groups in case of a parse error.\n        } finally {\n            this.gullet.endGroups();\n        }\n    }\n\n    /**\n     * Fully parse a separate sequence of tokens as a separate job.\n     * Tokens should be specified in reverse order, as in a MacroDefinition.\n     */\n    subparse(tokens: Token[]): AnyParseNode[] {\n        // Save the next token from the current job.\n        const oldToken = this.nextToken;\n        this.consume();\n\n        // Run the new job, terminating it with an excess '}'\n        this.gullet.pushToken(new Token(\"}\"));\n        this.gullet.pushTokens(tokens);\n        const parse = this.parseExpression(false);\n        this.expect(\"}\");\n\n        // Restore the next token from the current job.\n        this.nextToken = oldToken;\n\n        return parse;\n    }\n\n    static endOfExpression: string[] = [\"}\", \"\\\\endgroup\", \"\\\\end\", \"\\\\right\", \"&\"];\n\n    /**\n     * Parses an \"expression\", which is a list of atoms.\n     *\n     * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This\n     *                 happens when functions have higher precedence han infix\n     *                 nodes in implicit parses.\n     *\n     * `breakOnTokenText`: The text of the token that the expression should end\n     *                     with, or `null` if something else should end the\n     *                     expression.\n     */\n    parseExpression(\n        breakOnInfix: boolean,\n        breakOnTokenText?: BreakToken,\n    ): AnyParseNode[] {\n        const body = [];\n        // Keep adding atoms to the body until we can't parse any more atoms (either\n        // we reached the end, a }, or a \\right)\n        while (true) {\n            // Ignore spaces in math mode\n            if (this.mode === \"math\") {\n                this.consumeSpaces();\n            }\n            const lex = this.fetch();\n            if (Parser.endOfExpression.indexOf(lex.text) !== -1) {\n                break;\n            }\n            if (breakOnTokenText && lex.text === breakOnTokenText) {\n                break;\n            }\n            if (breakOnInfix && functions[lex.text] && functions[lex.text].infix) {\n                break;\n            }\n            const atom = this.parseAtom(breakOnTokenText);\n            if (!atom) {\n                break;\n            } else if (atom.type === \"internal\") {\n                continue;\n            }\n            body.push(atom);\n        }\n        if (this.mode === \"text\") {\n            this.formLigatures(body);\n        }\n        return this.handleInfixNodes(body);\n    }\n\n    /**\n     * Rewrites infix operators such as \\over with corresponding commands such\n     * as \\frac.\n     *\n     * There can only be one infix operator per group.  If there's more than one\n     * then the expression is ambiguous.  This can be resolved by adding {}.\n     */\n    handleInfixNodes(body: AnyParseNode[]): AnyParseNode[] {\n        let overIndex = -1;\n        let funcName;\n\n        for (let i = 0; i < body.length; i++) {\n            if (body[i].type === \"infix\") {\n                if (overIndex !== -1) {\n                    throw new ParseError(\n                        \"only one infix operator per group\",\n                        body[i].token);\n                }\n                overIndex = i;\n                funcName = body[i].replaceWith;\n            }\n        }\n\n        if (overIndex !== -1 && funcName) {\n            let numerNode;\n            let denomNode;\n\n            const numerBody = body.slice(0, overIndex);\n            const denomBody = body.slice(overIndex + 1);\n\n            if (numerBody.length === 1 && numerBody[0].type === \"ordgroup\") {\n                numerNode = numerBody[0];\n            } else {\n                numerNode = {type: \"ordgroup\", mode: this.mode, body: numerBody};\n            }\n\n            if (denomBody.length === 1 && denomBody[0].type === \"ordgroup\") {\n                denomNode = denomBody[0];\n            } else {\n                denomNode = {type: \"ordgroup\", mode: this.mode, body: denomBody};\n            }\n\n            let node;\n            if (funcName === \"\\\\\\\\abovefrac\") {\n                node = this.callFunction(funcName,\n                    [numerNode, body[overIndex], denomNode], []);\n            } else {\n                node = this.callFunction(funcName, [numerNode, denomNode], []);\n            }\n            return [node];\n        } else {\n            return body;\n        }\n    }\n\n    /**\n     * Handle a subscript or superscript with nice errors.\n     */\n    handleSupSubscript(\n        name: string,   // For error reporting.\n    ): AnyParseNode {\n        const symbolToken = this.fetch();\n        const symbol = symbolToken.text;\n        this.consume();\n        this.consumeSpaces(); // ignore spaces before sup/subscript argument\n        const group = this.parseGroup(name);\n\n        if (!group) {\n            throw new ParseError(\n                \"Expected group after '\" + symbol + \"'\",\n                symbolToken\n            );\n        }\n\n        return group;\n    }\n\n    /**\n     * Converts the textual input of an unsupported command into a text node\n     * contained within a color node whose color is determined by errorColor\n     */\n    formatUnsupportedCmd(text: string): UnsupportedCmdParseNode {\n        const textordArray = [];\n\n        for (let i = 0; i < text.length; i++) {\n            textordArray.push({type: \"textord\", mode: \"text\", text: text[i]});\n        }\n\n        const textNode = {\n            type: \"text\",\n            mode: this.mode,\n            body: textordArray,\n        };\n\n        const colorNode = {\n            type: \"color\",\n            mode: this.mode,\n            color: this.settings.errorColor,\n            body: [textNode],\n        };\n\n        return colorNode;\n    }\n\n    /**\n     * Parses a group with optional super/subscripts.\n     */\n    parseAtom(breakOnTokenText?: BreakToken): ?AnyParseNode {\n        // The body of an atom is an implicit group, so that things like\n        // \\left(x\\right)^2 work correctly.\n        const base = this.parseGroup(\"atom\", breakOnTokenText);\n\n        // In text mode, we don't have superscripts or subscripts\n        if (this.mode === \"text\") {\n            return base;\n        }\n\n        // Note that base may be empty (i.e. null) at this point.\n\n        let superscript;\n        let subscript;\n        while (true) {\n            // Guaranteed in math mode, so eat any spaces first.\n            this.consumeSpaces();\n\n            // Lex the first token\n            const lex = this.fetch();\n\n            if (lex.text === \"\\\\limits\" || lex.text === \"\\\\nolimits\") {\n                // We got a limit control\n                if (base && base.type === \"op\") {\n                    const limits = lex.text === \"\\\\limits\";\n                    base.limits = limits;\n                    base.alwaysHandleSupSub = true;\n                } else if (base && base.type === \"operatorname\") {\n                    if (base.alwaysHandleSupSub) {\n                        base.limits = lex.text === \"\\\\limits\";\n                    }\n                } else {\n                    throw new ParseError(\n                        \"Limit controls must follow a math operator\",\n                        lex);\n                }\n                this.consume();\n            } else if (lex.text === \"^\") {\n                // We got a superscript start\n                if (superscript) {\n                    throw new ParseError(\"Double superscript\", lex);\n                }\n                superscript = this.handleSupSubscript(\"superscript\");\n            } else if (lex.text === \"_\") {\n                // We got a subscript start\n                if (subscript) {\n                    throw new ParseError(\"Double subscript\", lex);\n                }\n                subscript = this.handleSupSubscript(\"subscript\");\n            } else if (lex.text === \"'\") {\n                // We got a prime\n                if (superscript) {\n                    throw new ParseError(\"Double superscript\", lex);\n                }\n                const prime = {type: \"textord\", mode: this.mode, text: \"\\\\prime\"};\n\n                // Many primes can be grouped together, so we handle this here\n                const primes = [prime];\n                this.consume();\n                // Keep lexing tokens until we get something that's not a prime\n                while (this.fetch().text === \"'\") {\n                    // For each one, add another prime to the list\n                    primes.push(prime);\n                    this.consume();\n                }\n                // If there's a superscript following the primes, combine that\n                // superscript in with the primes.\n                if (this.fetch().text === \"^\") {\n                    primes.push(this.handleSupSubscript(\"superscript\"));\n                }\n                // Put everything into an ordgroup as the superscript\n                superscript = {type: \"ordgroup\", mode: this.mode, body: primes};\n            } else if (uSubsAndSups[lex.text]) {\n                // A Unicode subscript or superscript character.\n                // We treat these similarly to the unicode-math package.\n                // So we render a string of Unicode (sub|super)scripts the\n                // same as a (sub|super)script of regular characters.\n                let str = uSubsAndSups[lex.text];\n                const isSub = unicodeSubRegEx.test(lex.text);\n                this.consume();\n                // Continue fetching tokens to fill out the string.\n                while (true) {\n                    const token = this.fetch().text;\n                    if (!(uSubsAndSups[token])) { break; }\n                    if (unicodeSubRegEx.test(token) !== isSub) { break; }\n                    this.consume();\n                    str += uSubsAndSups[token];\n                }\n                // Now create a (sub|super)script.\n                const body = (new Parser(str, this.settings)).parse();\n                if (isSub) {\n                    subscript = {type: \"ordgroup\", mode: \"math\", body};\n                } else {\n                    superscript = {type: \"ordgroup\", mode: \"math\", body};\n                }\n            } else {\n                // If it wasn't ^, _, or ', stop parsing super/subscripts\n                break;\n            }\n        }\n\n        // Base must be set if superscript or subscript are set per logic above,\n        // but need to check here for type check to pass.\n        if (superscript || subscript) {\n            // If we got either a superscript or subscript, create a supsub\n            return {\n                type: \"supsub\",\n                mode: this.mode,\n                base: base,\n                sup: superscript,\n                sub: subscript,\n            };\n        } else {\n            // Otherwise return the original body\n            return base;\n        }\n    }\n\n    /**\n     * Parses an entire function, including its base and all of its arguments.\n     */\n    parseFunction(\n        breakOnTokenText?: BreakToken,\n        name?: string, // For determining its context\n    ): ?AnyParseNode {\n        const token = this.fetch();\n        const func = token.text;\n        const funcData = functions[func];\n        if (!funcData) {\n            return null;\n        }\n        this.consume(); // consume command token\n\n        if (name && name !== \"atom\" && !funcData.allowedInArgument) {\n            throw new ParseError(\n                \"Got function '\" + func + \"' with no arguments\" +\n                (name ? \" as \" + name : \"\"), token);\n        } else if (this.mode === \"text\" && !funcData.allowedInText) {\n            throw new ParseError(\n                \"Can't use function '\" + func + \"' in text mode\", token);\n        } else if (this.mode === \"math\" && funcData.allowedInMath === false) {\n            throw new ParseError(\n                \"Can't use function '\" + func + \"' in math mode\", token);\n        }\n\n        const {args, optArgs} = this.parseArguments(func, funcData);\n        return this.callFunction(func, args, optArgs, token, breakOnTokenText);\n    }\n\n    /**\n     * Call a function handler with a suitable context and arguments.\n     */\n    callFunction(\n        name: string,\n        args: AnyParseNode[],\n        optArgs: (?AnyParseNode)[],\n        token?: Token,\n        breakOnTokenText?: BreakToken,\n    ): AnyParseNode {\n        const context: FunctionContext = {\n            funcName: name,\n            parser: this,\n            token,\n            breakOnTokenText,\n        };\n        const func = functions[name];\n        if (func && func.handler) {\n            return func.handler(context, args, optArgs);\n        } else {\n            throw new ParseError(`No function handler for ${name}`);\n        }\n    }\n\n    /**\n     * Parses the arguments of a function or environment\n     */\n    parseArguments(\n        func: string,   // Should look like \"\\name\" or \"\\begin{name}\".\n        funcData: FunctionSpec<*> | EnvSpec<*>,\n    ): {\n        args: AnyParseNode[],\n        optArgs: (?AnyParseNode)[],\n    } {\n        const totalArgs = funcData.numArgs + funcData.numOptionalArgs;\n        if (totalArgs === 0) {\n            return {args: [], optArgs: []};\n        }\n\n        const args = [];\n        const optArgs = [];\n\n        for (let i = 0; i < totalArgs; i++) {\n            let argType = funcData.argTypes && funcData.argTypes[i];\n            const isOptional = i < funcData.numOptionalArgs;\n\n            if ((funcData.primitive && argType == null) ||\n                // \\sqrt expands into primitive if optional argument doesn't exist\n                (funcData.type === \"sqrt\" && i === 1 && optArgs[0] == null)) {\n                argType = \"primitive\";\n            }\n\n            const arg = this.parseGroupOfType(`argument to '${func}'`,\n                argType, isOptional);\n            if (isOptional) {\n                optArgs.push(arg);\n            } else if (arg != null) {\n                args.push(arg);\n            } else { // should be unreachable\n                throw new ParseError(\"Null argument, please report this as a bug\");\n            }\n        }\n\n        return {args, optArgs};\n    }\n\n    /**\n     * Parses a group when the mode is changing.\n     */\n    parseGroupOfType(\n        name: string,\n        type: ?ArgType,\n        optional: boolean,\n    ): ?AnyParseNode {\n        switch (type) {\n            case \"color\":\n                return this.parseColorGroup(optional);\n            case \"size\":\n                return this.parseSizeGroup(optional);\n            case \"url\":\n                return this.parseUrlGroup(optional);\n            case \"math\":\n            case \"text\":\n                return this.parseArgumentGroup(optional, type);\n            case \"hbox\": {\n                // hbox argument type wraps the argument in the equivalent of\n                // \\hbox, which is like \\text but switching to \\textstyle size.\n                const group = this.parseArgumentGroup(optional, \"text\");\n                return group != null ? {\n                    type: \"styling\",\n                    mode: group.mode,\n                    body: [group],\n                    style: \"text\", // simulate \\textstyle\n                } : null;\n            }\n            case \"raw\": {\n                const token = this.parseStringGroup(\"raw\", optional);\n                return token != null ? {\n                    type: \"raw\",\n                    mode: \"text\",\n                    string: token.text,\n                } : null;\n            }\n            case \"primitive\": {\n                if (optional) {\n                    throw new ParseError(\"A primitive argument cannot be optional\");\n                }\n                const group = this.parseGroup(name);\n                if (group == null) {\n                    throw new ParseError(\"Expected group as \" + name, this.fetch());\n                }\n                return group;\n            }\n            case \"original\":\n            case null:\n            case undefined:\n                return this.parseArgumentGroup(optional);\n            default:\n                throw new ParseError(\n                    \"Unknown group type as \" + name, this.fetch());\n        }\n    }\n\n    /**\n     * Discard any space tokens, fetching the next non-space token.\n     */\n    consumeSpaces() {\n        while (this.fetch().text === \" \") {\n            this.consume();\n        }\n    }\n\n    /**\n     * Parses a group, essentially returning the string formed by the\n     * brace-enclosed tokens plus some position information.\n     */\n    parseStringGroup(\n        modeName: ArgType,  // Used to describe the mode in error messages.\n        optional: boolean,\n    ): ?Token {\n        const argToken = this.gullet.scanArgument(optional);\n        if (argToken == null) {\n            return null;\n        }\n        let str = \"\";\n        let nextToken;\n        while ((nextToken = this.fetch()).text !== \"EOF\") {\n            str += nextToken.text;\n            this.consume();\n        }\n        this.consume(); // consume the end of the argument\n        argToken.text = str;\n        return argToken;\n    }\n\n    /**\n     * Parses a regex-delimited group: the largest sequence of tokens\n     * whose concatenated strings match `regex`. Returns the string\n     * formed by the tokens plus some position information.\n     */\n    parseRegexGroup(\n        regex: RegExp,\n        modeName: string,   // Used to describe the mode in error messages.\n    ): Token {\n        const firstToken = this.fetch();\n        let lastToken = firstToken;\n        let str = \"\";\n        let nextToken;\n        while ((nextToken = this.fetch()).text !== \"EOF\" &&\n               regex.test(str + nextToken.text)) {\n            lastToken = nextToken;\n            str += lastToken.text;\n            this.consume();\n        }\n        if (str === \"\") {\n            throw new ParseError(\n                \"Invalid \" + modeName + \": '\" + firstToken.text + \"'\",\n                firstToken);\n        }\n        return firstToken.range(lastToken, str);\n    }\n\n    /**\n     * Parses a color description.\n     */\n    parseColorGroup(optional: boolean): ?ParseNode<\"color-token\"> {\n        const res = this.parseStringGroup(\"color\", optional);\n        if (res == null) {\n            return null;\n        }\n        const match = (/^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i).exec(res.text);\n        if (!match) {\n            throw new ParseError(\"Invalid color: '\" + res.text + \"'\", res);\n        }\n        let color = match[0];\n        if (/^[0-9a-f]{6}$/i.test(color)) {\n            // We allow a 6-digit HTML color spec without a leading \"#\".\n            // This follows the xcolor package's HTML color model.\n            // Predefined color names are all missed by this RegEx pattern.\n            color = \"#\" + color;\n        }\n        return {\n            type: \"color-token\",\n            mode: this.mode,\n            color,\n        };\n    }\n\n    /**\n     * Parses a size specification, consisting of magnitude and unit.\n     */\n    parseSizeGroup(optional: boolean): ?ParseNode<\"size\"> {\n        let res;\n        let isBlank = false;\n        // don't expand before parseStringGroup\n        this.gullet.consumeSpaces();\n        if (!optional && this.gullet.future().text !== \"{\") {\n            res = this.parseRegexGroup(\n                /^[-+]? *(?:$|\\d+|\\d+\\.\\d*|\\.\\d*) *[a-z]{0,2} *$/, \"size\");\n        } else {\n            res = this.parseStringGroup(\"size\", optional);\n        }\n        if (!res) {\n            return null;\n        }\n        if (!optional && res.text.length === 0) {\n            // Because we've tested for what is !optional, this block won't\n            // affect \\kern, \\hspace, etc. It will capture the mandatory arguments\n            // to \\genfrac and \\above.\n            res.text = \"0pt\";    // Enable \\above{}\n            isBlank = true;      // This is here specifically for \\genfrac\n        }\n        const match = (/([-+]?) *(\\d+(?:\\.\\d*)?|\\.\\d+) *([a-z]{2})/).exec(res.text);\n        if (!match) {\n            throw new ParseError(\"Invalid size: '\" + res.text + \"'\", res);\n        }\n        const data = {\n            number: +(match[1] + match[2]), // sign + magnitude, cast to number\n            unit: match[3],\n        };\n        if (!validUnit(data)) {\n            throw new ParseError(\"Invalid unit: '\" + data.unit + \"'\", res);\n        }\n        return {\n            type: \"size\",\n            mode: this.mode,\n            value: data,\n            isBlank,\n        };\n    }\n\n    /**\n     * Parses an URL, checking escaped letters and allowed protocols,\n     * and setting the catcode of % as an active character (as in \\hyperref).\n     */\n    parseUrlGroup(optional: boolean): ?ParseNode<\"url\"> {\n        this.gullet.lexer.setCatcode(\"%\", 13); // active character\n        this.gullet.lexer.setCatcode(\"~\", 12); // other character\n        const res = this.parseStringGroup(\"url\", optional);\n        this.gullet.lexer.setCatcode(\"%\", 14); // comment character\n        this.gullet.lexer.setCatcode(\"~\", 13); // active character\n        if (res == null) {\n            return null;\n        }\n        // hyperref package allows backslashes alone in href, but doesn't\n        // generate valid links in such cases; we interpret this as\n        // \"undefined\" behaviour, and keep them as-is. Some browser will\n        // replace backslashes with forward slashes.\n        const url = res.text.replace(/\\\\([#$%&~_^{}])/g, '$1');\n        return {\n            type: \"url\",\n            mode: this.mode,\n            url,\n        };\n    }\n\n    /**\n     * Parses an argument with the mode specified.\n     */\n    parseArgumentGroup(optional: boolean, mode?: Mode): ?ParseNode<\"ordgroup\"> {\n        const argToken = this.gullet.scanArgument(optional);\n        if (argToken == null) {\n            return null;\n        }\n        const outerMode = this.mode;\n        if (mode) { // Switch to specified mode\n            this.switchMode(mode);\n        }\n\n        this.gullet.beginGroup();\n        const expression = this.parseExpression(false, \"EOF\");\n        // TODO: find an alternative way to denote the end\n        this.expect(\"EOF\"); // expect the end of the argument\n        this.gullet.endGroup();\n        const result = {\n            type: \"ordgroup\",\n            mode: this.mode,\n            loc: argToken.loc,\n            body: expression,\n        };\n\n        if (mode) { // Switch mode back\n            this.switchMode(outerMode);\n        }\n        return result;\n    }\n\n    /**\n     * Parses an ordinary group, which is either a single nucleus (like \"x\")\n     * or an expression in braces (like \"{x+y}\") or an implicit group, a group\n     * that starts at the current position, and ends right before a higher explicit\n     * group ends, or at EOF.\n     */\n    parseGroup(\n        name: string, // For error reporting.\n        breakOnTokenText?: BreakToken,\n    ): ?AnyParseNode {\n        const firstToken = this.fetch();\n        const text = firstToken.text;\n\n        let result;\n        // Try to parse an open brace or \\begingroup\n        if (text === \"{\" || text === \"\\\\begingroup\") {\n            this.consume();\n            const groupEnd = text === \"{\" ? \"}\" : \"\\\\endgroup\";\n\n            this.gullet.beginGroup();\n            // If we get a brace, parse an expression\n            const expression = this.parseExpression(false, groupEnd);\n            const lastToken = this.fetch();\n            this.expect(groupEnd); // Check that we got a matching closing brace\n            this.gullet.endGroup();\n            result = {\n                type: \"ordgroup\",\n                mode: this.mode,\n                loc: SourceLocation.range(firstToken, lastToken),\n                body: expression,\n                // A group formed by \\begingroup...\\endgroup is a semi-simple group\n                // which doesn't affect spacing in math mode, i.e., is transparent.\n                // https://tex.stackexchange.com/questions/1930/when-should-one-\n                // use-begingroup-instead-of-bgroup\n                semisimple: text === \"\\\\begingroup\" || undefined,\n            };\n        } else {\n            // If there exists a function with this name, parse the function.\n            // Otherwise, just return a nucleus\n            result = this.parseFunction(breakOnTokenText, name) ||\n                this.parseSymbol();\n            if (result == null && text[0] === \"\\\\\" &&\n                    !implicitCommands.hasOwnProperty(text)) {\n                if (this.settings.throwOnError) {\n                    throw new ParseError(\n                        \"Undefined control sequence: \" + text, firstToken);\n                }\n                result = this.formatUnsupportedCmd(text);\n                this.consume();\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Form ligature-like combinations of characters for text mode.\n     * This includes inputs like \"--\", \"---\", \"``\" and \"''\".\n     * The result will simply replace multiple textord nodes with a single\n     * character in each value by a single textord node having multiple\n     * characters in its value.  The representation is still ASCII source.\n     * The group will be modified in place.\n     */\n    formLigatures(group: AnyParseNode[]) {\n        let n = group.length - 1;\n        for (let i = 0; i < n; ++i) {\n            const a = group[i];\n            // $FlowFixMe: Not every node type has a `text` property.\n            const v = a.text;\n            if (v === \"-\" && group[i + 1].text === \"-\") {\n                if (i + 1 < n && group[i + 2].text === \"-\") {\n                    group.splice(i, 3, {\n                        type: \"textord\",\n                        mode: \"text\",\n                        loc: SourceLocation.range(a, group[i + 2]),\n                        text: \"---\",\n                    });\n                    n -= 2;\n                } else {\n                    group.splice(i, 2, {\n                        type: \"textord\",\n                        mode: \"text\",\n                        loc: SourceLocation.range(a, group[i + 1]),\n                        text: \"--\",\n                    });\n                    n -= 1;\n                }\n            }\n            if ((v === \"'\" || v === \"`\") && group[i + 1].text === v) {\n                group.splice(i, 2, {\n                    type: \"textord\",\n                    mode: \"text\",\n                    loc: SourceLocation.range(a, group[i + 1]),\n                    text: v + v,\n                });\n                n -= 1;\n            }\n        }\n    }\n\n    /**\n     * Parse a single symbol out of the string. Here, we handle single character\n     * symbols and special functions like \\verb.\n     */\n    parseSymbol(): ?AnyParseNode {\n        const nucleus = this.fetch();\n        let text = nucleus.text;\n\n        if (/^\\\\verb[^a-zA-Z]/.test(text)) {\n            this.consume();\n            let arg = text.slice(5);\n            const star = (arg.charAt(0) === \"*\");\n            if (star) {\n                arg = arg.slice(1);\n            }\n            // Lexer's tokenRegex is constructed to always have matching\n            // first/last characters.\n            if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {\n                throw new ParseError(`\\\\verb assertion failed --\n                    please report what input caused this bug`);\n            }\n            arg = arg.slice(1, -1);  // remove first and last char\n            return {\n                type: \"verb\",\n                mode: \"text\",\n                body: arg,\n                star,\n            };\n        }\n        // At this point, we should have a symbol, possibly with accents.\n        // First expand any accented base symbol according to unicodeSymbols.\n        if (unicodeSymbols.hasOwnProperty(text[0]) &&\n            !symbols[this.mode][text[0]]) {\n            // This behavior is not strict (XeTeX-compatible) in math mode.\n            if (this.settings.strict && this.mode === \"math\") {\n                this.settings.reportNonstrict(\"unicodeTextInMathMode\",\n                    `Accented Unicode text character \"${text[0]}\" used in ` +\n                    `math mode`, nucleus);\n            }\n            text = unicodeSymbols[text[0]] + text.slice(1);\n        }\n        // Strip off any combining characters\n        const match = combiningDiacriticalMarksEndRegex.exec(text);\n        if (match) {\n            text = text.substring(0, match.index);\n            if (text === 'i') {\n                text = '\\u0131';  // dotless i, in math and text mode\n            } else if (text === 'j') {\n                text = '\\u0237';  // dotless j, in math and text mode\n            }\n        }\n        // Recognize base symbol\n        let symbol: AnyParseNode;\n        if (symbols[this.mode][text]) {\n            if (this.settings.strict && this.mode === 'math' &&\n                extraLatin.indexOf(text) >= 0) {\n                this.settings.reportNonstrict(\"unicodeTextInMathMode\",\n                    `Latin-1/Unicode text character \"${text[0]}\" used in ` +\n                    `math mode`, nucleus);\n            }\n            const group: Group = symbols[this.mode][text].group;\n            const loc = SourceLocation.range(nucleus);\n            let s: SymbolParseNode;\n            if (ATOMS.hasOwnProperty(group)) {\n                // $FlowFixMe\n                const family: Atom = group;\n                s = {\n                    type: \"atom\",\n                    mode: this.mode,\n                    family,\n                    loc,\n                    text,\n                };\n            } else {\n                // $FlowFixMe\n                s = {\n                    type: group,\n                    mode: this.mode,\n                    loc,\n                    text,\n                };\n            }\n            // $FlowFixMe\n            symbol = s;\n        } else if (text.charCodeAt(0) >= 0x80) { // no symbol for e.g. ^\n            if (this.settings.strict) {\n                if (!supportedCodepoint(text.charCodeAt(0))) {\n                    this.settings.reportNonstrict(\"unknownSymbol\",\n                        `Unrecognized Unicode character \"${text[0]}\"` +\n                        ` (${text.charCodeAt(0)})`, nucleus);\n                } else if (this.mode === \"math\") {\n                    this.settings.reportNonstrict(\"unicodeTextInMathMode\",\n                        `Unicode text character \"${text[0]}\" used in math mode`,\n                        nucleus);\n                }\n            }\n            // All nonmathematical Unicode characters are rendered as if they\n            // are in text mode (wrapped in \\text) because that's what it\n            // takes to render them in LaTeX.  Setting `mode: this.mode` is\n            // another natural choice (the user requested math mode), but\n            // this makes it more difficult for getCharacterMetrics() to\n            // distinguish Unicode characters without metrics and those for\n            // which we want to simulate the letter M.\n            symbol = {\n                type: \"textord\",\n                mode: \"text\",\n                loc: SourceLocation.range(nucleus),\n                text,\n            };\n        } else {\n            return null;  // EOF, ^, _, {, }, etc.\n        }\n        this.consume();\n        // Transform combining characters into accents\n        if (match) {\n            for (let i = 0; i < match[0].length; i++) {\n                const accent: string = match[0][i];\n                if (!unicodeAccents[accent]) {\n                    throw new ParseError(`Unknown accent ' ${accent}'`, nucleus);\n                }\n                const command = unicodeAccents[accent][this.mode] ||\n                    unicodeAccents[accent].text;\n                if (!command) {\n                    throw new ParseError(\n                        `Accent ${accent} unsupported in ${this.mode} mode`,\n                        nucleus);\n                }\n                symbol = {\n                    type: \"accent\",\n                    mode: this.mode,\n                    loc: SourceLocation.range(nucleus),\n                    label: command,\n                    isStretchy: false,\n                    isShifty: true,\n                    // $FlowFixMe\n                    base: symbol,\n                };\n            }\n        }\n        // $FlowFixMe\n        return symbol;\n    }\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2024-28245", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "// @flow\n/**\n * These objects store the data about the DOM nodes we create, as well as some\n * extra data. They can then be transformed into real DOM nodes with the\n * `toNode` function or HTML markup using `toMarkup`. They are useful for both\n * storing extra properties on the nodes, as well as providing a way to easily\n * work with the DOM.\n *\n * Similar functions for working with MathML nodes exist in mathMLTree.js.\n *\n * TODO: refactor `span` and `anchor` into common superclass when\n * target environments support class inheritance\n */\nimport {scriptFromCodepoint} from \"./unicodeScripts\";\nimport utils from \"./utils\";\nimport {path} from \"./svgGeometry\";\nimport type Options from \"./Options\";\nimport {DocumentFragment} from \"./tree\";\nimport {makeEm} from \"./units\";\n\nimport type {VirtualNode} from \"./tree\";\n\n\n/**\n * Create an HTML className based on a list of classes. In addition to joining\n * with spaces, we also remove empty classes.\n */\nexport const createClass = function(classes: string[]): string {\n    return classes.filter(cls => cls).join(\" \");\n};\n\nconst initNode = function(\n    classes?: string[],\n    options?: Options,\n    style?: CssStyle,\n) {\n    this.classes = classes || [];\n    this.attributes = {};\n    this.height = 0;\n    this.depth = 0;\n    this.maxFontSize = 0;\n    this.style = style || {};\n    if (options) {\n        if (options.style.isTight()) {\n            this.classes.push(\"mtight\");\n        }\n        const color = options.getColor();\n        if (color) {\n            this.style.color = color;\n        }\n    }\n};\n\n/**\n * Convert into an HTML node\n */\nconst toNode = function(tagName: string): HTMLElement {\n    const node = document.createElement(tagName);\n\n    // Apply the class\n    node.className = createClass(this.classes);\n\n    // Apply inline styles\n    for (const style in this.style) {\n        if (this.style.hasOwnProperty(style)) {\n            // $FlowFixMe Flow doesn't seem to understand span.style's type.\n            node.style[style] = this.style[style];\n        }\n    }\n\n    // Apply attributes\n    for (const attr in this.attributes) {\n        if (this.attributes.hasOwnProperty(attr)) {\n            node.setAttribute(attr, this.attributes[attr]);\n        }\n    }\n\n    // Append the children, also as HTML nodes\n    for (let i = 0; i < this.children.length; i++) {\n        node.appendChild(this.children[i].toNode());\n    }\n\n    return node;\n};\n\n/**\n * Convert into an HTML markup string\n */\nconst toMarkup = function(tagName: string): string {\n    let markup = `<${tagName}`;\n\n    // Add the class\n    if (this.classes.length) {\n        markup += ` class=\"${utils.escape(createClass(this.classes))}\"`;\n    }\n\n    let styles = \"\";\n\n    // Add the styles, after hyphenation\n    for (const style in this.style) {\n        if (this.style.hasOwnProperty(style)) {\n            styles += `${utils.hyphenate(style)}:${this.style[style]};`;\n        }\n    }\n\n    if (styles) {\n        markup += ` style=\"${utils.escape(styles)}\"`;\n    }\n\n    // Add the attributes\n    for (const attr in this.attributes) {\n        if (this.attributes.hasOwnProperty(attr)) {\n            markup += ` ${attr}=\"${utils.escape(this.attributes[attr])}\"`;\n        }\n    }\n\n    markup += \">\";\n\n    // Add the markup of the children, also as markup\n    for (let i = 0; i < this.children.length; i++) {\n        markup += this.children[i].toMarkup();\n    }\n\n    markup += `</${tagName}>`;\n\n    return markup;\n};\n\n// Making the type below exact with all optional fields doesn't work due to\n// - https://github.com/facebook/flow/issues/4582\n// - https://github.com/facebook/flow/issues/5688\n// However, since *all* fields are optional, $Shape<> works as suggested in 5688\n// above.\n// This type does not include all CSS properties. Additional properties should\n// be added as needed.\nexport type CssStyle = $Shape<{\n    backgroundColor: string,\n    borderBottomWidth: string,\n    borderColor: string,\n    borderRightStyle: string,\n    borderRightWidth: string,\n    borderTopWidth: string,\n    borderStyle: string;\n    borderWidth: string,\n    bottom: string,\n    color: string,\n    height: string,\n    left: string,\n    margin: string,\n    marginLeft: string,\n    marginRight: string,\n    marginTop: string,\n    minWidth: string,\n    paddingLeft: string,\n    position: string,\n    textShadow: string,\n    top: string,\n    width: string,\n    verticalAlign: string,\n}> & {};\n\nexport interface HtmlDomNode extends VirtualNode {\n    classes: string[];\n    height: number;\n    depth: number;\n    maxFontSize: number;\n    style: CssStyle;\n\n    hasClass(className: string): boolean;\n}\n\n// Span wrapping other DOM nodes.\nexport type DomSpan = Span<HtmlDomNode>;\n// Span wrapping an SVG node.\nexport type SvgSpan = Span<SvgNode>;\n\nexport type SvgChildNode = PathNode | LineNode;\nexport type documentFragment = DocumentFragment<HtmlDomNode>;\n\n\n/**\n * This node represents a span node, with a className, a list of children, and\n * an inline style. It also contains information about its height, depth, and\n * maxFontSize.\n *\n * Represents two types with different uses: SvgSpan to wrap an SVG and DomSpan\n * otherwise. This typesafety is important when HTML builders access a span's\n * children.\n */\nexport class Span<ChildType: VirtualNode> implements HtmlDomNode {\n    children: ChildType[];\n    attributes: {[string]: string};\n    classes: string[];\n    height: number;\n    depth: number;\n    width: ?number;\n    maxFontSize: number;\n    style: CssStyle;\n\n    constructor(\n        classes?: string[],\n        children?: ChildType[],\n        options?: Options,\n        style?: CssStyle,\n    ) {\n        initNode.call(this, classes, options, style);\n        this.children = children || [];\n    }\n\n    /**\n     * Sets an arbitrary attribute on the span. Warning: use this wisely. Not\n     * all browsers support attributes the same, and having too many custom\n     * attributes is probably bad.\n     */\n    setAttribute(attribute: string, value: string) {\n        this.attributes[attribute] = value;\n    }\n\n    hasClass(className: string): boolean {\n        return utils.contains(this.classes, className);\n    }\n\n    toNode(): HTMLElement {\n        return toNode.call(this, \"span\");\n    }\n\n    toMarkup(): string {\n        return toMarkup.call(this, \"span\");\n    }\n}\n\n/**\n * This node represents an anchor (<a>) element with a hyperlink.  See `span`\n * for further details.\n */\nexport class Anchor implements HtmlDomNode {\n    children: HtmlDomNode[];\n    attributes: {[string]: string};\n    classes: string[];\n    height: number;\n    depth: number;\n    maxFontSize: number;\n    style: CssStyle;\n\n    constructor(\n        href: string,\n        classes: string[],\n        children: HtmlDomNode[],\n        options: Options,\n    ) {\n        initNode.call(this, classes, options);\n        this.children = children || [];\n        this.setAttribute('href', href);\n    }\n\n    setAttribute(attribute: string, value: string) {\n        this.attributes[attribute] = value;\n    }\n\n    hasClass(className: string): boolean {\n        return utils.contains(this.classes, className);\n    }\n\n    toNode(): HTMLElement {\n        return toNode.call(this, \"a\");\n    }\n\n    toMarkup(): string {\n        return toMarkup.call(this, \"a\");\n    }\n}\n\n/**\n * This node represents an image embed (<img>) element.\n */\nexport class Img implements VirtualNode {\n    src: string;\n    alt: string;\n    classes: string[];\n    height: number;\n    depth: number;\n    maxFontSize: number;\n    style: CssStyle;\n\n    constructor(\n        src: string,\n        alt: string,\n        style: CssStyle,\n    ) {\n        this.alt = alt;\n        this.src = src;\n        this.classes = [\"mord\"];\n        this.style = style;\n    }\n\n    hasClass(className: string): boolean {\n        return utils.contains(this.classes, className);\n    }\n\n    toNode(): Node {\n        const node = document.createElement(\"img\");\n        node.src = this.src;\n        node.alt = this.alt;\n        node.className = \"mord\";\n\n        // Apply inline styles\n        for (const style in this.style) {\n            if (this.style.hasOwnProperty(style)) {\n                // $FlowFixMe\n                node.style[style] = this.style[style];\n            }\n        }\n\n        return node;\n    }\n\n    toMarkup(): string {\n        let markup = `<img  src='${this.src} 'alt='${this.alt}' `;\n\n        // Add the styles, after hyphenation\n        let styles = \"\";\n        for (const style in this.style) {\n            if (this.style.hasOwnProperty(style)) {\n                styles += `${utils.hyphenate(style)}:${this.style[style]};`;\n            }\n        }\n        if (styles) {\n            markup += ` style=\"${utils.escape(styles)}\"`;\n        }\n\n        markup += \"'/>\";\n        return markup;\n    }\n}\n\nconst iCombinations = {\n    '': '\\u0131\\u0302',\n    '': '\\u0131\\u0308',\n    '': '\\u0131\\u0301',\n    // '': '\\u0131\\u0304', // enable when we add Extended Latin\n    '': '\\u0131\\u0300',\n};\n\n/**\n * A symbol node contains information about a single symbol. It either renders\n * to a single text node, or a span with a single text node in it, depending on\n * whether it has CSS classes, styles, or needs italic correction.\n */\nexport class SymbolNode implements HtmlDomNode {\n    text: string;\n    height: number;\n    depth: number;\n    italic: number;\n    skew: number;\n    width: number;\n    maxFontSize: number;\n    classes: string[];\n    style: CssStyle;\n\n    constructor(\n        text: string,\n        height?: number,\n        depth?: number,\n        italic?: number,\n        skew?: number,\n        width?: number,\n        classes?: string[],\n        style?: CssStyle,\n    ) {\n        this.text = text;\n        this.height = height || 0;\n        this.depth = depth || 0;\n        this.italic = italic || 0;\n        this.skew = skew || 0;\n        this.width = width || 0;\n        this.classes = classes || [];\n        this.style = style || {};\n        this.maxFontSize = 0;\n\n        // Mark text from non-Latin scripts with specific classes so that we\n        // can specify which fonts to use.  This allows us to render these\n        // characters with a serif font in situations where the browser would\n        // either default to a sans serif or render a placeholder character.\n        // We use CSS class names like cjk_fallback, hangul_fallback and\n        // brahmic_fallback. See ./unicodeScripts.js for the set of possible\n        // script names\n        const script = scriptFromCodepoint(this.text.charCodeAt(0));\n        if (script) {\n            this.classes.push(script + \"_fallback\");\n        }\n\n        if (/[]/.test(this.text)) {    // add  when we add Extended Latin\n            this.text = iCombinations[this.text];\n        }\n    }\n\n    hasClass(className: string): boolean {\n        return utils.contains(this.classes, className);\n    }\n\n    /**\n     * Creates a text node or span from a symbol node. Note that a span is only\n     * created if it is needed.\n     */\n    toNode(): Node {\n        const node = document.createTextNode(this.text);\n        let span = null;\n\n        if (this.italic > 0) {\n            span = document.createElement(\"span\");\n            span.style.marginRight = makeEm(this.italic);\n        }\n\n        if (this.classes.length > 0) {\n            span = span || document.createElement(\"span\");\n            span.className = createClass(this.classes);\n        }\n\n        for (const style in this.style) {\n            if (this.style.hasOwnProperty(style)) {\n                span = span || document.createElement(\"span\");\n                // $FlowFixMe Flow doesn't seem to understand span.style's type.\n                span.style[style] = this.style[style];\n            }\n        }\n\n        if (span) {\n            span.appendChild(node);\n            return span;\n        } else {\n            return node;\n        }\n    }\n\n    /**\n     * Creates markup for a symbol node.\n     */\n    toMarkup(): string {\n        // TODO(alpert): More duplication than I'd like from\n        // span.prototype.toMarkup and symbolNode.prototype.toNode...\n        let needsSpan = false;\n\n        let markup = \"<span\";\n\n        if (this.classes.length) {\n            needsSpan = true;\n            markup += \" class=\\\"\";\n            markup += utils.escape(createClass(this.classes));\n            markup += \"\\\"\";\n        }\n\n        let styles = \"\";\n\n        if (this.italic > 0) {\n            styles += \"margin-right:\" + this.italic + \"em;\";\n        }\n        for (const style in this.style) {\n            if (this.style.hasOwnProperty(style)) {\n                styles += utils.hyphenate(style) + \":\" + this.style[style] + \";\";\n            }\n        }\n\n        if (styles) {\n            needsSpan = true;\n            markup += \" style=\\\"\" + utils.escape(styles) + \"\\\"\";\n        }\n\n        const escaped = utils.escape(this.text);\n        if (needsSpan) {\n            markup += \">\";\n            markup += escaped;\n            markup += \"</span>\";\n            return markup;\n        } else {\n            return escaped;\n        }\n    }\n}\n\n/**\n * SVG nodes are used to render stretchy wide elements.\n */\nexport class SvgNode implements VirtualNode {\n    children: SvgChildNode[];\n    attributes: {[string]: string};\n\n    constructor(children?: SvgChildNode[], attributes?: {[string]: string}) {\n        this.children = children || [];\n        this.attributes = attributes || {};\n    }\n\n    toNode(): Node {\n        const svgNS = \"http://www.w3.org/2000/svg\";\n        const node = document.createElementNS(svgNS, \"svg\");\n\n        // Apply attributes\n        for (const attr in this.attributes) {\n            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n                node.setAttribute(attr, this.attributes[attr]);\n            }\n        }\n\n        for (let i = 0; i < this.children.length; i++) {\n            node.appendChild(this.children[i].toNode());\n        }\n        return node;\n    }\n\n    toMarkup(): string {\n        let markup = `<svg xmlns=\"http://www.w3.org/2000/svg\"`;\n\n        // Apply attributes\n        for (const attr in this.attributes) {\n            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n                markup += ` ${attr}='${this.attributes[attr]}'`;\n            }\n        }\n\n        markup += \">\";\n\n        for (let i = 0; i < this.children.length; i++) {\n            markup += this.children[i].toMarkup();\n        }\n\n        markup += \"</svg>\";\n\n        return markup;\n\n    }\n}\n\nexport class PathNode implements VirtualNode {\n    pathName: string;\n    alternate: ?string;\n\n    constructor(pathName: string, alternate?: string) {\n        this.pathName = pathName;\n        this.alternate = alternate;  // Used only for \\sqrt, \\phase, & tall delims\n    }\n\n    toNode(): Node {\n        const svgNS = \"http://www.w3.org/2000/svg\";\n        const node = document.createElementNS(svgNS, \"path\");\n\n        if (this.alternate) {\n            node.setAttribute(\"d\", this.alternate);\n        } else {\n            node.setAttribute(\"d\", path[this.pathName]);\n        }\n\n        return node;\n    }\n\n    toMarkup(): string {\n        if (this.alternate) {\n            return `<path d='${this.alternate}'/>`;\n        } else {\n            return `<path d='${path[this.pathName]}'/>`;\n        }\n    }\n}\n\nexport class LineNode implements VirtualNode {\n    attributes: {[string]: string};\n\n    constructor(attributes?: {[string]: string}) {\n        this.attributes = attributes || {};\n    }\n\n    toNode(): Node {\n        const svgNS = \"http://www.w3.org/2000/svg\";\n        const node = document.createElementNS(svgNS, \"line\");\n\n        // Apply attributes\n        for (const attr in this.attributes) {\n            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n                node.setAttribute(attr, this.attributes[attr]);\n            }\n        }\n\n        return node;\n    }\n\n    toMarkup(): string {\n        let markup = \"<line\";\n\n        for (const attr in this.attributes) {\n            if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n                markup += ` ${attr}='${this.attributes[attr]}'`;\n            }\n        }\n\n        markup += \"/>\";\n\n        return markup;\n    }\n}\n\nexport function assertSymbolDomNode(\n    group: HtmlDomNode,\n): SymbolNode {\n    if (group instanceof SymbolNode) {\n        return group;\n    } else {\n        throw new Error(`Expected symbolNode but got ${String(group)}.`);\n    }\n}\n\nexport function assertSpan(\n    group: HtmlDomNode,\n): Span<HtmlDomNode> {\n    if (group instanceof Span) {\n        return group;\n    } else {\n        throw new Error(`Expected span<HtmlDomNode> but got ${String(group)}.`);\n    }\n}\n", "output": {"vulnerability_count": 4, "vulnerabilities": [{"description": "This template literal looks like HTML and has interpolated variables. These variables are not HTML-encoded by default. If the variables contain HTML tags, these may be interpreted by the browser, resulting in cross-site scripting (XSS).", "risk": "Medium", "conceptual_fix": "Not provided", "line": 318}, {"description": "This template literal looks like HTML and has interpolated variables. These variables are not HTML-encoded by default. If the variables contain HTML tags, these may be interpreted by the browser, resulting in cross-site scripting (XSS).", "risk": "Medium", "conceptual_fix": "Not provided", "line": 556}, {"description": "This template literal looks like HTML and has interpolated variables. These variables are not HTML-encoded by default. If the variables contain HTML tags, these may be interpreted by the browser, resulting in cross-site scripting (XSS).", "risk": "Medium", "conceptual_fix": "Not provided", "line": 558}, {"description": "This template literal looks like HTML and has interpolated variables. These variables are not HTML-encoded by default. If the variables contain HTML tags, these may be interpreted by the browser, resulting in cross-site scripting (XSS).", "risk": "Medium", "conceptual_fix": "Not provided", "line": 615}]}}
{"CVE": "CVE-2024-28246", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "// @flow\n/**\n * This file contains a list of utility functions which are useful in other\n * files.\n */\n\nimport type {AnyParseNode} from \"./parseNode\";\n\n/**\n * Return whether an element is contained in a list\n */\nconst contains = function<T>(list: Array<T>, elem: T): boolean {\n    return list.indexOf(elem) !== -1;\n};\n\n/**\n * Provide a default value if a setting is undefined\n * NOTE: Couldn't use `T` as the output type due to facebook/flow#5022.\n */\nconst deflt = function<T>(setting: T | void, defaultIfUndefined: T): * {\n    return setting === undefined ? defaultIfUndefined : setting;\n};\n\n// hyphenate and escape adapted from Facebook's React under Apache 2 license\n\nconst uppercase = /([A-Z])/g;\nconst hyphenate = function(str: string): string {\n    return str.replace(uppercase, \"-$1\").toLowerCase();\n};\n\nconst ESCAPE_LOOKUP = {\n    \"&\": \"&amp;\",\n    \">\": \"&gt;\",\n    \"<\": \"&lt;\",\n    \"\\\"\": \"&quot;\",\n    \"'\": \"&#x27;\",\n};\n\nconst ESCAPE_REGEX = /[&><\"']/g;\n\n/**\n * Escapes text to prevent scripting attacks.\n */\nfunction escape(text: mixed): string {\n    return String(text).replace(ESCAPE_REGEX, match => ESCAPE_LOOKUP[match]);\n}\n\n/**\n * Sometimes we want to pull out the innermost element of a group. In most\n * cases, this will just be the group itself, but when ordgroups and colors have\n * a single element, we want to pull that out.\n */\nconst getBaseElem = function(group: AnyParseNode): AnyParseNode {\n    if (group.type === \"ordgroup\") {\n        if (group.body.length === 1) {\n            return getBaseElem(group.body[0]);\n        } else {\n            return group;\n        }\n    } else if (group.type === \"color\") {\n        if (group.body.length === 1) {\n            return getBaseElem(group.body[0]);\n        } else {\n            return group;\n        }\n    } else if (group.type === \"font\") {\n        return getBaseElem(group.body);\n    } else {\n        return group;\n    }\n};\n\n/**\n * TeXbook algorithms often reference \"character boxes\", which are simply groups\n * with a single character in them. To decide if something is a character box,\n * we find its innermost group, and see if it is a single character.\n */\nconst isCharacterBox = function(group: AnyParseNode): boolean {\n    const baseElem = getBaseElem(group);\n\n    // These are all they types of groups which hold single characters\n    return baseElem.type === \"mathord\" ||\n        baseElem.type === \"textord\" ||\n        baseElem.type === \"atom\";\n};\n\nexport const assert = function<T>(value: ?T): T {\n    if (!value) {\n        throw new Error('Expected non-null, but got ' + String(value));\n    }\n    return value;\n};\n\n/**\n * Return the protocol of a URL, or \"_relative\" if the URL does not specify a\n * protocol (and thus is relative).\n */\nexport const protocolFromUrl = function(url: string): string {\n    const protocol = /^\\s*([^\\\\/#]*?)(?::|&#0*58|&#x0*3a)/i.exec(url);\n    return (protocol != null ? protocol[1] : \"_relative\");\n};\n\nexport default {\n    contains,\n    deflt,\n    escape,\n    hyphenate,\n    getBaseElem,\n    isCharacterBox,\n    protocolFromUrl,\n};\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2024-30264", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "import {\n  Button,\n  HTMLChakraProps,\n  Input,\n  Stack,\n  HStack,\n  Text,\n  Spinner,\n  Alert,\n  Flex,\n  AlertIcon,\n  SlideFade,\n} from '@chakra-ui/react'\nimport React, { ChangeEvent, FormEvent, useEffect } from 'react'\nimport { useState } from 'react'\nimport {\n  ClientSafeProvider,\n  getProviders,\n  LiteralUnion,\n  signIn,\n  useSession,\n} from 'next-auth/react'\nimport { DividerWithText } from './DividerWithText'\nimport { SocialLoginButtons } from './SocialLoginButtons'\nimport { useRouter } from 'next/router'\nimport { BuiltInProviderType } from 'next-auth/providers'\nimport { useToast } from '@/hooks/useToast'\nimport { TextLink } from '@/components/TextLink'\nimport { SignInError } from './SignInError'\nimport { useTranslate } from '@tolgee/react'\n\ntype Props = {\n  defaultEmail?: string\n}\nexport const SignInForm = ({\n  defaultEmail,\n}: Props & HTMLChakraProps<'form'>) => {\n  const { t } = useTranslate()\n  const router = useRouter()\n  const { status } = useSession()\n  const [authLoading, setAuthLoading] = useState(false)\n  const [isLoadingProviders, setIsLoadingProviders] = useState(true)\n\n  const [emailValue, setEmailValue] = useState(defaultEmail ?? '')\n  const [isMagicLinkSent, setIsMagicLinkSent] = useState(false)\n\n  const { showToast } = useToast()\n  const [providers, setProviders] =\n    useState<\n      Record<LiteralUnion<BuiltInProviderType, string>, ClientSafeProvider>\n    >()\n\n  const hasNoAuthProvider =\n    !isLoadingProviders && Object.keys(providers ?? {}).length === 0\n\n  useEffect(() => {\n    if (status === 'authenticated') {\n      router.replace(router.query.redirectPath?.toString() ?? '/typebots')\n      return\n    }\n    ;(async () => {\n      const providers = await getProviders()\n      setProviders(providers ?? undefined)\n      setIsLoadingProviders(false)\n    })()\n  }, [status, router])\n\n  useEffect(() => {\n    if (!router.isReady) return\n    if (router.query.error === 'ip-banned') {\n      showToast({\n        status: 'info',\n        description:\n          'Your account has suspicious activity and is being reviewed by our team. Feel free to contact us.',\n      })\n    }\n  }, [router.isReady, router.query.error, showToast])\n\n  const handleEmailChange = (e: ChangeEvent<HTMLInputElement>) =>\n    setEmailValue(e.target.value)\n\n  const handleEmailSubmit = async (e: FormEvent) => {\n    e.preventDefault()\n    if (isMagicLinkSent) return\n    setAuthLoading(true)\n    try {\n      const response = await signIn('email', {\n        email: emailValue,\n        redirect: false,\n      })\n      if (response?.error) {\n        if (response.error.includes('rate-limited'))\n          showToast({\n            status: 'info',\n            description: t('auth.signinErrorToast.tooManyRequests'),\n          })\n        else if (response.error.includes('sign-up-disabled'))\n          showToast({\n            title: t('auth.signinErrorToast.title'),\n            description: t('auth.signinErrorToast.description'),\n          })\n        else\n          showToast({\n            status: 'info',\n            description: t('errorMessage'),\n            details: {\n              content: 'Check server logs to see relevent error message.',\n              lang: 'json',\n            },\n          })\n      } else {\n        setIsMagicLinkSent(true)\n      }\n    } catch (e) {\n      showToast({\n        status: 'info',\n        description: 'An error occured while signing in',\n      })\n    }\n    setAuthLoading(false)\n  }\n\n  if (isLoadingProviders) return <Spinner />\n  if (hasNoAuthProvider)\n    return (\n      <Text>\n        {t('auth.noProvider.preLink')}{' '}\n        <TextLink\n          href=\"https://docs.typebot.io/self-hosting/configuration\"\n          isExternal\n        >\n          {t('auth.noProvider.link')}\n        </TextLink>\n      </Text>\n    )\n  return (\n    <Stack spacing=\"4\" w=\"330px\">\n      {!isMagicLinkSent && (\n        <>\n          <SocialLoginButtons providers={providers} />\n          {providers?.email && (\n            <>\n              <DividerWithText mt=\"6\">{t('auth.orEmailLabel')}</DividerWithText>\n              <HStack as=\"form\" onSubmit={handleEmailSubmit}>\n                <Input\n                  name=\"email\"\n                  type=\"email\"\n                  autoComplete=\"email\"\n                  placeholder=\"email@company.com\"\n                  required\n                  value={emailValue}\n                  onChange={handleEmailChange}\n                />\n                <Button\n                  type=\"submit\"\n                  isLoading={\n                    ['loading', 'authenticated'].includes(status) || authLoading\n                  }\n                  isDisabled={isMagicLinkSent}\n                >\n                  {t('auth.emailSubmitButton.label')}\n                </Button>\n              </HStack>\n            </>\n          )}\n        </>\n      )}\n      {router.query.error && (\n        <SignInError error={router.query.error.toString()} />\n      )}\n      <SlideFade offsetY=\"20px\" in={isMagicLinkSent} unmountOnExit>\n        <Flex>\n          <Alert status=\"success\" w=\"100%\">\n            <HStack>\n              <AlertIcon />\n              <Stack spacing={1}>\n                <Text fontWeight=\"semibold\">{t('auth.magicLink.title')}</Text>\n                <Text fontSize=\"sm\">{t('auth.magicLink.description')}</Text>\n              </Stack>\n            </HStack>\n          </Alert>\n        </Flex>\n      </SlideFade>\n    </Stack>\n  )\n}\n", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2025-24981", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "export const unsafeLinkPrefix = [\n  'javascript:',\n  'data:text/html',\n  'vbscript:',\n  'data:text/javascript',\n  'data:text/vbscript',\n  'data:text/css',\n  'data:text/plain',\n  'data:text/xml'\n]\n\nexport const validateProp = (attribute: string, value: string) => {\n  if (attribute.startsWith('on')) {\n    return false\n  }\n\n  if (attribute === 'href' || attribute === 'src') {\n    return !unsafeLinkPrefix.some(prefix => value.toLowerCase().startsWith(prefix))\n  }\n\n  return true\n}\n\nexport const validateProps = (type: string, props?: Record<string, any>) => {\n  if (!props) {\n    return {}\n  }\n  props = Object.fromEntries(\n    Object.entries(props).filter(([name, value]) => {\n      const isValid = validateProp(name, value)\n\n      if (!isValid) {\n        console.warn(`[@nuxtjs/mdc] removing unsafe attribute: ${name}=\"${value}\"`)\n      }\n\n      return isValid\n    })\n  )\n\n  if (type === 'pre') {\n    if (typeof props.highlights === 'string') {\n      props.highlights = props.highlights.split(' ').map(i => Number.parseInt(i))\n    }\n  }\n\n  return props\n}", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2025-27108", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "import { Aliases, BooleanAttributes, ChildProperties, Properties } from \"./constants\";\nimport { sharedConfig, root } from \"rxcore\";\nimport { createSerializer, getLocalHeaderScript } from \"./serializer\";\n\nexport { getOwner, createComponent, effect, memo, untrack } from \"rxcore\";\n\nexport {\n  Properties,\n  ChildProperties,\n  getPropAlias,\n  Aliases,\n  DOMElements,\n  SVGElements,\n  SVGNamespace,\n  DelegatedEvents\n} from \"./constants.js\";\n\n// Based on https://github.com/WebReflection/domtagger/blob/master/esm/sanitizer.js\nconst VOID_ELEMENTS =\n  /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;\nconst REPLACE_SCRIPT = `function $df(e,n,o,t){if(n=document.getElementById(e),o=document.getElementById(\"pl-\"+e)){for(;o&&8!==o.nodeType&&o.nodeValue!==\"pl-\"+e;)t=o.nextSibling,o.remove(),o=t;_$HY.done?o.remove():o.replaceWith(n.content)}n.remove(),_$HY.fe(e)}`;\n\nexport function renderToString(code, options = {}) {\n  const { renderId } = options;\n  let scripts = \"\";\n  const serializer = createSerializer({\n    scopeId: renderId,\n    onData(script) {\n      if (!scripts) {\n        scripts = getLocalHeaderScript(renderId);\n      }\n      scripts += script + \";\";\n    },\n    onError: options.onError\n  });\n  sharedConfig.context = {\n    id: renderId || \"\",\n    count: 0,\n    suspense: {},\n    lazy: {},\n    assets: [],\n    nonce: options.nonce,\n    serialize(id, p) {\n      !sharedConfig.context.noHydrate && serializer.write(id, p);\n    },\n    roots: 0,\n    nextRoot() {\n      return this.renderId + \"i-\" + this.roots++;\n    }\n  };\n  let html = root(d => {\n    setTimeout(d);\n    return resolveSSRNode(escape(code()));\n  });\n  sharedConfig.context.noHydrate = true;\n  serializer.close();\n  html = injectAssets(sharedConfig.context.assets, html);\n  if (scripts.length) html = injectScripts(html, scripts, options.nonce);\n  return html;\n}\n\nexport function renderToStringAsync(code, options = {}) {\n  const { timeoutMs = 30000 } = options;\n  let timeoutHandle;\n  const timeout = new Promise((_, reject) => {\n    timeoutHandle = setTimeout(() => reject(\"renderToString timed out\"), timeoutMs);\n  });\n  return Promise.race([renderToStream(code, options), timeout]).then(html => {\n    clearTimeout(timeoutHandle);\n    return html;\n  });\n}\n\nexport function renderToStream(code, options = {}) {\n  let { nonce, onCompleteShell, onCompleteAll, renderId, noScripts } = options;\n  let dispose;\n  const blockingPromises = [];\n  const pushTask = task => {\n    if (noScripts) return;\n    if (!tasks && !firstFlushed) {\n      tasks = getLocalHeaderScript(renderId);\n    }\n    tasks += task + \";\";\n    if (!timer && firstFlushed) {\n      timer = setTimeout(writeTasks);\n    }\n  };\n  const onDone = () => {\n    writeTasks();\n    doShell();\n    onCompleteAll &&\n      onCompleteAll({\n        write(v) {\n          !completed && buffer.write(v);\n        }\n      });\n    writable && writable.end();\n    completed = true;\n    if (firstFlushed) dispose();\n  };\n  const serializer = createSerializer({\n    scopeId: options.renderId,\n    onData: pushTask,\n    onDone,\n    onError: options.onError\n  });\n  const flushEnd = () => {\n    if (!registry.size) {\n      // We are no longer writing any resource\n      // now we just need to wait for the pending promises\n      // to resolve\n      queue(() => queue(() => serializer.flush())); // double queue because of elsewhere\n    }\n  };\n  const registry = new Map();\n  const writeTasks = () => {\n    if (tasks.length && !completed && firstFlushed) {\n      buffer.write(`<script${nonce ? ` nonce=\"${nonce}\"` : \"\"}>${tasks}</script>`);\n      tasks = \"\";\n    }\n    timer && clearTimeout(timer);\n    timer = null;\n  };\n\n  let context;\n  let writable;\n  let tmp = \"\";\n  let tasks = \"\";\n  let firstFlushed = false;\n  let completed = false;\n  let shellCompleted = false;\n  let scriptFlushed = false;\n  let timer = null;\n  let buffer = {\n    write(payload) {\n      tmp += payload;\n    }\n  };\n  sharedConfig.context = context = {\n    id: renderId || \"\",\n    count: 0,\n    async: true,\n    resources: {},\n    lazy: {},\n    suspense: {},\n    assets: [],\n    nonce,\n    block(p) {\n      if (!firstFlushed) blockingPromises.push(p);\n    },\n    replace(id, payloadFn) {\n      if (firstFlushed) return;\n      const placeholder = `<!--!$${id}-->`;\n      const first = html.indexOf(placeholder);\n      if (first === -1) return;\n      const last = html.indexOf(`<!--!$/${id}-->`, first + placeholder.length);\n      html = html.replace(\n        html.slice(first, last + placeholder.length + 1),\n        resolveSSRNode(payloadFn())\n      );\n    },\n    serialize(id, p, wait) {\n      const serverOnly = sharedConfig.context.noHydrate;\n      if (!firstFlushed && wait && typeof p === \"object\" && \"then\" in p) {\n        blockingPromises.push(p);\n        !serverOnly &&\n          p\n            .then(d => {\n              serializer.write(id, d);\n            })\n            .catch(e => {\n              serializer.write(id, e);\n            });\n      } else if (!serverOnly) serializer.write(id, p);\n    },\n    roots: 0,\n    nextRoot() {\n      return this.renderId + \"i-\" + this.roots++;\n    },\n    registerFragment(key) {\n      if (!registry.has(key)) {\n        let resolve, reject;\n        const p = new Promise((r, rej) => ((resolve = r), (reject = rej)));\n        // double queue to ensure that Suspense is last but in same flush\n        registry.set(key, err =>\n          queue(() =>\n            queue(() => {\n              err ? reject(err) : resolve(true);\n              queue(flushEnd);\n            })\n          )\n        );\n        serializer.write(key, p);\n      }\n      return (value, error) => {\n        if (registry.has(key)) {\n          const resolve = registry.get(key);\n          registry.delete(key);\n          if (waitForFragments(registry, key)) {\n            resolve();\n            return;\n          }\n          if (!completed) {\n            if (!firstFlushed) {\n              queue(() => (html = replacePlaceholder(html, key, value !== undefined ? value : \"\")));\n              resolve(error);\n            } else {\n              buffer.write(`<template id=\"${key}\">${value !== undefined ? value : \" \"}</template>`);\n              pushTask(`$df(\"${key}\")${!scriptFlushed ? \";\" + REPLACE_SCRIPT : \"\"}`);\n              resolve(error);\n              scriptFlushed = true;\n            }\n          }\n        }\n        return firstFlushed;\n      };\n    }\n  };\n\n  let html = root(d => {\n    dispose = d;\n    return resolveSSRNode(escape(code()));\n  });\n  function doShell() {\n    if (shellCompleted) return;\n    sharedConfig.context = context;\n    context.noHydrate = true;\n    html = injectAssets(context.assets, html);\n    if (tasks.length) html = injectScripts(html, tasks, nonce);\n    buffer.write(html);\n    tasks = \"\";\n    onCompleteShell &&\n      onCompleteShell({\n        write(v) {\n          !completed && buffer.write(v);\n        }\n      });\n    shellCompleted = true;\n  }\n  return {\n    then(fn) {\n      function complete() {\n        dispose();\n        fn(tmp);\n      }\n      if (onCompleteAll) {\n        let ogComplete = onCompleteAll;\n        onCompleteAll = options => {\n          ogComplete(options);\n          complete();\n        };\n      } else onCompleteAll = complete;\n      queue(flushEnd);\n    },\n    pipe(w) {\n      allSettled(blockingPromises).then(() => {\n        setTimeout(() => {\n          doShell();\n          buffer = writable = w;\n          buffer.write(tmp);\n          firstFlushed = true;\n          if (completed) {\n            dispose();\n            writable.end();\n          } else flushEnd();\n        });\n      });\n    },\n    pipeTo(w) {\n      return allSettled(blockingPromises).then(() => {\n        let resolve;\n        const p = new Promise(r => (resolve = r));\n        setTimeout(() => {\n          doShell();\n          const encoder = new TextEncoder();\n          const writer = w.getWriter();\n          writable = {\n            end() {\n              writer.releaseLock();\n              w.close();\n              resolve();\n            }\n          };\n          buffer = {\n            write(payload) {\n              writer.write(encoder.encode(payload));\n            }\n          };\n          buffer.write(tmp);\n          firstFlushed = true;\n          if (completed) {\n            dispose();\n            writable.end();\n          } else flushEnd();\n        });\n        return p;\n      });\n    }\n  };\n}\n\n// components\nexport function HydrationScript(props) {\n  const { nonce } = sharedConfig.context;\n  return ssr(generateHydrationScript({ nonce, ...props }));\n}\n\n// rendering\nexport function ssr(t, ...nodes) {\n  if (nodes.length) {\n    let result = \"\";\n\n    for (let i = 0; i < nodes.length; i++) {\n      result += t[i];\n      const node = nodes[i];\n      if (node !== undefined) result += resolveSSRNode(node);\n    }\n\n    t = result + t[nodes.length];\n  }\n\n  return { t };\n}\n\nexport function ssrClassList(value) {\n  if (!value) return \"\";\n  let classKeys = Object.keys(value),\n    result = \"\";\n  for (let i = 0, len = classKeys.length; i < len; i++) {\n    const key = classKeys[i],\n      classValue = !!value[key];\n    if (!key || key === \"undefined\" || !classValue) continue;\n    i && (result += \" \");\n    result += escape(key);\n  }\n  return result;\n}\n\nexport function ssrStyle(value) {\n  if (!value) return \"\";\n  if (typeof value === \"string\") return escape(value, true);\n  let result = \"\";\n  const k = Object.keys(value);\n  for (let i = 0; i < k.length; i++) {\n    const s = k[i];\n    const v = value[s];\n    if (v != undefined) {\n      if (i) result += \";\";\n      result += `${s}:${escape(v, true)}`;\n    }\n  }\n  return result;\n}\n\nexport function ssrElement(tag, props, children, needsId) {\n  if (props == null) props = {};\n  else if (typeof props === \"function\") props = props();\n  const skipChildren = VOID_ELEMENTS.test(tag);\n  const keys = Object.keys(props);\n  let result = `<${tag}${needsId ? ssrHydrationKey() : \"\"} `;\n  let classResolved;\n  for (let i = 0; i < keys.length; i++) {\n    const prop = keys[i];\n    if (ChildProperties.has(prop)) {\n      if (children === undefined && !skipChildren)\n        children = prop === \"innerHTML\" ? props[prop] : escape(props[prop]);\n      continue;\n    }\n    const value = props[prop];\n    if (prop === \"style\") {\n      result += `style=\"${ssrStyle(value)}\"`;\n    } else if (prop === \"class\" || prop === \"className\" || prop === \"classList\") {\n      if (classResolved) continue;\n      let n;\n      result += `class=\"${\n        escape(((n = props.class) ? n + \" \" : \"\") + ((n = props.className) ? n + \" \" : \"\"), true) +\n        ssrClassList(props.classList)\n      }\"`;\n      classResolved = true;\n    } else if (BooleanAttributes.has(prop)) {\n      if (value) result += prop;\n      else continue;\n    } else if (\n      value == undefined ||\n      prop === \"ref\" ||\n      prop.slice(0, 2) === \"on\" ||\n      prop.slice(0, 5) === \"prop:\"\n    ) {\n      continue;\n    } else if (prop.slice(0, 5) === \"bool:\") {\n      if (!value) continue;\n      result += escape(prop.slice(5));\n    } else if (prop.slice(0, 5) === \"attr:\") {\n      result += `${escape(prop.slice(5))}=\"${escape(value, true)}\"`;\n    } else {\n      result += `${Aliases[prop] || escape(prop)}=\"${escape(value, true)}\"`;\n    }\n    if (i !== keys.length - 1) result += \" \";\n  }\n\n  if (skipChildren) return { t: result + \"/>\" };\n  if (typeof children === \"function\") children = children();\n  return { t: result + `>${resolveSSRNode(children, true)}</${tag}>` };\n}\n\nexport function ssrAttribute(key, value, isBoolean) {\n  return isBoolean ? (value ? \" \" + key : \"\") : value != null ? ` ${key}=\"${value}\"` : \"\";\n}\n\nexport function ssrHydrationKey() {\n  const hk = getHydrationKey();\n  return hk ? ` data-hk=${hk}` : \"\";\n}\n\nexport function escape(s, attr) {\n  const t = typeof s;\n  if (t !== \"string\") {\n    if (!attr && t === \"function\") return escape(s());\n    if (!attr && Array.isArray(s)) {\n      for (let i = 0; i < s.length; i++) s[i] = escape(s[i]);\n      return s;\n    }\n    if (attr && t === \"boolean\") return String(s);\n    return s;\n  }\n  const delim = attr ? '\"' : \"<\";\n  const escDelim = attr ? \"&quot;\" : \"&lt;\";\n  let iDelim = s.indexOf(delim);\n  let iAmp = s.indexOf(\"&\");\n\n  if (iDelim < 0 && iAmp < 0) return s;\n\n  let left = 0,\n    out = \"\";\n\n  while (iDelim >= 0 && iAmp >= 0) {\n    if (iDelim < iAmp) {\n      if (left < iDelim) out += s.substring(left, iDelim);\n      out += escDelim;\n      left = iDelim + 1;\n      iDelim = s.indexOf(delim, left);\n    } else {\n      if (left < iAmp) out += s.substring(left, iAmp);\n      out += \"&amp;\";\n      left = iAmp + 1;\n      iAmp = s.indexOf(\"&\", left);\n    }\n  }\n\n  if (iDelim >= 0) {\n    do {\n      if (left < iDelim) out += s.substring(left, iDelim);\n      out += escDelim;\n      left = iDelim + 1;\n      iDelim = s.indexOf(delim, left);\n    } while (iDelim >= 0);\n  } else\n    while (iAmp >= 0) {\n      if (left < iAmp) out += s.substring(left, iAmp);\n      out += \"&amp;\";\n      left = iAmp + 1;\n      iAmp = s.indexOf(\"&\", left);\n    }\n\n  return left < s.length ? out + s.substring(left) : out;\n}\n\nexport function resolveSSRNode(node, top) {\n  const t = typeof node;\n  if (t === \"string\") return node;\n  if (node == null || t === \"boolean\") return \"\";\n  if (Array.isArray(node)) {\n    let prev = {};\n    let mapped = \"\";\n    for (let i = 0, len = node.length; i < len; i++) {\n      if (!top && typeof prev !== \"object\" && typeof node[i] !== \"object\") mapped += `<!--!$-->`;\n      mapped += resolveSSRNode((prev = node[i]));\n    }\n    return mapped;\n  }\n  if (t === \"object\") return node.t;\n  if (t === \"function\") return resolveSSRNode(node());\n  return String(node);\n}\n\nexport function mergeProps(...sources) {\n  const target = {};\n  for (let i = 0; i < sources.length; i++) {\n    let source = sources[i];\n    if (typeof source === \"function\") source = source();\n    if (source) {\n      const descriptors = Object.getOwnPropertyDescriptors(source);\n      for (const key in descriptors) {\n        if (key in target) continue;\n        Object.defineProperty(target, key, {\n          enumerable: true,\n          get() {\n            for (let i = sources.length - 1; i >= 0; i--) {\n              const v = (sources[i] || {})[key];\n              if (v !== undefined) return v;\n            }\n          }\n        });\n      }\n    }\n  }\n  return target;\n}\n\nexport function getHydrationKey() {\n  const hydrate = sharedConfig.context;\n  return hydrate && !hydrate.noHydrate && sharedConfig.getNextContextId();\n}\n\nexport function useAssets(fn) {\n  sharedConfig.context.assets.push(() => resolveSSRNode(fn()));\n}\n\nexport function getAssets() {\n  const assets = sharedConfig.context.assets;\n  let out = \"\";\n  for (let i = 0, len = assets.length; i < len; i++) out += assets[i]();\n  return out;\n}\n\nexport function generateHydrationScript({ eventNames = [\"click\", \"input\"], nonce } = {}) {\n  return `<script${\n    nonce ? ` nonce=\"${nonce}\"` : \"\"\n  }>window._$HY||(e=>{let t=e=>e&&e.hasAttribute&&(e.hasAttribute(\"data-hk\")?e:t(e.host&&e.host.nodeType?e.host:e.parentNode));[\"${eventNames.join(\n    '\", \"'\n  )}\"].forEach((o=>document.addEventListener(o,(o=>{if(!e.events)return;let s=t(o.composedPath&&o.composedPath()[0]||o.target);s&&!e.completed.has(s)&&e.events.push([s,o])}))))})(_$HY={events:[],completed:new WeakSet,r:{},fe(){}});</script><!--xs-->`;\n}\n\nexport function Hydration(props) {\n  if (!sharedConfig.context.noHydrate) return props.children;\n  const context = sharedConfig.context;\n  sharedConfig.context = {\n    ...context,\n    count: 0,\n    id: sharedConfig.getNextContextId(),\n    noHydrate: false\n  };\n  const res = props.children;\n  sharedConfig.context = context;\n  return res;\n}\n\nexport function NoHydration(props) {\n  if (sharedConfig.context)\n    sharedConfig.context.noHydrate = true;\n  return props.children;\n}\n\nfunction queue(fn) {\n  return Promise.resolve().then(fn);\n}\n\nfunction allSettled(promises) {\n  let length = promises.length;\n  return Promise.allSettled(promises).then(() => {\n    if (promises.length !== length) return allSettled(promises);\n    return;\n  });\n}\n\nfunction injectAssets(assets, html) {\n  if (!assets || !assets.length) return html;\n  let out = \"\";\n  for (let i = 0, len = assets.length; i < len; i++) out += assets[i]();\n  return html.replace(`</head>`, out + `</head>`);\n}\n\nfunction injectScripts(html, scripts, nonce) {\n  const tag = `<script${nonce ? ` nonce=\"${nonce}\"` : \"\"}>${scripts}</script>`;\n  const index = html.indexOf(\"<!--xs-->\");\n  if (index > -1) {\n    return html.slice(0, index) + tag + html.slice(index);\n  }\n  return html + tag;\n}\n\nfunction waitForFragments(registry, key) {\n  for (const k of [...registry.keys()].reverse()) {\n    if (key.startsWith(k)) return true;\n  }\n  return false;\n}\n\nfunction replacePlaceholder(html, key, value) {\n  const marker = `<template id=\"pl-${key}\">`;\n  const close = `<!--pl-${key}-->`;\n\n  const first = html.indexOf(marker);\n  if (first === -1) return html;\n  const last = html.indexOf(close, first + marker.length);\n\n  return html.slice(0, first) + value + html.slice(last + close.length);\n}\n\n// experimental\nexport const RequestContext = Symbol();\n\nexport function getRequestEvent() {\n  return globalThis[RequestContext]\n    ? globalThis[RequestContext].getStore() ||\n        (sharedConfig.context && sharedConfig.context.event) ||\n        console.log(\n          \"RequestEvent is missing. This is most likely due to accessing `getRequestEvent` non-managed async scope in a partially polyfilled environment. Try moving it above all `await` calls.\"\n        )\n    : undefined;\n}\n\n// consider deprecating\nexport function Assets(props) {\n  useAssets(() => props.children);\n}\n\n/* istanbul ignore next */\n/** @deprecated Replaced by renderToStream */\nexport function pipeToNodeWritable(code, writable, options = {}) {\n  if (options.onReady) {\n    options.onCompleteShell = ({ write }) => {\n      options.onReady({\n        write,\n        startWriting() {\n          stream.pipe(writable);\n        }\n      });\n    };\n  }\n  const stream = renderToStream(code, options);\n  if (!options.onReady) stream.pipe(writable);\n}\n\n/* istanbul ignore next */\n/** @deprecated Replaced by renderToStream */\nexport function pipeToWritable(code, writable, options = {}) {\n  if (options.onReady) {\n    options.onCompleteShell = ({ write }) => {\n      options.onReady({\n        write,\n        startWriting() {\n          stream.pipeTo(writable);\n        }\n      });\n    };\n  }\n  const stream = renderToStream(code, options);\n  if (!options.onReady) stream.pipeTo(writable);\n}\n\n/* istanbul ignore next */\n/** @deprecated Replaced by ssrElement */\nexport function ssrSpread(props, isSVG, skipChildren) {\n  let result = \"\";\n  if (props == null) return result;\n  if (typeof props === \"function\") props = props();\n  const keys = Object.keys(props);\n  let classResolved;\n  for (let i = 0; i < keys.length; i++) {\n    let prop = keys[i];\n    if (prop === \"children\") {\n      !skipChildren && console.warn(`SSR currently does not support spread children.`);\n      continue;\n    }\n    const value = props[prop];\n    if (prop === \"style\") {\n      result += `style=\"${ssrStyle(value)}\"`;\n    } else if (prop === \"class\" || prop === \"className\" || prop === \"classList\") {\n      if (classResolved) continue;\n      let n;\n      result += `class=\"${(n = props.class) ? n + \" \" : \"\"}${\n        (n = props.className) ? n + \" \" : \"\"\n      }${ssrClassList(props.classList)}\"`;\n      classResolved = true;\n    } else if (prop !== \"value\" && Properties.has(prop)) {\n      if (value) result += prop;\n      else continue;\n    } else if (\n      value == undefined ||\n      prop === \"ref\" ||\n      prop.slice(0, 2) === \"on\" ||\n      prop.slice(0, 5) === \"prop:\"\n    ) {\n      continue;\n    } else if (prop.slice(0, 5) === \"bool:\") {\n      if (!value) continue;\n      result += escape(prop.slice(5));\n    } else if (prop.slice(0, 5) === \"attr:\") {\n      result += `${escape(prop.slice(5))}=\"${escape(value, true)}\"`;\n    } else {\n      result += `${Aliases[prop] || escape(prop)}=\"${escape(value, true)}\"`;\n    }\n    if (i !== keys.length - 1) result += \" \";\n  }\n  return result;\n}\n\n// client-only APIs\n\nexport {\n  notSup as classList,\n  notSup as style,\n  notSup as insert,\n  notSup as spread,\n  notSup as delegateEvents,\n  notSup as dynamicProperty,\n  notSup as setAttribute,\n  notSup as setAttributeNS,\n  notSup as addEventListener,\n  notSup as render,\n  notSup as template,\n  notSup as setProperty,\n  notSup as className,\n  notSup as assign,\n  notSup as hydrate,\n  notSup as getNextElement,\n  notSup as getNextMatch,\n  notSup as getNextMarker,\n  notSup as runHydrationEvents\n};\n\nfunction notSup() {\n  throw new Error(\n    \"Client-only API called on the server side. Run client-only code in onMount, or conditionally run client-only component with <Show>.\"\n  );\n}", "output": {"vulnerability_count": 10, "vulnerabilities": [{"description": "This looks like a JavaScript template string. Are you missing a '$' in front of '{...}'?", "risk": "Medium", "conceptual_fix": "Not provided", "line": 21}, {"description": "This looks like a JavaScript template string. Are you missing a '$' in front of '{...}'?", "risk": "Medium", "conceptual_fix": "Not provided", "line": 21}, {"description": "This template literal looks like HTML and has interpolated variables. These variables are not HTML-encoded by default. If the variables contain HTML tags, these may be interpreted by the browser, resulting in cross-site scripting (XSS).", "risk": "Medium", "conceptual_fix": "Not provided", "line": 118}, {"description": "This template literal looks like HTML and has interpolated variables. These variables are not HTML-encoded by default. If the variables contain HTML tags, these may be interpreted by the browser, resulting in cross-site scripting (XSS).", "risk": "Medium", "conceptual_fix": "Not provided", "line": 208}, {"description": "Using non-static data to retrieve and run functions from the object is dangerous. If the data is user-controlled, it may allow executing arbitrary code.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 522}, {"description": "This template literal looks like HTML and has interpolated variables. These variables are not HTML-encoded by default. If the variables contain HTML tags, these may be interpreted by the browser, resulting in cross-site scripting (XSS).", "risk": "Medium", "conceptual_fix": "Not provided", "line": 527}, {"description": "This looks like a JavaScript template string. Are you missing a '$' in front of '{...}'?", "risk": "Medium", "conceptual_fix": "Not provided", "line": 531}, {"description": "Using non-static data to retrieve and run functions from the object is dangerous. If the data is user-controlled, it may allow executing arbitrary code.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 569}, {"description": "This template literal looks like HTML and has interpolated variables. These variables are not HTML-encoded by default. If the variables contain HTML tags, these may be interpreted by the browser, resulting in cross-site scripting (XSS).", "risk": "Medium", "conceptual_fix": "Not provided", "line": 574}, {"description": "This template literal looks like HTML and has interpolated variables. These variables are not HTML-encoded by default. If the variables contain HTML tags, these may be interpreted by the browser, resulting in cross-site scripting (XSS).", "risk": "Medium", "conceptual_fix": "Not provided", "line": 590}]}}
{"CVE": "CVE-2025-27109", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "import {\n  Owner,\n  createContext,\n  createMemo,\n  useContext,\n  runWithOwner,\n  catchError,\n  Accessor,\n  Setter,\n  Signal,\n  castError,\n  cleanNode,\n  createOwner\n} from \"./reactive.js\";\nimport type { JSX } from \"../jsx.js\";\n\nexport type Component<P = {}> = (props: P) => JSX.Element;\nexport type VoidProps<P = {}> = P & { children?: never };\nexport type VoidComponent<P = {}> = Component<VoidProps<P>>;\nexport type ParentProps<P = {}> = P & { children?: JSX.Element };\nexport type ParentComponent<P = {}> = Component<ParentProps<P>>;\nexport type FlowProps<P = {}, C = JSX.Element> = P & { children: C };\nexport type FlowComponent<P = {}, C = JSX.Element> = Component<FlowProps<P, C>>;\nexport type Ref<T> = T | ((val: T) => void);\nexport type ValidComponent = keyof JSX.IntrinsicElements | Component<any> | (string & {});\nexport type ComponentProps<T extends ValidComponent> = T extends Component<infer P>\n  ? P\n  : T extends keyof JSX.IntrinsicElements\n  ? JSX.IntrinsicElements[T]\n  : Record<string, unknown>;\n\nfunction resolveSSRNode(node: any): string {\n  const t = typeof node;\n  if (t === \"string\") return node;\n  if (node == null || t === \"boolean\") return \"\";\n  if (Array.isArray(node)) {\n    let prev = {};\n    let mapped = \"\";\n    for (let i = 0, len = node.length; i < len; i++) {\n      if (typeof prev !== \"object\" && typeof node[i] !== \"object\") mapped += `<!--!$-->`;\n      mapped += resolveSSRNode((prev = node[i]));\n    }\n    return mapped;\n  }\n  if (t === \"object\") return node.t;\n  if (t === \"function\") return resolveSSRNode(node());\n  return String(node);\n}\n\ntype SharedConfig = {\n  context?: HydrationContext;\n  getContextId(): string;\n  getNextContextId(): string;\n};\nexport const sharedConfig: SharedConfig = {\n  context: undefined,\n  getContextId() {\n    if (!this.context) throw new Error(`getContextId cannot be used under non-hydrating context`);\n    return getContextId(this.context.count);\n  },\n  getNextContextId() {\n    if (!this.context)\n      throw new Error(`getNextContextId cannot be used under non-hydrating context`);\n    return getContextId(this.context.count++);\n  }\n};\n\nfunction getContextId(count: number) {\n  const num = String(count),\n    len = num.length - 1;\n  return sharedConfig.context!.id + (len ? String.fromCharCode(96 + len) : \"\") + num;\n}\n\nfunction setHydrateContext(context?: HydrationContext): void {\n  sharedConfig.context = context;\n}\n\nfunction nextHydrateContext(): HydrationContext | undefined {\n  return sharedConfig.context\n    ? {\n        ...sharedConfig.context,\n        id: sharedConfig.getNextContextId(),\n        count: 0\n      }\n    : undefined;\n}\n\nexport function createUniqueId(): string {\n  return sharedConfig.getNextContextId();\n}\n\nexport function createComponent<T>(Comp: (props: T) => JSX.Element, props: T): JSX.Element {\n  if (sharedConfig.context && !sharedConfig.context.noHydrate) {\n    const c = sharedConfig.context;\n    setHydrateContext(nextHydrateContext());\n    const r = Comp(props || ({} as T));\n    setHydrateContext(c);\n    return r;\n  }\n  return Comp(props || ({} as T));\n}\n\nexport function mergeProps<T, U>(source: T, source1: U): T & U;\nexport function mergeProps<T, U, V>(source: T, source1: U, source2: V): T & U & V;\nexport function mergeProps<T, U, V, W>(\n  source: T,\n  source1: U,\n  source2: V,\n  source3: W\n): T & U & V & W;\nexport function mergeProps(...sources: any): any {\n  const target = {};\n  for (let i = 0; i < sources.length; i++) {\n    let source = sources[i];\n    if (typeof source === \"function\") source = source();\n    if (source) {\n      const descriptors = Object.getOwnPropertyDescriptors(source);\n      for (const key in descriptors) {\n        if (key in target) continue;\n        Object.defineProperty(target, key, {\n          enumerable: true,\n          get() {\n            for (let i = sources.length - 1; i >= 0; i--) {\n              let v,\n                s = sources[i];\n              if (typeof s === \"function\") s = s();\n              v = (s || {})[key];\n              if (v !== undefined) return v;\n            }\n          }\n        });\n      }\n    }\n  }\n  return target;\n}\n\nexport function splitProps<T extends object, K1 extends keyof T>(\n  props: T,\n  ...keys: [K1[]]\n): [Pick<T, K1>, Omit<T, K1>];\nexport function splitProps<T extends object, K1 extends keyof T, K2 extends keyof T>(\n  props: T,\n  ...keys: [K1[], K2[]]\n): [Pick<T, K1>, Pick<T, K2>, Omit<T, K1 | K2>];\nexport function splitProps<\n  T extends object,\n  K1 extends keyof T,\n  K2 extends keyof T,\n  K3 extends keyof T\n>(\n  props: T,\n  ...keys: [K1[], K2[], K3[]]\n): [Pick<T, K1>, Pick<T, K2>, Pick<T, K3>, Omit<T, K1 | K2 | K3>];\nexport function splitProps<\n  T extends object,\n  K1 extends keyof T,\n  K2 extends keyof T,\n  K3 extends keyof T,\n  K4 extends keyof T\n>(\n  props: T,\n  ...keys: [K1[], K2[], K3[], K4[]]\n): [Pick<T, K1>, Pick<T, K2>, Pick<T, K3>, Pick<T, K4>, Omit<T, K1 | K2 | K3 | K4>];\nexport function splitProps<\n  T extends object,\n  K1 extends keyof T,\n  K2 extends keyof T,\n  K3 extends keyof T,\n  K4 extends keyof T,\n  K5 extends keyof T\n>(\n  props: T,\n  ...keys: [K1[], K2[], K3[], K4[], K5[]]\n): [\n  Pick<T, K1>,\n  Pick<T, K2>,\n  Pick<T, K3>,\n  Pick<T, K4>,\n  Pick<T, K5>,\n  Omit<T, K1 | K2 | K3 | K4 | K5>\n];\nexport function splitProps<T>(props: T, ...keys: [(keyof T)[]]) {\n  const descriptors = Object.getOwnPropertyDescriptors(props),\n    split = (k: (keyof T)[]) => {\n      const clone: Partial<T> = {};\n      for (let i = 0; i < k.length; i++) {\n        const key = k[i];\n        if (descriptors[key]) {\n          Object.defineProperty(clone, key, descriptors[key]);\n          delete descriptors[key];\n        }\n      }\n      return clone;\n    };\n  return keys.map(split).concat(split(Object.keys(descriptors) as (keyof T)[]));\n}\n\nfunction simpleMap(\n  props: { each: any[]; children: Function; fallback?: string },\n  wrap: (fn: Function, item: any, i: number) => string\n) {\n  const list = props.each || [],\n    len = list.length,\n    fn = props.children;\n  if (len) {\n    let mapped = Array(len);\n    for (let i = 0; i < len; i++) mapped[i] = wrap(fn, list[i], i);\n    return mapped;\n  }\n  return props.fallback;\n}\n\nexport function For<T>(props: {\n  each: T[];\n  fallback?: string;\n  children: (item: T, index: () => number) => string;\n}) {\n  return simpleMap(props, (fn, item, i) => fn(item, () => i));\n}\n\n// non-keyed\nexport function Index<T>(props: {\n  each: T[];\n  fallback?: string;\n  children: (item: () => T, index: number) => string;\n}) {\n  return simpleMap(props, (fn, item, i) => fn(() => item, i));\n}\n\ntype RequiredParameter<T> = T extends () => unknown ? never : T;\n/**\n * Conditionally render its children or an optional fallback component\n * @description https://docs.solidjs.com/reference/components/show\n */\nexport function Show<T>(props: {\n  when: T | undefined | null | false;\n  keyed?: boolean;\n  fallback?: string;\n  children: string | ((item: NonNullable<T> | Accessor<NonNullable<T>>) => string);\n}): string {\n  let c: string | ((item: NonNullable<T> | Accessor<NonNullable<T>>) => string);\n  return props.when\n    ? typeof (c = props.children) === \"function\"\n      ? c(props.keyed ? props.when! : () => props.when as any)\n      : c\n    : props.fallback || \"\";\n}\n\nexport function Switch(props: {\n  fallback?: string;\n  children: MatchProps<unknown> | MatchProps<unknown>[];\n}) {\n  let conditions = props.children;\n  Array.isArray(conditions) || (conditions = [conditions]);\n\n  for (let i = 0; i < conditions.length; i++) {\n    const w = conditions[i].when;\n    if (w) {\n      const c = conditions[i].children;\n      return typeof c === \"function\" ? c(conditions[i].keyed ? w : () => w) : c;\n    }\n  }\n  return props.fallback || \"\";\n}\n\ntype MatchProps<T> = {\n  when: T | false;\n  keyed?: boolean;\n  children: string | ((item: NonNullable<T> | Accessor<NonNullable<T>>) => string);\n};\nexport function Match<T>(props: MatchProps<T>) {\n  return props;\n}\n\nexport function resetErrorBoundaries() {}\nexport function ErrorBoundary(props: {\n  fallback: string | ((err: any, reset: () => void) => string);\n  children: string;\n}) {\n  let error: any,\n    res: any,\n    clean: any,\n    sync = true;\n  const ctx = sharedConfig.context!;\n  const id = sharedConfig.getContextId();\n  function displayFallback() {\n    cleanNode(clean);\n    ctx.serialize(id, error);\n    setHydrateContext({ ...ctx, count: 0 });\n    const f = props.fallback;\n    return typeof f === \"function\" && f.length ? f(error, () => {}) : f;\n  }\n  createMemo(() => {\n    clean = Owner;\n    return catchError(\n      () => (res = props.children),\n      err => {\n        error = err;\n        !sync && ctx.replace(\"e\" + id, displayFallback);\n        sync = true;\n      }\n    );\n  });\n  if (error) return displayFallback();\n  sync = false;\n  return { t: `<!--!$e${id}-->${resolveSSRNode(res)}<!--!$/e${id}-->` };\n}\n\n// Suspense Context\nexport interface Resource<T> {\n  (): T | undefined;\n  state: \"unresolved\" | \"pending\" | \"ready\" | \"refreshing\" | \"errored\";\n  loading: boolean;\n  error: any;\n  latest: T | undefined;\n}\n\ntype SuspenseContextType = {\n  resources: Map<string, { loading: boolean; error: any }>;\n  completed: () => void;\n};\n\nexport type ResourceActions<T> = { mutate: Setter<T>; refetch: (info?: unknown) => void };\n\nexport type ResourceReturn<T> = [Resource<T>, ResourceActions<T>];\n\nexport type ResourceSource<S> = S | false | null | undefined | (() => S | false | null | undefined);\n\nexport type ResourceFetcher<S, T> = (k: S, info: ResourceFetcherInfo<T>) => T | Promise<T>;\n\nexport type ResourceFetcherInfo<T> = { value: T | undefined; refetching?: unknown };\n\nexport type ResourceOptions<T> = undefined extends T\n  ? {\n      initialValue?: T;\n      name?: string;\n      deferStream?: boolean;\n      ssrLoadFrom?: \"initial\" | \"server\";\n      storage?: () => Signal<T | undefined>;\n      onHydrated?: <S, T>(k: S, info: ResourceFetcherInfo<T>) => void;\n    }\n  : {\n      initialValue: T;\n      name?: string;\n      deferStream?: boolean;\n      ssrLoadFrom?: \"initial\" | \"server\";\n      storage?: (v?: T) => Signal<T | undefined>;\n      onHydrated?: <S, T>(k: S, info: ResourceFetcherInfo<T>) => void;\n    };\n\nconst SuspenseContext = createContext<SuspenseContextType>();\nlet resourceContext: any[] | null = null;\nexport function createResource<T, S = true>(\n  fetcher: ResourceFetcher<S, T>,\n  options?: ResourceOptions<undefined>\n): ResourceReturn<T | undefined>;\nexport function createResource<T, S = true>(\n  fetcher: ResourceFetcher<S, T>,\n  options: ResourceOptions<T>\n): ResourceReturn<T>;\nexport function createResource<T, S>(\n  source: ResourceSource<S>,\n  fetcher: ResourceFetcher<S, T>,\n  options?: ResourceOptions<undefined>\n): ResourceReturn<T | undefined>;\nexport function createResource<T, S>(\n  source: ResourceSource<S>,\n  fetcher: ResourceFetcher<S, T>,\n  options: ResourceOptions<T>\n): ResourceReturn<T>;\nexport function createResource<T, S>(\n  source: ResourceSource<S> | ResourceFetcher<S, T>,\n  fetcher?: ResourceFetcher<S, T> | ResourceOptions<T> | ResourceOptions<undefined>,\n  options: ResourceOptions<T> | ResourceOptions<undefined> = {}\n): ResourceReturn<T> | ResourceReturn<T | undefined> {\n  \n  if (typeof fetcher !== \"function\") {\n    source = true as ResourceSource<S>;\n    fetcher = source as ResourceFetcher<S, T>;\n    options = (fetcher || {}) as ResourceOptions<T> | ResourceOptions<undefined>;\n  }\n\n  const contexts = new Set<SuspenseContextType>();\n  const id = sharedConfig.getNextContextId();\n  let resource: { ref?: any; data?: T } = {};\n  let value = options.storage ? options.storage(options.initialValue)[0]() : options.initialValue;\n  let p: Promise<T> | T | null;\n  let error: any;\n  if (sharedConfig.context!.async && options.ssrLoadFrom !== \"initial\") {\n    resource = sharedConfig.context!.resources[id] || (sharedConfig.context!.resources[id] = {});\n    if (resource.ref) {\n      if (!resource.data && !resource.ref[0].loading && !resource.ref[0].error)\n        resource.ref[1].refetch();\n      return resource.ref;\n    }\n  }\n  const read = () => {\n    if (error) throw error;\n    const resolved =\n      options.ssrLoadFrom !== \"initial\" &&\n      sharedConfig.context!.async &&\n      \"data\" in sharedConfig.context!.resources[id];\n    if (!resolved && resourceContext) resourceContext.push(id);\n    if (!resolved && read.loading) {\n      const ctx = useContext(SuspenseContext);\n      if (ctx) {\n        ctx.resources.set(id, read);\n        contexts.add(ctx);\n      }\n    }\n    return resolved ? sharedConfig.context!.resources[id].data : value;\n  };\n  read.loading = false;\n  read.error = undefined as any;\n  read.state = \"initialValue\" in options ? \"ready\" : \"unresolved\";\n  Object.defineProperty(read, \"latest\", {\n    get() {\n      return read();\n    }\n  });\n  function load() {\n    const ctx = sharedConfig.context!;\n    if (!ctx.async)\n      return (read.loading = !!(typeof source === \"function\" ? (source as () => S)() : source));\n    if (ctx.resources && id in ctx.resources && \"data\" in ctx.resources[id]) {\n      value = ctx.resources[id].data;\n      return;\n    }\n    let lookup;\n    try {\n      resourceContext = [];\n      lookup = typeof source === \"function\" ? (source as () => S)() : source;\n      if (resourceContext.length) return;\n    } finally {\n      resourceContext = null;\n    }\n    if (!p) {\n      if (lookup == null || lookup === false) return;\n      p = (fetcher as ResourceFetcher<S, T>)(lookup, { value });\n    }\n    if (p != undefined && typeof p === \"object\" && \"then\" in p) {\n      read.loading = true;\n      read.state = \"pending\";\n      p = p\n        .then(res => {\n          read.loading = false;\n          read.state = \"ready\";\n          ctx.resources[id].data = res;\n          p = null;\n          notifySuspense(contexts);\n          return res;\n        })\n        .catch(err => {\n          read.loading = false;\n          read.state = \"errored\";\n          read.error = error = castError(err);\n          p = null;\n          notifySuspense(contexts);\n          throw error;\n        });\n      if (ctx.serialize) ctx.serialize(id, p, options.deferStream);\n      return p;\n    }\n    ctx.resources[id].data = p;\n    if (ctx.serialize) ctx.serialize(id, p);\n    p = null;\n    return ctx.resources[id].data;\n  }\n  if (options.ssrLoadFrom !== \"initial\") load();\n  return (resource.ref = [\n    read,\n    { refetch: load, mutate: (v: T) => (value = v) }\n  ] as ResourceReturn<T>);\n}\n\nexport function lazy<T extends Component<any>>(\n  fn: () => Promise<{ default: T }>\n): T & { preload: () => Promise<{ default: T }> } {\n  let p: Promise<{ default: T }> & { resolved?: T };\n  let load = (id?: string) => {\n    if (!p) {\n      p = fn();\n      p.then(mod => (p.resolved = mod.default));\n      if (id) sharedConfig.context!.lazy[id] = p;\n    }\n    return p;\n  };\n  const contexts = new Set<SuspenseContextType>();\n  const wrap: Component<ComponentProps<T>> & {\n    preload?: () => Promise<{ default: T }>;\n  } = props => {\n    const id = sharedConfig.context!.id;\n    let ref = sharedConfig.context!.lazy[id];\n    if (ref) p = ref;\n    else load(id);\n    if (p.resolved) return p.resolved(props);\n    const ctx = useContext(SuspenseContext);\n    const track = { loading: true, error: undefined };\n    if (ctx) {\n      ctx.resources.set(id, track);\n      contexts.add(ctx);\n    }\n    if (sharedConfig.context!.async) {\n      sharedConfig.context!.block(\n        p.then(() => {\n          track.loading = false;\n          notifySuspense(contexts);\n        })\n      );\n    }\n    return \"\";\n  };\n  wrap.preload = load;\n  return wrap as T & { preload: () => Promise<{ default: T }> };\n}\n\nfunction suspenseComplete(c: SuspenseContextType) {\n  for (const r of c.resources.values()) {\n    if (r.loading) return false;\n  }\n  return true;\n}\n\nfunction notifySuspense(contexts: Set<SuspenseContextType>) {\n  for (const c of contexts) {\n    if (!suspenseComplete(c)) {\n      continue;\n    }\n    c.completed();\n    contexts.delete(c);\n  }\n}\n\nexport function enableScheduling() {}\n\nexport function enableHydration() {}\n\nexport function startTransition(fn: () => any): void {\n  fn();\n}\n\nexport function useTransition(): [() => boolean, (fn: () => any) => void] {\n  return [\n    () => false,\n    fn => {\n      fn();\n    }\n  ];\n}\n\ntype HydrationContext = {\n  id: string;\n  count: number;\n  serialize: (id: string, v: Promise<any> | any, deferStream?: boolean) => void;\n  nextRoot: (v: any) => string;\n  replace: (id: string, replacement: () => any) => void;\n  block: (p: Promise<any>) => void;\n  resources: Record<string, any>;\n  suspense: Record<string, SuspenseContextType>;\n  registerFragment: (v: string) => (v?: string, err?: any) => boolean;\n  lazy: Record<string, Promise<any>>;\n  async?: boolean;\n  noHydrate: boolean;\n};\n\nexport function SuspenseList(props: {\n  children: string;\n  revealOrder: \"forwards\" | \"backwards\" | \"together\";\n  tail?: \"collapsed\" | \"hidden\";\n}) {\n  // TODO: support tail options\n  return props.children;\n}\n\nexport function Suspense(props: { fallback?: string; children: string }) {\n  let done: undefined | ((html?: string, error?: any) => boolean);\n  const ctx = sharedConfig.context!;\n  const id = sharedConfig.getContextId();\n  const o = createOwner();\n  const value: SuspenseContextType =\n    ctx.suspense[id] ||\n    (ctx.suspense[id] = {\n      resources: new Map<string, { loading: boolean; error: any }>(),\n      completed: () => {\n        const res = runSuspense();\n        if (suspenseComplete(value)) {\n          done!(resolveSSRNode(res));\n        }\n      }\n    });\n\n  function suspenseError(err: Error) {\n    if (!done || !done(undefined, err)) {\n      runWithOwner(o.owner!, () => {\n        throw err;\n      });\n    }\n  }\n\n  function runSuspense() {\n    setHydrateContext({ ...ctx, count: 0 });\n    cleanNode(o);\n    return runWithOwner(o, () =>\n      createComponent(SuspenseContext.Provider, {\n        value,\n        get children() {\n          return catchError(() => props.children, suspenseError);\n        }\n      })\n    );\n  }\n  const res = runSuspense();\n\n  // never suspended\n  if (suspenseComplete(value)) {\n    delete ctx.suspense[id];\n    return res;\n  }\n\n  done = ctx.async ? ctx.registerFragment(id) : undefined;\n  return catchError(() => {\n    if (ctx.async) {\n      setHydrateContext({ ...ctx, count: 0, id: ctx.id + \"0F\", noHydrate: true });\n      const res = {\n        t: `<template id=\"pl-${id}\"></template>${resolveSSRNode(props.fallback)}<!--pl-${id}-->`\n      };\n      setHydrateContext(ctx);\n      return res;\n    }\n    setHydrateContext({ ...ctx, count: 0, id: ctx.id + \"0F\" });\n    ctx.serialize(id, \"$$f\");\n    return props.fallback;\n  }, suspenseError);\n}", "output": {"vulnerability_count": 1, "vulnerabilities": [{"description": "This template literal looks like HTML and has interpolated variables. These variables are not HTML-encoded by default. If the variables contain HTML tags, these may be interpreted by the browser, resulting in cross-site scripting (XSS).", "risk": "Medium", "conceptual_fix": "Not provided", "line": 626}]}}
{"CVE": "CVE-2025-27145", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "\"use strict\";\n\n\nfunction goto_up2k() {\n    if (up2k === false)\n        return goto('bup');\n\n    if (!up2k)\n        return setTimeout(goto_up2k, 100);\n\n    up2k.init_deps();\n}\n\n\n// chrome requires https to use crypto.subtle,\n// usually it's undefined but some chromes throw on invoke\nvar up2k = null,\n    up2k_hooks = [],\n    hws = [],\n    hws_ok = 0,\n    hws_ng = false,\n    sha_js = WebAssembly ? 'hw' : 'ac',  // ff53,c57,sa11\n    m = 'will use ' + sha_js + ' instead of native sha512 due to';\n\ntry {\n    if (sread('nosubtle') || window.nosubtle)\n        throw 'chickenbit';\n    var cf = crypto.subtle || crypto.webkitSubtle;\n    cf.digest('SHA-512', new Uint8Array(1)).then(\n        function (x) { console.log('sha-ok'); up2k = up2k_init(cf); },\n        function (x) { console.log(m, x); up2k = up2k_init(false); }\n    );\n}\ncatch (ex) {\n    console.log(m, ex);\n    try {\n        up2k = up2k_init(false);\n    }\n    catch (ex) {\n        console.log('up2k init failed:', ex);\n        toast.err(10, 'could not initialze up2k\\n\\n' + basenames(ex));\n    }\n}\ntreectl.onscroll();\n\n\nfunction up2k_flagbus() {\n    var flag = {\n        \"id\": Math.floor(Math.random() * 1024 * 1024 * 1023 * 2),\n        \"ch\": new BroadcastChannel(\"up2k_flagbus\"),\n        \"ours\": false,\n        \"owner\": null,\n        \"wants\": null,\n        \"act\": false,\n        \"last_tx\": [\"x\", null]\n    };\n    var dbg = function (who, msg) {\n        console.log('flagbus(' + flag.id + '): [' + who + '] ' + msg);\n    };\n    flag.ch.onmessage = function (e) {\n        var who = e.data[0],\n            what = e.data[1];\n\n        if (who == flag.id) {\n            dbg(who, 'hi me (??)');\n            return;\n        }\n        flag.act = Date.now();\n        if (what == \"want\") {\n            // lowest id wins, don't care if that's us\n            if (who < flag.id) {\n                dbg(who, 'wants (ack)');\n                flag.wants = [who, flag.act];\n            }\n            else {\n                dbg(who, 'wants (ign)');\n            }\n        }\n        else if (what == \"have\") {\n            dbg(who, 'have');\n            flag.owner = [who, flag.act];\n        }\n        else if (what == \"give\") {\n            if (flag.owner && flag.owner[0] == who) {\n                flag.owner = null;\n                dbg(who, 'give (ok)');\n            }\n            else {\n                dbg(who, 'give, INVALID, ' + flag.owner);\n            }\n        }\n        else if (what == \"hi\") {\n            dbg(who, 'hi');\n            flag.ch.postMessage([flag.id, \"hey\"]);\n        }\n        else {\n            dbg('?', e.data);\n        }\n    };\n    var tx = function (now, msg) {\n        var td = now - flag.last_tx[1];\n        if (td > 500 || flag.last_tx[0] != msg) {\n            dbg('*', 'tx ' + msg);\n            flag.ch.postMessage([flag.id, msg]);\n            flag.last_tx = [msg, now];\n        }\n    };\n    var do_take = function (now) {\n        tx(now, \"have\");\n        flag.owner = [flag.id, now];\n        flag.ours = true;\n    };\n    var do_want = function (now) {\n        tx(now, \"want\");\n    };\n    flag.take = function (now) {\n        if (flag.ours) {\n            do_take(now);\n            return;\n        }\n        if (flag.owner && now - flag.owner[1] > 12000) {\n            flag.owner = null;\n        }\n        if (flag.wants && now - flag.wants[1] > 12000) {\n            flag.wants = null;\n        }\n        if (!flag.owner && !flag.wants) {\n            do_take(now);\n            return;\n        }\n        do_want(now);\n    };\n    flag.give = function () {\n        dbg('#', 'put give');\n        flag.ch.postMessage([flag.id, \"give\"]);\n        flag.owner = null;\n        flag.ours = false;\n    };\n    flag.ch.postMessage([flag.id, 'hi']);\n    return flag;\n}\n\n\nfunction U2pvis(act, btns, uc, st) {\n    var r = this;\n    r.act = act;\n    r.ctr = { \"ok\": 0, \"ng\": 0, \"bz\": 0, \"q\": 0 };\n    r.tab = [];\n    r.hq = {};\n    r.head = 0;\n    r.tail = -1;\n    r.wsz = 3;\n    r.npotato = 99;\n    r.modn = 0;\n    r.modv = 0;\n    r.mod0 = null;\n\n    var markup = {\n        '404': '<span class=\"err\">' + L.utl_404 + '</span>',\n        'ERROR': '<span class=\"err\">' + L.utl_err + '</span>',\n        'OS-error': '<span class=\"err\">' + L.utl_oserr + '</span>',\n        'found': '<span class=\"inf\">' + L.utl_found + '</span>',\n        'defer': '<span class=\"inf\">' + L.utl_defer + '</span>',\n        'YOLO': '<span class=\"inf\">' + L.utl_yolo + '</span>',\n        'done': '<span class=\"ok\">' + L.utl_done + '</span>',\n    };\n\n    r.addfile = function (entry, sz, draw) {\n        r.tab.push({\n            \"hn\": entry[0],\n            \"ht\": entry[1],\n            \"hp\": entry[2],\n            \"in\": 'q',\n            \"nh\": 0, //hashed\n            \"nd\": 0, //done\n            \"cb\": [], // bytes done in chunk\n            \"bt\": sz, // bytes total\n            \"bd\": 0,  // bytes done\n            \"bd0\": 0  // upload start\n        });\n        r.ctr[\"q\"]++;\n        if (!draw)\n            return;\n\n        r.drawcard(\"q\");\n        if (r.act == \"q\") {\n            r.addrow(r.tab.length - 1);\n        }\n        if (r.act == \"bz\") {\n            r.bzw();\n        }\n    };\n\n    r.is_act = function (card) {\n        if (uc.potato && !uc.fsearch)\n            return false;\n\n        if (r.act == \"done\")\n            return card == \"ok\" || card == \"ng\";\n\n        return r.act == card;\n    }\n\n    r.seth = function (nfile, field, html) {\n        var fo = r.tab[nfile];\n        field = ['hn', 'ht', 'hp'][field];\n        if (fo[field] === html)\n            return;\n\n        fo[field] = html;\n        if (!r.is_act(fo.in))\n            return;\n\n        var k = 'f' + nfile + '' + field.slice(1),\n            obj = ebi(k);\n\n        obj.innerHTML = field == 'ht' ? (markup[html] || html) : html;\n        if (field == 'hp') {\n            obj.style.color = '';\n            obj.style.background = '';\n            delete r.hq[nfile];\n        }\n    };\n\n    r.setab = function (nfile, nblocks) {\n        var t = [];\n        for (var a = 0; a < nblocks; a++)\n            t.push(0);\n\n        r.tab[nfile].cb = t;\n    };\n\n    r.setat = function (nfile, blocktab) {\n        var fo = r.tab[nfile], bd = 0;\n\n        for (var a = 0; a < blocktab.length; a++)\n            bd += blocktab[a];\n\n        fo.bd = bd;\n        fo.bd0 = bd;\n        fo.cb = blocktab;\n    };\n\n    r.perc = function (bd, bd0, sz, t0) {\n        var td = Date.now() - t0,\n            p = bd * 100.0 / sz,\n            nb = bd - bd0,\n            spd = nb / (td / 1000),\n            eta = spd ? (sz - bd) / spd : 3599;\n\n        return [p, s2ms(eta), spd / (1024 * 1024)];\n    };\n\n    r.hashed = function (fobj) {\n        var fo = r.tab[fobj.n],\n            nb = fo.bt * (++fo.nh / fo.cb.length),\n            p = r.perc(nb, 0, fobj.size, fobj.t_hashing);\n\n        fo.hp = f2f(p[0], 2) + '%, ' + p[1] + ', ' + f2f(p[2], 2) + ' MB/s';\n        if (!r.is_act(fo.in))\n            return;\n\n        var o1 = p[0] - 2, o2 = p[0] - 0.1, o3 = p[0];\n\n        r.hq[fobj.n] = [fo.hp, '#fff', 'linear-gradient(90deg, #025, #06a ' + o1 + '%, #09d ' + o2 + '%, #222 ' + o3 + '%, #222 99%, #555)'];\n    };\n\n    r.prog = function (fobj, nchunk, cbd) {\n        var fo = r.tab[fobj.n],\n            delta = cbd - fo.cb[nchunk];\n\n        fo.cb[nchunk] = cbd;\n        fo.bd += delta;\n\n        if (!fo.bd)\n            return;\n\n        var p = r.perc(fo.bd, fo.bd0, fo.bt, fobj.t_uploading);\n        fo.hp = f2f(p[0], 2) + '%, ' + p[1] + ', ' + f2f(p[2], 2) + ' MB/s';\n\n        if (!r.is_act(fo.in))\n            return;\n\n        var obj = ebi('f' + fobj.n + 'p'),\n            o1 = p[0] - 2, o2 = p[0] - 0.1, o3 = p[0];\n\n        if (!obj) {\n            var msg = [\n                \"act\", r.act,\n                \"in\", fo.in,\n                \"is_act\", r.is_act(fo.in),\n                \"head\", r.head,\n                \"tail\", r.tail,\n                \"nfile\", fobj.n,\n                \"name\", fobj.name,\n                \"sz\", fobj.size,\n                \"bytesDelta\", delta,\n                \"bytesDone\", fo.bd,\n            ],\n                m2 = '',\n                ds = QSA(\"#u2tab>tbody>tr>td:first-child>a:last-child\");\n\n            for (var a = 0; a < msg.length; a += 2)\n                m2 += msg[a] + '=' + msg[a + 1] + ', ';\n\n            console.log(m2);\n\n            for (var a = 0, aa = ds.length; a < aa; a++) {\n                var id = ds[a].parentNode.getAttribute('id').slice(1, -1);\n                console.log(\"dom %d/%d = [%s] in(%s) is_act(%s) %s\",\n                    a, aa, id, r.tab[id].in, r.is_act(fo.in), ds[a].textContent);\n            }\n\n            for (var a = 0, aa = r.tab.length; a < aa; a++)\n                if (r.is_act(r.tab[a].in))\n                    console.log(\"tab %d/%d = sz %s\", a, aa, r.tab[a].bt);\n\n            throw new Error('see console');\n        }\n\n        r.hq[fobj.n] = [fo.hp, '#fff', 'linear-gradient(90deg, #050, #270 ' + o1 + '%, #4b0 ' + o2 + '%, #222 ' + o3 + '%, #222 99%, #555)'];\n    };\n\n    r.move = function (nfile, newcat) {\n        var fo = r.tab[nfile],\n            oldcat = fo.in,\n            bz_act = r.act == \"bz\";\n\n        if (oldcat == newcat)\n            return;\n\n        fo.in = newcat;\n        r.ctr[oldcat]--;\n        r.ctr[newcat]++;\n\n        while (st.car < r.tab.length && has(['ok', 'ng'], r.tab[st.car].in))\n            st.car++;\n\n        r.drawcard(oldcat);\n        r.drawcard(newcat);\n        if (r.is_act(newcat)) {\n            r.tail = Math.max(r.tail, nfile + 1);\n            if (!ebi('f' + nfile))\n                r.addrow(nfile);\n        }\n        else if (r.is_act(oldcat)) {\n            while (r.head < Math.min(r.tab.length, r.tail) && r.precard[r.tab[r.head].in])\n                r.head++;\n\n            if (!bz_act) {\n                qsr(\"#f\" + nfile);\n            }\n        }\n        else return;\n\n        if (bz_act)\n            r.bzw();\n    };\n\n    r.bzw = function () {\n        var mod = 0,\n            t0 = Date.now(),\n            first = QS('#u2tab>tbody>tr:first-child');\n\n        if (!first)\n            return;\n\n        var last = QS('#u2tab>tbody>tr:last-child');\n        first = parseInt(first.getAttribute('id').slice(1));\n        last = parseInt(last.getAttribute('id').slice(1));\n\n        while (r.head - first > r.wsz) {\n            qsr('#f' + (first++));\n            mod++;\n        }\n        while (last - r.tail < r.wsz && last < r.tab.length - 1) {\n            var obj = ebi('f' + (++last));\n            if (!obj) {\n                r.addrow(last);\n                mod++;\n            }\n        }\n        if (mod && r.modn < 200 && ebi('repl').offsetTop) {\n            if (++r.modn >= 10) {\n                if (r.modn == 10)\n                    r.mod0 = Date.now();\n\n                r.modv += Date.now() - t0;\n            }\n\n            if (r.modn >= 200) {\n                var n = r.modn - 10,\n                    ipu = r.modv / n,\n                    spu = (Date.now() - r.mod0) / n,\n                    ir = spu / ipu;\n\n                console.log('bzw:', f2f(ipu, 2), ' spu:', f2f(spu, 2), ' ir:', f2f(ir, 2), ' tab:', r.tab.length);\n                // efficiency estimates;\n                // ir: 5=16% 4=50%,30% 27=100%\n                // ipu: 2.7=16% 2=30% 1.6=50% 1.8=100% (ng for big files)\n                if (ipu >= 1.5 && ir <= 9 && r.tab.length >= 1000 && r.tab[Math.floor(r.tab.length / 3)].bt <= 1024 * 1024 * 4)\n                    r.go_potato();\n            }\n        }\n    };\n\n    r.potatolabels = function () {\n        var ode = ebi('u2depotato'),\n            oen = ebi('u2enpotato');\n\n        if (!ode)\n            return;\n\n        ode.style.display = uc.potato ? '' : 'none';\n        oen.style.display = uc.potato ? 'none' : '';\n    }\n\n    r.potato = function () {\n        ebi('u2tabw').style.minHeight = '';\n        QS('#u2cards a[act=\"bz\"]').click();\n        timer[uc.potato ? \"add\" : \"rm\"](draw_potato);\n        timer[uc.potato ? \"rm\" : \"add\"](apply_html);\n        r.potatolabels();\n    };\n\n    r.go_potato = function () {\n        r.go_potato = noop;\n        var ode = mknod('div', 'u2depotato'),\n            oen = mknod('div', 'u2enpotato'),\n            u2f = ebi('u2foot'),\n            btn = ebi('potato');\n\n        ode.innerHTML = L.u_depot;\n        oen.innerHTML = L.u_enpot;\n\n        if (sread('potato') === null) {\n            btn.click();\n            toast.inf(30, L.u_gotpot);\n            sdrop('potato');\n        }\n\n        u2f.appendChild(ode);\n        u2f.appendChild(oen);\n        ode.onclick = oen.onclick = btn.onclick;\n        r.potatolabels();\n    };\n\n    function draw_potato() {\n        if (++r.npotato < 2)\n            return;\n\n        r.npotato = 0;\n        var html = [L.u_pott.format(r.ctr.ok, r.ctr.ng, r.ctr.bz, r.ctr.q)];\n\n        while (r.head < r.tab.length && has([\"ok\", \"ng\"], r.tab[r.head].in))\n            r.head++;\n\n        var act = null;\n        if (r.head < r.tab.length)\n            act = r.tab[r.head];\n\n        if (act)\n            html.push(\"<p>file {0} of {1} : &nbsp; {2} &nbsp; <code>{3}</code></p>\\n<div>{4}</div>\".format(\n                r.head + 1, r.tab.length, act.ht, act.hp, act.hn));\n\n        html = html.join('\\n');\n        if (r.hpotato == html)\n            return;\n\n        r.hpotato = html;\n        ebi('u2mu').innerHTML = html;\n    }\n\n    function apply_html() {\n        var oq = {}, n = 0;\n        for (var k in r.hq) {\n            var o = ebi('f' + k + 'p');\n            if (!o)\n                continue;\n\n            oq[k] = o;\n            n++;\n        }\n        if (!n)\n            return;\n\n        for (var k in oq) {\n            var o = oq[k],\n                v = r.hq[k];\n\n            o.innerHTML = v[0];\n            o.style.color = v[1];\n            o.style.background = v[2];\n        }\n        r.hq = {};\n    }\n\n    r.drawcard = function (cat) {\n        var cards = QSA('#u2cards>a>span');\n\n        if (cat == \"q\") {\n            cards[4].innerHTML = r.ctr[cat];\n            return;\n        }\n        if (cat == \"bz\") {\n            cards[3].innerHTML = r.ctr[cat];\n            return;\n        }\n\n        cards[2].innerHTML = r.ctr[\"ok\"] + r.ctr[\"ng\"];\n\n        if (cat == \"ng\") {\n            cards[1].innerHTML = r.ctr[cat];\n        }\n        if (cat == \"ok\") {\n            cards[0].innerHTML = r.ctr[cat];\n        }\n    };\n\n    r.changecard = function (card) {\n        r.act = card;\n        r.precard = has([\"ok\", \"ng\", \"done\"], r.act) ? {} : r.act == \"bz\" ? { \"ok\": 1, \"ng\": 1 } : { \"ok\": 1, \"ng\": 1, \"bz\": 1 };\n        r.postcard = has([\"ok\", \"ng\", \"done\"], r.act) ? { \"bz\": 1, \"q\": 1 } : r.act == \"bz\" ? { \"q\": 1 } : {};\n        r.head = -1;\n        r.tail = -1;\n        var html = [];\n        for (var a = 0; a < r.tab.length; a++) {\n            var rt = r.tab[a].in;\n            if (r.is_act(rt)) {\n                html.push(r.genrow(a, true));\n\n                r.tail = a;\n                if (r.head == -1)\n                    r.head = a;\n            }\n        }\n        if (r.head == -1) {\n            for (var a = 0; a < r.tab.length; a++) {\n                var rt = r.tab[a].in;\n                if (r.precard[rt]) {\n                    r.head = a + 1;\n                    r.tail = a;\n                }\n                else if (r.postcard[rt]) {\n                    r.head = a;\n                    r.tail = a - 1;\n                    break;\n                }\n            }\n        }\n\n        if (r.head < 0)\n            r.head = 0;\n\n        if (card == \"bz\") {\n            for (var a = r.head - 1; a >= r.head - r.wsz && a >= 0; a--) {\n                html.unshift(r.genrow(a, true).replace(/><td>/, \"><td>a \"));\n            }\n            for (var a = r.tail + 1; a <= r.tail + r.wsz && a < r.tab.length; a++) {\n                html.push(r.genrow(a, true).replace(/><td>/, \"><td>b \"));\n            }\n        }\n        var el = ebi('u2tab');\n        el.tBodies[0].innerHTML = html.join('\\n');\n        el.className = (uc.fsearch ? 'srch ' : 'up ') + r.act;\n    };\n\n    r.genrow = function (nfile, as_html) {\n        var row = r.tab[nfile],\n            td1 = '<td id=\"f' + nfile,\n            td = '</td>' + td1,\n            ret = td1 + 'n\">' + row.hn +\n                td + 't\">' + (markup[row.ht] || row.ht) +\n                td + 'p\" class=\"prog\">' + row.hp + '</td>';\n\n        if (as_html)\n            return '<tr id=\"f' + nfile + '\">' + ret + '</tr>';\n\n        var obj = mknod('tr', 'f' + nfile);\n        obj.innerHTML = ret;\n        return obj;\n    };\n\n    r.addrow = function (nfile) {\n        var tr = r.genrow(nfile);\n        ebi('u2tab').tBodies[0].appendChild(tr);\n    };\n\n    btns = QSA(btns + '>a[act]');\n    for (var a = 0; a < btns.length; a++) {\n        btns[a].onclick = function (e) {\n            ev(e);\n            var newtab = this.getAttribute('act');\n            var go = function () {\n                for (var b = 0; b < btns.length; b++) {\n                    btns[b].className = (\n                        btns[b].getAttribute('act') == newtab) ? 'act' : '';\n                }\n                r.changecard(newtab);\n            }\n            var nf = r.ctr[newtab];\n            if (nf === undefined)\n                nf = r.ctr[\"ok\"] + r.ctr[\"ng\"];\n\n            if (nf < 9000)\n                return go();\n\n            modal.confirm(L.u_bigtab.format(nf), go, null);\n        };\n    }\n\n    r.changecard(r.act);\n    r.potato();\n}\n\n\nfunction Donut(uc, st) {\n    var r = this,\n        el = null,\n        psvg = null,\n        tenstrobe = null,\n        tstrober = null,\n        strobes = [],\n        o = 20 * 2 * Math.PI,\n        optab = QS('#ops a[data-dest=\"up2k\"]');\n\n    optab.setAttribute('ico', optab.textContent);\n\n    function svg(v) {\n        var ico = v !== undefined,\n            bg = ico ? '#333' : 'transparent',\n            fg = '#fff',\n            fsz = 52,\n            rc = 32;\n\n        if (r.eta && (r.eta > 99 || (uc.fsearch ? st.time.hashing : st.time.uploading) < 20))\n            r.eta = null;\n\n        if (r.eta) {\n            if (r.eta < 10) {\n                fg = '#fa0';\n                fsz = 72;\n            }\n            rc = 8;\n        }\n\n        return (\n            '<svg version=\"1.1\" viewBox=\"0 0 64 64\" xmlns=\"http://www.w3.org/2000/svg\">\\n' +\n            (ico ? '<rect width=\"100%\" height=\"100%\" rx=\"' + rc + '\" fill=\"#333\" />\\n' :\n                '<circle stroke=\"white\" stroke-width=\"6\" r=\"3\" cx=\"32\" cy=\"32\" />\\n') +\n            (r.eta ? (\n                '<text x=\"55%\" y=\"58%\" dominant-baseline=\"middle\" text-anchor=\"middle\"' +\n                ' font-family=\"sans-serif\" font-weight=\"bold\" font-size=\"' + fsz + 'px\"' +\n                ' fill=\"' + fg + '\">' + r.eta + '</text></svg>'\n            ) : (\n                '<circle class=\"donut\" stroke=\"white\" fill=\"' + bg +\n                '\" stroke-dashoffset=\"' + (ico ? v : o) + '\" stroke-dasharray=\"' + o + ' ' + o +\n                '\" transform=\"rotate(270 32 32)\" stroke-width=\"12\" r=\"20\" cx=\"32\" cy=\"32\" /></svg>'\n            ))\n        );\n    }\n\n    function pos() {\n        return uc.fsearch ?\n            Math.max(st.bytes.hashed, st.bytes.finished) :\n            st.bytes.inflight + st.bytes.finished;\n    }\n\n    r.on = function (ya) {\n        r.fc = r.tc = r.dc = 99;\n        r.eta = null;\n        r.base = pos();\n        optab.innerHTML = ya ? svg() : optab.getAttribute('ico');\n        el = QS('#ops a .donut');\n        clearTimeout(tenstrobe);\n        if (!ya) {\n            favico.upd();\n            wintitle();\n            if (document.visibilityState == 'hidden')\n                tenstrobe = setTimeout(r.enstrobe, 500); //debounce\n        }\n    };\n\n    r.do = function () {\n        if (!el)\n            return;\n\n        var t = st.bytes.total - r.base,\n            v = pos() - r.base,\n            ofs = o - o * v / t;\n\n        if (!uc.potato || ++r.dc >= 4) {\n            el.style.strokeDashoffset = ofs;\n            r.dc = 0;\n        }\n\n        if (++r.tc >= 10) {\n            var s = r.eta === null ? 'paused' : r.eta > 60 ? shumantime(r.eta) : (r.eta + 's');\n            wintitle(\"{0}%, {1}, #{2}, \".format(\n                f2f(v * 100 / t, 1), s, st.files.length - st.nfile.upload), true);\n            r.tc = 0;\n        }\n\n        if (favico.txt) {\n            if (++r.fc < 10 && r.eta && r.eta > 99)\n                return;\n\n            var s = svg(ofs);\n            if (s == psvg || (r.eta === null && r.fc < 10))\n                return;\n\n            favico.upd('', s);\n            psvg = s;\n            r.fc = 0;\n        }\n    };\n\n    r.enstrobe = function () {\n        strobes = ['', '________________', ''];\n        tstrober = setInterval(strobe, 300);\n\n        if (uc.upsfx && actx && actx.state != 'suspended')\n            sfx();\n\n        // firefox may forget that filedrops are user-gestures so it can skip this:\n        if (uc.upnag && Notification && Notification.permission == 'granted')\n            new Notification(uc.nagtxt);\n    }\n\n    function strobe() {\n        var txt = strobes.pop();\n        wintitle(txt, false);\n        if (!txt)\n            clearInterval(tstrober);\n    }\n\n    function sfx() {\n        var osc = actx.createOscillator(),\n            gain = actx.createGain(),\n            gg = gain.gain,\n            ft = [660, 880, 440, 660, 880],\n            ofs = 0;\n\n        osc.connect(gain);\n        gain.connect(actx.destination);\n        var ct = actx.currentTime + 0.03;\n\n        osc.type = 'triangle';\n        while (ft.length)\n            osc.frequency.setTargetAtTime(\n                ft.shift(), ct + (ofs += 0.05), 0.001);\n\n        gg.value = 0.15;\n        gg.setTargetAtTime(0.8, ct, 0.01);\n        gg.setTargetAtTime(0.3, ct + 0.13, 0.01);\n        gg.setTargetAtTime(0, ct + ofs + 0.05, 0.02);\n\n        osc.start();\n        setTimeout(function () {\n            osc.stop();\n            osc.disconnect();\n            gain.disconnect();\n        }, 500);\n    }\n}\n\n\nfunction fsearch_explain(n) {\n    if (n)\n        return toast.inf(60, L.ue_ro + (acct == '*' ? L.ue_nl : L.ue_la).format(acct));\n\n    if (bcfg_get('fsearch', false))\n        return toast.inf(60, L.ue_sr);\n\n    return toast.inf(60, L.ue_ta);\n}\n\n\nfunction up2k_init(subtle) {\n    var r = {\n        \"tact\": Date.now(),\n        \"init_deps\": init_deps,\n        \"set_fsearch\": set_fsearch,\n        \"gotallfiles\": [gotallfiles]  // hooks\n    };\n\n    setTimeout(function () {\n        if (WebAssembly && !hws.length)\n            fetch(SR + '/.cpr/w.hash.js?_=' + TS);\n    }, 1000);\n\n    function showmodal(msg) {\n        ebi('u2notbtn').innerHTML = msg;\n        ebi('u2btn').style.display = 'none';\n        ebi('u2notbtn').style.display = 'block';\n        ebi('u2conf').style.opacity = '0.5';\n    }\n\n    function unmodal() {\n        ebi('u2notbtn').style.display = 'none';\n        ebi('u2conf').style.opacity = '1';\n        ebi('u2btn').style.display = '';\n        ebi('u2notbtn').innerHTML = '';\n    }\n\n    var suggest_up2k = L.u_su2k;\n\n    function got_deps() {\n        return subtle || window.asmCrypto || window.hashwasm;\n    }\n\n    var loading_deps = false;\n    function init_deps() {\n        if (!loading_deps && !got_deps()) {\n            var fn = 'sha512.' + sha_js + '.js',\n                m = L.u_https1 + ' <a href=\"' + (location + '').replace(':', 's:') + '\">' + L.u_https2 + '</a> ' + L.u_https3;\n\n            showmodal('<h1>loading ' + fn + '</h1>');\n            import_js(SR + '/.cpr/deps/' + fn, unmodal);\n\n            if (HTTPS) {\n                // chrome<37 firefox<34 edge<12 opera<24 safari<7\n                m = L.u_ancient;\n                setmsg('');\n            }\n            qsr('#u2depmsg');\n            var o = mknod('div', 'u2depmsg');\n            o.innerHTML = m;\n            ebi('u2foot').appendChild(o);\n        }\n        loading_deps = true;\n    }\n\n    if (perms.length && !has(perms, 'read') && has(perms, 'write'))\n        goto('up2k');\n\n    function setmsg(msg, type) {\n        if (msg !== undefined) {\n            ebi('u2err').className = type;\n            ebi('u2err').innerHTML = msg;\n        }\n        else {\n            ebi('u2err').className = '';\n            ebi('u2err').innerHTML = '';\n        }\n        if (msg == suggest_up2k) {\n            ebi('u2yea').onclick = function (e) {\n                ev(e);\n                goto('up2k');\n            };\n        }\n    }\n\n    function un2k(msg) {\n        setmsg(msg, 'err');\n        return false;\n    }\n\n    setmsg(suggest_up2k, 'msg');\n\n    var u2szs = u2sz.split(','),\n        u2sz_min = parseInt(u2szs[0]),\n        u2sz_tgt = parseInt(u2szs[1]),\n        u2sz_max = parseInt(u2szs[2]);\n\n    var parallel_uploads = ebi('nthread').value = icfg_get('nthread', u2j),\n        stitch_tgt = ebi('u2szg').value = icfg_get('u2sz', u2sz_tgt),\n        uc = {},\n        fdom_ctr = 0,\n        biggest_file = 0;\n\n    bcfg_bind(uc, 'rand', 'u2rand', false, null, false);\n    bcfg_bind(uc, 'multitask', 'multitask', true, null, false);\n    bcfg_bind(uc, 'potato', 'potato', false, set_potato, false);\n    bcfg_bind(uc, 'ask_up', 'ask_up', true, null, false);\n    bcfg_bind(uc, 'umod', 'umod', false, null, false);\n    bcfg_bind(uc, 'u2ts', 'u2ts', !u2ts.endsWith('u'), set_u2ts, false);\n    bcfg_bind(uc, 'fsearch', 'fsearch', false, set_fsearch, false);\n\n    bcfg_bind(uc, 'flag_en', 'flag_en', false, apply_flag_cfg);\n    bcfg_bind(uc, 'turbo', 'u2turbo', turbolvl > 1, draw_turbo);\n    bcfg_bind(uc, 'datechk', 'u2tdate', turbolvl < 3, null);\n    bcfg_bind(uc, 'az', 'u2sort', u2sort.indexOf('n') + 1, set_u2sort);\n    bcfg_bind(uc, 'hashw', 'hashw', !!WebAssembly && !(CHROME && MOBILE) && (!subtle || !CHROME), set_hashw);\n    bcfg_bind(uc, 'upnag', 'upnag', false, set_upnag);\n    bcfg_bind(uc, 'upsfx', 'upsfx', false, set_upsfx);\n\n    uc.ow = parseInt(sread('u2ow', ['0', '1', '2']) || u2ow);\n    uc.owt = ['', '', ''];\n    function set_ow() {\n        QS('label[for=\"u2ow\"]').innerHTML = uc.owt[uc.ow];\n        ebi('u2ow').checked  = true; //cosmetic\n    }\n    ebi('u2ow').onclick = function (e) {\n        ev(e);\n        if (++uc.ow > 2)\n            uc.ow = 0;\n        swrite('u2ow', uc.ow);\n        set_ow();\n        if (uc.ow && !has(perms, 'delete'))\n            toast.warn(10, L.u_enoow, 'noow');\n        else if (toast.tag == 'noow')\n            toast.hide();\n    };\n    set_ow();\n\n    var st = {\n        \"files\": [],\n        \"nfile\": {\n            \"hash\": 0,\n            \"upload\": 0\n        },\n        \"seen\": {},\n        \"todo\": {\n            \"head\": [],\n            \"hash\": [],\n            \"handshake\": [],\n            \"upload\": []\n        },\n        \"busy\": {\n            \"head\": [],\n            \"hash\": [],\n            \"handshake\": [],\n            \"upload\": []\n        },\n        \"bytes\": {\n            \"total\": 0,\n            \"hashed\": 0,\n            \"inflight\": 0,\n            \"uploaded\": 0,\n            \"finished\": 0\n        },\n        \"time\": {\n            \"hashing\": 0.01,\n            \"uploading\": 0.01,\n            \"busy\": 0.01\n        },\n        \"eta\": {\n            \"h\": \"\",\n            \"u\": \"\",\n            \"t\": \"\"\n        },\n        \"etaw\": {\n            \"h\": [['', 0, 0, 0]],\n            \"u\": [['', 0, 0, 0]],\n            \"t\": [['', 0, 0, 0]]\n        },\n        \"etac\": {\n            \"h\": 0,\n            \"u\": 0,\n            \"t\": 0\n        },\n        \"car\": 0,\n        \"slow_io\": null,\n        \"oserr\": false,\n        \"modn\": 0,\n        \"modv\": 0,\n        \"mod0\": null\n    };\n\n    function push_t(arr, t) {\n        var sort = arr.length && arr[arr.length - 1].n > t.n;\n        arr.push(t);\n        if (sort)\n            arr.sort(function (a, b) {\n                return a.n < b.n ? -1 : 1;\n            });\n    }\n\n    var pvis = new U2pvis(\"bz\", '#u2cards', uc, st),\n        donut = new Donut(uc, st);\n\n    r.ui = pvis;\n    r.st = st;\n    r.uc = uc;\n\n    if (!window.File || !window.FileReader || !window.FileList || !File.prototype || !File.prototype.slice)\n        return un2k(L.u_ever);\n\n    var flag = false;\n    apply_flag_cfg();\n    set_fsearch();\n\n    function nav() {\n        start_actx();\n\n        var uf = function () { ebi('file' + fdom_ctr).click(); },\n            ud = function () { ebi('dir' + fdom_ctr).click(); };\n\n        // too buggy on chrome <= 72\n        var m = / Chrome\\/([0-9]+)\\./.exec(UA);\n        if (m && parseInt(m[1]) < 73)\n            return uf();\n\n        // phones dont support folder upload\n        if (MOBILE)\n            return uf();\n\n        modal.confirm(L.u_nav_m, uf, ud, null, L.u_nav_b);\n    }\n    ebi('u2btn').onclick = nav;\n\n    var nenters = 0;\n    function ondrag(e) {\n        if (++nenters <= 0)\n            nenters = 1;\n\n        if (onover.call(this, e))\n            return true;\n\n        var mup, up = QS('#up_zd');\n        var msr, sr = QS('#srch_zd');\n        if (!has(perms, 'write'))\n            mup = L.u_ewrite;\n        if (!has(perms, 'read'))\n            msr = L.u_eread;\n        if (!have_up2k_idx)\n            msr = L.u_enoi;\n\n        up.querySelector('span').textContent = mup || L.udt_drop;\n        sr.querySelector('span').textContent = msr || L.udt_drop;\n        clmod(up, 'err', mup);\n        clmod(sr, 'err', msr);\n        clmod(up, 'ok', !mup);\n        clmod(sr, 'ok', !msr);\n        ebi('up_dz').setAttribute('err', mup || '');\n        ebi('srch_dz').setAttribute('err', msr || '');\n    }\n    function onoverb(e) {\n        // zones are alive; disable cuo2duo branch\n        document.body.ondragover = document.body.ondrop = null;\n        return onover.call(this, e);\n    }\n    function onover(e) {\n        return onovercmn(this, e, false);\n    }\n    function onoverbtn(e) {\n        return onovercmn(this, e, true);\n    }\n    function onovercmn(self, e, btn) {\n        try {\n            var ok = false, dt = e.dataTransfer.types;\n            for (var a = 0; a < dt.length; a++)\n                if (dt[a] == 'Files')\n                    ok = true;\n                else if (dt[a] == 'text/uri-list') {\n                    if (btn) {\n                        ok = true;\n                        if (toast.txt == L.u_uri)\n                            toast.hide();\n                    }\n                    else\n                        return toast.inf(10, L.u_uri) || true;\n                }\n\n            if (!ok)\n                return true;\n        }\n        catch (ex) { }\n\n        ev(e);\n        try {\n            e.dataTransfer.dropEffect = 'copy';\n            e.dataTransfer.effectAllowed = 'copy';\n        }\n        catch (ex) {\n            document.body.ondragenter = document.body.ondragleave = document.body.ondragover = null;\n            return modal.alert(L.u_nodrop);\n        }\n        if (btn)\n            return;\n\n        clmod(ebi('drops'), 'vis', 1);\n        var v = self.getAttribute('v');\n        if (v)\n            clmod(ebi(v), 'hl', 1);\n    }\n    function offdrag(e) {\n        noope(e);\n\n        var v = this.getAttribute('v');\n        if (v)\n            clmod(ebi(v), 'hl');\n\n        if (--nenters <= 0) {\n            clmod(ebi('drops'), 'vis');\n            clmod(ebi('up_dz'), 'hl');\n            clmod(ebi('srch_dz'), 'hl');\n            // cuo2duo:\n            document.body.ondragover = onover;\n            document.body.ondrop = gotfile;\n        }\n    }\n    document.body.ondragenter = ondrag;\n    document.body.ondragleave = offdrag;\n    document.body.ondragover = onover;\n    document.body.ondrop = gotfile;\n    ebi('u2btn').ondrop = gotfile;\n    ebi('u2btn').ondragover = onoverbtn;\n\n    var drops = [ebi('up_dz'), ebi('srch_dz')];\n    for (var a = 0; a < 2; a++) {\n        drops[a].ondragenter = ondrag;\n        drops[a].ondragover = onoverb;\n        drops[a].ondragleave = offdrag;\n        drops[a].ondrop = gotfile;\n    }\n    ebi('drops').onclick = offdrag;  // old ff\n\n    function gotdir(e) {\n        ev(e);\n        var good_files = [],\n            nil_files = [],\n            bad_files = [];\n\n        for (var a = 0, aa = e.target.files.length; a < aa; a++) {\n            var fobj = e.target.files[a],\n                name = fobj.webkitRelativePath,\n                dst = good_files;\n\n            try {\n                if (!name)\n                    throw 1;\n\n                if (fobj.size < 1)\n                    dst = nil_files;\n            }\n            catch (ex) {\n                dst = bad_files;\n            }\n            dst.push([fobj, name]);\n        }\n\n        if (!good_files.length && bad_files.length)\n            return toast.err(30, L.u_notdir);\n\n        return read_dirs(null, [], [], good_files, nil_files, bad_files);\n    }\n\n    function gotfile(e) {\n        ev(e);\n        nenters = 0;\n        offdrag.call(this);\n        var dz = this && this.getAttribute('id');\n        if (!dz && e && e.clientY)\n            // cuo2duo fallback\n            dz = e.clientY < window.innerHeight / 2 ? 'up_dz' : 'srch_dz';\n\n        var err = this.getAttribute('err');\n        if (err)\n            return modal.alert('sorry, ' + err);\n\n        toast.inf(0, L.u_scan);\n\n        if ((dz == 'up_dz' && uc.fsearch) || (dz == 'srch_dz' && !uc.fsearch))\n            tgl_fsearch();\n\n        if (!QS('#op_up2k.act'))\n            goto('up2k');\n\n        var files,\n            is_itemlist = false;\n\n        if (e.dataTransfer) {\n            if (e.dataTransfer.items) {\n                files = e.dataTransfer.items; // DataTransferItemList\n                is_itemlist = true;\n            }\n            else files = e.dataTransfer.files; // FileList\n        }\n        else files = e.target.files;\n\n        if (!files || !files.length)\n            return toast.err(0, 'no files selected??');\n\n        more_one_file();\n        var bad_files = [],\n            nil_files = [],\n            good_files = [],\n            dirs = [];\n\n        for (var a = 0; a < files.length; a++) {\n            var fobj = files[a],\n                dst = good_files;\n\n            if (is_itemlist) {\n                if (fobj.kind !== 'file' && fobj.type !== 'text/uri-list')\n                    continue;\n\n                try {\n                    var wi = fobj.getAsEntry ? fobj.getAsEntry() : fobj.webkitGetAsEntry();\n                    if (wi.isDirectory) {\n                        dirs.push(wi);\n                        continue;\n                    }\n                }\n                catch (ex) { }\n                fobj = fobj.getAsFile();\n                if (!fobj)\n                    continue;\n            }\n            try {\n                if (fobj.size < 1)\n                    dst = nil_files;\n            }\n            catch (ex) {\n                dst = bad_files;\n            }\n            dst.push([fobj, fobj.name]);\n        }\n        start_actx();  // good enough for chrome; not firefox\n        return read_dirs(null, [], dirs, good_files, nil_files, bad_files);\n    }\n\n    function rd_flatten(pf, dirs) {\n        var ret = jcp(pf);\n        for (var a = 0; a < dirs.length; a++)\n            ret.push(dirs.fullPath || '');\n\n        ret.sort();\n        return ret;\n    }\n\n    var rd_missing_ref = [];\n    function read_dirs(rd, pf, dirs, good, nil, bad, spins) {\n        spins = spins || 0;\n        if (++spins == 5)\n            rd_missing_ref = rd_flatten(pf, dirs);\n\n        if (spins == 200) {\n            var missing = rd_flatten(pf, dirs),\n                match = rd_missing_ref.length == missing.length,\n                aa = match ? missing.length : 0;\n\n            missing.sort();\n            for (var a = 0; a < aa; a++)\n                if (rd_missing_ref[a] != missing[a])\n                    match = false;\n\n            if (match) {\n                var msg = [L.u_dirstuck.format(missing.length) + '<ul>'];\n                for (var a = 0; a < Math.min(20, missing.length); a++)\n                    msg.push('<li>' + esc(missing[a]) + '</li>');\n\n                return modal.alert(msg.join('') + '</ul>', function () {\n                    read_dirs(rd, [], [], good, nil, bad, spins);\n                });\n            }\n            spins = 0;\n        }\n\n        if (!dirs.length) {\n            if (!pf.length)\n                // call first hook, pass list of remaining hooks to call\n                return r.gotallfiles[0](good, nil, bad, r.gotallfiles.slice(1));\n\n            console.log(\"retry pf, \" + pf.length);\n            setTimeout(function () {\n                read_dirs(rd, pf, dirs, good, nil, bad, spins);\n            }, 50);\n            return;\n        }\n\n        if (!rd)\n            rd = dirs[0].createReader();\n\n        rd.readEntries(function (ents) {\n            var ngot = 0;\n            ents.forEach(function (dn) {\n                if (dn.isDirectory) {\n                    dirs.push(dn);\n                }\n                else {\n                    var name = dn.fullPath;\n                    if (name.startsWith('/'))\n                        name = name.slice(1);\n\n                    pf.push(name);\n                    dn.file(function (fobj) {\n                        apop(pf, name);\n                        var dst = good;\n                        try {\n                            if (fobj.size < 1)\n                                dst = nil;\n                        }\n                        catch (ex) {\n                            dst = bad;\n                        }\n                        dst.push([fobj, name]);\n                    });\n                }\n                ngot += 1;\n            });\n            if (!ngot) {\n                dirs.shift();\n                rd = null;\n            }\n            read_dirs(rd, pf, dirs, good, nil, bad, spins);\n        }, function () {\n            var dn = dirs[0],\n                name = dn.fullPath;\n\n            if (name.startsWith('/'))\n                name = name.slice(1);\n\n            bad.push([dn, name + '/']);\n            read_dirs(null, pf, dirs.slice(1), good, nil, bad, spins);\n        });\n    }\n\n    function gotallfiles(good_files, nil_files, bad_files) {\n        if (toast.txt == L.u_scan)\n            toast.hide();\n\n        if (uc.fsearch && !uc.turbo)\n            nil_files = [];\n\n        var ntot = good_files.concat(nil_files, bad_files).length;\n        if (bad_files.length) {\n            var msg = L.u_badf.format(bad_files.length, ntot);\n            for (var a = 0, aa = Math.min(20, bad_files.length); a < aa; a++)\n                msg += '-- ' + bad_files[a][1] + '\\n';\n\n            msg += L.u_just1;\n            return modal.alert(msg, function () {\n                start_actx();\n                gotallfiles(good_files, nil_files, []);\n            });\n        }\n\n        if (nil_files.length) {\n            var msg = L.u_blankf.format(nil_files.length, ntot);\n            for (var a = 0, aa = Math.min(20, nil_files.length); a < aa; a++)\n                msg += '-- ' + nil_files[a][1] + '\\n';\n\n            msg += L.u_just1;\n            return modal.confirm(msg, function () {\n                start_actx();\n                gotallfiles(good_files.concat(nil_files), [], []);\n            }, function () {\n                start_actx();\n                gotallfiles(good_files, [], []);\n            });\n        }\n\n        good_files.sort(function (a, b) {\n            a = a[1];\n            b = b[1];\n            return a < b ? -1 : a > b ? 1 : 0;\n        });\n\n        var msg = [];\n\n        if (lifetime)\n            msg.push('<b>' + L.u_up_life.format(lhumantime(st.lifetime || lifetime)) + '</b>\\n\\n');\n\n        if (FIREFOX && good_files.length > 3000)\n            msg.push(L.u_ff_many + \"\\n\\n\");\n\n        msg.push(L.u_asku.format(good_files.length, esc(get_vpath())) + '<ul>');\n        for (var a = 0, aa = Math.min(20, good_files.length); a < aa; a++)\n            msg.push('<li>' + esc(good_files[a][1]) + '</li>');\n\n        if (uc.ask_up && !uc.fsearch)\n            return modal.confirm(msg.join('') + '</ul>', function () {\n                start_actx();\n                up_them(good_files);\n                if (have_up2k_idx)\n                    toast.inf(15, L.u_unpt, L.u_unpt);\n            }, null);\n\n        up_them(good_files);\n    }\n\n    function up_them(good_files) {\n        start_actx();\n        draw_turbo();\n        var evpath = get_evpath(),\n            draw_each = good_files.length < 50;\n\n        if (WebAssembly && !hws.length) {\n            var nw = Math.min(navigator.hardwareConcurrency || 4, 16);\n\n            if (CHROME) {\n                // chrome-bug 383568268 // #124\n                nw = Math.max(1, (nw > 4 ? 4 : (nw - 1)));\n                nw = (subtle && !MOBILE && nw > 2) ? 2 : nw;\n            }\n\n            for (var a = 0; a < nw; a++)\n                hws.push(new Worker(SR + '/.cpr/w.hash.js?_=' + TS));\n\n            if (!subtle)\n                for (var a = 0; a < hws.length; a++)\n                    hws[a].postMessage('nosubtle');\n\n            console.log(hws.length + \" hashers\");\n        }\n\n        if (!uc.az)\n            good_files.sort(function (a, b) {\n                a = a[0].size;\n                b = b[0].size;\n                return a < b ? -1 : a > b ? 1 : 0;\n            });\n\n        for (var a = 0; a < good_files.length; a++) {\n            var fobj = good_files[a][0],\n                name = good_files[a][1],\n                fdir = evpath,\n                now = Date.now(),\n                lmod = uc.u2ts ? (fobj.lastModified || now) : 0,\n                ofs = name.lastIndexOf('/') + 1;\n\n            if (ofs) {\n                fdir += url_enc(name.slice(0, ofs));\n                name = name.slice(ofs);\n            }\n\n            var entry = {\n                \"n\": st.files.length,\n                \"t0\": now,\n                \"fobj\": fobj,\n                \"name\": name,\n                \"size\": fobj.size || 0,\n                \"lmod\": lmod / 1000,\n                \"purl\": fdir,\n                \"done\": false,\n                \"bytes_uploaded\": 0,\n                \"hash\": []\n            },\n                key = name + '\\n' + entry.size + '\\n' + lmod + '\\n' + uc.fsearch;\n\n            if (uc.fsearch)\n                entry.srch = 1;\n            else if (uc.rand) {\n                entry.rand = true;\n                entry.name = 'a\\n' + entry.name;\n            }\n            else if (uc.umod)\n                entry.umod = true;\n\n            if (biggest_file < entry.size)\n                biggest_file = entry.size;\n\n            try {\n                if (st.seen[fdir][key])\n                    continue;\n            }\n            catch (ex) {\n                st.seen[fdir] = {};\n            }\n\n            st.seen[fdir][key] = 1;\n\n            pvis.addfile([\n                uc.fsearch ? esc(entry.name) : linksplit(\n                    entry.purl + uricom_enc(entry.name)).join(' / '),\n                ' ' + L.u_hashing,\n                ''\n            ], entry.size, draw_each);\n\n            st.bytes.total += entry.size;\n            st.files.push(entry);\n            if (uc.turbo)\n                push_t(st.todo.head, entry);\n            else\n                push_t(st.todo.hash, entry);\n        }\n        if (!draw_each) {\n            pvis.drawcard(\"q\");\n            pvis.changecard(pvis.act);\n        }\n        ebi('u2tabw').className = 'ye';\n\n        setTimeout(function () {\n            if (!actx || actx.state != 'suspended' || toast.visible)\n                return;\n\n            toast.warn(30, \"<div onclick=\\\"start_actx();toast.inf(3,'thanks!')\\\">\" + L.u_actx + \"</div>\");\n        }, 500);\n    }\n\n    function more_one_file() {\n        fdom_ctr++;\n        var elm = mknod('div');\n        elm.innerHTML = (\n            '<input id=\"file{0}\" type=\"file\" name=\"file{0}[]\" multiple=\"multiple\" tabindex=\"-1\" />' +\n            '<input id=\"dir{0}\" type=\"file\" name=\"dir{0}[]\" multiple=\"multiple\" tabindex=\"-1\" webkitdirectory />'\n        ).format(fdom_ctr);\n        ebi('u2form').appendChild(elm);\n        ebi('file' + fdom_ctr).onchange = gotfile;\n        ebi('dir' + fdom_ctr).onchange = gotdir;\n    }\n    more_one_file();\n\n    function linklist() {\n        var ret = [],\n            base = document.location.origin.replace(/\\/$/, '');\n\n        for (var a = 0; a < st.files.length; a++) {\n            var t = st.files[a],\n                url = t.purl + uricom_enc(t.name);\n\n            if (t.fk)\n                url += '?k=' + t.fk;\n\n            ret.push(base + url);\n        }\n        return ret.join('\\r\\n');\n    }\n\n    ebi('luplinks').onclick = function (e) {\n        ev(e);\n        modal.alert(linklist());\n    };\n\n    ebi('cuplinks').onclick = function (e) {\n        ev(e);\n        var txt = linklist();\n        cliptxt(txt + '\\n', function () {\n            toast.inf(5, un_clip.format(txt.split('\\n').length));\n        });\n    };\n\n    var etaref = 0, etaskip = 0, utw_minh = 0, utw_read = 0, utw_card = 0;\n    function etafun() {\n        var nhash = st.busy.head.length + st.busy.hash.length + st.todo.head.length + st.todo.hash.length,\n            nsend = st.busy.upload.length + st.todo.upload.length,\n            now = Date.now(),\n            td = (now - (etaref || now)) / 1000.0;\n\n        etaref = now;\n        if (td > 1.2)\n            td = 0.05;\n\n        //ebi('acc_info').innerHTML = humantime(st.time.busy) + ' ' + f2f(now / 1000, 1);\n\n        if (utw_card != pvis.act) {\n            utw_card = pvis.act;\n            utw_read = 9001;\n            ebi('u2tabw').style.minHeight = '0px';\n        }\n\n        if (++utw_read >= 20) {\n            utw_read = 0;\n            utw_minh = parseInt(ebi('u2tabw').style.minHeight || '0');\n        }\n\n        var minh = QS('#op_up2k.act') && st.is_busy ? Math.max(utw_minh, ebi('u2tab').offsetHeight + 32) : 0;\n        if (utw_minh < minh || !utw_minh) {\n            utw_minh = minh;\n            ebi('u2tabw').style.minHeight = utw_minh + 'px';\n        }\n\n        if (!nhash) {\n            var h = L.u_etadone.format(humansize(st.bytes.hashed), pvis.ctr.ok + pvis.ctr.ng);\n            if (st.eta.h !== h) {\n                st.eta.h = ebi('u2etah').innerHTML = h;\n                console.log('{0} hash, {1} up, {2} busy'.format(\n                    f2f(st.time.hashing, 1),\n                    f2f(st.time.uploading, 1),\n                    f2f(st.time.busy, 1)));\n            }\n        }\n\n        if (!nsend && !nhash) {\n            var h = L.u_etadone.format(humansize(st.bytes.uploaded), pvis.ctr.ok + pvis.ctr.ng);\n\n            if (st.eta.u !== h)\n                st.eta.u = ebi('u2etau').innerHTML = h;\n\n            if (st.eta.t !== h)\n                st.eta.t = ebi('u2etat').innerHTML = h;\n        }\n\n        if (!st.busy.hash.length && !hashing_permitted())\n            nhash = 0;\n\n        if (!parallel_uploads || !(nhash + nsend) || (flag && flag.owner && !flag.ours))\n            return;\n\n        var t = [];\n        if (nhash) {\n            st.time.hashing += td;\n            t.push(['u2etah', st.bytes.hashed, st.bytes.hashed, st.time.hashing]);\n            if (uc.fsearch) {\n                st.time.busy += td;\n                t.push(['u2etat', st.bytes.hashed, st.bytes.hashed, st.time.hashing]);\n            }\n        }\n\n        var b_up = st.bytes.inflight + st.bytes.uploaded,\n            b_fin = st.bytes.inflight + st.bytes.finished;\n\n        if (nsend) {\n            st.time.uploading += td;\n            t.push(['u2etau', b_up, b_fin, st.time.uploading]);\n        }\n        if ((nhash || nsend) && !uc.fsearch) {\n            if (!b_fin) {\n                ebi('u2etat').innerHTML = L.u_etaprep;\n            }\n            else {\n                st.time.busy += td;\n                t.push(['u2etat', b_fin, b_fin, st.time.busy]);\n            }\n        }\n        for (var a = 0; a < t.length; a++) {\n            var hid = t[a][0],\n                eid = hid.slice(-1),\n                etaw = st.etaw[eid];\n\n            if (st.etac[eid] > 100) {  // num chunks\n                st.etac[eid] = 0;\n                etaw.push(jcp(t[a]));\n                if (etaw.length > 5)\n                    etaw.shift();\n            }\n\n            var h = etaw[0],\n                rem = st.bytes.total - t[a][2],\n                bps = (t[a][1] - h[1]) / Math.max(0.1, t[a][3] - h[3]),\n                eta = Math.floor(rem / bps);\n\n            if (t[a][1] < 1024 || t[a][3] < 0.1) {\n                ebi(hid).innerHTML = L.u_etaprep;\n                continue;\n            }\n\n            donut.eta = eta;\n            st.eta[eid] = '{0}, {1}/s, {2}'.format(\n                humansize(rem), humansize(bps, 1), humantime(eta));\n\n            if (!etaskip)\n                ebi(hid).innerHTML = st.eta[eid];\n        }\n        if (++etaskip > 2)\n            etaskip = 0;\n    }\n\n    function got_oserr() {\n        if (!hws.length || !uc.hashw || st.oserr)\n            return;\n\n        st.oserr = true;\n        var msg = HTTPS ? L.u_emtleak3 : L.u_emtleak2.format((location + '').replace(':', 's:'));\n        modal.alert(L.u_emtleak1 + msg + (CHROME ? L.u_emtleakc : FIREFOX ? L.u_emtleakf : ''));\n    }\n\n    /////\n    ////\n    ///   actuator\n    //\n\n    function handshakes_permitted() {\n        if (!st.todo.handshake.length)\n            return true;\n\n        var t = st.todo.handshake[0],\n            cd = t.cooldown;\n\n        if (cd && cd > Date.now())\n            return false;\n\n        // keepalive or verify\n        if (t.keepalive ||\n            t.t_uploaded)\n            return true;\n\n        if (parallel_uploads <\n            st.busy.handshake.length)\n            return false;\n\n        if (t.n - st.car > Math.max(8, parallel_uploads))\n            // prevent runahead from a stuck upload (slow server hdd)\n            return false;\n\n        if ((uc.multitask ? parallel_uploads : 0) <\n            st.todo.upload.length +\n            st.busy.upload.length)\n            return false;\n\n        return true;\n    }\n\n    function hashing_permitted() {\n        if (!parallel_uploads)\n            return false;\n\n        var nhs = st.todo.handshake.length + st.busy.handshake.length,\n            nup = st.todo.upload.length + st.busy.upload.length;\n\n        if (uc.multitask) {\n            if (nhs + nup < parallel_uploads)\n                return true;\n\n            if (!uc.az)\n                return nhs < 2;\n\n            var ahead = st.bytes.hashed - st.bytes.finished,\n                nmax = ahead < biggest_file / 8 ? 32 : 16;\n\n            return ahead < biggest_file && nhs < nmax;\n        }\n        return handshakes_permitted() && 0 == nhs + nup;\n    }\n\n    var tasker = (function () {\n        var running = false,\n            was_busy = false;\n\n        var defer = function () {\n            running = false;\n        }\n\n        var taskerd = function () {\n            if (running)\n                return;\n\n            if (crashed || !got_deps())\n                return defer();\n\n            running = true;\n            while (true) {\n                var now = Date.now(),\n                    blocktime = now - r.tact,\n                    is_busy = st.car < st.files.length;\n\n                if (blocktime > 2500)\n                    console.log('main thread blocked for ' + blocktime);\n\n                r.tact = now;\n\n                if (was_busy && !is_busy) {\n                    for (var a = 0; a < st.files.length; a++) {\n                        var t = st.files[a];\n                        if (t.want_recheck) {\n                            t.rechecks++;\n                            t.want_recheck = false;\n                            push_t(st.todo.handshake, t);\n                        }\n                    }\n                    is_busy = st.todo.handshake.length;\n                    try {\n                        if (!is_busy && !uc.fsearch && !msel.getsel().length && (!mp.au || mp.au.paused))\n                            treectl.goto();\n                    }\n                    catch (ex) { }\n                }\n\n                if (was_busy != is_busy) {\n                    st.is_busy = was_busy = is_busy;\n\n                    window[(is_busy ? \"add\" : \"remove\") +\n                        \"EventListener\"](\"beforeunload\", warn_uploader_busy);\n\n                    donut.on(is_busy);\n\n                    if (!is_busy) {\n                        uptoast();\n                        //throw console.hist.join('\\n');\n                    }\n                    else {\n                        timer.add(donut.do);\n                        timer.add(etafun, false);\n                        ebi('u2etas').style.textAlign = 'left';\n                    }\n                    etafun();\n                }\n\n                if (flag) {\n                    if (is_busy) {\n                        flag.take(now);\n                        ebi('u2flagblock').style.display = flag.ours ? '' : 'block';\n                        if (!flag.ours)\n                            return defer();\n                    }\n                    else if (flag.ours) {\n                        flag.give();\n                    }\n                }\n\n                if (st.bytes.inflight && (st.bytes.inflight < 0 || !st.busy.upload.length)) {\n                    console.log('insane inflight ' + st.bytes.inflight);\n                    st.bytes.inflight = 0;\n                }\n\n                var mou_ikkai = false;\n\n                var nprev = -1;\n                for (var a = 0; a < st.todo.upload.length; a++) {\n                    var nf = st.todo.upload[a].nfile;\n                    if (nprev == nf)\n                        continue;\n\n                    nprev = nf;\n                    var t = st.files[nf];\n                    if (now - t.t_busied > 1000 * 30 &&\n                        now - t.t_handshake > 1000 * (21600 - 1800)\n                    ) {\n                        apop(st.todo.handshake, t);\n                        st.todo.handshake.unshift(t);\n                        t.keepalive = true;\n                    }\n                }\n\n                if (st.todo.head.length &&\n                    st.busy.head.length < parallel_uploads &&\n                    (!is_busy || st.todo.head[0].n - st.car < parallel_uploads * 2)) {\n                    exec_head();\n                    mou_ikkai = true;\n                }\n\n                if (handshakes_permitted() &&\n                    st.todo.handshake.length) {\n                    exec_handshake();\n                    mou_ikkai = true;\n                }\n\n                if (st.todo.upload.length &&\n                    st.busy.upload.length < parallel_uploads &&\n                    can_upload_next()) {\n                    exec_upload();\n                    mou_ikkai = true;\n                }\n\n                if (hashing_permitted() &&\n                    st.todo.hash.length &&\n                    !st.busy.hash.length) {\n                    exec_hash();\n                    mou_ikkai = true;\n                }\n\n                if (is_busy && st.modn < 100) {\n                    var t0 = Date.now() + (ebi('repl').offsetTop ? 0 : 0);\n\n                    if (++st.modn >= 10) {\n                        if (st.modn == 10)\n                            st.mod0 = Date.now();\n\n                        st.modv += Date.now() - t0;\n                    }\n\n                    if (st.modn >= 100) {\n                        var n = st.modn - 10,\n                            ipu = st.modv / n,\n                            spu = (Date.now() - st.mod0) / n,\n                            ir = spu / ipu;\n\n                        console.log('tsk:', f2f(ipu, 2), ' spu:', f2f(spu, 2), ' ir:', f2f(ir, 2));\n                        // efficiency estimates;\n                        // ir: 8=16% 11=60% 16=90% 24=100%\n                        // ipu: 1=40% .8=60% .3=100%\n                        if (ipu >= 0.5 && ir <= 15)\n                            pvis.go_potato();\n                    }\n                }\n\n                if (!mou_ikkai || crashed)\n                    return defer();\n            }\n        }\n        timer.add(taskerd, true);\n        return taskerd;\n    })();\n\n    function uptoast() {\n        if (st.busy.handshake.length)\n            return;\n\n        for (var a = 0; a < st.files.length; a++) {\n            var t = st.files[a];\n            if (t.want_recheck && !t.rechecks)\n                return;\n        }\n\n        var sr = uc.fsearch,\n            ok = pvis.ctr.ok,\n            ng = pvis.ctr.ng,\n            spd = Math.floor(st.bytes.finished / st.time.busy),\n            suf = '\\n\\n{0} @ {1}/s'.format(shumantime(st.time.busy), humansize(spd)),\n            t = uc.ask_up ? 0 : 10;\n\n        console.log('toast', ok, ng);\n\n        if (ok && ng)\n            toast.warn(t, uc.nagtxt = (sr ? L.ur_sm : L.ur_um).format(ok, ng) + suf);\n        else if (ok > 1)\n            toast.ok(t, uc.nagtxt = (sr ? L.ur_aso : L.ur_auo).format(ok) + suf);\n        else if (ok)\n            toast.ok(t, uc.nagtxt = (sr ? L.ur_1so : L.ur_1uo) + suf);\n        else if (ng > 1)\n            toast.err(t, uc.nagtxt = (sr ? L.ur_asn : L.ur_aun).format(ng) + suf);\n        else if (ng)\n            toast.err(t, uc.nagtxt = (sr ? L.ur_1sn : L.ur_1un) + suf);\n\n        timer.rm(etafun);\n        timer.rm(donut.do);\n        ebi('u2tabw').style.minHeight = '0px';\n        utw_minh = 0;\n\n        if (pvis.act == 'bz')\n            pvis.changecard('bz');\n    }\n\n    function chill(t) {\n        var now = Date.now();\n        if ((t.coolmul || 0) < 5 || now - t.cooldown < t.coolmul * 700)\n            t.coolmul = Math.min((t.coolmul || 0.5) * 2, 32);\n\n        var cd = now + 1000 * (t.coolmul + Math.random() * 4 + 2);\n        t.cooldown = Math.floor(Math.max(cd, t.cooldown || 1));\n        return t;\n    }\n\n    /////\n    ////\n    ///   hashing\n    //\n\n    // https://gist.github.com/jonleighton/958841\n    function buf2b64(arrayBuffer) {\n        var base64 = '',\n            cset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n            src = new Uint8Array(arrayBuffer),\n            nbytes = src.byteLength,\n            byteRem = nbytes % 3,\n            mainLen = nbytes - byteRem,\n            a, b, c, d, chunk;\n\n        for (var i = 0; i < mainLen; i = i + 3) {\n            chunk = (src[i] << 16) | (src[i + 1] << 8) | src[i + 2];\n            // create 8*3=24bit segment then split into 6bit segments\n            a = (chunk & 16515072) >> 18; // (2^6 - 1) << 18\n            b = (chunk & 258048) >> 12; // (2^6 - 1) << 12\n            c = (chunk & 4032) >> 6; // (2^6 - 1) << 6\n            d = chunk & 63; // 2^6 - 1\n\n            // Convert the raw binary segments to the appropriate ASCII encoding\n            base64 += cset[a] + cset[b] + cset[c] + cset[d];\n        }\n\n        if (byteRem == 1) {\n            chunk = src[mainLen];\n            a = (chunk & 252) >> 2; // (2^6 - 1) << 2\n            b = (chunk & 3) << 4; // 2^2 - 1  (zero 4 LSB)\n            base64 += cset[a] + cset[b];//+ '==';\n        }\n        else if (byteRem == 2) {\n            chunk = (src[mainLen] << 8) | src[mainLen + 1];\n            a = (chunk & 64512) >> 10; // (2^6 - 1) << 10\n            b = (chunk & 1008) >> 4; // (2^6 - 1) << 4\n            c = (chunk & 15) << 2; // 2^4 - 1  (zero 2 LSB)\n            base64 += cset[a] + cset[b] + cset[c];//+ '=';\n        }\n\n        return base64;\n    }\n\n    function hex2u8(txt) {\n        return new Uint8Array(txt.match(/.{2}/g).map(function (b) { return parseInt(b, 16); }));\n    }\n\n    function get_chunksize(filesize) {\n        var chunksize = 1024 * 1024,\n            stepsize = 512 * 1024;\n\n        while (true) {\n            for (var mul = 1; mul <= 2; mul++) {\n                var nchunks = Math.ceil(filesize / chunksize);\n                if (nchunks <= 256 || (chunksize >= 32 * 1024 * 1024 && nchunks <= 4096))\n                    return chunksize;\n\n                chunksize += stepsize;\n                stepsize *= mul;\n            }\n        }\n    }\n\n    function exec_hash() {\n        var t = st.todo.hash.shift();\n        if (!t.size)\n            return st.todo.handshake.push(t);\n\n        st.busy.hash.push(t);\n        st.nfile.hash = t.n;\n        t.t_hashing = Date.now();\n\n        var bpend = 0,\n            nchunk = 0,\n            chunksize = get_chunksize(t.size),\n            nchunks = Math.ceil(t.size / chunksize),\n            csz_mib = chunksize / 1048576,\n            tread = t.t_hashing,\n            cache_buf = null,\n            cache_car = 0,\n            cache_cdr = 0,\n            hashers = 0,\n            hashtab = {};\n\n        // resolving subtle.digest w/o worker takes 1sec on blur if the actx hack breaks\n        var use_workers = hws.length && !hws_ng && uc.hashw && (nchunks > 1 || document.visibilityState == 'hidden'),\n            hash_par = (!subtle && !use_workers) ? 0 : csz_mib < 48 ? 2 : csz_mib < 96 ? 1 : 0;\n\n        pvis.setab(t.n, nchunks);\n        pvis.move(t.n, 'bz');\n\n        if (use_workers)\n            return wexec_hash(t, chunksize, nchunks);\n\n        var segm_next = function () {\n            if (nchunk >= nchunks || bpend)\n                return false;\n\n            var nch = nchunk++,\n                car = nch * chunksize,\n                cdr = Math.min(chunksize + car, t.size);\n\n            st.bytes.hashed += cdr - car;\n            st.etac.h++;\n\n            if (MOBILE && CHROME && st.slow_io === null && nch == 1 && cdr - car >= 1024 * 512) {\n                var spd = Math.floor((cdr - car) / (Date.now() + 1 - tread));\n                st.slow_io = spd < 40 * 1024;\n                console.log('spd {0}, slow: {1}'.format(spd, st.slow_io));\n            }\n\n            if (cdr <= cache_cdr && car >= cache_car) {\n                try {\n                    var ofs = car - cache_car,\n                        ofs2 = ofs + (cdr - car),\n                        buf = cache_buf.subarray(ofs, ofs2);\n\n                    hash_calc(nch, buf);\n                }\n                catch (ex) {\n                    vis_exh(ex + '', 'up2k.js', '', '', ex);\n                }\n                return;\n            }\n\n            var reader = new FileReader(),\n                fr_cdr = cdr;\n\n            if (st.slow_io) {\n                var step = cdr - car,\n                    tgt = 48 * 1048576;\n\n                while (step && fr_cdr - car < tgt)\n                    fr_cdr += step;\n                if (fr_cdr - car > tgt && fr_cdr > cdr)\n                    fr_cdr -= step;\n                if (fr_cdr > t.size)\n                    fr_cdr = t.size;\n            }\n\n            var orz = function (e) {\n                bpend = 0;\n                var buf = e.target.result;\n                if (fr_cdr > cdr) {\n                    cache_buf = new Uint8Array(buf);\n                    cache_car = car;\n                    cache_cdr = fr_cdr;\n                    buf = cache_buf.subarray(0, cdr - car);\n                }\n                if (hashers < hash_par)\n                    segm_next();\n\n                hash_calc(nch, buf);\n            };\n            reader.onload = function (e) {\n                try { orz(e); } catch (ex) { vis_exh(ex + '', 'up2k.js', '', '', ex); }\n            };\n            reader.onerror = function () {\n                var err = reader.error + '';\n                var handled = false;\n\n                if (err.indexOf('NotReadableError') !== -1 || // win10-chrome defender\n                    err.indexOf('NotFoundError') !== -1  // macos-firefox permissions\n                ) {\n                    pvis.seth(t.n, 1, 'OS-error');\n                    pvis.seth(t.n, 2, err + ' @ ' + car);\n                    console.log('OS-error', reader.error, '@', car);\n                    handled = true;\n                    got_oserr();\n                }\n\n                if (handled) {\n                    pvis.move(t.n, 'ng');\n                    apop(st.busy.hash, t);\n                    st.bytes.finished += t.size;\n                    return;\n                }\n\n                toast.err(0, 'y o u   b r o k e    i t\\nfile: ' + esc(t.name + '') + '\\nerror: ' + err);\n            };\n            bpend = 1;\n            tread = Date.now();\n            reader.readAsArrayBuffer(t.fobj.slice(car, fr_cdr));\n\n            return true;\n        };\n\n        var hash_calc = function (nch, buf) {\n            hashers++;\n            var orz = function (hashbuf) {\n                var hslice = new Uint8Array(hashbuf).subarray(0, 33),\n                    b64str = buf2b64(hslice);\n\n                hashers--;\n                hashtab[nch] = b64str;\n                t.hash.push(nch);\n                pvis.hashed(t);\n                if (t.hash.length < nchunks)\n                    return segm_next();\n\n                t.hash = [];\n                for (var a = 0; a < nchunks; a++)\n                    t.hash.push(hashtab[a]);\n\n                t.t_hashed = Date.now();\n\n                pvis.seth(t.n, 2, L.u_hashdone);\n                pvis.seth(t.n, 1, ' wait');\n                apop(st.busy.hash, t);\n                st.todo.handshake.push(t);\n                tasker();\n            };\n\n            var hash_done = function (hashbuf) {\n                try { orz(hashbuf); } catch (ex) { vis_exh(ex + '', 'up2k.js', '', '', ex); }\n            };\n\n            if (subtle)\n                subtle.digest('SHA-512', buf).then(hash_done);\n            else setTimeout(function () {\n                var u8buf = new Uint8Array(buf);\n                if (sha_js == 'hw') {\n                    hashwasm.sha512(u8buf).then(function (v) {\n                        hash_done(hex2u8(v))\n                    });\n                }\n                else {\n                    var hasher = new asmCrypto.Sha512();\n                    hasher.process(u8buf);\n                    hasher.finish();\n                    hash_done(hasher.result);\n                }\n            }, 1);\n        };\n        segm_next();\n    }\n\n    function wexec_hash(t, chunksize, nchunks) {\n        var nchunk = 0,\n            reading = 0,\n            max_readers = 1,\n            opt_readers = 2,\n            free = [],\n            busy = {},\n            nbusy = 0,\n            init = 0,\n            hashtab = {},\n            mem = (MOBILE ? 128 : 256) * 1024 * 1024;\n\n        if (!hws_ok)\n            init = setTimeout(function() {\n                hws_ng = true;\n                toast.warn(30, 'webworkers failed to start\\n\\nwill be a bit slower due to\\nhashing on main-thread');\n                apop(st.busy.hash, t);\n                st.todo.hash.unshift(t);\n                exec_hash();\n            }, 5000);\n\n        for (var a = 0; a < hws.length; a++) {\n            var w = hws[a];\n            w.onmessage = onmsg;\n            if (init)\n                w.postMessage('ping');\n            if (mem > 0)\n                free.push(w);\n            mem -= chunksize;\n        }\n\n        function go_next() {\n            if (st.slow_io && uc.multitask)\n                // android-chrome filereader latency is ridiculous but scales linearly\n                // (unlike every other platform which instead suffers on parallel reads...)\n                max_readers = opt_readers = free.length;\n\n            if (reading >= max_readers || !free.length || nchunk >= nchunks)\n                return;\n\n            var w = free.pop(),\n                car = nchunk * chunksize,\n                cdr = Math.min(chunksize + car, t.size);\n\n            //console.log('[P ] %d read bgin (%d reading, %d busy)', nchunk, reading + 1, nbusy + 1);\n            w.postMessage([nchunk, t.fobj, car, cdr]);\n            busy[nchunk] = w;\n            nbusy++;\n            reading++;\n            nchunk++;\n            if (Date.now() - up2k.tact > 1500)\n                tasker();\n        }\n\n        function onmsg(d) {\n            d = d.data;\n            var k = d[0];\n\n            if (k == \"pong\")\n                if (++hws_ok == hws.length) {\n                    clearTimeout(init);\n                    go_next();\n                }\n\n            if (k == \"panic\")\n                return vis_exh(d[1], 'up2k.js', '', '', d[1]);\n\n            if (k == \"fail\") {\n                pvis.seth(t.n, 1, d[1]);\n                pvis.seth(t.n, 2, d[2]);\n                console.log(d[1], d[2]);\n                if (d[1] == 'OS-error')\n                    got_oserr();\n\n                pvis.move(t.n, 'ng');\n                apop(st.busy.hash, t);\n                st.bytes.finished += t.size;\n                return;\n            }\n\n            if (k == \"ferr\")\n                return toast.err(0, 'y o u   b r o k e    i t\\nfile: ' + esc(t.name + '') + '\\nerror: ' + d[1]);\n\n            if (k == \"read\") {\n                reading--;\n                if (MOBILE && CHROME && st.slow_io === null && d[1] == 1 && d[2] > 1024 * 512) {\n                    var spd = Math.floor(d[2] / d[3]);\n                    st.slow_io = spd < 40 * 1024;\n                    console.log('spd {0}, slow: {1}'.format(spd, st.slow_io));\n                }\n                //console.log('[P ] %d read DONE (%d reading, %d busy)', d[1], reading, nbusy);\n                return go_next();\n            }\n\n            if (k == \"done\") {\n                var nchunk = d[1],\n                    hslice = d[2],\n                    sz = d[3];\n\n                free.push(busy[nchunk]);\n                delete busy[nchunk];\n                nbusy--;\n\n                //console.log('[P ] %d HASH DONE (%d reading, %d busy)', nchunk, reading, nbusy);\n\n                hashtab[nchunk] = buf2b64(hslice);\n                st.bytes.hashed += sz;\n                t.hash.push(nchunk);\n                pvis.hashed(t);\n\n                if (t.hash.length < nchunks)\n                    return nbusy < opt_readers && go_next();\n\n                t.hash = [];\n                for (var a = 0; a < nchunks; a++)\n                    t.hash.push(hashtab[a]);\n\n                t.t_hashed = Date.now();\n\n                pvis.seth(t.n, 2, L.u_hashdone);\n                pvis.seth(t.n, 1, ' wait');\n                apop(st.busy.hash, t);\n                st.todo.handshake.push(t);\n                tasker();\n            }\n        }\n        if (!init)\n            go_next();\n    }\n\n    /////\n    ////\n    ///   head\n    //\n\n    function exec_head() {\n        var t = st.todo.head.shift();\n        if (t.done)\n            return console.log('done; skip head1', t.name, t);\n\n        st.busy.head.push(t);\n\n        var xhr = new XMLHttpRequest();\n        xhr.onerror = xhr.ontimeout = function () {\n            console.log('head onerror, retrying', t.name, t);\n            if (!toast.visible)\n                toast.warn(9.98, L.u_enethd + \"\\n\\nfile: \" + t.name, t);\n\n            apop(st.busy.head, t);\n            st.todo.head.unshift(t);\n        };\n        function orz(e) {\n            if (t.done)\n                return console.log('done; skip head2', t.name, t);\n\n            var ok = false;\n            if (xhr.status == 200) {\n                var srv_sz = xhr.getResponseHeader('Content-Length'),\n                    srv_ts = xhr.getResponseHeader('Last-Modified');\n\n                ok = t.size == srv_sz;\n                if (ok && uc.datechk) {\n                    srv_ts = new Date(srv_ts) / 1000;\n                    ok = Math.abs(srv_ts - t.lmod) < 2;\n                }\n            }\n            apop(st.busy.head, t);\n            if (!ok && !t.srch) {\n                push_t(st.todo.hash, t);\n                tasker();\n                return;\n            }\n\n            t.done = true;\n            t.fobj = null;\n            st.bytes.hashed += t.size;\n            st.bytes.finished += t.size;\n            pvis.move(t.n, 'bz');\n            pvis.seth(t.n, 1, ok ? 'YOLO' : '404');\n            pvis.seth(t.n, 2, \"turbo'd\");\n            pvis.move(t.n, ok ? 'ok' : 'ng');\n            tasker();\n        };\n        xhr.onload = function (e) {\n            try { orz(e); } catch (ex) { vis_exh(ex + '', 'up2k.js', '', '', ex); }\n        };\n\n        xhr.timeout = 34000;\n        xhr.open('HEAD', t.purl + uricom_enc(t.name), true);\n        xhr.send();\n    }\n\n    /////\n    ////\n    ///   handshake\n    //\n\n    function exec_handshake() {\n        var t = st.todo.handshake.shift(),\n            keepalive = t.keepalive,\n            me = Date.now();\n\n        if (t.done)\n            return console.log('done; skip hs', t.name, t);\n\n        st.busy.handshake.push(t);\n        t.keepalive = undefined;\n        t.t_busied = me;\n\n        if (keepalive)\n            console.log(\"sending keepalive handshake\", t.name, t);\n\n        if (!t.srch && !t.t_handshake)\n            pvis.seth(t.n, 2, L.u_hs);\n\n        var xhr = new XMLHttpRequest();\n        xhr.onerror = xhr.ontimeout = function () {\n            if (t.t_busied != me)  // t.done ok\n                return console.log('zombie handshake onerror', t.name, t);\n\n            if (!toast.visible)\n                toast.warn(9.98, L.u_eneths + \"\\n\\nfile: \" + t.name, t);\n\n            console.log('handshake onerror, retrying', t.name, t);\n            apop(st.busy.handshake, t);\n            st.todo.handshake.unshift(chill(t));\n            t.keepalive = keepalive;\n        };\n        var orz = function (e) {\n            if (t.t_busied != me || t.done)\n                return console.log('zombie handshake onload', t.name, t);\n\n            if (xhr.status == 200) {\n                try {\n                    var response = JSON.parse(xhr.responseText);\n                }\n                catch (ex) {\n                    apop(st.busy.handshake, t);\n                    st.todo.handshake.unshift(chill(t));\n                    var txt = t.t_uploading ? L.u_ehsfin : t.srch ? L.u_ehssrch : L.u_ehsinit;\n                    return toast.err(0, txt + '\\n\\n' + L.badreply + ':\\n\\n' + unpre(xhr.responseText));\n                }\n\n                t.t_handshake = Date.now();\n                if (keepalive) {\n                    apop(st.busy.handshake, t);\n                    tasker();\n                    return;\n                }\n\n                if (toast.tag === t)\n                    toast.ok(5, L.u_fixed);\n\n                if (!response.name) {\n                    var msg = '',\n                        smsg = '';\n\n                    if (!response || !response.hits || !response.hits.length) {\n                        smsg = '404';\n                        msg = (L.u_s404 + ' <a href=\"#\" onclick=\"fsearch_explain(' +\n                            (has(perms, 'write') ? '0' : '1') + ')\" class=\"fsearch_explain\">(' + L.u_expl + ')</a>');\n                    }\n                    else {\n                        smsg = 'found';\n                        var msg = [];\n                        for (var a = 0, aa = Math.min(20, response.hits.length); a < aa; a++) {\n                            var hit = response.hits[a],\n                                tr = unix2iso(hit.ts),\n                                tu = unix2iso(t.lmod),\n                                diff = parseInt(t.lmod) - parseInt(hit.ts),\n                                cdiff = (Math.abs(diff) <= 2) ? '3c0' : 'f0b',\n                                sdiff = '<span style=\"color:#' + cdiff + '\">diff ' + diff;\n\n                            msg.push(linksplit(hit.rp).join(' / ') + '<br /><small>' + tr + ' (srv), ' + tu + ' (You), ' + sdiff + '</small></span>');\n                        }\n                        msg = msg.join('<br />\\n');\n                    }\n                    pvis.seth(t.n, 2, msg);\n                    pvis.seth(t.n, 1, smsg);\n                    pvis.move(t.n, smsg == '404' ? 'ng' : 'ok');\n                    apop(st.busy.handshake, t);\n                    st.bytes.finished += t.size;\n                    t.done = true;\n                    t.fobj = null;\n                    tasker();\n                    return;\n                }\n\n                t.sprs = response.sprs;\n\n                var fk = response.fk,\n                    rsp_purl = url_enc(response.purl),\n                    rename = rsp_purl !== t.purl || response.name !== t.name;\n\n                if (rename || fk) {\n                    if (rename)\n                        console.log(\"server-rename [\" + t.purl + \"] [\" + t.name + \"] to [\" + rsp_purl + \"] [\" + response.name + \"]\");\n\n                    t.purl = rsp_purl;\n                    t.name = response.name;\n\n                    var url = t.purl + uricom_enc(t.name);\n                    if (fk) {\n                        t.fk = fk;\n                        url += '?k=' + fk;\n                    }\n\n                    pvis.seth(t.n, 0, linksplit(url).join(' / '));\n                }\n\n                var chunksize = get_chunksize(t.size),\n                    cdr_idx = Math.ceil(t.size / chunksize) - 1,\n                    cdr_sz = (t.size % chunksize) || chunksize,\n                    cbd = [];\n\n                for (var a = 0; a <= cdr_idx; a++) {\n                    cbd.push(a == cdr_idx ? cdr_sz : chunksize);\n                }\n\n                t.postlist = [];\n                t.wark = response.wark;\n                var missing = response.hash;\n                for (var a = 0; a < missing.length; a++) {\n                    var idx = t.hash.indexOf(missing[a]);\n                    if (idx < 0)\n                        return modal.alert('wtf negative index for hash \"{0}\" in task:\\n{1}'.format(\n                            missing[a], JSON.stringify(t)));\n\n                    t.postlist.push(idx);\n                    cbd[idx] = 0;\n                }\n\n                pvis.setat(t.n, cbd);\n                pvis.prog(t, 0, cbd[0]);\n\n                var done = true,\n                    msg = 'done';\n\n                if (t.postlist.length) {\n                    if (t.rechecks && QS('#opa_del.act'))\n                        toast.inf(30, L.u_started, L.u_unpt);\n\n                    var arr = st.todo.upload,\n                        sort = arr.length && arr[arr.length - 1].nfile > t.n;\n\n                    if (!t.stitch_sz) {\n                        // keep all connections busy\n                        var bpc = (st.bytes.total - st.bytes.finished) / (parallel_uploads || 1),\n                            ocs = 1024 * 1024,\n                            stp = 1024 * 512,\n                            ccs = ocs;\n                        while (ccs < bpc) {\n                            ocs = ccs;\n                            ccs += stp; if (ccs < bpc) ocs = ccs;\n                            ccs += stp; stp *= 2;\n                        }\n                        ocs = Math.floor(ocs / 1024 / 1024);\n                        t.stitch_sz = Math.min(ocs, stitch_tgt);\n                    }\n\n                    for (var a = 0; a < t.postlist.length; a++) {\n                        var nparts = [], tbytes = 0, stitch = t.stitch_sz;\n                        if (t.nojoin && t.nojoin - t.postlist.length < 6)\n                            stitch = 1;\n\n                        --a;\n                        for (var b = 0; b < stitch; b++) {\n                            nparts.push(t.postlist[++a]);\n                            tbytes += chunksize;\n                            if (tbytes + chunksize > stitch * 1024 * 1024 || t.postlist[a + 1] - t.postlist[a] !== 1)\n                                break;\n                        }\n                        arr.push({\n                            'nfile': t.n,\n                            'nparts': nparts\n                        });\n                    }\n                    t.nojoin = 0;\n\n                    msg = null;\n                    done = false;\n\n                    if (sort)\n                        arr.sort(function (a, b) {\n                            return a.nfile < b.nfile ? -1 :\n                            /*  */ a.nfile > b.nfile ? 1 :\n                            /*  */ a.nparts[0] < b.nparts[0] ? -1 : 1;\n                        });\n                }\n\n                if (msg)\n                    pvis.seth(t.n, 1, msg);\n\n                apop(st.busy.handshake, t);\n\n                if (done) {\n                    t.done = true;\n                    t.fobj = null;\n                    st.bytes.finished += t.size - t.bytes_uploaded;\n                    var spd1 = (t.size / ((t.t_hashed - t.t_hashing) / 1000.)) / (1024 * 1024.),\n                        spd2 = (t.size / ((t.t_uploaded - t.t_uploading) / 1000.)) / (1024 * 1024.);\n\n                    pvis.seth(t.n, 2, 'hash {0}, up {1} MB/s'.format(\n                        f2f(spd1, 2), !isNum(spd2) ? '--' : f2f(spd2, 2)));\n\n                    pvis.move(t.n, 'ok');\n                    if (!pvis.ctr.bz && !pvis.ctr.q)\n                        uptoast();\n                }\n                else {\n                    if (t.t_uploaded)\n                        chill(t);\n\n                    t.t_uploaded = undefined;\n                }\n                tasker();\n            }\n            else {\n                pvis.seth(t.n, 1, \"ERROR\");\n                pvis.seth(t.n, 2, L.u_ehstmp, t);\n                apop(st.busy.handshake, t);\n\n                var err = \"\",\n                    cls = \"ERROR\",\n                    rsp = unpre(xhr.responseText),\n                    ofs = rsp.lastIndexOf('\\nURL: ');\n\n                if (ofs !== -1)\n                    rsp = rsp.slice(0, ofs);\n\n                if (rsp.indexOf('rate-limit ') !== -1) {\n                    var penalty = rsp.replace(/.*rate-limit /, \"\").split(' ')[0];\n                    console.log(\"rate-limit: \" + penalty);\n                    t.cooldown = Date.now() + parseFloat(penalty) * 1000;\n                    st.todo.handshake.unshift(t);\n                    return;\n                }\n\n                var err_pend = rsp.indexOf('partial upload exists at a different') + 1,\n                    err_srcb = rsp.indexOf('source file busy; please try again') + 1,\n                    err_plug = rsp.indexOf('upload blocked by x') + 1,\n                    err_dupe = rsp.indexOf('upload rejected, file already exists') + 1;\n\n                if (err_pend || err_srcb || err_plug || err_dupe) {\n                    err = rsp;\n                    ofs = err.indexOf('\\n/');\n                    if (ofs !== -1) {\n                        err = err.slice(0, ofs + 1) + linksplit(err.slice(ofs + 2).trimEnd()).join(' / ');\n                    }\n                    if (!t.rechecks && (err_pend || err_srcb)) {\n                        t.rechecks = 0;\n                        t.want_recheck = true;\n                        if (st.busy.upload.length || st.busy.handshake.length || st.bytes.uploaded) {\n                            err = L.u_dupdefer;\n                            cls = 'defer';\n                        }\n                    }\n                    if (err_pend) {\n                        err += ' <a href=\"#\" onclick=\"toast.inf(60, L.ue_ab);\" class=\"fsearch_explain\">(' + L.u_expl + ')</a>';\n                    }\n                }\n\n                if (err != \"\") {\n                    if (!t.t_uploading)\n                        st.bytes.finished += t.size;\n\n                    pvis.seth(t.n, 1, cls);\n                    pvis.seth(t.n, 2, err);\n                    pvis.move(t.n, 'ng');\n\n                    tasker();\n                    return;\n                }\n\n                st.todo.handshake.unshift(chill(t));\n\n                if (rsp.indexOf('server HDD is full') + 1)\n                    return toast.err(0, L.u_ehsdf + \"\\n\\n\" + rsp.replace(/.*; /, ''));\n\n                err = t.t_uploading ? L.u_ehsfin : t.srch ? L.u_ehssrch : L.u_ehsinit;\n                xhrchk(xhr, err + \"\\n\\nfile: \" + t.name + \"\\n\\nerror \", \"404, target folder not found\", \"warn\", t);\n            }\n        }\n        xhr.onload = function (e) {\n            try { orz(e); } catch (ex) { vis_exh(ex + '', 'up2k.js', '', '', ex); }\n        };\n\n        var req = {\n            \"name\": t.name,\n            \"size\": t.size,\n            \"lmod\": t.lmod,\n            \"life\": st.lifetime,\n            \"hash\": t.hash\n        };\n        if (t.srch)\n            req.srch = 1;\n        else if (t.rand)\n            req.rand = true;\n        else if (t.umod)\n            req.umod = true;\n\n        if (!t.srch) {\n            if (uc.ow == 1)\n                req.replace = 'mt';\n            if (uc.ow == 2)\n                req.replace = true;\n        }\n\n        xhr.open('POST', t.purl, true);\n        xhr.responseType = 'text';\n        xhr.timeout = 42000 + (t.srch || t.t_uploaded ? 0 :\n            (t.size / (1048 * 20))); // safededup 20M/s hdd\n        xhr.send(JSON.stringify(req));\n    }\n\n    /////\n    ////\n    ///   upload\n    //\n\n    function can_upload_next() {\n        var upt = st.todo.upload[0],\n            upf = st.files[upt.nfile],\n            nhs = st.busy.handshake.length,\n            hs = nhs && st.busy.handshake[0],\n            now = Date.now();\n\n        if (nhs >= 16)\n            return false;\n\n        if (hs && hs.t_uploaded && Date.now() - hs.t_busied > 10000)\n            // verification HS possibly held back by uploads\n            return false;\n\n        for (var a = 0, aa = st.busy.handshake.length; a < aa; a++) {\n            var hs = st.busy.handshake[a];\n            if (hs.n < upt.nfile && hs.t_busied > now - 10 * 1000 && !st.files[hs.n].bytes_uploaded)\n                return false;  // handshake race; wait for lexically first\n        }\n\n        if (upf.sprs)\n            return true;\n\n        for (var a = 0, aa = st.busy.upload.length; a < aa; a++)\n            if (st.busy.upload[a].nfile == upt.nfile)\n                return false;\n\n        return true;\n    }\n\n    function exec_upload() {\n        var upt = st.todo.upload.shift(),\n            t = st.files[upt.nfile],\n            nparts = upt.nparts,\n            pcar = nparts[0],\n            pcdr = nparts[nparts.length - 1],\n            maxsz = (u2sz_max > 1 ? u2sz_max : 2040) * 1024 * 1024;\n\n        if (t.done)\n            return console.log('done; skip chunk', t.name, t);\n\n        st.busy.upload.push(upt);\n        st.nfile.upload = upt.nfile;\n\n        if (!t.t_uploading)\n            t.t_uploading = Date.now();\n\n        pvis.seth(t.n, 1, \" send\");\n\n        var chunksize = get_chunksize(t.size),\n            car = pcar * chunksize,\n            cdr = (pcdr + 1) * chunksize;\n\n        if (cdr >= t.size)\n            cdr = t.size;\n\n        if (cdr - car <= maxsz)\n            return upload_sub(t, upt, pcar, pcdr, car, cdr, chunksize, car, []);\n\n        var car0 = car, subs = [];\n        while (car < cdr) {\n            subs.push([car, Math.min(cdr, car + maxsz)]);\n            car += maxsz;\n        }\n        upload_sub(t, upt, pcar, pcdr, 0, 0, chunksize, car0, subs);\n    }\n\n    function upload_sub(t, upt, pcar, pcdr, car, cdr, chunksize, car0, subs) {\n        var nparts = upt.nparts,\n            is_sub = subs.length;\n\n        if (is_sub) {\n            var x = subs.shift();\n            car = x[0];\n            cdr = x[1];\n        }\n\n        var snpart = is_sub ? ('' + pcar + '(' + (car-car0) +'+'+ (cdr-car)) :\n                pcar == pcdr ? pcar : ('' + pcar + '~' + pcdr);\n\n        var orz = function (xhr) {\n            st.bytes.inflight -= xhr.bsent;\n            var txt = unpre((xhr.response && xhr.response.err) || xhr.responseText);\n            if (txt.indexOf('upload blocked by x') + 1) {\n                apop(st.busy.upload, upt);\n                for (var a = pcar; a <= pcdr; a++)\n                    apop(t.postlist, a);\n                pvis.seth(t.n, 1, \"ERROR\");\n                pvis.seth(t.n, 2, txt.split(/\\n/)[0]);\n                pvis.move(t.n, 'ng');\n                return;\n            }\n            if (xhr.status == 200) {\n                car = car0;\n                if (subs.length)\n                    return upload_sub(t, upt, pcar, pcdr, 0, 0, chunksize, car0, subs);\n\n                var bdone = cdr - car;\n                for (var a = pcar; a <= pcdr; a++) {\n                    pvis.prog(t, a, Math.min(bdone, chunksize));\n                    bdone -= chunksize;\n                }\n                st.bytes.finished += cdr - car;\n                st.bytes.uploaded += cdr - car;\n                t.bytes_uploaded += cdr - car;\n                t.cooldown = t.coolmul = 0;\n                st.etac.u++;\n                st.etac.t++;\n            }\n            else if (txt.indexOf('already got that') + 1 ||\n                txt.indexOf('already being written') + 1) {\n                t.nojoin = t.nojoin || t.postlist.length;\n                console.log(\"ignoring dupe-segment with backoff\", t.nojoin, t.name, t);\n                if (!toast.visible && st.todo.upload.length < 4)\n                    toast.inf(10, L.u_cbusy);\n            }\n            else {\n                xhrchk(xhr, L.u_cuerr2.format(snpart, Math.ceil(t.size / chunksize), t.name), \"404, target folder not found (???)\", \"warn\", t);\n                chill(t);\n            }\n            orz2(xhr);\n        }\n        var orz2 = function (xhr) {\n            apop(st.busy.upload, upt);\n            for (var a = pcar; a <= pcdr; a++)\n                apop(t.postlist, a);\n            if (!t.postlist.length) {\n                t.t_uploaded = Date.now();\n                pvis.seth(t.n, 1, 'verifying');\n                st.todo.handshake.unshift(t);\n            }\n            tasker();\n        }\n        function do_send() {\n            var xhr = new XMLHttpRequest(),\n                bfin = Math.floor(st.bytes.finished / 1024 / 1024),\n                btot = Math.floor(st.bytes.total / 1024 / 1024);\n\n            xhr.upload.onprogress = function (xev) {\n                var nb = xev.loaded,\n                    db = nb - xhr.bsent;\n\n                if (!db)\n                    return;\n\n                st.bytes.inflight += db;\n                xhr.bsent = nb;\n                xhr.timeout = 64000 + Date.now() - xhr.t0;\n                pvis.prog(t, pcar, nb);\n            };\n            xhr.onload = function (xev) {\n                try { orz(xhr); } catch (ex) { vis_exh(ex + '', 'up2k.js', '', '', ex); }\n            };\n            xhr.onerror = xhr.ontimeout = function (xev) {\n                if (crashed)\n                    return;\n\n                st.bytes.inflight -= (xhr.bsent || 0);\n                xhr.bsent = 0;\n\n                if (!toast.visible)\n                    toast.warn(9.98, L.u_cuerr.format(snpart, Math.ceil(t.size / chunksize), t.name), t);\n\n                t.nojoin = t.nojoin || t.postlist.length;  // maybe rproxy postsize limit\n                console.log('chunkpit onerror,', t.name, t);\n                orz2(xhr);\n            };\n\n            var chashes = [],\n                ctxt = t.hash[pcar],\n                plen = Math.floor(192 / nparts.length);\n\n            plen = plen > 9 ? 9 : plen < 2 ? 2 : plen;\n            for (var a = pcar + 1; a <= pcdr; a++)\n                chashes.push(t.hash[a].slice(0, plen));\n\n            if (chashes.length)\n                ctxt += ',' + plen + ',' + chashes.join('');\n\n            xhr.open('POST', t.purl, true);\n            xhr.setRequestHeader(\"X-Up2k-Hash\", ctxt);\n            xhr.setRequestHeader(\"X-Up2k-Wark\", t.wark);\n            if (is_sub)\n                xhr.setRequestHeader(\"X-Up2k-Subc\", car - car0);\n\n            xhr.setRequestHeader(\"X-Up2k-Stat\", \"{0}/{1}/{2}/{3} {4}/{5} {6}\".format(\n                pvis.ctr.ok, pvis.ctr.ng, pvis.ctr.bz, pvis.ctr.q, btot, btot - bfin,\n                st.eta.t.indexOf('/s, ')+1 ? st.eta.t.split(' ').pop() : 'x'));\n\n            xhr.setRequestHeader('Content-Type', 'application/octet-stream');\n            if (xhr.overrideMimeType)\n                xhr.overrideMimeType('Content-Type', 'application/octet-stream');\n\n            xhr.bsent = 0;\n            xhr.t0 = Date.now();\n            xhr.timeout = 42000;\n            xhr.responseType = 'text';\n            xhr.send(t.fobj.slice(car, cdr));\n        }\n        do_send();\n    }\n\n    /////\n    ////\n    ///   config ui\n    //\n\n    function onresize(e) {\n        // 10x faster than matchMedia('(min-width\n        var bar = ebi('ops'),\n            wpx = window.innerWidth,\n            fpx = parseInt(getComputedStyle(bar)['font-size']),\n            wem = wpx * 1.0 / fpx,\n            wide = wem > 57 ? 'w' : '',\n            parent = ebi(wide ? 'u2btn_cw' : 'u2btn_ct'),\n            btn = ebi('u2btn');\n\n        if (btn.parentNode !== parent) {\n            parent.appendChild(btn);\n            ebi('u2conf').className = ebi('u2cards').className = ebi('u2etaw').className = wide;\n        }\n\n        wide = wem > 86 ? 'ww' : wide;\n        parent = ebi(wide == 'ww' ? 'u2c3w' : 'u2c3t');\n        var its = [ebi('u2etaw'), ebi('u2cards')];\n        if (its[0].parentNode !== parent) {\n            ebi('u2conf').className = wide;\n            for (var a = 0; a < 2; a++) {\n                parent.appendChild(its[a]);\n                its[a].className = wide;\n            }\n        }\n    }\n    onresize100.add(onresize, true);\n\n    if (MOBILE) {\n        // android-chrome wobbles for a bit; firefox / iOS-safari are OK\n        setTimeout(onresize, 20);\n        setTimeout(onresize, 100);\n        setTimeout(onresize, 500);\n    }\n\n    var o = QSA('#u2conf .c *[tt]');\n    for (var a = o.length - 1; a >= 0; a--) {\n        o[a].parentNode.getElementsByTagName('input')[0].setAttribute('tt', o[a].getAttribute('tt'));\n    }\n    tt.att(QS('#u2conf'));\n\n    function bumpthread2(e) {\n        if (anymod(e))\n            return;\n\n        if (e.code == 'ArrowUp')\n            bumpthread(1);\n\n        if (e.code == 'ArrowDown')\n            bumpthread(-1);\n    }\n\n    function bumpthread(dir) {\n        try {\n            dir.stopPropagation();\n            dir.preventDefault();\n        } catch (ex) { }\n\n        var obj = ebi('nthread');\n        if (dir.target) {\n            clmod(obj, 'err', 1);\n            var v = Math.floor(parseInt(obj.value));\n            if (v < 0 || v !== v)\n                return;\n\n            if (v > 64) {\n                var p = obj.selectionStart;\n                v = obj.value = 64;\n                obj.selectionStart = obj.selectionEnd = p;\n            }\n\n            parallel_uploads = v;\n            if (v == u2j)\n                sdrop('nthread');\n            else\n                swrite('nthread', v);\n\n            clmod(obj, 'err');\n            return;\n        }\n\n        parallel_uploads += dir;\n\n        if (parallel_uploads < 0)\n            parallel_uploads = 0;\n\n        if (parallel_uploads > 16)\n            parallel_uploads = 16;\n\n        if (parallel_uploads > 6)\n            toast.warn(10, L.u_maxconn);\n        else if (toast.txt == L.u_maxconn)\n            toast.hide();\n\n        obj.value = parallel_uploads;\n        bumpthread({ \"target\": 1 });\n    }\n\n    var read_u2sz = function () {\n        var el = ebi('u2szg'), n = parseInt(el.value);\n        stitch_tgt = n = (\n            isNaN(n) ? u2sz_tgt :\n            n < u2sz_min ? u2sz_min :\n            n > u2sz_max ? u2sz_max : n\n        );\n        if (n == u2sz_tgt) sdrop('u2sz'); else swrite('u2sz', n);\n        if (el.value != n) el.value = n;\n    };\n    ebi('u2szg').addEventListener('blur', read_u2sz);\n    ebi('u2szg').onkeydown = function (e) {\n        if (anymod(e)) return;\n        var n = e.code == 'ArrowUp' ? 1 : e.code == 'ArrowDown' ? -1 : 0;\n        if (!n) return;\n        this.value = parseInt(this.value) + n;\n        read_u2sz();\n    }\n\n    function tgl_fsearch() {\n        set_fsearch(!uc.fsearch);\n    }\n\n    function draw_turbo() {\n        if (turbolvl < 0 && uc.turbo) {\n            bcfg_set('u2turbo', uc.turbo = false);\n            toast.err(10, L.u_turbo_c);\n        }\n\n        if (uc.turbo && !has(perms, 'read')) {\n            bcfg_set('u2turbo', uc.turbo = false);\n            toast.warn(30, L.u_turbo_g);\n        }\n\n        var msg = (turbolvl || !uc.turbo) ? null : uc.fsearch ? L.u_ts : L.u_tu,\n            html = ebi('u2foot').innerHTML;\n\n        if (msg && html.indexOf(msg) + 1)\n            return;\n\n        qsr('#u2turbomsg');\n        if (!msg)\n            return;\n\n        var o = mknod('div', 'u2turbomsg');\n        o.innerHTML = msg;\n        ebi('u2foot').appendChild(o);\n    }\n    draw_turbo();\n\n    function draw_life() {\n        var el = ebi('u2life');\n        if (!lifetime) {\n            el.style.display = 'none';\n            el.innerHTML = '';\n            st.lifetime = 0;\n            return;\n        }\n        el.style.display = uc.fsearch ? 'none' : '';\n        el.innerHTML = '<div>' + L.u_life_cfg + '</div><div>' + L.u_life_est + '</div><div id=\"undor\"></div>';\n        set_life(Math.min(lifetime, icfg_get('lifetime', lifetime)));\n        ebi('lifem').oninput = ebi('lifeh').oninput = mod_life;\n        ebi('lifem').onkeydown = ebi('lifeh').onkeydown = kd_life;\n        tt.att(ebi('u2life'));\n    }\n    draw_life();\n\n    function mod_life(e) {\n        var el = e.target,\n            pow = parseInt(el.getAttribute('p')),\n            v = parseInt(el.value);\n\n        if (!isNum(v))\n            return;\n\n        if (toast.tag == mod_life)\n            toast.hide();\n\n        v *= pow;\n        if (v > lifetime) {\n            v = lifetime;\n            toast.warn(20, L.u_life_max.format(lhumantime(lifetime)), mod_life);\n        }\n\n        swrite('lifetime', v);\n        set_life(v);\n    }\n\n    function kd_life(e) {\n        var el = e.target,\n            d = e.code == 'ArrowUp' ? 1 : e.code == 'ArrowDown' ? -1 : 0;\n\n        if (anymod(e) || !d)\n            return;\n\n        el.value = parseInt(el.value) + d;\n        mod_life(e);\n    }\n\n    function set_life(v) {\n        //ebi('lifes').value = v;\n        ebi('lifem').value = parseInt(v / 60);\n        ebi('lifeh').value = parseInt(v / 3600);\n\n        var undo = have_unpost - (v ? lifetime - v : 0);\n        ebi('undor').innerHTML = undo <= 0 ?\n            L.u_unp_ng : L.u_unp_ok.format(lhumantime(undo));\n\n        st.lifetime = v;\n        rel_life();\n    }\n\n    function rel_life() {\n        if (!lifetime)\n            return;\n\n        try {\n            ebi('lifew').innerHTML = unix2iso((st.lifetime || lifetime) +\n                Date.now() / 1000 - new Date().getTimezoneOffset() * 60\n            ).replace(' ', ', ').slice(0, -3);\n        }\n        catch (ex) { }\n    }\n    setInterval(rel_life, 9000);\n\n    function set_potato() {\n        pvis.potato();\n        set_fsearch();\n    }\n\n    function set_fsearch(new_state) {\n        var fixed = false,\n            persist = new_state !== undefined,\n            preferred = bcfg_get('fsearch', undefined),\n            can_write = false;\n\n        if (!ebi('fsearch')) {\n            new_state = false;\n        }\n        else if (perms.length) {\n            if (!(can_write = has(perms, 'write'))) {\n                new_state = true;\n                fixed = true;\n            }\n            if (!has(perms, 'read') || !have_up2k_idx) {\n                new_state = false;\n                fixed = true;\n            }\n            if (new_state === undefined && preferred === undefined)\n                new_state = can_write ? false : have_up2k_idx ? true : undefined;\n        }\n\n        if (new_state === undefined)\n            new_state = preferred;\n\n        if (new_state !== undefined)\n            if (persist)\n                bcfg_set('fsearch', uc.fsearch = new_state);\n            else\n                bcfg_upd_ui('fsearch', uc.fsearch = new_state);\n\n        try {\n            clmod(ebi('u2c3w'), 's', !can_write);\n            QS('label[for=\"fsearch\"]').style.display = QS('#fsearch').style.display = fixed ? 'none' : '';\n        }\n        catch (ex) { }\n\n        try {\n            var ico = uc.fsearch ? '' : '',\n                desc = uc.fsearch ? L.ul_btns : L.ul_btnu;\n\n            clmod(ebi('op_up2k'), 'srch', uc.fsearch);\n            ebi('u2bm').innerHTML = ico + '&nbsp; <sup>' + desc + '</sup>';\n        }\n        catch (ex) { }\n\n        ebi('u2tab').className = (uc.fsearch ? 'srch ' : 'up ') + pvis.act;\n\n        var potato = uc.potato && !uc.fsearch;\n        ebi('u2cards').style.display = ebi('u2tab').style.display = potato ? 'none' : '';\n        ebi('u2mu').style.display = potato ? '' : 'none';\n\n        if (u2ts.startsWith('f') || !sread('u2ts'))\n            uc.u2ts = bcfg_upd_ui('u2ts', !u2ts.endsWith('u'));\n\n        draw_turbo();\n        draw_life();\n        onresize();\n    }\n\n    function apply_flag_cfg() {\n        if (uc.flag_en && !flag) {\n            try {\n                flag = up2k_flagbus();\n            }\n            catch (ex) {\n                toast.err(5, \"not supported on your browser:\\n\" + esc(basenames(ex)));\n                bcfg_set('flag_en', uc.flag_en = false);\n            }\n        }\n        else if (!uc.flag_en && flag) {\n            if (flag.ours)\n                flag.give();\n\n            flag.ch.close();\n            flag = false;\n        }\n    }\n\n    function set_u2sort(en) {\n        if (u2sort.indexOf('f') < 0)\n            return;\n\n        var fen = uc.az = u2sort.indexOf('n') + 1;\n        bcfg_upd_ui('u2sort', fen);\n        if (en != fen)\n            toast.warn(10, L.ul_btnlk);\n    }\n\n    function set_u2ts(en) {\n        if (u2ts.indexOf('f') < 0)\n            return;\n\n        var fen = !u2ts.endsWith('u');\n        bcfg_upd_ui('u2ts', fen);\n        if (en != fen)\n            toast.warn(10, L.ul_btnlk);\n    }\n\n    function set_hashw() {\n        if (!WebAssembly) {\n            bcfg_set('hashw', uc.hashw = false);\n            toast.err(10, L.u_nowork);\n        }\n    }\n\n    function set_upnag(en) {\n        function nopenag() {\n            bcfg_set('upnag', uc.upnag = false);\n            toast.err(10, \"https only\");\n        }\n\n        function chknag() {\n            if (Notification.permission != 'granted')\n                nopenag();\n        }\n\n        if (!Notification || !HTTPS)\n            return nopenag();\n\n        if (en && Notification.permission == 'default')\n            Notification.requestPermission().then(chknag, chknag);\n\n        set_upsfx(en);\n    }\n\n    function set_upsfx(en) {\n        if (!en)\n            return;\n\n        toast.inf(10, 'OK -- <a href=\"#\" id=\"nagtest\">test it!</a>')\n\n        ebi('nagtest').onclick = function () {\n            start_actx();\n            uc.nagtxt = ':^)';\n            setTimeout(donut.enstrobe, 200);\n        };\n    }\n\n    if (uc.upnag && (!Notification || Notification.permission != 'granted'))\n        bcfg_set('upnag', uc.upnag = false);\n\n    ebi('nthread_add').onclick = function (e) {\n        ev(e);\n        bumpthread(1);\n    };\n    ebi('nthread_sub').onclick = function (e) {\n        ev(e);\n        bumpthread(-1);\n    };\n\n    ebi('nthread').onkeydown = bumpthread2;\n    ebi('nthread').oninput = bumpthread;\n\n    ebi('u2etas').onclick = function (e) {\n        ev(e);\n        clmod(ebi('u2etas'), 'o', 't');\n    };\n\n    set_fsearch();\n    bumpthread({ \"target\": 1 });\n    if (parallel_uploads < 1)\n        bumpthread(1);\n\n    setTimeout(function () {\n        for (var a = 0; a < up2k_hooks.length; a++)\n            up2k_hooks[a]();\n    }, 1);\n\n    return r;\n}\n\n\nfunction warn_uploader_busy(e) {\n    e.preventDefault();\n    e.returnValue = '';\n    return \"upload in progress, click abort and use the file-tree to navigate instead\";\n}\n\n\ntt.init();\nfavico.init();\nebi('ico1').onclick = function () {\n    var a = favico.txt == this.textContent;\n    swrite('icot', a ? 'c' : this.textContent);\n    swrite('icof', a ? 'fc5' : '000');\n    swrite('icob', a ? '222' : '');\n    favico.init();\n};\n\n\nif (QS('#op_up2k.act'))\n    goto_up2k();\n\napply_perms({ \"perms\": perms, \"frand\": frand, \"u2ts\": u2ts });\n\n\n(function () {\n    goto();\n    var op = sread('opmode');\n    if (op !== null && op !== '.')\n        try {\n            goto(op);\n        }\n        catch (ex) { }\n})();", "output": {"vulnerability_count": 61, "vulnerabilities": [{"description": "Possibility of prototype polluting assignment detected. By adding or modifying attributes of an object prototype, it is possible to create attributes that exist on every object, or replace critical attributes with malicious ones. This can be problematic if the software depends on existence or non-existence of certain attributes, or uses pre-defined attributes of object prototype (such as hasOwnProperty, toString or valueOf). Possible mitigations might be: freezing the object prototype, using an object without prototypes (via Object.create(null) ), blocking modifications of attributes that resolve to object prototype, using Map instead of object.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 210}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 217}, {"description": "User controlled data in a `obj.innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 217}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 433}, {"description": "User controlled data in a `ode.innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 433}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 434}, {"description": "User controlled data in a `oen.innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 434}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 471}, {"description": "User controlled data in a `ebi('u2mu').innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 471}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 491}, {"description": "User controlled data in a `o.innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 491}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 502}, {"description": "User controlled data in a `cards[4].innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 502}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 506}, {"description": "User controlled data in a `cards[3].innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 506}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 510}, {"description": "User controlled data in a `cards[2].innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 510}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 513}, {"description": "User controlled data in a `cards[1].innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 513}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 516}, {"description": "User controlled data in a `cards[0].innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 516}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 564}, {"description": "User controlled data in a `el.tBodies[0].innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 564}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 580}, {"description": "User controlled data in a `obj.innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 580}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 673}, {"description": "User controlled data in a `optab.innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 673}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 793}, {"description": "User controlled data in a `ebi('u2notbtn').innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 793}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 828}, {"description": "User controlled data in a `o.innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 828}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 840}, {"description": "User controlled data in a `ebi('u2err').innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 840}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 891}, {"description": "User controlled data in a `QS('label[for=\"u2ow\"]').innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 891}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1487}, {"description": "User controlled data in a `elm.innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1487}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1559}, {"description": "User controlled data in a `ebi('u2etah').innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1559}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1571}, {"description": "User controlled data in a `ebi('u2etau').innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1571}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1574}, {"description": "User controlled data in a `ebi('u2etat').innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1574}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1602}, {"description": "User controlled data in a `ebi('u2etat').innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1602}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1627}, {"description": "User controlled data in a `ebi(hid).innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1627}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1636}, {"description": "User controlled data in a `ebi(hid).innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1636}, {"description": "Using non-static data to retrieve and run functions from the object is dangerous. If the data is user-controlled, it may allow executing arbitrary code.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1755}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 3025}, {"description": "User controlled data in a `o.innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 3025}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 3039}, {"description": "User controlled data in a `el.innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 3039}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 3085}, {"description": "User controlled data in a `ebi('undor').innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 3085}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 3097}, {"description": "User controlled data in a `ebi('lifew').innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 3097}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 3152}, {"description": "User controlled data in a `ebi('u2bm').innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 3152}, {"description": "Using non-static data to retrieve and run functions from the object is dangerous. If the data is user-controlled, it may allow executing arbitrary code.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 3276}]}}
{"CVE": "CVE-2025-27793", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "import { ascending, error, isArray, isFunction, isString } from 'vega-util';\n\nfunction array(seq) {\n  return isArray(seq) || ArrayBuffer.isView(seq) ? seq : null;\n}\n\nfunction sequence(seq) {\n  return array(seq) || (isString(seq) ? seq : null);\n}\n\nexport function join(seq, ...args) {\n  return array(seq).join(...args);\n}\n\nexport function indexof(seq, ...args) {\n  return sequence(seq).indexOf(...args);\n}\n\nexport function lastindexof(seq, ...args) {\n  return sequence(seq).lastIndexOf(...args);\n}\n\nexport function slice(seq, ...args) {\n  return sequence(seq).slice(...args);\n}\n\nexport function replace(str, pattern, repl) {\n  if (isFunction(repl)) error('Function argument passed to replace.');\n  return String(str).replace(pattern, repl);\n}\nexport function reverse(seq) {\n  return array(seq).slice().reverse();\n}\nexport function sort(seq) {\n  return array(seq).slice().sort(ascending);\n}", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2025-29907", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "/** @license\n * jsPDF addImage plugin\n * Copyright (c) 2012 Jason Siefken, https://github.com/siefkenj/\n *               2013 Chris Dowling, https://github.com/gingerchris\n *               2013 Trinh Ho, https://github.com/ineedfat\n *               2013 Edwin Alejandro Perez, https://github.com/eaparango\n *               2013 Norah Smith, https://github.com/burnburnrocket\n *               2014 Diego Casorran, https://github.com/diegocr\n *               2014 James Robb, https://github.com/jamesbrobb\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n/**\n * @name addImage\n * @module\n */\n\nimport { jsPDF } from \"../jspdf.js\";\nimport { atob, btoa } from \"../libs/AtobBtoa.js\";\n\n(function(jsPDFAPI) {\n  \"use strict\";\n\n  var namespace = \"addImage_\";\n  jsPDFAPI.__addimage__ = {};\n\n  var UNKNOWN = \"UNKNOWN\";\n\n  // Heuristic selection of a good batch for large array .apply. Not limiting make the call overflow.\n  // With too small batch iteration will be slow as more calls are made,\n  // higher values cause larger and slower garbage collection.\n  var ARRAY_APPLY_BATCH = 8192;\n\n  var imageFileTypeHeaders = {\n    PNG: [[0x89, 0x50, 0x4e, 0x47]],\n    TIFF: [\n      [0x4d, 0x4d, 0x00, 0x2a], //Motorola\n      [0x49, 0x49, 0x2a, 0x00] //Intel\n    ],\n    JPEG: [\n      [\n        0xff,\n        0xd8,\n        0xff,\n        0xe0,\n        undefined,\n        undefined,\n        0x4a,\n        0x46,\n        0x49,\n        0x46,\n        0x00\n      ], //JFIF\n      [\n        0xff,\n        0xd8,\n        0xff,\n        0xe1,\n        undefined,\n        undefined,\n        0x45,\n        0x78,\n        0x69,\n        0x66,\n        0x00,\n        0x00\n      ], //Exif\n      [0xff, 0xd8, 0xff, 0xdb], //JPEG RAW\n      [0xff, 0xd8, 0xff, 0xee] //EXIF RAW\n    ],\n    JPEG2000: [[0x00, 0x00, 0x00, 0x0c, 0x6a, 0x50, 0x20, 0x20]],\n    GIF87a: [[0x47, 0x49, 0x46, 0x38, 0x37, 0x61]],\n    GIF89a: [[0x47, 0x49, 0x46, 0x38, 0x39, 0x61]],\n    WEBP: [\n      [\n        0x52,\n        0x49,\n        0x46,\n        0x46,\n        undefined,\n        undefined,\n        undefined,\n        undefined,\n        0x57,\n        0x45,\n        0x42,\n        0x50\n      ]\n    ],\n    BMP: [\n      [0x42, 0x4d], //BM - Windows 3.1x, 95, NT, ... etc.\n      [0x42, 0x41], //BA - OS/2 struct bitmap array\n      [0x43, 0x49], //CI - OS/2 struct color icon\n      [0x43, 0x50], //CP - OS/2 const color pointer\n      [0x49, 0x43], //IC - OS/2 struct icon\n      [0x50, 0x54] //PT - OS/2 pointer\n    ]\n  };\n\n  /**\n   * Recognize filetype of Image by magic-bytes\n   *\n   * https://en.wikipedia.org/wiki/List_of_file_signatures\n   *\n   * @name getImageFileTypeByImageData\n   * @public\n   * @function\n   * @param {string|arraybuffer} imageData imageData as binary String or arraybuffer\n   * @param {string} format format of file if filetype-recognition fails, e.g. 'JPEG'\n   *\n   * @returns {string} filetype of Image\n   */\n  var getImageFileTypeByImageData = (jsPDFAPI.__addimage__.getImageFileTypeByImageData = function(\n    imageData,\n    fallbackFormat\n  ) {\n    fallbackFormat = fallbackFormat || UNKNOWN;\n    var i;\n    var j;\n    var result = UNKNOWN;\n    var headerSchemata;\n    var compareResult;\n    var fileType;\n\n    if (\n      fallbackFormat === \"RGBA\" ||\n      (imageData.data !== undefined &&\n        imageData.data instanceof Uint8ClampedArray &&\n        \"height\" in imageData &&\n        \"width\" in imageData)\n    ) {\n      return \"RGBA\";\n    }\n\n    if (isArrayBufferView(imageData)) {\n      for (fileType in imageFileTypeHeaders) {\n        headerSchemata = imageFileTypeHeaders[fileType];\n        for (i = 0; i < headerSchemata.length; i += 1) {\n          compareResult = true;\n          for (j = 0; j < headerSchemata[i].length; j += 1) {\n            if (headerSchemata[i][j] === undefined) {\n              continue;\n            }\n            if (headerSchemata[i][j] !== imageData[j]) {\n              compareResult = false;\n              break;\n            }\n          }\n          if (compareResult === true) {\n            result = fileType;\n            break;\n          }\n        }\n      }\n    } else {\n      for (fileType in imageFileTypeHeaders) {\n        headerSchemata = imageFileTypeHeaders[fileType];\n        for (i = 0; i < headerSchemata.length; i += 1) {\n          compareResult = true;\n          for (j = 0; j < headerSchemata[i].length; j += 1) {\n            if (headerSchemata[i][j] === undefined) {\n              continue;\n            }\n            if (headerSchemata[i][j] !== imageData.charCodeAt(j)) {\n              compareResult = false;\n              break;\n            }\n          }\n          if (compareResult === true) {\n            result = fileType;\n            break;\n          }\n        }\n      }\n    }\n\n    if (result === UNKNOWN && fallbackFormat !== UNKNOWN) {\n      result = fallbackFormat;\n    }\n    return result;\n  });\n\n  // Image functionality ported from pdf.js\n  var putImage = function(image) {\n    var out = this.internal.write;\n    var putStream = this.internal.putStream;\n    var getFilters = this.internal.getFilters;\n\n    var filter = getFilters();\n    while (filter.indexOf(\"FlateEncode\") !== -1) {\n      filter.splice(filter.indexOf(\"FlateEncode\"), 1);\n    }\n\n    image.objectId = this.internal.newObject();\n\n    var additionalKeyValues = [];\n    additionalKeyValues.push({ key: \"Type\", value: \"/XObject\" });\n    additionalKeyValues.push({ key: \"Subtype\", value: \"/Image\" });\n    additionalKeyValues.push({ key: \"Width\", value: image.width });\n    additionalKeyValues.push({ key: \"Height\", value: image.height });\n\n    if (image.colorSpace === color_spaces.INDEXED) {\n      additionalKeyValues.push({\n        key: \"ColorSpace\",\n        value:\n          \"[/Indexed /DeviceRGB \" +\n          // if an indexed png defines more than one colour with transparency, we've created a sMask\n          (image.palette.length / 3 - 1) +\n          \" \" +\n          (\"sMask\" in image && typeof image.sMask !== \"undefined\"\n            ? image.objectId + 2\n            : image.objectId + 1) +\n          \" 0 R]\"\n      });\n    } else {\n      additionalKeyValues.push({\n        key: \"ColorSpace\",\n        value: \"/\" + image.colorSpace\n      });\n      if (image.colorSpace === color_spaces.DEVICE_CMYK) {\n        additionalKeyValues.push({ key: \"Decode\", value: \"[1 0 1 0 1 0 1 0]\" });\n      }\n    }\n    additionalKeyValues.push({\n      key: \"BitsPerComponent\",\n      value: image.bitsPerComponent\n    });\n    if (\n      \"decodeParameters\" in image &&\n      typeof image.decodeParameters !== \"undefined\"\n    ) {\n      additionalKeyValues.push({\n        key: \"DecodeParms\",\n        value: \"<<\" + image.decodeParameters + \">>\"\n      });\n    }\n    if (\"transparency\" in image && Array.isArray(image.transparency)) {\n      var transparency = \"\",\n        i = 0,\n        len = image.transparency.length;\n      for (; i < len; i++)\n        transparency +=\n          image.transparency[i] + \" \" + image.transparency[i] + \" \";\n\n      additionalKeyValues.push({\n        key: \"Mask\",\n        value: \"[\" + transparency + \"]\"\n      });\n    }\n    if (typeof image.sMask !== \"undefined\") {\n      additionalKeyValues.push({\n        key: \"SMask\",\n        value: image.objectId + 1 + \" 0 R\"\n      });\n    }\n\n    var alreadyAppliedFilters =\n      typeof image.filter !== \"undefined\" ? [\"/\" + image.filter] : undefined;\n\n    putStream({\n      data: image.data,\n      additionalKeyValues: additionalKeyValues,\n      alreadyAppliedFilters: alreadyAppliedFilters,\n      objectId: image.objectId\n    });\n\n    out(\"endobj\");\n\n    // Soft mask\n    if (\"sMask\" in image && typeof image.sMask !== \"undefined\") {\n      var decodeParameters =\n        \"/Predictor \" +\n        image.predictor +\n        \" /Colors 1 /BitsPerComponent \" +\n        image.bitsPerComponent +\n        \" /Columns \" +\n        image.width;\n      var sMask = {\n        width: image.width,\n        height: image.height,\n        colorSpace: \"DeviceGray\",\n        bitsPerComponent: image.bitsPerComponent,\n        decodeParameters: decodeParameters,\n        data: image.sMask\n      };\n      if (\"filter\" in image) {\n        sMask.filter = image.filter;\n      }\n      putImage.call(this, sMask);\n    }\n\n    //Palette\n    if (image.colorSpace === color_spaces.INDEXED) {\n      var objId = this.internal.newObject();\n      //out('<< /Filter / ' + img['f'] +' /Length ' + img['pal'].length + '>>');\n      //putStream(zlib.compress(img['pal']));\n      putStream({\n        data: arrayBufferToBinaryString(new Uint8Array(image.palette)),\n        objectId: objId\n      });\n      out(\"endobj\");\n    }\n  };\n  var putResourcesCallback = function() {\n    var images = this.internal.collections[namespace + \"images\"];\n    for (var i in images) {\n      putImage.call(this, images[i]);\n    }\n  };\n  var putXObjectsDictCallback = function() {\n    var images = this.internal.collections[namespace + \"images\"],\n      out = this.internal.write,\n      image;\n    for (var i in images) {\n      image = images[i];\n      out(\"/I\" + image.index, image.objectId, \"0\", \"R\");\n    }\n  };\n\n  var checkCompressValue = function(value) {\n    if (value && typeof value === \"string\") value = value.toUpperCase();\n    return value in jsPDFAPI.image_compression ? value : image_compression.NONE;\n  };\n\n  var initialize = function() {\n    if (!this.internal.collections[namespace + \"images\"]) {\n      this.internal.collections[namespace + \"images\"] = {};\n      this.internal.events.subscribe(\"putResources\", putResourcesCallback);\n      this.internal.events.subscribe(\"putXobjectDict\", putXObjectsDictCallback);\n    }\n  };\n\n  var getImages = function() {\n    var images = this.internal.collections[namespace + \"images\"];\n    initialize.call(this);\n    return images;\n  };\n  var getImageIndex = function() {\n    return Object.keys(this.internal.collections[namespace + \"images\"]).length;\n  };\n  var notDefined = function(value) {\n    return typeof value === \"undefined\" || value === null || value.length === 0;\n  };\n  var generateAliasFromImageData = function(imageData) {\n    if (typeof imageData === \"string\" || isArrayBufferView(imageData)) {\n      return sHashCode(imageData);\n    } else if (isArrayBufferView(imageData.data)) {\n      return sHashCode(imageData.data);\n    }\n\n    return null;\n  };\n\n  var isImageTypeSupported = function(type) {\n    return typeof jsPDFAPI[\"process\" + type.toUpperCase()] === \"function\";\n  };\n\n  var isDOMElement = function(object) {\n    return typeof object === \"object\" && object.nodeType === 1;\n  };\n\n  var getImageDataFromElement = function(element, format) {\n    //if element is an image which uses data url definition, just return the dataurl\n    if (element.nodeName === \"IMG\" && element.hasAttribute(\"src\")) {\n      var src = \"\" + element.getAttribute(\"src\");\n\n      //is base64 encoded dataUrl, directly process it\n      if (src.indexOf(\"data:image/\") === 0) {\n        return atob(\n          unescape(src)\n            .split(\"base64,\")\n            .pop()\n        );\n      }\n\n      //it is probably an url, try to load it\n      var tmpImageData = jsPDFAPI.loadFile(src, true);\n      if (tmpImageData !== undefined) {\n        return tmpImageData;\n      }\n    }\n\n    if (element.nodeName === \"CANVAS\") {\n      if (element.width === 0 || element.height === 0) {\n        throw new Error(\n          \"Given canvas must have data. Canvas width: \" +\n            element.width +\n            \", height: \" +\n            element.height\n        );\n      }\n      var mimeType;\n      switch (format) {\n        case \"PNG\":\n          mimeType = \"image/png\";\n          break;\n        case \"WEBP\":\n          mimeType = \"image/webp\";\n          break;\n        case \"JPEG\":\n        case \"JPG\":\n        default:\n          mimeType = \"image/jpeg\";\n          break;\n      }\n      return atob(\n        element\n          .toDataURL(mimeType, 1.0)\n          .split(\"base64,\")\n          .pop()\n      );\n    }\n  };\n\n  var checkImagesForAlias = function(alias) {\n    var images = this.internal.collections[namespace + \"images\"];\n    if (images) {\n      for (var e in images) {\n        if (alias === images[e].alias) {\n          return images[e];\n        }\n      }\n    }\n  };\n\n  var determineWidthAndHeight = function(width, height, image) {\n    if (!width && !height) {\n      width = -96;\n      height = -96;\n    }\n    if (width < 0) {\n      width = (-1 * image.width * 72) / width / this.internal.scaleFactor;\n    }\n    if (height < 0) {\n      height = (-1 * image.height * 72) / height / this.internal.scaleFactor;\n    }\n    if (width === 0) {\n      width = (height * image.width) / image.height;\n    }\n    if (height === 0) {\n      height = (width * image.height) / image.width;\n    }\n\n    return [width, height];\n  };\n\n  var writeImageToPDF = function(x, y, width, height, image, rotation) {\n    var dims = determineWidthAndHeight.call(this, width, height, image),\n      coord = this.internal.getCoordinateString,\n      vcoord = this.internal.getVerticalCoordinateString;\n\n    var images = getImages.call(this);\n\n    width = dims[0];\n    height = dims[1];\n    images[image.index] = image;\n\n    if (rotation) {\n      rotation *= Math.PI / 180;\n      var c = Math.cos(rotation);\n      var s = Math.sin(rotation);\n      //like in pdf Reference do it 4 digits instead of 2\n      var f4 = function(number) {\n        return number.toFixed(4);\n      };\n      var rotationTransformationMatrix = [\n        f4(c),\n        f4(s),\n        f4(s * -1),\n        f4(c),\n        0,\n        0,\n        \"cm\"\n      ];\n    }\n    this.internal.write(\"q\"); //Save graphics state\n    if (rotation) {\n      this.internal.write(\n        [1, \"0\", \"0\", 1, coord(x), vcoord(y + height), \"cm\"].join(\" \")\n      ); //Translate\n      this.internal.write(rotationTransformationMatrix.join(\" \")); //Rotate\n      this.internal.write(\n        [coord(width), \"0\", \"0\", coord(height), \"0\", \"0\", \"cm\"].join(\" \")\n      ); //Scale\n    } else {\n      this.internal.write(\n        [\n          coord(width),\n          \"0\",\n          \"0\",\n          coord(height),\n          coord(x),\n          vcoord(y + height),\n          \"cm\"\n        ].join(\" \")\n      ); //Translate and Scale\n    }\n\n    if (this.isAdvancedAPI()) {\n      // draw image bottom up when in \"advanced\" API mode\n      this.internal.write([1, 0, 0, -1, 0, 0, \"cm\"].join(\" \"));\n    }\n\n    this.internal.write(\"/I\" + image.index + \" Do\"); //Paint Image\n    this.internal.write(\"Q\"); //Restore graphics state\n  };\n\n  /**\n   * COLOR SPACES\n   */\n  var color_spaces = (jsPDFAPI.color_spaces = {\n    DEVICE_RGB: \"DeviceRGB\",\n    DEVICE_GRAY: \"DeviceGray\",\n    DEVICE_CMYK: \"DeviceCMYK\",\n    CAL_GREY: \"CalGray\",\n    CAL_RGB: \"CalRGB\",\n    LAB: \"Lab\",\n    ICC_BASED: \"ICCBased\",\n    INDEXED: \"Indexed\",\n    PATTERN: \"Pattern\",\n    SEPARATION: \"Separation\",\n    DEVICE_N: \"DeviceN\"\n  });\n\n  /**\n   * DECODE METHODS\n   */\n  jsPDFAPI.decode = {\n    DCT_DECODE: \"DCTDecode\",\n    FLATE_DECODE: \"FlateDecode\",\n    LZW_DECODE: \"LZWDecode\",\n    JPX_DECODE: \"JPXDecode\",\n    JBIG2_DECODE: \"JBIG2Decode\",\n    ASCII85_DECODE: \"ASCII85Decode\",\n    ASCII_HEX_DECODE: \"ASCIIHexDecode\",\n    RUN_LENGTH_DECODE: \"RunLengthDecode\",\n    CCITT_FAX_DECODE: \"CCITTFaxDecode\"\n  };\n\n  /**\n   * IMAGE COMPRESSION TYPES\n   */\n  var image_compression = (jsPDFAPI.image_compression = {\n    NONE: \"NONE\",\n    FAST: \"FAST\",\n    MEDIUM: \"MEDIUM\",\n    SLOW: \"SLOW\"\n  });\n\n  /**\n   * @name sHashCode\n   * @function\n   * @param {string} data\n   * @returns {string}\n   */\n  var sHashCode = (jsPDFAPI.__addimage__.sHashCode = function(data) {\n    var hash = 0,\n      i,\n      len;\n\n    if (typeof data === \"string\") {\n      len = data.length;\n      for (i = 0; i < len; i++) {\n        hash = (hash << 5) - hash + data.charCodeAt(i);\n        hash |= 0; // Convert to 32bit integer\n      }\n    } else if (isArrayBufferView(data)) {\n      len = data.byteLength / 2;\n      for (i = 0; i < len; i++) {\n        hash = (hash << 5) - hash + data[i];\n        hash |= 0; // Convert to 32bit integer\n      }\n    }\n    return hash;\n  });\n\n  /**\n   * Validates if given String is a valid Base64-String\n   *\n   * @name validateStringAsBase64\n   * @public\n   * @function\n   * @param {String} possible Base64-String\n   *\n   * @returns {boolean}\n   */\n  var validateStringAsBase64 = (jsPDFAPI.__addimage__.validateStringAsBase64 = function(\n    possibleBase64String\n  ) {\n    possibleBase64String = possibleBase64String || \"\";\n    possibleBase64String.toString().trim();\n\n    var result = true;\n\n    if (possibleBase64String.length === 0) {\n      result = false;\n    }\n\n    if (possibleBase64String.length % 4 !== 0) {\n      result = false;\n    }\n\n    if (\n      /^[A-Za-z0-9+/]+$/.test(\n        possibleBase64String.substr(0, possibleBase64String.length - 2)\n      ) === false\n    ) {\n      result = false;\n    }\n\n    if (\n      /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(\n        possibleBase64String.substr(-2)\n      ) === false\n    ) {\n      result = false;\n    }\n    return result;\n  });\n\n  /**\n   * Strips out and returns info from a valid base64 data URI\n   *\n   * @name extractImageFromDataUrl\n   * @function\n   * @param {string} dataUrl a valid data URI of format 'data:[<MIME-type>][;base64],<data>'\n   * @returns {Array}an Array containing the following\n   * [0] the complete data URI\n   * [1] <MIME-type>\n   * [2] format - the second part of the mime-type i.e 'png' in 'image/png'\n   * [4] <data>\n   */\n  var extractImageFromDataUrl = (jsPDFAPI.__addimage__.extractImageFromDataUrl = function(\n    dataUrl\n  ) {\n    dataUrl = dataUrl || \"\";\n    var dataUrlParts = dataUrl.split(\"base64,\");\n    var result = null;\n\n    if (dataUrlParts.length === 2) {\n      var extractedInfo = /^data:(\\w*\\/\\w*);*(charset=(?!charset=)[\\w=-]*)*;*$/.exec(\n        dataUrlParts[0]\n      );\n      if (Array.isArray(extractedInfo)) {\n        result = {\n          mimeType: extractedInfo[1],\n          charset: extractedInfo[2],\n          data: dataUrlParts[1]\n        };\n      }\n    }\n    return result;\n  });\n\n  /**\n   * Check to see if ArrayBuffer is supported\n   *\n   * @name supportsArrayBuffer\n   * @function\n   * @returns {boolean}\n   */\n  var supportsArrayBuffer = (jsPDFAPI.__addimage__.supportsArrayBuffer = function() {\n    return (\n      typeof ArrayBuffer !== \"undefined\" && typeof Uint8Array !== \"undefined\"\n    );\n  });\n\n  /**\n   * Tests supplied object to determine if ArrayBuffer\n   *\n   * @name isArrayBuffer\n   * @function\n   * @param {Object} object an Object\n   *\n   * @returns {boolean}\n   */\n  jsPDFAPI.__addimage__.isArrayBuffer = function(object) {\n    return supportsArrayBuffer() && object instanceof ArrayBuffer;\n  };\n\n  /**\n   * Tests supplied object to determine if it implements the ArrayBufferView (TypedArray) interface\n   *\n   * @name isArrayBufferView\n   * @function\n   * @param {Object} object an Object\n   * @returns {boolean}\n   */\n  var isArrayBufferView = (jsPDFAPI.__addimage__.isArrayBufferView = function(\n    object\n  ) {\n    return (\n      supportsArrayBuffer() &&\n      typeof Uint32Array !== \"undefined\" &&\n      (object instanceof Int8Array ||\n        object instanceof Uint8Array ||\n        (typeof Uint8ClampedArray !== \"undefined\" &&\n          object instanceof Uint8ClampedArray) ||\n        object instanceof Int16Array ||\n        object instanceof Uint16Array ||\n        object instanceof Int32Array ||\n        object instanceof Uint32Array ||\n        object instanceof Float32Array ||\n        object instanceof Float64Array)\n    );\n  });\n\n  /**\n   * Convert Binary String to ArrayBuffer\n   *\n   * @name binaryStringToUint8Array\n   * @public\n   * @function\n   * @param {string} BinaryString with ImageData\n   * @returns {Uint8Array}\n   */\n  var binaryStringToUint8Array = (jsPDFAPI.__addimage__.binaryStringToUint8Array = function(\n    binary_string\n  ) {\n    var len = binary_string.length;\n    var bytes = new Uint8Array(len);\n    for (var i = 0; i < len; i++) {\n      bytes[i] = binary_string.charCodeAt(i);\n    }\n    return bytes;\n  });\n\n  /**\n   * Convert the Buffer to a Binary String\n   *\n   * @name arrayBufferToBinaryString\n   * @public\n   * @function\n   * @param {ArrayBuffer|ArrayBufferView} ArrayBuffer buffer or bufferView with ImageData\n   *\n   * @returns {String}\n   */\n  var arrayBufferToBinaryString = (jsPDFAPI.__addimage__.arrayBufferToBinaryString = function(\n    buffer\n  ) {\n    var out = \"\";\n    // There are calls with both ArrayBuffer and already converted Uint8Array or other BufferView.\n    // Do not copy the array if input is already an array.\n    var buf = isArrayBufferView(buffer) ? buffer : new Uint8Array(buffer);\n    for (var i = 0; i < buf.length; i += ARRAY_APPLY_BATCH) {\n      // Limit the amount of characters being parsed to prevent overflow.\n      // Note that while TextDecoder would be faster, it does not have the same\n      // functionality as fromCharCode with any provided encodings as of 3/2021.\n      out += String.fromCharCode.apply(\n        null,\n        buf.subarray(i, i + ARRAY_APPLY_BATCH)\n      );\n    }\n    return out;\n  });\n\n  /**\n   * Possible parameter for addImage, an RGBA buffer with size.\n   *\n   * @typedef {Object} RGBAData\n   * @property {Uint8ClampedArray} data - Single dimensional array of RGBA values. For example from canvas getImageData.\n   * @property {number} width - Image width as the data does not carry this information in itself.\n   * @property {number} height - Image height as the data does not carry this information in itself.\n   */\n\n  /**\n   * Adds an Image to the PDF.\n   *\n   * @name addImage\n   * @public\n   * @function\n   * @param {string|HTMLImageElement|HTMLCanvasElement|Uint8Array|RGBAData} imageData imageData as base64 encoded DataUrl or Image-HTMLElement or Canvas-HTMLElement or object containing RGBA array (like output from canvas.getImageData).\n   * @param {string} format format of file if filetype-recognition fails or in case of a Canvas-Element needs to be specified (default for Canvas is JPEG), e.g. 'JPEG', 'PNG', 'WEBP'\n   * @param {number} x x Coordinate (in units declared at inception of PDF document) against left edge of the page\n   * @param {number} y y Coordinate (in units declared at inception of PDF document) against upper edge of the page\n   * @param {number} width width of the image (in units declared at inception of PDF document)\n   * @param {number} height height of the Image (in units declared at inception of PDF document)\n   * @param {string} alias alias of the image (if used multiple times)\n   * @param {string} compression compression of the generated JPEG, can have the values 'NONE', 'FAST', 'MEDIUM' and 'SLOW'\n   * @param {number} rotation rotation of the image in degrees (0-359)\n   *\n   * @returns jsPDF\n   */\n  jsPDFAPI.addImage = function() {\n    var imageData, format, x, y, w, h, alias, compression, rotation;\n\n    imageData = arguments[0];\n    if (typeof arguments[1] === \"number\") {\n      format = UNKNOWN;\n      x = arguments[1];\n      y = arguments[2];\n      w = arguments[3];\n      h = arguments[4];\n      alias = arguments[5];\n      compression = arguments[6];\n      rotation = arguments[7];\n    } else {\n      format = arguments[1];\n      x = arguments[2];\n      y = arguments[3];\n      w = arguments[4];\n      h = arguments[5];\n      alias = arguments[6];\n      compression = arguments[7];\n      rotation = arguments[8];\n    }\n\n    if (\n      typeof imageData === \"object\" &&\n      !isDOMElement(imageData) &&\n      \"imageData\" in imageData\n    ) {\n      var options = imageData;\n\n      imageData = options.imageData;\n      format = options.format || format || UNKNOWN;\n      x = options.x || x || 0;\n      y = options.y || y || 0;\n      w = options.w || options.width || w;\n      h = options.h || options.height || h;\n      alias = options.alias || alias;\n      compression = options.compression || compression;\n      rotation = options.rotation || options.angle || rotation;\n    }\n\n    //If compression is not explicitly set, determine if we should use compression\n    var filter = this.internal.getFilters();\n    if (compression === undefined && filter.indexOf(\"FlateEncode\") !== -1) {\n      compression = \"SLOW\";\n    }\n\n    if (isNaN(x) || isNaN(y)) {\n      throw new Error(\"Invalid coordinates passed to jsPDF.addImage\");\n    }\n\n    initialize.call(this);\n\n    var image = processImageData.call(\n      this,\n      imageData,\n      format,\n      alias,\n      compression\n    );\n\n    writeImageToPDF.call(this, x, y, w, h, image, rotation);\n\n    return this;\n  };\n\n  var processImageData = function(imageData, format, alias, compression) {\n    var result, dataAsBinaryString;\n\n    if (\n      typeof imageData === \"string\" &&\n      getImageFileTypeByImageData(imageData) === UNKNOWN\n    ) {\n      imageData = unescape(imageData);\n      var tmpImageData = convertBase64ToBinaryString(imageData, false);\n\n      if (tmpImageData !== \"\") {\n        imageData = tmpImageData;\n      } else {\n        tmpImageData = jsPDFAPI.loadFile(imageData, true);\n        if (tmpImageData !== undefined) {\n          imageData = tmpImageData;\n        }\n      }\n    }\n\n    if (isDOMElement(imageData)) {\n      imageData = getImageDataFromElement(imageData, format);\n    }\n\n    format = getImageFileTypeByImageData(imageData, format);\n    if (!isImageTypeSupported(format)) {\n      throw new Error(\n        \"addImage does not support files of type '\" +\n          format +\n          \"', please ensure that a plugin for '\" +\n          format +\n          \"' support is added.\"\n      );\n    }\n\n    // now do the heavy lifting\n\n    if (notDefined(alias)) {\n      alias = generateAliasFromImageData(imageData);\n    }\n    result = checkImagesForAlias.call(this, alias);\n\n    if (!result) {\n      if (supportsArrayBuffer()) {\n        // no need to convert if imageData is already uint8array\n        if (!(imageData instanceof Uint8Array) && format !== \"RGBA\") {\n          dataAsBinaryString = imageData;\n          imageData = binaryStringToUint8Array(imageData);\n        }\n      }\n\n      result = this[\"process\" + format.toUpperCase()](\n        imageData,\n        getImageIndex.call(this),\n        alias,\n        checkCompressValue(compression),\n        dataAsBinaryString\n      );\n    }\n\n    if (!result) {\n      throw new Error(\"An unknown error occurred whilst processing the image.\");\n    }\n    return result;\n  };\n\n  /**\n   * @name convertBase64ToBinaryString\n   * @function\n   * @param {string} stringData\n   * @returns {string} binary string\n   */\n  var convertBase64ToBinaryString = (jsPDFAPI.__addimage__.convertBase64ToBinaryString = function(\n    stringData,\n    throwError\n  ) {\n    throwError = typeof throwError === \"boolean\" ? throwError : true;\n    var base64Info;\n    var imageData = \"\";\n    var rawData;\n\n    if (typeof stringData === \"string\") {\n      base64Info = extractImageFromDataUrl(stringData);\n      rawData = base64Info !== null ? base64Info.data : stringData;\n\n      try {\n        imageData = atob(rawData);\n      } catch (e) {\n        if (throwError) {\n          if (!validateStringAsBase64(rawData)) {\n            throw new Error(\n              \"Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString \"\n            );\n          } else {\n            throw new Error(\n              \"atob-Error in jsPDF.convertBase64ToBinaryString \" + e.message\n            );\n          }\n        }\n      }\n    }\n    return imageData;\n  });\n\n  /**\n   * @name getImageProperties\n   * @function\n   * @param {Object} imageData\n   * @returns {Object}\n   */\n  jsPDFAPI.getImageProperties = function(imageData) {\n    var image;\n    var tmpImageData = \"\";\n    var format;\n\n    if (isDOMElement(imageData)) {\n      imageData = getImageDataFromElement(imageData);\n    }\n\n    if (\n      typeof imageData === \"string\" &&\n      getImageFileTypeByImageData(imageData) === UNKNOWN\n    ) {\n      tmpImageData = convertBase64ToBinaryString(imageData, false);\n\n      if (tmpImageData === \"\") {\n        tmpImageData = jsPDFAPI.loadFile(imageData) || \"\";\n      }\n      imageData = tmpImageData;\n    }\n\n    format = getImageFileTypeByImageData(imageData);\n    if (!isImageTypeSupported(format)) {\n      throw new Error(\n        \"addImage does not support files of type '\" +\n          format +\n          \"', please ensure that a plugin for '\" +\n          format +\n          \"' support is added.\"\n      );\n    }\n\n    if (supportsArrayBuffer() && !(imageData instanceof Uint8Array)) {\n      imageData = binaryStringToUint8Array(imageData);\n    }\n\n    image = this[\"process\" + format.toUpperCase()](imageData);\n\n    if (!image) {\n      throw new Error(\"An unknown error occurred whilst processing the image\");\n    }\n\n    image.fileType = format;\n\n    return image;\n  };\n})(jsPDF.API);", "output": {"vulnerability_count": 2, "vulnerabilities": [{"description": "Using non-static data to retrieve and run functions from the object is dangerous. If the data is user-controlled, it may allow executing arbitrary code.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 919}, {"description": "Using non-static data to retrieve and run functions from the object is dangerous. If the data is user-controlled, it may allow executing arbitrary code.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1014}]}}
{"CVE": "CVE-2025-30222", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "/**\n * @overview Provides functionality for the Windows Command Prompt.\n * @license MPL-2.0\n */\n\n/**\n * Escape an argument for use in CMD.\n *\n * @param {string} arg The argument to escape.\n * @returns {string} The escaped argument.\n */\nfunction escapeArg(arg) {\n  let shouldEscapeSpecialChar = true;\n  return arg\n    .replace(/[\\0\\u0008\\r\\u001B\\u009B]/gu, \"\")\n    .replace(/\\n/gu, \" \")\n    .replace(/(?<!\\\\)(\\\\*)\"/gu, '$1$1\\\\\"')\n    .split(\"\")\n    .map(\n      // Due to the way CMD determines if it is inside a quoted section, and the\n      // way we escape double quotes, whether or not special character need to\n      // be escaped depends on the number of double quotes that proceed it. So,\n      // we flip a flag for every double quote we encounter and escape special\n      // characters conditionally on that flag.\n      (char) => {\n        if (char === '\"') {\n          shouldEscapeSpecialChar = !shouldEscapeSpecialChar;\n        } else if (shouldEscapeSpecialChar && /[%&<>^|]/u.test(char)) {\n          return `^${char}`;\n        }\n\n        return char;\n      },\n    )\n    .join(\"\");\n}\n\n/**\n * Returns a function to escape arguments for use in CMD for the given use case.\n *\n * @returns {Function} A function to escape arguments.\n */\nexport function getEscapeFunction() {\n  return escapeArg;\n}\n\n/**\n * Escape an argument for use in CMD when the argument is being quoted.\n *\n * @param {string} arg The argument to escape.\n * @returns {string} The escaped argument.\n */\nfunction escapeArgForQuoted(arg) {\n  return escapeArg(arg).replace(/(?<!\\\\)(\\\\*)([\\t ])/gu, \"$1$1$2\");\n}\n\n/**\n * Quotes an argument for use in CMD.\n *\n * @param {string} arg The argument to quote.\n * @returns {string} The quoted argument.\n */\nfunction quoteArg(arg) {\n  return arg.replace(/([\\t ]+)/gu, '\"$1\"');\n}\n\n/**\n * Returns a pair of functions to escape and quote arguments for use in CMD.\n *\n * @returns {Function[]} A function pair to escape & quote arguments.\n */\nexport function getQuoteFunction() {\n  return [escapeArgForQuoted, quoteArg];\n}\n\n/**\n * Remove any prefix from the provided argument that might be interpreted as a\n * flag on Windows systems for CMD.\n *\n * @param {string} arg The argument to update.\n * @returns {string} The updated argument.\n */\nfunction stripFlagPrefix(arg) {\n  return arg.replace(/^(?:-+|\\/+)/gu, \"\");\n}\n\n/**\n * Returns a function to protect against flag injection for CMD.\n *\n * @returns {Function} A function to protect against flag injection.\n */\nexport function getFlagProtectionFunction() {\n  return stripFlagPrefix;\n}", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2025-3034", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "import { Factory } from 'final-di';\nimport { Id } from 'src/core/key-transforms';\n\nimport { HashingService } from './hashing-service';\nimport { Logger } from './logger';\nimport { DatastoreAdapter } from '../../adapter/datastore-adapter';\nimport { AuthenticationException } from '../../core/exceptions/authentication-exception';\nimport { User } from '../../core/models/user';\nimport { Datastore, EventType, GetManyAnswer } from '../interfaces/datastore';\nimport { HashingHandler } from '../interfaces/hashing-handler';\nimport { UserHandler } from '../interfaces/user-handler';\n\nconst userFields: (keyof User)[] = ['id', 'username', 'password', 'is_active', 'meta_deleted'];\n\nexport class UserService implements UserHandler {\n    @Factory(DatastoreAdapter)\n    private readonly _datastore: Datastore;\n\n    @Factory(HashingService)\n    private readonly _hashingHandler: HashingHandler;\n\n    public async getUserByCredentials(username: string, password: string): Promise<User> {\n        Logger.debug(`Get user by credentials: ${username} and ${password}`);\n        return await this.readUserFromDatastoreByCredentials(username, password);\n    }\n\n    public async getUserByUserId(userId: Id): Promise<User> {\n        Logger.debug(`Get user by user id: ${userId}`);\n        return await this._datastore.get<User>('user', userId, userFields);\n    }\n\n    public async getUserByUsername(username: string): Promise<User> {\n        const userObj = await this.getUserCollectionFromDatastore('username', username);\n        Logger.debug('User object by username from datastore: ', userObj);\n\n        const users = Object.values(userObj).filter(user => !user.meta_deleted);\n        if (users.length > 1) {\n            Logger.error('Multiple users found for same username!');\n            throw new AuthenticationException('Multiple users with same credentials!');\n        }\n        const thisUser: User = new User(users[0]);\n        if (!thisUser.isExisting()) {\n            throw new AuthenticationException('Username is incorrect.');\n        }\n        if (!thisUser.is_active) {\n            throw new AuthenticationException('The account is deactivated.');\n        }\n        return thisUser;\n    }\n\n    public async updateLastLogin(userId: Id): Promise<void> {\n        await this.updateUser(userId, { last_login: Math.floor(Date.now() / 1000) });\n    }\n\n    private async updateUser(userId: Id, data: { [K in keyof User]?: unknown }): Promise<void> {\n        Logger.debug(`Update user ${userId}: ` + JSON.stringify(data));\n        await this._datastore.write({\n            user_id: userId,\n            information: {},\n            locked_fields: {},\n            events: [\n                {\n                    type: EventType.UPDATE,\n                    fqid: `user/${userId}`,\n                    fields: data\n                }\n            ]\n        });\n    }\n\n    private async isPasswordCorrect(input: string, toCompare: string): Promise<boolean> {\n        return await this._hashingHandler.isEquals(input, toCompare);\n    }\n\n    private async readUserFromDatastoreByCredentials(username: string, password: string): Promise<User> {\n        const userObj = await this.getUserCollectionFromDatastore('username', username);\n        Logger.debug('User object from datastore: ', userObj);\n        const users = Object.values(userObj).filter(user => !user.meta_deleted);\n        if (users.length > 1) {\n            Logger.error('Multiple users found for same username!');\n            throw new AuthenticationException('Multiple users with same credentials!');\n        }\n        const thisUser: User = new User(users[0]);\n        if (!thisUser.isExisting() || !(await this.isPasswordCorrect(password, thisUser.password))) {\n            throw new AuthenticationException('Username or password is incorrect.');\n        }\n        if (!thisUser.is_active) {\n            throw new AuthenticationException('The account is deactivated.');\n        }\n        // migrate old passwords\n        if (this._hashingHandler.isDeprecatedHash(thisUser.password)) {\n            const newHash = await this._hashingHandler.hash(password);\n            await this.updateUser(thisUser.id, { password: newHash });\n        }\n        return thisUser;\n    }\n\n    private async getUserCollectionFromDatastore(property: keyof User, value: string): Promise<GetManyAnswer<User>> {\n        if (!value) {\n            Logger.error(`Property ${property} is ${value}`);\n            throw new Error(`Property ${property} is ${value}`);\n        }\n        return await this._datastore.filter<User>('user', property, value, userFields);\n    }\n}", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2025-30343", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "import { Injectable } from '@angular/core';\nimport { saveAs } from 'file-saver';\nimport JSZip from 'jszip';\nimport { HttpService } from 'src/app/gateways/http.service';\n\nimport { ExportServiceModule } from '../export-service.module';\n\n@Injectable({\n    providedIn: ExportServiceModule\n})\nexport class FileExportService {\n    public constructor(private http: HttpService) {}\n\n    /**\n     * Saves a file\n     * @param file\n     * @param filename\n     * @param mimeType an optional mime type\n     */\n    public saveFile(file: BlobPart, filename: string, mimeType?: string): void {\n        const options: BlobPropertyBag = {};\n        if (mimeType) {\n            options.type = mimeType;\n        }\n        const blob = new Blob([file], options);\n        saveAs(blob, filename, { autoBom: true });\n        // autoBom = automatic byte-order-mark\n    }\n\n    /**\n     * @deprecated This is maybe too specific\n     *\n     * @param filename\n     * @param createContentFn\n     */\n    public async saveFileZip(filename: string, createContentFn: (zip: JSZip) => Promise<void>): Promise<void> {\n        const zip = new JSZip();\n        await createContentFn(zip);\n        const archive = await zip.generateAsync({ type: `blob` });\n        saveAs(archive, `${filename}.zip`);\n    }\n}", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2025-31475", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "/*jslint browser: true, evil: true */\n/* min ready */\n\nvar scripts = document.getElementsByTagName('script'),\n    tarteaucitronPath = (document.currentScript || scripts[scripts.length - 1]).src.split('?')[0],\n    tarteaucitronForceCDN = (tarteaucitronForceCDN === undefined) ? '' : tarteaucitronForceCDN,\n    tarteaucitronUseMin = (tarteaucitronUseMin === undefined) ? '' : tarteaucitronUseMin,\n    cdn = (tarteaucitronForceCDN === '') ? tarteaucitronPath.split('/').slice(0, -1).join('/') + '/' : tarteaucitronForceCDN,\n    alreadyLaunch = (alreadyLaunch === undefined) ? 0 : alreadyLaunch,\n    tarteaucitronForceLanguage = (tarteaucitronForceLanguage === undefined) ? '' : tarteaucitronForceLanguage,\n    tarteaucitronForceExpire = (tarteaucitronForceExpire === undefined) ? '' : tarteaucitronForceExpire,\n    tarteaucitronCustomText = (tarteaucitronCustomText === undefined) ? '' : tarteaucitronCustomText,\n    // tarteaucitronExpireInDay: true for day(s) value - false for hour(s) value\n    tarteaucitronExpireInDay = (tarteaucitronExpireInDay === undefined || typeof tarteaucitronExpireInDay !== \"boolean\") ? true : tarteaucitronExpireInDay,\n    timeExpire = 31536000000,\n    tarteaucitronProLoadServices,\n    tarteaucitronNoAdBlocker = false,\n    tarteaucitronIsLoaded = false;\n\n\nvar tarteaucitron = {\n    \"version\": 1.19,\n    \"cdn\": cdn,\n    \"user\": {},\n    \"lang\": {},\n    \"services\": {},\n    \"added\": [],\n    \"idprocessed\": [],\n    \"state\": {},\n    \"launch\": [],\n    \"parameters\": {},\n    \"isAjax\": false,\n    \"reloadThePage\": false,\n    \"events\": {\n        \"init\": function () {},\n        \"load\": function () {},\n    },\n    \"init\": function (params) {\n        \"use strict\";\n        var origOpen;\n\n        tarteaucitron.parameters = params;\n        if (alreadyLaunch === 0) {\n            alreadyLaunch = 1;\n            if (window.addEventListener) {\n                window.addEventListener(\"load\", function () {\n                    tarteaucitron.initEvents.loadEvent(false);\n                }, false);\n                window.addEventListener(\"scroll\", function () {\n                    tarteaucitron.initEvents.scrollEvent();\n                }, false);\n\n                window.addEventListener(\"keydown\", function (evt) {\n                    tarteaucitron.initEvents.keydownEvent(false, evt);\n                }, false);\n                window.addEventListener(\"hashchange\", function () {\n                    tarteaucitron.initEvents.hashchangeEvent();\n                }, false);\n                window.addEventListener(\"resize\", function () {\n                    tarteaucitron.initEvents.resizeEvent();\n                }, false);\n            } else {\n                window.attachEvent(\"onload\", function () {\n                    tarteaucitron.initEvents.loadEvent(true);\n                });\n                window.attachEvent(\"onscroll\", function () {\n                    tarteaucitron.initEvents.scrollEvent();\n                });\n                window.attachEvent(\"onkeydown\", function (evt) {\n                    tarteaucitron.initEvents.keydownEvent(true, evt);\n\n                });\n                window.attachEvent(\"onhashchange\", function () {\n                    tarteaucitron.initEvents.hashchangeEvent();\n                });\n                window.attachEvent(\"onresize\", function () {\n                    tarteaucitron.initEvents.resizeEvent();\n                });\n            }\n\n            if (typeof XMLHttpRequest !== 'undefined') {\n                origOpen = XMLHttpRequest.prototype.open;\n                XMLHttpRequest.prototype.open = function () {\n\n                    if (window.addEventListener) {\n                        this.addEventListener(\"load\", function () {\n                            if (typeof tarteaucitronProLoadServices === 'function') {\n                                tarteaucitronProLoadServices();\n                            }\n                        }, false);\n                    } else if (typeof this.attachEvent !== 'undefined') {\n                        this.attachEvent(\"onload\", function () {\n                            if (typeof tarteaucitronProLoadServices === 'function') {\n                                tarteaucitronProLoadServices();\n                            }\n                        });\n                    } else {\n                        if (typeof tarteaucitronProLoadServices === 'function') {\n                            setTimeout(tarteaucitronProLoadServices, 1000);\n                        }\n                    }\n\n                    try {\n                        origOpen.apply(this, arguments);\n                    } catch (err) {}\n                };\n            }\n        }\n\n        if(tarteaucitron.events.init) {\n            tarteaucitron.events.init();\n        }\n    },\n    \"initEvents\": {\n        \"loadEvent\": function (isOldBrowser) {\n            tarteaucitron.load();\n            tarteaucitron.fallback(['tarteaucitronOpenPanel'], function (elem) {\n                if (isOldBrowser) {\n                    elem.attachEvent(\"onclick\", function (event) {\n                        tarteaucitron.userInterface.openPanel();\n                        event.preventDefault();\n                    });\n                } else {\n                    elem.addEventListener(\"click\", function (event) {\n                        tarteaucitron.userInterface.openPanel();\n                        event.preventDefault();\n                    }, false);\n                }\n            }, true);\n        },\n        \"keydownEvent\": function (isOldBrowser, evt) {\n            if (evt.keyCode === 27) {\n                tarteaucitron.userInterface.closePanel();\n            }\n\n            if (isOldBrowser) {\n                if ( evt.keyCode === 9 && focusableEls.indexOf(evt.target) >= 0) {\n                    if ( evt.shiftKey ) /* shift + tab */ {\n                        if (document.activeElement === firstFocusableEl) {\n                            lastFocusableEl.focus();\n                            evt.preventDefault();\n                        }\n                    } else /* tab */ {\n                        if (document.activeElement === lastFocusableEl) {\n                            firstFocusableEl.focus();\n                            evt.preventDefault();\n                        }\n                    }\n                }\n            }\n        },\n        \"hashchangeEvent\": function () {\n            if (document.location.hash === tarteaucitron.hashtag && tarteaucitron.hashtag !== '') {\n                tarteaucitron.userInterface.openPanel();\n            }\n        },\n        \"resizeEvent\": function () {\n            var tacElem = document.getElementById('tarteaucitron');\n            var tacCookieContainer = document.getElementById('tarteaucitronCookiesListContainer');\n\n            if (tacElem && tacElem.style.display === 'block') {\n                tarteaucitron.userInterface.jsSizing('main');\n            }\n\n            if (tacCookieContainer && tacCookieContainer.style.display === 'block') {\n                tarteaucitron.userInterface.jsSizing('cookie');\n            }\n        },\n        \"scrollEvent\": function () {\n            var scrollPos = window.pageYOffset || document.documentElement.scrollTop;\n            var heightPosition;\n            var tacPercentage = document.getElementById('tarteaucitronPercentage');\n            var tacAlertBig = document.getElementById('tarteaucitronAlertBig');\n\n            if (tacAlertBig && !tarteaucitron.highPrivacy) {\n                if (tacAlertBig.style.display === 'block') {\n                    heightPosition = tacAlertBig.offsetHeight + 'px';\n\n                    if (scrollPos > (screen.height * 2)) {\n                        tarteaucitron.userInterface.respondAll(true);\n                    } else if (scrollPos > (screen.height / 2)) {\n                        document.getElementById('tarteaucitronDisclaimerAlert').innerHTML = '<strong>' + tarteaucitron.lang.alertBigScroll + '</strong> ' + tarteaucitron.lang.alertBig;\n                    }\n\n                    if (tacPercentage) {\n                        if (tarteaucitron.orientation === 'top') {\n                            tacPercentage.style.top = heightPosition;\n                        } else {\n                            tacPercentage.style.bottom = heightPosition;\n                        }\n                        tacPercentage.style.width = ((100 / (screen.height * 2)) * scrollPos) + '%';\n                    }\n                }\n            }\n        },\n    },\n    \"load\": function () {\n        \"use strict\";\n\n        if (tarteaucitronIsLoaded === true) {\n            return;\n        }\n\n        var cdn = tarteaucitron.cdn,\n            language = tarteaucitron.getLanguage(),\n            useMinifiedJS = ((new URL(cdn).host == 'cdn.jsdelivr.net') || (tarteaucitronPath.indexOf('.min.') >= 0) || (tarteaucitronUseMin !== '')),\n            pathToLang = cdn + 'lang/tarteaucitron.' + language + (useMinifiedJS ? '.min' : '') + '.js',\n            pathToServices = cdn + 'tarteaucitron.services' + (useMinifiedJS ? '.min' : '') + '.js',\n            linkElement = document.createElement('link'),\n            defaults = {\n                \"adblocker\": false,\n                \"hashtag\": '#tarteaucitron',\n                \"cookieName\": 'tarteaucitron',\n                \"highPrivacy\": true,\n                \"orientation\": \"middle\",\n                \"bodyPosition\": \"bottom\",\n                \"removeCredit\": false,\n                \"showAlertSmall\": false,\n                \"showDetailsOnClick\": true,\n                \"showIcon\": true,\n                \"iconPosition\": \"BottomRight\",\n                \"cookieslist\": false,\n                \"handleBrowserDNTRequest\": false,\n                \"DenyAllCta\": true,\n                \"AcceptAllCta\" : true,\n                \"moreInfoLink\": true,\n                \"privacyUrl\": \"\",\n                \"useExternalCss\": false,\n                \"useExternalJs\": false,\n                \"mandatory\": true,\n                \"mandatoryCta\": true,\n                \"closePopup\": false,\n                \"groupServices\": false,\n                \"serviceDefaultState\": 'wait',\n                \"googleConsentMode\": true,\n                \"bingConsentMode\": true,\n                \"dataLayer\": false,\n                \"serverSide\": false,\n                \"partnersList\": false,\n                \"alwaysNeedConsent\": false\n            },\n            params = tarteaucitron.parameters;\n\n        // flag the tac load\n        tarteaucitronIsLoaded = true;\n\n        // Don't show the middle bar if we are on the privacy policy or more page\n        if (((tarteaucitron.parameters.readmoreLink !== undefined && window.location.href == tarteaucitron.parameters.readmoreLink) || window.location.href == tarteaucitron.parameters.privacyUrl) && tarteaucitron.parameters.orientation == \"middle\") {\n            tarteaucitron.parameters.orientation = \"bottom\";\n        }\n\n        // Step -1\n        if (typeof tarteaucitronCustomPremium !== 'undefined') {\n            tarteaucitronCustomPremium();\n        }\n\n        // Step 0: get params\n        if (params !== undefined) {\n\n            for (var k in defaults) {\n                if(!tarteaucitron.parameters.hasOwnProperty(k)) {\n                    tarteaucitron.parameters[k] = defaults[k];\n                }\n            }\n        }\n\n        // global\n        tarteaucitron.orientation = tarteaucitron.parameters.orientation;\n        tarteaucitron.hashtag = tarteaucitron.parameters.hashtag;\n        tarteaucitron.highPrivacy = tarteaucitron.parameters.highPrivacy;\n        tarteaucitron.handleBrowserDNTRequest = tarteaucitron.parameters.handleBrowserDNTRequest;\n        tarteaucitron.customCloserId = tarteaucitron.parameters.customCloserId;\n\n        // update dataLayer when consent is updated\n        if (tarteaucitron.parameters.dataLayer === true) {\n            document.addEventListener('tac.consent_updated', function () {\n                window.dataLayer = window.dataLayer || [];\n                window.dataLayer.push({\n                    event: 'tac_consent_update',\n                    tacAuthorizedVendors: tarteaucitron.job.filter(job => tarteaucitron.state[job] === true)\n                });\n            });\n        }\n        \n        // bing consent mode\n        if (tarteaucitron.parameters.bingConsentMode === true) {\n            window.uetq = window.uetq || [];\n            window.uetq.push('consent', 'default', {'ad_storage': 'denied'});\n\n            document.addEventListener('clarity_loaded', function () {\n                window.uetq.push('consent', 'update', {'ad_storage': 'granted'});\n            });\n            document.addEventListener('clarity_allowed', function () {\n                window.uetq.push('consent', 'update', {'ad_storage': 'granted'});\n            });\n            document.addEventListener('clarity_disallowed', function () {\n                window.uetq.push('consent', 'update', {'ad_storage': 'denied'});\n            });\n            document.addEventListener('bingads_loaded', function () {\n                window.uetq.push('consent', 'update', {'ad_storage': 'granted'});\n            });\n            document.addEventListener('bingads_allowed', function () {\n                window.uetq.push('consent', 'update', {'ad_storage': 'granted'});\n            });\n            document.addEventListener('bingads_disallowed', function () {\n                window.uetq.push('consent', 'update', {'ad_storage': 'denied'});\n            });\n\n            window.addEventListener('tac.root_available', function() {\n                if (typeof tarteaucitron_block !== 'undefined') {\n                    tarteaucitron_block.unblock(/clarity\\.ms/);\n                    tarteaucitron_block.unblock(/bat\\.bing\\.com/);\n                }\n            });\n        }\n\n        // google consent mode\n        if (tarteaucitron.parameters.googleConsentMode === true) {\n\n            // set the dataLayer and a function to update\n            window.dataLayer = window.dataLayer || [];\n            window.tac_gtag = function tac_gtag() {\n                dataLayer.push(arguments);\n            };\n\n            // default consent to denied\n            window.tac_gtag('consent', 'default', {\n                ad_storage: 'denied',\n                analytics_storage: 'denied',\n                ad_user_data: 'denied',\n                ad_personalization: 'denied',\n                wait_for_update: 800\n            });\n\n            // if google ads, add a service for personalized ads\n            document.addEventListener('googleads_added', function() {\n\n                // skip if already added\n                if (tarteaucitron.added[\"gcmads\"] === true) {\n                    return;\n                }\n\n                // simple service to control gcm with event\n                tarteaucitron.services.gcmads = {\n                    \"key\": \"gcmads\",\n                    \"type\": \"ads\",\n                    \"name\": \"Google Ads (personalized ads)\",\n                    \"uri\": \"https://support.google.com/analytics/answer/9976101\",\n                    \"needConsent\": true,\n                    \"cookies\": [],\n                    \"js\": function() {},\n                    \"fallback\": function() {}\n                };\n                tarteaucitron.job.push('gcmads');\n\n                // fix the event handler on the buttons\n                var i,\n                    allowBtns = document.getElementsByClassName(\"tarteaucitronAllow\"),\n                    denyBtns = document.getElementsByClassName(\"tarteaucitronDeny\");\n                for (i = 0; i < allowBtns.length; i++) {\n                    tarteaucitron.addClickEventToElement(allowBtns[i], function() {\n                        tarteaucitron.userInterface.respond(this, true);\n                    });\n                }\n                for (i = 0; i < denyBtns.length; i++) {\n                    tarteaucitron.addClickEventToElement(denyBtns[i], function() {\n                        tarteaucitron.userInterface.respond(this, false);\n                    });\n                }\n            });\n\n            // when personalized ads are accepted, accept googleads\n            document.addEventListener('gcmads_allowed', function() {\n                tarteaucitron.setConsent('googleads', true);\n            });\n\n            // personalized ads loaded/allowed, set gcm to granted\n            document.addEventListener('gcmads_loaded', function() {\n                window.tac_gtag('consent', 'update', {\n                    ad_user_data: 'granted',\n                    ad_personalization: 'granted'\n                });\n            });\n            document.addEventListener('gcmads_allowed', function() {\n                window.tac_gtag('consent', 'update', {\n                    ad_user_data: 'granted',\n                    ad_personalization: 'granted'\n                });\n            });\n\n            // personalized ads disallowed, set gcm to denied\n            document.addEventListener('gcmads_disallowed', function() {\n                window.tac_gtag('consent', 'update', {\n                    ad_user_data: 'denied',\n                    ad_personalization: 'denied'\n                });\n            });\n\n            // google ads loaded/allowed, set gcm to granted\n            document.addEventListener('googleads_loaded', function() {\n                window.tac_gtag('consent', 'update', {\n                    ad_storage: 'granted'\n                });\n            });\n            document.addEventListener('googleads_allowed', function() {\n                window.tac_gtag('consent', 'update', {\n                    ad_storage: 'granted'\n                });\n            });\n\n            // google ads disallowed, disable personalized ads and update gcm\n            document.addEventListener('googleads_disallowed', function() {\n                tarteaucitron.setConsent('gcmads', false);\n                window.tac_gtag('consent', 'update', {\n                    ad_storage: 'denied'\n                });\n            });\n\n            // ga4 loaded/allowed, set gcm to granted\n            document.addEventListener('gtag_loaded', function() {\n                window.tac_gtag('consent', 'update', {\n                    analytics_storage: 'granted'\n                });\n            });\n            document.addEventListener('gtag_allowed', function() {\n                window.tac_gtag('consent', 'update', {\n                    analytics_storage: 'granted'\n                });\n            });\n\n            // ga4 disallowed, update gcm\n            document.addEventListener('gtag_disallowed', function() {\n                window.tac_gtag('consent', 'update', {\n                    analytics_storage: 'denied'\n                });\n            });\n\n            // multiple ga4 loaded/allowed, set gcm to granted\n            document.addEventListener('multiplegtag_loaded', function() {\n                window.tac_gtag('consent', 'update', {\n                    analytics_storage: 'granted'\n                });\n            });\n            document.addEventListener('multiplegtag_allowed', function() {\n                window.tac_gtag('consent', 'update', {\n                    analytics_storage: 'granted'\n                });\n            });\n\n            // multiple ga4 disallowed, update gcm\n            document.addEventListener('multiplegtag_disallowed', function() {\n                window.tac_gtag('consent', 'update', {\n                    analytics_storage: 'denied'\n                });\n            });\n\n            // allow gtag/googleads by default if consent mode is on\n            window.addEventListener('tac.root_available', function() {\n                if (typeof tarteaucitron_block !== 'undefined') {\n                    tarteaucitron_block.unblock(/www\\.googletagmanager\\.com\\/gtag\\/js/);\n                    tarteaucitron_block.unblock(/www\\.googleadservices\\.com\\/pagead\\/conversion/);\n                    tarteaucitron_block.unblock(/AW-/);\n                    tarteaucitron_block.unblock(/google-analytics\\.com\\/analytics\\.js/);\n                    tarteaucitron_block.unblock(/google-analytics\\.com\\/ga\\.js/);\n                }\n            });\n        }\n\n        // Step 1: load css\n        if ( !tarteaucitron.parameters.useExternalCss ) {\n            linkElement.rel = 'stylesheet';\n            linkElement.type = 'text/css';\n            linkElement.href = cdn + 'css/tarteaucitron' + (useMinifiedJS ? '.min' : '') + '.css';\n            document.getElementsByTagName('head')[0].appendChild(linkElement);\n        }\n        // Step 2: load language and services\n        tarteaucitron.addInternalScript(pathToLang, '', function () {\n\n          if(tarteaucitronCustomText !== ''){\n            tarteaucitron.lang = tarteaucitron.AddOrUpdate(tarteaucitron.lang, tarteaucitronCustomText);\n          }\n            tarteaucitron.addInternalScript(pathToServices, '', function () {\n\n                // css for the middle bar TODO: add it on the css file\n                if (tarteaucitron.orientation === 'middle') {\n                    var customThemeMiddle = document.createElement('style'),\n                        cssRuleMiddle = 'div#tarteaucitronRoot.tarteaucitronBeforeVisible:before {content: \\'\\';position: fixed;width: 100%;height: 100%;background: white;top: 0;left: 0;z-index: 999;opacity: 0.5;}div#tarteaucitronAlertBig:before {content: \\'' + tarteaucitron.lang.middleBarHead + '\\';font-size: 35px;}body #tarteaucitronRoot div#tarteaucitronAlertBig {width: 60%;min-width: 285px;height: auto;margin: auto;left: 50%;top: 50%;transform: translate(-50%, -50%);box-shadow: 0 0 9000px #000;border-radius: 20px;padding: 35px 25px;}span#tarteaucitronDisclaimerAlert {padding: 0 30px;}#tarteaucitronRoot span#tarteaucitronDisclaimerAlert {margin: 10px 0 30px;display: block;text-align: center;font-size: 21px;}@media screen and (max-width: 900px) {div#tarteaucitronAlertBig button {margin: 0 auto 10px!important;display: block!important;}}';\n\n                    customThemeMiddle.type = 'text/css';\n                    if (customThemeMiddle.styleSheet) {\n                        customThemeMiddle.styleSheet.cssText = cssRuleMiddle;\n                    } else {\n                        customThemeMiddle.appendChild(document.createTextNode(cssRuleMiddle));\n                    }\n                    document.getElementsByTagName('head')[0].appendChild(customThemeMiddle);\n                }\n\n                // disable the expand option if services grouped by category\n                if (tarteaucitron.parameters.groupServices == true) {\n                    tarteaucitron.parameters.showDetailsOnClick = true;\n                }\n\n                // css for the popup bar TODO: add it on the css file\n                if (tarteaucitron.orientation === 'popup') {\n                    var customThemePopup = document.createElement('style'),\n                        cssRulePopup = 'div#tarteaucitronAlertBig:before {content: \\'' + tarteaucitron.lang.middleBarHead + '\\';font-size: 22px;}body #tarteaucitronRoot div#tarteaucitronAlertBig {bottom: 0;top: auto!important;left: 8px!important;right: auto!important;transform: initial!important;border-radius: 5px 5px 0 0!important;max-width: 250px!important;width: calc(100% - 16px)!important;min-width: 0!important;padding: 25px 0;}span#tarteaucitronDisclaimerAlert {padding: 0 30px;font-size: 15px!important;}#tarteaucitronRoot span#tarteaucitronDisclaimerAlert {margin: 10px 0 30px;display: block;text-align: center;font-size: 21px;}div#tarteaucitronAlertBig button:not(#tarteaucitronCloseCross) {margin: 0 auto 10px!important;display: block!important;width: calc(100% - 60px);box-sizing: border-box;}';\n\n                    customThemePopup.type = 'text/css';\n                    if (customThemePopup.styleSheet) {\n                        customThemePopup.styleSheet.cssText = cssRulePopup;\n                    } else {\n                        customThemePopup.appendChild(document.createTextNode(cssRulePopup));\n                    }\n                    document.getElementsByTagName('head')[0].appendChild(customThemePopup);\n                }\n\n                var body = document.body,\n                    div = document.createElement('div'),\n                    html = '',\n                    index,\n                    orientation = 'Top',\n                    modalAttrs = '',\n                    cat = ['ads', 'analytic', 'api', 'comment', 'social', 'support', 'video', 'other', 'google'],\n                    i;\n\n                cat = cat.sort(function (a, b) {\n                    if (tarteaucitron.lang[a].title > tarteaucitron.lang[b].title) { return 1; }\n                    if (tarteaucitron.lang[a].title < tarteaucitron.lang[b].title) { return -1; }\n                    return 0;\n                });\n\n                // Step 3: prepare the html\n                html += '<div role=\"heading\" aria-level=\"1\" id=\"tac_title\" class=\"tac_visually-hidden\">' + tarteaucitron.lang.title + '</div>';\n                html += '<div id=\"tarteaucitronPremium\"></div>';\n                if (tarteaucitron.reloadThePage) {\n                    html += '<button type=\"button\" id=\"tarteaucitronBack\" aria-label=\"' + tarteaucitron.lang.close + ' (' + tarteaucitron.lang.reload + ')\" title=\"' + tarteaucitron.lang.close + ' (' + tarteaucitron.lang.reload + ')\"></button>';\n                } else {\n                    html += '<button type=\"button\" id=\"tarteaucitronBack\" aria-label=\"' + tarteaucitron.lang.close + '\" title=\"' + tarteaucitron.lang.close + '\"></button>';\n                }\n                html += '<div id=\"tarteaucitron\" role=\"dialog\" aria-modal=\"true\" aria-labelledby=\"dialogTitle\" tabindex=\"-1\">';\n                if (tarteaucitron.reloadThePage) {\n                    html += '   <button type=\"button\" id=\"tarteaucitronClosePanel\" aria-describedby=\"dialogTitle\" aria-label=\"' + tarteaucitron.lang.close + ' (' + tarteaucitron.lang.reload + ')\" title=\"' + tarteaucitron.lang.close + ' (' + tarteaucitron.lang.reload + ')\">';\n                } else {\n                    html += '   <button type=\"button\" id=\"tarteaucitronClosePanel\" aria-describedby=\"dialogTitle\" >';\n                }\n                html += '       ' + tarteaucitron.lang.close;\n                html += '   </button>';\n                html += '   <div id=\"tarteaucitronServices\">';\n                html += '      <div class=\"tarteaucitronLine tarteaucitronMainLine\" id=\"tarteaucitronMainLineOffset\">';\n                html += '         <span class=\"tarteaucitronH1\" role=\"heading\" aria-level=\"1\" id=\"dialogTitle\">'+ tarteaucitron.lang.title + '</span>';\n                html += '         <div id=\"tarteaucitronInfo\">';\n                html += '         ' + tarteaucitron.lang.disclaimer;\n                if (tarteaucitron.parameters.privacyUrl !== \"\") {\n                    html += '   <br/><br/>';\n                    html += '   <button type=\"button\" id=\"tarteaucitronPrivacyUrlDialog\" role=\"link\">';\n                    html += '       ' + tarteaucitron.lang.privacyUrl;\n                    html += '   </button>';\n                }\n                html += '         </div>';\n                html += '         <div class=\"tarteaucitronName\">';\n                html += '            <span class=\"tarteaucitronH2\" role=\"heading\" aria-level=\"2\">' + tarteaucitron.lang.all + '</span>';\n                html += '         </div>';\n                html += '         <div class=\"tarteaucitronAsk\" id=\"tarteaucitronScrollbarAdjust\">';\n                html += '            <button type=\"button\" id=\"tarteaucitronAllAllowed\" class=\"tarteaucitronAllow\">';\n                html += '               <span class=\"tarteaucitronCheck\" aria-hidden=\"true\"></span> ' + tarteaucitron.lang.allowAll;\n                html += '            </button> ';\n                html += '            <button type=\"button\" id=\"tarteaucitronAllDenied\" class=\"tarteaucitronDeny\">';\n                html += '               <span class=\"tarteaucitronCross\" aria-hidden=\"true\"></span> ' + tarteaucitron.lang.denyAll;\n                html += '            </button>';\n                html += '         </div>';\n                html += '      </div>';\n                html += '      <div class=\"tarteaucitronBorder\">';\n                html += '         <div class=\"clear\"></div><ul>';\n\n\n                if (tarteaucitron.parameters.mandatory == true) {\n                   html += '<li id=\"tarteaucitronServicesTitle_mandatory\">';\n                   html += '<div class=\"tarteaucitronTitle\">';\n                    if(tarteaucitron.parameters.showDetailsOnClick){\n                        html += '   <button type=\"button\" tabindex=\"-1\"><span class=\"tarteaucitronPlus\" aria-hidden=\"true\"></span> ' + tarteaucitron.lang.mandatoryTitle + '</button>';\n                    }else{\n                        html += '   <span class=\"asCatToggleBtn\">' + tarteaucitron.lang.mandatoryTitle + '</span>';\n                    }\n                   html += '</div>';\n                   html += '<ul id=\"tarteaucitronServices_mandatory\">';\n                   html += '<li class=\"tarteaucitronLine\">';\n                   html += '   <div class=\"tarteaucitronName\">';\n                   html += '       <span class=\"tarteaucitronH3\" role=\"heading\" aria-level=\"3\">' + tarteaucitron.lang.mandatoryText + '</span>';\n                   html += '       <span class=\"tarteaucitronListCookies\" aria-hidden=\"true\"></span><br/>';\n                   html += '   </div>';\n                   if (tarteaucitron.parameters.mandatoryCta == true) {\n                       html += '   <div class=\"tarteaucitronAsk\">';\n                       html += '       <button type=\"button\" class=\"tarteaucitronAllow\" tabindex=\"-1\" disabled>';\n                       html += '           <span class=\"tarteaucitronCheck\" aria-hidden=\"true\"></span> ' + tarteaucitron.lang.allow;\n                       html += '       </button> ';\n                       html += '       <button type=\"button\" class=\"tarteaucitronDeny\" tabindex=\"-1\">';\n                       html += '           <span class=\"tarteaucitronCross\" aria-hidden=\"true\"></span> ' + tarteaucitron.lang.deny;\n                       html += '       </button> ';\n                       html += '   </div>';\n                   }\n                   html += '</li>';\n                   html += '</ul></li>';\n                }\n\n                for (i = 0; i < cat.length; i += 1) {\n                    html += '         <li id=\"tarteaucitronServicesTitle_' + cat[i] + '\" class=\"tarteaucitronHidden\">';\n                    html += '            <div class=\"tarteaucitronTitle\" role=\"heading\" aria-level=\"2\">';\n                    if(tarteaucitron.parameters.showDetailsOnClick)\n                    {\n                        html += '               <button type=\"button\" class=\"catToggleBtn\" aria-expanded=\"false\" data-cat=\"tarteaucitronDetails' + cat[i] + '\"><span class=\"tarteaucitronPlus\" aria-hidden=\"true\"></span> ' + tarteaucitron.lang[cat[i]].title + '</button>';\n                    }else{\n                        html += '               <span class=\"asCatToggleBtn\" data-cat=\"tarteaucitronInlineDetails' + cat[i] + '\">' + tarteaucitron.lang[cat[i]].title + '</span>';\n                    }\n                    html += '            </div>';\n                    html += '            <div id=\"tarteaucitronDetails' + cat[i] + '\" class=\"tarteaucitronDetails '+ (tarteaucitron.parameters.showDetailsOnClick ? 'tarteaucitronInfoBox' : 'tarteaucitronDetailsInline')+'\">';\n                    html += '               ' + tarteaucitron.lang[cat[i]].details;\n                    html += '            </div>';\n                    html += '         <ul id=\"tarteaucitronServices_' + cat[i] + '\"></ul></li>';\n                }\n                html += '             <li id=\"tarteaucitronNoServicesTitle\" class=\"tarteaucitronLine\">' + tarteaucitron.lang.noServices + '</li>';\n                html += '         </ul>';\n                html += '         <div class=\"tarteaucitronHidden tarteaucitron-spacer-20\" id=\"tarteaucitronScrollbarChild\"></div>';\n                if (tarteaucitron.parameters.removeCredit === false) {\n                    html += '     <a class=\"tarteaucitronSelfLink\" href=\"https://tarteaucitron.io/\" rel=\"nofollow noreferrer noopener\" target=\"_blank\" title=\"tarteaucitron ' + tarteaucitron.lang.newWindow + '\"><img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHcAAAAeCAYAAAAWwoEYAAADl0lEQVRoge1Y0W3bQAx9CjKARlC+9GVUmqDJBHEmiDyB6wkcTxBngtgTxJ0gzgQW4C/9aYOmE6g4lTQo+k6y3Rb94QOERNQd+cjj8XiGwWAwGAwGg8FgMBgMBoPB8F8RNRXe+whEKe7c36ZCAeCRxC9Rig2PUd8kPgAsoxSfQ3YAzAA8D/HwYYCb05kBKKO0teFkmbC1jlKsAnq/Abjn+QBqAIsoRS30ttwG/HNz1wH/XIxWTicLdvtW7xTAGEAMtP685CNsBTe2d/BLydfXAG57SEnMAST0zgYZSUCPk02bCvkJduIzuJzDLfPolbY+tLKmar+/8+IRePy4qdpE03qHuH8fipFb4N2+XdA3AJ/0vaQxt7s9FvkIS2XvtqnwM0rxpOQfbnE5G2LhTCmUO2fHIngOmcv+KG3HafDchB6ntwjYqenR2PqC7sOZ3E7FXHB0vqxoFyUyLh7OEH7LOGouvhhN3eIBeKXv0n5MsufdHqXcwYR5U2EbpV35lSspVPJmQj4TcgRK7jTg5IzmPUhhwM5a2WHUFCx+NgiDucmgh7idikLovHFlL0pxQ9xzX+IIP9Y6FrJsqhjlQpZRAkFVDCjZfcCHt6bqJDmuh5ylCWx0RVnk3oumaknqTH5sqrY0fBWyULaHUIgAgxb46MxV3DbieAhxOxUxjSuljig9lMQ/Bcfoi9BTEv9aLORSndVxYOH525sUDC6u2gWxcNzBNRxPanyh3ktKinOgy3WoxPbtUM0t6RkbQnzBnFPgi9GCOEubY9UffIryz9iKRe8s/FUfEWosJJGxagp85bpUO3VywQ46lOtAWfNxKwa4JXQ+628+bpxYGXXMzp5rXH401VEyXwIdowXFaKWSMFHvMTVmGnc+P3oXV2QOiBCfgex8QtcQCbcQE/H+eoHzrkFo1KM7zVO4jVVj5s6lRiWF7zyXyfRMc97J3tzj87mYqZ7E2YjzUct9GUi4tjHLR8dVkBLjQcuHFleWvQfRNEhFR7uX7pkctOwvZXsft7sAtyldEUIN2UTeLxnEfxKYswzdi88BdbZ8hifUoSMftQvP+muRwN6+Q3DeqqRExP9QmTtcheiHh0Ot1x2i2km1bP9pbufw5zZdyWsOrh7vQae5OZWbsMv30pi7cd/CKj3coPEVaCP4Zhx4eQWhOZ1Y9MTXGyP8/iGjEyfa1T4fO/4Lea9vBoPBYDAYDAaDwWAwGAwGwz8GgF8siXCCbrSRhgAAAABJRU5ErkJggg==\" alt=\"tarteaucitron.io\" /></a>';\n                }\n                html += '       </div>';\n                html += '   </div>';\n                html += '</div>';\n\n                if (tarteaucitron.parameters.orientation === 'bottom') {\n                    orientation = 'Bottom';\n                }\n\n                if (tarteaucitron.parameters.orientation === 'middle' || tarteaucitron.parameters.orientation === 'popup') {\n                    modalAttrs = ' role=\"dialog\" aria-modal=\"true\" aria-labelledby=\"tac_title\"';\n                }\n\n                if (tarteaucitron.parameters.highPrivacy && !tarteaucitron.parameters.AcceptAllCta) {\n                    html += '<div tabindex=\"-1\" id=\"tarteaucitronAlertBig\" class=\"tarteaucitronAlertBig' + orientation + '\"' + modalAttrs + '>';\n                    //html += '<div class=\"tarteaucitronAlertBigWrapper\">';\n                    html += '   <span id=\"tarteaucitronDisclaimerAlert\" role=\"paragraph\">';\n                    html += '       ' + tarteaucitron.lang.alertBigPrivacy;\n                    html += '   </span>';\n                    //html += '   <span class=\"tarteaucitronAlertBigBtnWrapper\">';\n                    html += '   <button type=\"button\" id=\"tarteaucitronPersonalize\" aria-label=\"' + tarteaucitron.lang.personalize + ' ' + tarteaucitron.lang.modalWindow + '\" title=\"' + tarteaucitron.lang.personalize + ' ' + tarteaucitron.lang.modalWindow + '\">';\n                    html += '       ' + tarteaucitron.lang.personalize;\n                    html += '   </button>';\n\n                    if (tarteaucitron.parameters.privacyUrl !== \"\") {\n                        html += '   <button role=\"link\" type=\"button\" id=\"tarteaucitronPrivacyUrl\">';\n                        html += '       ' + tarteaucitron.lang.privacyUrl;\n                        html += '   </button>';\n                    }\n\n                    //html += '   </span>';\n                    //html += '</div>';\n                    html += '</div>';\n                } else {\n                    html += '<div tabindex=\"-1\" id=\"tarteaucitronAlertBig\" class=\"tarteaucitronAlertBig' + orientation + '\"' + modalAttrs + '>';\n                    //html += '<div class=\"tarteaucitronAlertBigWrapper\">';\n                    html += '   <span id=\"tarteaucitronDisclaimerAlert\" role=\"paragraph\">';\n\n                    if (tarteaucitron.parameters.highPrivacy) {\n                        html += '       ' + tarteaucitron.lang.alertBigPrivacy;\n                    } else {\n                        html += '       ' + tarteaucitron.lang.alertBigClick + ' ' + tarteaucitron.lang.alertBig;\n                    }\n\n                    html += '   </span>';\n                    //html += '   <span class=\"tarteaucitronAlertBigBtnWrapper\">';\n                    html += '   <button type=\"button\" class=\"tarteaucitronCTAButton tarteaucitronAllow\" id=\"tarteaucitronPersonalize2\" aria-describedby=\"tarteaucitronDisclaimerAlert\" >';\n                    html += '       <span class=\"tarteaucitronCheck\" aria-hidden=\"true\"></span> ' + tarteaucitron.lang.acceptAll;\n                    html += '   </button>';\n\n\n                    if (tarteaucitron.parameters.DenyAllCta) {\n                        if (tarteaucitron.reloadThePage) {\n                                    html += '   <button type=\"button\" class=\"tarteaucitronCTAButton tarteaucitronDeny\" id=\"tarteaucitronAllDenied2\" aria-describedby=\"tarteaucitronDisclaimerAlert\" aria-label=\"' + tarteaucitron.lang.denyAll + ' (' + tarteaucitron.lang.reload + ')\" title=\"' + tarteaucitron.lang.denyAll + ' (' + tarteaucitron.lang.reload + ')\">';\n                        } else {\n                                    html += '   <button type=\"button\" class=\"tarteaucitronCTAButton tarteaucitronDeny\" id=\"tarteaucitronAllDenied2\" aria-describedby=\"tarteaucitronDisclaimerAlert\" >';\n                        }\n                                    html += '       <span class=\"tarteaucitronCross\" aria-hidden=\"true\"></span> ' + tarteaucitron.lang.denyAll;\n                                    html += '   </button>';\n                                    //html += '   <br/><br/>';\n                    }\n\n                    html += '   <button type=\"button\" id=\"tarteaucitronCloseAlert\"  aria-describedby=\"tarteaucitronDisclaimerAlert\" aria-label=\"' + tarteaucitron.lang.personalize + ' ' + tarteaucitron.lang.modalWindow + '\" title=\"' + tarteaucitron.lang.personalize + ' ' + tarteaucitron.lang.modalWindow + '\">';\n                    html += '       ' + tarteaucitron.lang.personalize;\n                    html += '   </button>';\n\n                    if (tarteaucitron.parameters.privacyUrl !== \"\") {\n                        html += '   <button type=\"button\" id=\"tarteaucitronPrivacyUrl\" role=\"link\">';\n                        html += '       ' + tarteaucitron.lang.privacyUrl;\n                        html += '   </button>';\n                    }\n\n                    //html += '   </span>';\n                    //html += '</div>';\n                    html += '</div>';\n                    html += '<div id=\"tarteaucitronPercentage\"></div>';\n                }\n\n                if (tarteaucitron.parameters.showIcon === true) {\n                    html += '<div id=\"tarteaucitronIcon\" class=\"tarteaucitronIcon' + tarteaucitron.parameters.iconPosition + '\">';\n                    html += '   <button type=\"button\" id=\"tarteaucitronManager\" aria-label=\"' + tarteaucitron.lang.icon + ' ' + tarteaucitron.lang.modalWindow + '\" title=\"' + tarteaucitron.lang.icon + ' ' + tarteaucitron.lang.modalWindow + '\">';\n                    html += '       <img src=\"' + (tarteaucitron.parameters.iconSrc ? tarteaucitron.parameters.iconSrc : 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAGA0lEQVRoge1a207bWBRdBtJwLYZhKDMVmlSK1LxNkPo+ZH6g8B6p5AuALwC+APoFoVLeoT8whPeRSt+CZKmZVu3AiIsRlEtCktGyjy8xzuXYhvahS0JJHJ/4rLP3XnuffcAPfGdQ7mM6jRLSAF4BxqsbewB2lRS2o35mpEQaJcwCyANIdLi1DGBNSWEzqmdHRqRRwjqAJclhtExOSUEP+/xIiDRKhhUWfL7ShTtBuJnqcw+/z4Ql0xNmMEwSSz4kuNIzSgpjSsqYJP/GeE185wYJroedRyiLNEpGLLzzrHSuk+83SgbxvOcyyRaDziWsRVZkSRDinpzPbwVGWIucuohsKynMS47fAQyls/BMSRmKJo3AFhG5wm2N1wF+Zs3zebbFfR0RxrXcJHQlgH+LMW616pR/WiIMEXfW3mtzXyeEGWsjKot8c4TOI98L+iKaR5PS6IUk88RLAO9F8UjrbYoYMOosNavpfmODIiwRXRR/G3ohaWVo1RU/c30jV8ab2mV8qVGzHWBOLyTLZiWs5Rolg/C3ySOi0tXP/k4aEwOwSBKPJs7Rp16ABJTe+p1xVX0It/owqqdDEMRoqd3RFxqDPh20Ig6VEPVC0i5RSCD+6wl6HlW7GksSlUMV11/GrUs5NasFLusDE9ELSVphXemtJwaT/8JyIRvxNNCfBmIiNdR04LII3DSrbe0yjqvyJF/ppptqVlt+MCLCEh/oOkPPP6N38Mb5cnQBGFsEqmXg5j3QMwoMzwGnr4HYbybBq13gZAOom/FO63zdf2qQArCsZrUN2TlJy69eSDKYV+6Q4MpP75ivHzPA53ngaBW4eGuSOt0A/lsGPmXMz0+3TFJcTfFbPfFbfnwlhON+iQhlWmA82CQ4ocQ7c6KcfL3DHuls0yT6Sx4YnLXJDCQOIRRv5yGIJBgP8Sdisj2qubpc5UGJmo+W49ifVmzL8HcpGhQPvZCUKiCliIhEN0tr2OCqHuSA8gwQ/92MkU7gxEmeVqGrTTgpxPXbUrtGWYus0I9thRIraagRQUIDf7Qn4yZhKRiFQIyhfMfUr3yblokVWSJ6k8xSnc7eNN/RjowfCYiFoDUFer1S3gW6JiJ8Nt30EMbEhU+vzSIztuRYjRLsR8IHLjlf7HZ+MrWWEXxNmbvapt4jGSqZRYSkGUetSNTPzHsui5YMQ2ajJUNks6mw4wT54Ok2ShnzzIPCUGshzawCRKy5FqvrTZe0RWzQGvw79m67XZjKmxJrLsICjtZa55gxXy+6F4sYsEtxTqhXdRTLC8ulSDaWoCLsolfN+8YUhOsJV709H7Cudr0LlVEtzqBcN+shEyThdR941OnAbF8pirKJqXyupTRTtQSReiVmXW1j7oBErB0d9xM2WEd5J9ZKYtuR4WKwwBSoORbpGrJ5ZI9lt71irJmGX1px0JYE26uNErawr2zfIcP4OHEKXm66PA3wjpCNEfpJunI4muifPjKvsFCkGjExTq63yxMJsZNMYF/J4HmDC5A3Yq36jy0ClePHVhwuu/b1HSFlEfHD5ZtD1bEK44Qu1mWys6tbWmZyPWckzlPTGiRw/XHCuk+q4Rek+mVrVL/UppwrdDEGNV2kpyuhccgc5Oxm9vWnn+19vJrVpLor0kTUrGacMplb1CfOFyTD4o9uNrHqr2Z+ZMSp1c2XcVSORnh9Q81q3k599ETgkNnjg0nGzi10K7rX+bZpHbrblPcY5A4Zxk2xcjzCvTpd9027Aa0QtouyyrKFRR6D/04DwkFGvHPXM3Qda/Jb4nPgI7hQLVM1q5HIBt2MzQNa57Z1DiiLAGa5Mi+O4Sz3Mpp6laPHO6InII3ITnX1QtI+EOX+m9ZxleOZ/j9PiuKoLi3aqXPuEoSye/Vhkm+LalbLtHhMS0R6zu7aZ3vP2jOjL7QVv4McxhcDnZIelAQibGIbULOapf3PuE1Vs9qeaOTdkVKr00gCQiw4NlBzDvf1Lxx+uP5r3Dgv5KQZRzWn+GRwz8jmDS8itUg7iB6vLuJCF5Uty4A9mVKkFR6MiJDachST/oHvHgD+B4SoUIitpF05AAAAAElFTkSuQmCC') + '\" alt=\"' + tarteaucitron.lang.icon + ' ' + tarteaucitron.lang.modalWindow + '\" title=\"' + tarteaucitron.lang.icon + ' ' + tarteaucitron.lang.modalWindow + '\">';\n                    html += '   </button>';\n                    html += '</div>';\n                }\n\n                if (tarteaucitron.parameters.showAlertSmall === true) {\n                    html += '<div id=\"tarteaucitronAlertSmall\" class=\"tarteaucitronAlertSmall' + orientation + '\">';\n                    html += '   <button type=\"button\" id=\"tarteaucitronManager\" aria-label=\"' + tarteaucitron.lang.alertSmall + ' ' + tarteaucitron.lang.modalWindow + '\" title=\"' + tarteaucitron.lang.alertSmall + ' ' + tarteaucitron.lang.modalWindow + '\">';\n                    html += '       ' + tarteaucitron.lang.alertSmall;\n                    html += '       <span id=\"tarteaucitronDot\">';\n                    html += '           <span id=\"tarteaucitronDotGreen\"></span>';\n                    html += '           <span id=\"tarteaucitronDotYellow\"></span>';\n                    html += '           <span id=\"tarteaucitronDotRed\"></span>';\n                    html += '       </span>';\n                    if (tarteaucitron.parameters.cookieslist === true) {\n                        html += '   </button><!-- @whitespace';\n                        html += '   --><button type=\"button\" id=\"tarteaucitronCookiesNumber\" aria-expanded=\"false\" aria-controls=\"tarteaucitronCookiesListContainer\">0</button>';\n                        html += '   <div id=\"tarteaucitronCookiesListContainer\">';\n                        if (tarteaucitron.reloadThePage) {\n                            html += '       <button type=\"button\" id=\"tarteaucitronClosePanelCookie\" aria-label=\"' + tarteaucitron.lang.close + ' (' + tarteaucitron.lang.reload + ')\" title=\"' + tarteaucitron.lang.close + ' (' + tarteaucitron.lang.reload + ')\">';\n                        } else {\n                            html += '       <button type=\"button\" id=\"tarteaucitronClosePanelCookie\">';\n                        }\n                        html += '           ' + tarteaucitron.lang.close;\n                        html += '       </button>';\n                        html += '       <div class=\"tarteaucitronCookiesListMain\" id=\"tarteaucitronCookiesTitle\">';\n                        html += '            <span class=\"tarteaucitronH2\" role=\"heading\" aria-level=\"2\" id=\"tarteaucitronCookiesNumberBis\">0 cookie</span>';\n                        html += '       </div>';\n                        html += '       <div id=\"tarteaucitronCookiesList\"></div>';\n                        html += '    </div>';\n                    } else {\n                        html += '   </div>';\n                    }\n                    html += '</div>';\n                }\n\n                tarteaucitron.addInternalScript(tarteaucitron.cdn + 'advertising' + (useMinifiedJS ? '.min' : '') + '.js', '', function () {\n                    if (tarteaucitronNoAdBlocker === true || tarteaucitron.parameters.adblocker === false) {\n\n                        // create a wrapper container at the same level than tarteaucitron so we can add an aria-hidden when tarteaucitron is opened\n                        /*var wrapper = document.createElement('div');\n                        wrapper.id = \"tarteaucitronContentWrapper\";\n\n                        while (document.body.firstChild)\n                        {\n                            wrapper.appendChild(document.body.firstChild);\n                        }\n\n                        // Append the wrapper to the body\n                        document.body.appendChild(wrapper);*/\n\n                        div.id = 'tarteaucitronRoot';\n                        if (tarteaucitron.parameters.bodyPosition === 'top') {\n                            // Prepend tarteaucitron: #tarteaucitronRoot first-child of the body for better accessibility\n                            var bodyFirstChild = body.firstChild;\n                            body.insertBefore(div, bodyFirstChild);\n                        }\n                        else {\n                            // Append tarteaucitron: #tarteaucitronRoot last-child of the body\n                            body.appendChild(div, body);\n                        }\n\n                        div.setAttribute('data-nosnippet', 'true');\n                        div.setAttribute('lang', language);\n                        div.setAttribute('role', 'region');\n                        div.setAttribute('aria-labelledby', 'tac_title');\n\n                        div.innerHTML = html;\n\n                        //ie compatibility\n                        var tacRootAvailableEvent;\n                        if(typeof(Event) === 'function') {\n                            tacRootAvailableEvent = new Event(\"tac.root_available\");\n                        }else if (typeof(document.createEvent) === 'function'){\n                            tacRootAvailableEvent = document.createEvent('Event');\n                            tacRootAvailableEvent.initEvent(\"tac.root_available\", true, true);\n                        }\n                        //end ie compatibility\n\n                        if (typeof(window.dispatchEvent) === 'function') {window.dispatchEvent(tacRootAvailableEvent);}\n\n                        if (tarteaucitron.job !== undefined) {\n                            tarteaucitron.job = tarteaucitron.cleanArray(tarteaucitron.job);\n                            for (index = 0; index < tarteaucitron.job.length; index += 1) {\n                                tarteaucitron.addService(tarteaucitron.job[index]);\n                            }\n                        } else {\n                            tarteaucitron.job = [];\n                        }\n\n                        if (tarteaucitron.job.length === 0) {\n                            tarteaucitron.userInterface.closeAlert();\n                        }\n\n                        tarteaucitron.isAjax = true;\n\n                        tarteaucitron.job.push = function (id) {\n\n                            // ie <9 hack\n                            if (typeof tarteaucitron.job.indexOf === 'undefined') {\n                                tarteaucitron.job.indexOf = function (obj, start) {\n                                    var i,\n                                        j = this.length;\n                                    for (i = (start || 0); i < j; i += 1) {\n                                        if (this[i] === obj) { return i; }\n                                    }\n                                    return -1;\n                                };\n                            }\n\n                            if (tarteaucitron.job.indexOf(id) === -1) {\n                                Array.prototype.push.call(this, id);\n                            }\n                            tarteaucitron.launch[id] = false;\n                            tarteaucitron.addService(id);\n                        };\n\n                        if (document.location.hash === tarteaucitron.hashtag && tarteaucitron.hashtag !== '') {\n                            tarteaucitron.userInterface.openPanel();\n                        }\n\n                        tarteaucitron.cookie.number();\n                        setInterval(tarteaucitron.cookie.number, 60000);\n                    }\n                }, tarteaucitron.parameters.adblocker);\n\n                if (tarteaucitron.parameters.adblocker === true) {\n                    setTimeout(function () {\n                        if (tarteaucitronNoAdBlocker === false) {\n                            html = '<div id=\"tarteaucitronAlertBig\" class=\"tarteaucitronAlertBig' + orientation + ' tarteaucitron-display-block\" role=\"alert\" aria-live=\"polite\">';\n                            html += '   <p id=\"tarteaucitronDisclaimerAlert\">';\n                            html += '       ' + tarteaucitron.lang.adblock + '<br/>';\n                            html += '       <strong>' + tarteaucitron.lang.adblock_call + '</strong>';\n                            html += '   </p>';\n                            html += '   <button type=\"button\" class=\"tarteaucitronCTAButton\" id=\"tarteaucitronCTAButton\">';\n                            html += '       ' + tarteaucitron.lang.reload;\n                            html += '   </button>';\n                            html += '</div>';\n                            html += '<div role=\"heading\" aria-level=\"1\" id=\"tac_title\" class=\"tac_visually-hidden\">' + tarteaucitron.lang.title + '</div>';\n                            html += '<div id=\"tarteaucitronPremium\"></div>';\n\n                            div.id = 'tarteaucitronRoot';\n                            if (tarteaucitron.parameters.bodyPosition === 'top') {\n                                // Prepend tarteaucitron: #tarteaucitronRoot first-child of the body for better accessibility\n                                var bodyFirstChild = body.firstChild;\n                                body.insertBefore(div, bodyFirstChild);\n                            }\n                            else {\n                                // Append tarteaucitron: #tarteaucitronRoot last-child of the body\n                                body.appendChild(div, body);\n                            }\n\n                            div.setAttribute('data-nosnippet', 'true');\n                            div.setAttribute('lang', language);\n                            div.setAttribute('role', 'region');\n                            div.setAttribute('aria-labelledby', 'tac_title');\n\n                            div.innerHTML = html;\n                        }\n                    }, 1500);\n                }\n                if(tarteaucitron.parameters.closePopup === true){\n                    setTimeout(function() {\n                        var closeElement = document.getElementById('tarteaucitronAlertBig'),\n                            closeButton = document.createElement('button');\n                        if (closeElement) {\n                            closeButton.innerHTML = '<span aria-hidden=\"true\">X</span><span class=\"tac_visually-hidden\">' + tarteaucitron.lang.closeBanner + '</span>';\n                            closeButton.setAttribute('id', 'tarteaucitronCloseCross');\n                            closeElement.insertAdjacentElement('beforeend', closeButton);\n                        }\n                    }, 100);\n                }\n\n                if(tarteaucitron.parameters.groupServices === true) {\n                    var tac_group_style = document.createElement('style');\n                    tac_group_style.innerHTML = '.tarteaucitronTitle{display:none}';\n                    document.head.appendChild(tac_group_style);\n                    var cats = document.querySelectorAll('[id^=\"tarteaucitronServicesTitle_\"]')\n                    Array.prototype.forEach.call(cats, function(item) {\n                        var cat = item.getAttribute('id').replace(/^(tarteaucitronServicesTitle_)/, \"\");\n                        if (cat !== \"mandatory\") {\n                            var html = '';\n                            html += '<li  class=\"tarteaucitronLine\">';\n                            html += '   <div class=\"tarteaucitronName\">';\n                            html += '       <span class=\"tarteaucitronH3\" role=\"heading\" aria-level=\"2\">'+tarteaucitron.lang[cat].title+'</span>';\n                            html += '       <span>'+tarteaucitron.lang[cat].details+'</span>';\n                            html += '   <button type=\"button\" aria-expanded=\"false\" class=\"tarteaucitron-toggle-group\" id=\"tarteaucitron-toggle-group-'+cat+'\">'+tarteaucitron.lang.alertSmall+' <span id=\"tarteaucitronCounter-'+cat+'\"></span></button>';\n                            html += '   </div>';\n                            html += '   <div class=\"tarteaucitronAsk\" id=\"tarteaucitron-group-'+cat+'\">';\n                            html += '       <button type=\"button\" aria-label=\"' + tarteaucitron.lang.allow + ' ' + tarteaucitron.lang[cat].title + '\" class=\"tarteaucitronAllow\" id=\"tarteaucitron-accept-group-'+cat+'\">';\n                            html += '           <span class=\"tarteaucitronCheck\" aria-hidden=\"true\"></span> ' + tarteaucitron.lang.allow;\n                            html += '       </button> ';\n                            html += '       <button type=\"button\" aria-label=\"' + tarteaucitron.lang.deny + ' ' + tarteaucitron.lang[cat].title + '\" class=\"tarteaucitronDeny\" id=\"tarteaucitron-reject-group-'+cat+'\">';\n                            html += '           <span class=\"tarteaucitronCross\" aria-hidden=\"true\"></span> ' + tarteaucitron.lang.deny;\n                            html += '       </button>';\n                            html += '   </div>';\n                            html += '</li>';\n                            var ul = document.createElement('ul');\n                            ul.innerHTML = html;\n                            item.insertBefore(ul, item.querySelector('#tarteaucitronServices_'+cat+''));\n                            document.querySelector('#tarteaucitronServices_' + cat).style.display = 'none';\n                            tarteaucitron.addClickEventToId(\"tarteaucitron-toggle-group-\" + cat, function () {\n                                tarteaucitron.userInterface.toggle('tarteaucitronServices_' + cat);\n                               if (document.getElementById('tarteaucitronServices_' + cat).style.display == 'block') {\n                                    tarteaucitron.userInterface.addClass('tarteaucitronServicesTitle_' + cat, 'tarteaucitronIsExpanded');\n                                    document.getElementById('tarteaucitron-toggle-group-'+cat).setAttribute('aria-expanded', 'true');\n                                } else {\n                                    tarteaucitron.userInterface.removeClass('tarteaucitronServicesTitle_' + cat, 'tarteaucitronIsExpanded');\n                                    document.getElementById('tarteaucitron-toggle-group-'+cat).setAttribute('aria-expanded', 'false');\n                                }\n                                //tarteaucitron.initEvents.resizeEvent();\n                            });\n                            tarteaucitron.addClickEventToId(\"tarteaucitron-accept-group-\" + cat, function () {\n                                tarteaucitron.userInterface.respondAll(true, cat);\n                            });\n                            tarteaucitron.addClickEventToId(\"tarteaucitron-reject-group-\" + cat, function () {\n                                tarteaucitron.userInterface.respondAll(false, cat);\n                            });\n                        }\n                    });\n                }\n\n                // add info about the services on the main banner\n                if (tarteaucitron.parameters.partnersList === true && (tarteaucitron.parameters.orientation === \"middle\" || tarteaucitron.parameters.orientation === \"popup\")) {\n                    setTimeout(function() {\n                        var tacPartnersInfoParent = document.getElementById('tarteaucitronDisclaimerAlert');\n                        if (tacPartnersInfoParent !== null) {\n                            tacPartnersInfoParent.insertAdjacentHTML('beforeend', '<div class=\"tarteaucitronPartnersList\"><b>' + tarteaucitron.lang.ourpartners + ' <span id=\"tarteaucitronCounter-all\"></span></b> <ul id=\"tarteaucitronCounter-list\"></ul></div>');\n                        }\n                    }, 100);\n                }\n\n                // add a save button\n                setTimeout(function() {\n                    var tacSaveButtonParent = document.getElementById('tarteaucitronServices');\n                    if (tacSaveButtonParent !== null) {\n                        tacSaveButtonParent.insertAdjacentHTML('beforeend', '<div id=\"tarteaucitronSave\"><button class=\"tarteaucitronAllow\" id=\"tarteaucitronSaveButton\">' + tarteaucitron.lang.save + '</button></div>');\n                    }\n                }, 100);\n\n                tarteaucitron.userInterface.color(\"\", true);\n\n                // add a little timeout to be sure everything is accessible\n                setTimeout(function () {\n\n                    // Setup events\n                    tarteaucitron.addClickEventToId(\"tarteaucitronCloseCross\", function () {\n                        tarteaucitron.userInterface.closeAlert();\n                    });\n                    tarteaucitron.addClickEventToId(\"tarteaucitronPersonalize\", function () {\n                        tarteaucitron.userInterface.openPanel();\n                    });\n                    tarteaucitron.addClickEventToId(\"tarteaucitronPersonalize2\", function () {\n                        tarteaucitron.userInterface.respondAll(true);\n                    });\n                    tarteaucitron.addClickEventToId(\"tarteaucitronManager\", function () {\n                        tarteaucitron.userInterface.openPanel();\n                    });\n                    tarteaucitron.addClickEventToId(\"tarteaucitronBack\", function () {\n                        tarteaucitron.userInterface.closePanel();\n                    });\n                    tarteaucitron.addClickEventToId(\"tarteaucitronClosePanel\", function () {\n                        tarteaucitron.userInterface.closePanel();\n                    });\n                    tarteaucitron.addClickEventToId(\"tarteaucitronClosePanelCookie\", function () {\n                        tarteaucitron.userInterface.closePanel();\n                    });\n                    tarteaucitron.addClickEventToId(\"tarteaucitronPrivacyUrl\", function () {\n                        document.location = tarteaucitron.parameters.privacyUrl;\n                    });\n                    tarteaucitron.addClickEventToId(\"tarteaucitronPrivacyUrlDialog\", function () {\n                        document.location = tarteaucitron.parameters.privacyUrl;\n                    });\n                    tarteaucitron.addClickEventToId(\"tarteaucitronCookiesNumber\", function () {\n                        tarteaucitron.userInterface.toggleCookiesList();\n                    });\n                    tarteaucitron.addClickEventToId(\"tarteaucitronAllAllowed\", function () {\n                        tarteaucitron.userInterface.respondAll(true);\n                    });\n                    tarteaucitron.addClickEventToId(\"tarteaucitronAllDenied\", function () {\n                        tarteaucitron.userInterface.respondAll(false);\n                    });\n                    tarteaucitron.addClickEventToId(\"tarteaucitronAllDenied2\", function () {\n                        tarteaucitron.userInterface.respondAll(false, '', true);\n                        if (tarteaucitron.reloadThePage === true) {\n                            window.location.reload();\n                        }\n                    });\n                    tarteaucitron.addClickEventToId(\"tarteaucitronCloseAlert\", function () {\n                        tarteaucitron.userInterface.openPanel();\n                    });\n                    tarteaucitron.addClickEventToId(\"tarteaucitronCTAButton\", function () {\n                        location.reload();\n                    });\n                    tarteaucitron.addClickEventToId(\"tarteaucitronSaveButton\", function () {\n                        var timeoutSaveButton = 0;\n                        tarteaucitron.job.forEach(function(id) {\n                            if (tarteaucitron.state[id] !== true && tarteaucitron.state[id] !== false) {\n                                timeoutSaveButton = 500;\n                                tarteaucitron.setConsent(id, false);\n                            }\n                        });\n                        setTimeout(tarteaucitron.userInterface.closePanel, timeoutSaveButton);\n                    });\n                    var toggleBtns = document.getElementsByClassName(\"catToggleBtn\"), i;\n                    for (i = 0; i < toggleBtns.length; i++) {\n                        toggleBtns[i].dataset.index = i;\n                        tarteaucitron.addClickEventToElement(toggleBtns[i], function () {\n                            if(!tarteaucitron.parameters.showDetailsOnClick) return false;\n                            tarteaucitron.userInterface.toggle('tarteaucitronDetails' + cat[this.dataset.index], 'tarteaucitronInfoBox');\n                            if (document.getElementById('tarteaucitronDetails' + cat[this.dataset.index]).style.display === 'block') {\n                                this.setAttribute('aria-expanded', 'true');\n                            } else {\n                                this.setAttribute('aria-expanded', 'false');\n                            }\n                            return false;\n                        });\n                    }\n\n                    // accessibility: on click on \"Allow\" in the site (not in TAC module), move focus to the loaded service's parent \n                    var allowBtnsInSite = document.querySelectorAll(\".tac_activate .tarteaucitronAllow\");\n                    for (i = 0; i < allowBtnsInSite.length; i++) {\n                        tarteaucitron.addClickEventToElement(allowBtnsInSite[i], function () {\n                            if(this.closest('.tac_activate') !== null && this.closest('.tac_activate').parentNode !== null) {\n                                this.closest('.tac_activate').parentNode.setAttribute(\"tabindex\", \"-1\");\n                                this.closest('.tac_activate').parentNode.focus();\n                            }\n                        });\n                    }\n\n                    var allowBtns = document.getElementsByClassName(\"tarteaucitronAllow\");\n                    for (i = 0; i < allowBtns.length; i++) {\n                        tarteaucitron.addClickEventToElement(allowBtns[i], function () {\n                            tarteaucitron.userInterface.respond(this, true);\n                        });\n                    }\n                    var denyBtns = document.getElementsByClassName(\"tarteaucitronDeny\");\n                    for (i = 0; i < denyBtns.length; i++) {\n                        tarteaucitron.addClickEventToElement(denyBtns[i], function () {\n                            tarteaucitron.userInterface.respond(this, false);\n                        });\n                    }\n                    if(tarteaucitron.events.load) {\n                        tarteaucitron.events.load();\n                    }\n                }, 500);\n\n            });\n        });\n    },\n    \"addService\": function (serviceId) {\n        \"use strict\";\n        var html = '',\n            s = tarteaucitron.services,\n            service = s[serviceId];\n\n        if (typeof service === \"undefined\") {\n\n            var serviceToRemoveIndex = tarteaucitron.job.indexOf(serviceId);\n            if (serviceToRemoveIndex !== -1) {\n                tarteaucitron.job.splice(serviceToRemoveIndex, 1);\n            }\n            return;\n        }\n\n        if (tarteaucitron.parameters.alwaysNeedConsent === true) {\n            service.needConsent = true;\n        }\n\n        var cookie = tarteaucitron.cookie.read(),\n            hostname = document.location.hostname,\n            hostRef = document.referrer.split('/')[2],\n            isNavigating = (hostRef === hostname && window.location.href !== tarteaucitron.parameters.privacyUrl),\n            isAutostart = (!service.needConsent),\n            isWaiting = (cookie.indexOf(service.key + '=wait') >= 0),\n            isDenied = (cookie.indexOf(service.key + '=false') >= 0),\n            isAllowed = ((cookie.indexOf(service.key + '=true') >= 0) || (!service.needConsent && cookie.indexOf(service.key + '=false') < 0)),\n            isResponded = (cookie.indexOf(service.key + '=false') >= 0 || cookie.indexOf(service.key + '=true') >= 0),\n            isDNTRequested = (navigator.doNotTrack === \"1\" || navigator.doNotTrack === \"yes\" || navigator.msDoNotTrack === \"1\" || window.doNotTrack === \"1\"),\n            currentStatus = (isAllowed) ? tarteaucitron.lang.allowed : tarteaucitron.lang.disallowed,\n            state = (undefined !== service.defaultState) ? service.defaultState :\n                    (undefined !== tarteaucitron.parameters.serviceDefaultState ? tarteaucitron.parameters.serviceDefaultState : 'wait');\n\n\n        if (tarteaucitron.added[service.key] !== true) {\n            tarteaucitron.added[service.key] = true;\n\n            html += '<li id=\"' + service.key + 'Line\" class=\"tarteaucitronLine\">';\n            html += '   <div class=\"tarteaucitronName\">';\n            html += '       <span class=\"tarteaucitronH3\" role=\"heading\" aria-level=\"3\">' + service.name + '</span>';\n            html += '       <div class=\"tarteaucitronStatusInfo\">';\n            html += '          <span class=\"tacCurrentStatus\" id=\"tacCurrentStatus' + service.key + '\">'+currentStatus+'</span>';\n            html += '          <span class=\"tarteaucitronReadmoreSeparator\"> - </span>';\n            html += '          <span id=\"tacCL' + service.key + '\" class=\"tarteaucitronListCookies\"></span>';\n            html += '       </div>';\n            if (tarteaucitron.parameters.moreInfoLink == true) {\n\n                var link = 'https://tarteaucitron.io/service/' + service.key + '/';\n                if (service.readmoreLink !== undefined && service.readmoreLink !== '') {\n                    link = service.readmoreLink;\n                }\n                if (tarteaucitron.parameters.readmoreLink !== undefined && tarteaucitron.parameters.readmoreLink !== '') {\n                    link = tarteaucitron.parameters.readmoreLink;\n                }\n                html += '       <a href=\"' + link + '\" target=\"_blank\" rel=\"noreferrer noopener nofollow\" title=\"' + tarteaucitron.lang.more + ' : '+ tarteaucitron.lang.cookieDetail + ' ' + service.name + ' ' + tarteaucitron.lang.ourSite + ' ' + tarteaucitron.lang.newWindow +'\" class=\"tarteaucitronReadmoreInfo\">' + tarteaucitron.lang.more + '</a>';\n                html += '       <span class=\"tarteaucitronReadmoreSeparator\"> - </span>';\n                html += '       <a href=\"' + service.uri + '\" target=\"_blank\" rel=\"noreferrer noopener\" title=\"' + tarteaucitron.lang.source + ' ' + service.name + ' ' + tarteaucitron.lang.newWindow + '\" class=\"tarteaucitronReadmoreOfficial\">' + tarteaucitron.lang.source + '</a>';\n            }\n\n            html += '   </div>';\n            html += '   <div class=\"tarteaucitronAsk\">';\n            html += '       <button type=\"button\" aria-label=\"' + tarteaucitron.lang.allow + ' ' + service.name + '\" id=\"' + service.key + 'Allowed\" class=\"tarteaucitronAllow\">';\n            html += '           <span class=\"tarteaucitronCheck\" aria-hidden=\"true\"></span> ' + tarteaucitron.lang.allow;\n            html += '       </button> ';\n            html += '       <button type=\"button\" aria-label=\"' + tarteaucitron.lang.deny + ' ' + service.name + '\" id=\"' + service.key + 'Denied\" class=\"tarteaucitronDeny\">';\n            html += '           <span class=\"tarteaucitronCross\" aria-hidden=\"true\"></span> ' + tarteaucitron.lang.deny;\n            html += '       </button>';\n            html += '   </div>';\n            html += '</li>';\n\n            tarteaucitron.userInterface.css('tarteaucitronServicesTitle_' + service.type, 'display', 'block');\n\n            if (document.getElementById('tarteaucitronServices_' + service.type) !== null) {\n                document.getElementById('tarteaucitronServices_' + service.type).innerHTML += html;\n            }\n\n            tarteaucitron.userInterface.css('tarteaucitronNoServicesTitle', 'display', 'none');\n\n            tarteaucitron.userInterface.order(service.type);\n\n            tarteaucitron.addClickEventToId(service.key + 'Allowed', function () {\n                tarteaucitron.userInterface.respond(this, true);\n            });\n\n            tarteaucitron.addClickEventToId(service.key + 'Denied', function () {\n                tarteaucitron.userInterface.respond(this, false);\n            });\n        }\n\n        tarteaucitron.pro('!' + service.key + '=' + isAllowed);\n\n        // allow by default for non EU\n        if (isResponded === false && tarteaucitron.user.bypass === true) {\n            isAllowed = true;\n            tarteaucitron.cookie.create(service.key, true);\n        }\n\n        if ((!isResponded && (isAutostart || (isNavigating && isWaiting)) && !tarteaucitron.highPrivacy) || isAllowed) {\n            if (!isAllowed || (!service.needConsent && cookie.indexOf(service.key + '=false') < 0)) {\n                tarteaucitron.cookie.create(service.key, true);\n            }\n            if (tarteaucitron.launch[service.key] !== true) {\n                tarteaucitron.launch[service.key] = true;\n                if ((typeof tarteaucitronMagic === 'undefined' || tarteaucitronMagic.indexOf(\"_\" + service.key + \"_\") < 0) && tarteaucitron.parameters.serverSide !== true) { service.js(); }\n                tarteaucitron.sendEvent(service.key + '_loaded');\n            }\n            tarteaucitron.state[service.key] = true;\n            tarteaucitron.userInterface.color(service.key, true);\n        } else if (isDenied) {\n            if (typeof service.fallback === 'function') {\n                if ((typeof tarteaucitronMagic === 'undefined' || tarteaucitronMagic.indexOf(\"_\" + service.key + \"_\") < 0) && tarteaucitron.parameters.serverSide !== true) { service.fallback(); }\n            }\n            tarteaucitron.state[service.key] = false;\n            tarteaucitron.userInterface.color(service.key, false);\n        } else if (!isResponded && isDNTRequested && tarteaucitron.handleBrowserDNTRequest) {\n            tarteaucitron.cookie.create(service.key, 'false');\n            if (typeof service.fallback === 'function') {\n                if ((typeof tarteaucitronMagic === 'undefined' || tarteaucitronMagic.indexOf(\"_\" + service.key + \"_\") < 0) && tarteaucitron.parameters.serverSide !== true) { service.fallback(); }\n            }\n            tarteaucitron.state[service.key] = false;\n            tarteaucitron.userInterface.color(service.key, false);\n        } else if (!isResponded) {\n            tarteaucitron.cookie.create(service.key, state);\n            if ((typeof tarteaucitronMagic === 'undefined' || tarteaucitronMagic.indexOf(\"_\" + service.key + \"_\") < 0) && tarteaucitron.parameters.serverSide !== true) {\n                if(true === state && typeof service.js === 'function') {\n                    service.js();\n                } else if (typeof service.fallback === 'function') {\n                    service.fallback();\n                }\n            }\n\n            if (true === state) {\n                tarteaucitron.sendEvent(service.key + '_loaded');\n            }\n\n            if (true === state || false === state) {\n                tarteaucitron.state[service.key] = state;\n            }\n            tarteaucitron.userInterface.color(service.key, state);\n\n            if( 'wait' === state ) {\n                tarteaucitron.userInterface.openAlert();\n            }\n        }\n\n        tarteaucitron.cookie.checkCount(service.key);\n        tarteaucitron.sendEvent(service.key + '_added');\n    },\n    \"sendEvent\" : function(event_key) {\n        if(event_key !== undefined) {\n            //ie compatibility\n            var send_event_item;\n            if(typeof(Event) === 'function') {\n                send_event_item = new Event(event_key);\n            }else if (typeof(document.createEvent) === 'function'){\n                send_event_item = document.createEvent('Event');\n                send_event_item.initEvent(event_key, true, true);\n            }\n            //end ie compatibility\n\n            document.dispatchEvent(send_event_item);\n        }\n    },\n    \"cleanArray\": function cleanArray(arr) {\n        \"use strict\";\n        var i,\n            len = arr.length,\n            out = [],\n            obj = {},\n            s = tarteaucitron.services;\n\n        for (i = 0; i < len; i += 1) {\n            if (!obj[arr[i]]) {\n                obj[arr[i]] = {};\n                if (tarteaucitron.services[arr[i]] !== undefined) {\n                    out.push(arr[i]);\n                }\n            }\n        }\n\n        out = out.sort(function (a, b) {\n            if (s[a].type + s[a].key > s[b].type + s[b].key) { return 1; }\n            if (s[a].type + s[a].key < s[b].type + s[b].key) { return -1; }\n            return 0;\n        });\n\n        return out;\n    },\n    \"setConsent\": function (id, status) {\n        if (status === true) {\n            tarteaucitron.userInterface.respond(document.getElementById(id + 'Allowed'), true);\n        } else if (status === false) {\n            tarteaucitron.userInterface.respond(document.getElementById(id + 'Denied'), false);\n        }\n    },\n    \"userInterface\": {\n        \"css\": function (id, property, value) {\n            \"use strict\";\n            if (document.getElementById(id) !== null) {\n\n                if (property == \"display\" && value == \"none\" && (id == \"tarteaucitron\" || id == \"tarteaucitronBack\" || id == \"tarteaucitronAlertBig\")) {\n                    document.getElementById(id).style[\"opacity\"] = \"0\";\n\n                    /*setTimeout(function() {*/document.getElementById(id).style[property] = value;/*}, 200);*/\n                } else {\n\n                    document.getElementById(id).style[property] = value;\n\n                    if (property == \"display\" && value == \"block\" && (id == \"tarteaucitron\" || id == \"tarteaucitronAlertBig\")) {\n                        document.getElementById(id).style[\"opacity\"] = \"1\";\n                    }\n\n                    if (property == \"display\" && value == \"block\" && id == \"tarteaucitronBack\") {\n                        document.getElementById(id).style[\"opacity\"] = \"0.7\";\n                    }\n\n                    if (property == \"display\" && value == \"block\" && id == \"tarteaucitronAlertBig\" && (tarteaucitron.parameters.orientation == \"middle\"|| tarteaucitron.parameters.orientation == \"popup\")) {\n                        tarteaucitron.userInterface.focusTrap('tarteaucitronAlertBig');\n                    }\n                }\n            }\n        },\n        \"addClass\": function (id, className) {\n            \"use strict\";\n            if (document.getElementById(id) !== null && document.getElementById(id).classList !== undefined) {\n                document.getElementById(id).classList.add(className);\n            }\n        },\n        \"removeClass\": function (id, className) {\n            \"use strict\";\n            if (document.getElementById(id) !== null && document.getElementById(id).classList !== undefined) {\n                document.getElementById(id).classList.remove(className);\n            }\n        },\n        \"respondAll\": function (status, type, allowSafeAnalytics) {\n            \"use strict\";\n            var s = tarteaucitron.services,\n                service,\n                key,\n                index = 0;\n\n            for (index = 0; index < tarteaucitron.job.length; index += 1) {\n\n                if (typeof type !== 'undefined' && type !== '' && s[tarteaucitron.job[index]].type !== type) {\n                    continue;\n                }\n\n                if (allowSafeAnalytics && typeof s[tarteaucitron.job[index]].safeanalytic !== \"undefined\" && s[tarteaucitron.job[index]].safeanalytic === true) {\n                    continue;\n                }\n\n                service = s[tarteaucitron.job[index]];\n                key = service.key;\n                if (tarteaucitron.state[key] !== status) {\n                    if (status === false && tarteaucitron.launch[key] === true) {\n                        tarteaucitron.reloadThePage = true;\n                        if (tarteaucitron.checkIfExist('tarteaucitronClosePanel')) {\n                            var ariaCloseValue = document.getElementById('tarteaucitronClosePanel').textContent.trim() + ' (' + tarteaucitron.lang.reload + ')';\n                            document.getElementById('tarteaucitronClosePanel').setAttribute(\"aria-label\", ariaCloseValue);\n                            document.getElementById('tarteaucitronClosePanel').setAttribute(\"title\", ariaCloseValue);\n                        }\n                    }\n                    if (tarteaucitron.launch[key] !== true && status === true) {\n\n                        tarteaucitron.pro('!' + key + '=engage');\n\n                        tarteaucitron.launch[key] = true;\n                        if ((typeof tarteaucitronMagic === 'undefined' || tarteaucitronMagic.indexOf(\"_\" + key + \"_\") < 0) && tarteaucitron.parameters.serverSide !== true) { tarteaucitron.services[key].js(); }\n                        tarteaucitron.sendEvent(key + '_loaded');\n                    }\n                    var itemStatusElem = document.getElementById('tacCurrentStatus'+key);\n                    tarteaucitron.state[key] = status;\n                    tarteaucitron.cookie.create(key, status);\n                    tarteaucitron.userInterface.color(key, status);\n                    if (status == true) {\n                        itemStatusElem.innerHTML = tarteaucitron.lang.allowed;\n                        tarteaucitron.sendEvent(key + '_allowed');\n                    } else {\n                        itemStatusElem.innerHTML = tarteaucitron.lang.disallowed;\n                        tarteaucitron.sendEvent(key + '_disallowed');\n                    }\n                }\n            }\n        },\n        \"respond\": function (el, status) {\n            \"use strict\";\n            if (el.id === '') {\n                return;\n            }\n            var key = el.id.replace(new RegExp(\"(Eng[0-9]+|Allow|Deni)ed\", \"g\"), '');\n\n            if (key.substring(0, 13) === 'tarteaucitron' || key === '') {return;}\n\n            // return if same state\n            if (tarteaucitron.state[key] === status) {\n                return;\n            }\n\n            if (status === false && tarteaucitron.launch[key] === true) {\n                tarteaucitron.reloadThePage = true;\n                if (tarteaucitron.checkIfExist('tarteaucitronClosePanel')) {\n                    var ariaCloseValue = document.getElementById('tarteaucitronClosePanel').textContent.trim() + ' (' + tarteaucitron.lang.reload + ')';\n                    document.getElementById('tarteaucitronClosePanel').setAttribute(\"aria-label\", ariaCloseValue);\n                    document.getElementById('tarteaucitronClosePanel').setAttribute(\"title\", ariaCloseValue);\n                }\n            }\n\n            // if not already launched... launch the service\n            if (status === true) {\n                if (tarteaucitron.launch[key] !== true) {\n\n                    tarteaucitron.pro('!' + key + '=engage');\n\n                    tarteaucitron.launch[key] = true;\n                    if ((typeof tarteaucitronMagic === 'undefined' || tarteaucitronMagic.indexOf(\"_\" + key + \"_\") < 0) && tarteaucitron.parameters.serverSide !== true) { tarteaucitron.services[key].js(); }\n                    tarteaucitron.sendEvent(key + '_loaded');\n                }\n            }\n            var itemStatusElem = document.getElementById('tacCurrentStatus'+key);\n            tarteaucitron.state[key] = status;\n            tarteaucitron.cookie.create(key, status);\n            tarteaucitron.userInterface.color(key, status);\n            if (status == true) {\n                itemStatusElem.innerHTML = tarteaucitron.lang.allowed;\n                tarteaucitron.sendEvent(key + '_allowed');\n            } else {\n                itemStatusElem.innerHTML = tarteaucitron.lang.disallowed;\n                tarteaucitron.sendEvent(key + '_disallowed');\n            }\n        },\n        \"color\": function (key, status) {\n            \"use strict\";\n            var c = 'tarteaucitron',\n                nbDenied = 0,\n                nbPending = 0,\n                nbAllowed = 0,\n                sum = tarteaucitron.job.length,\n                index,\n                s = tarteaucitron.services;\n\n            if (key !== \"\") {\n\n            if (status === true) {\n                tarteaucitron.userInterface.addClass(key + 'Line', 'tarteaucitronIsAllowed');\n                tarteaucitron.userInterface.removeClass(key + 'Line', 'tarteaucitronIsDenied');\n                document.getElementById(key + 'Allowed').setAttribute('aria-pressed', 'true');\n                document.getElementById(key + 'Denied').setAttribute('aria-pressed', 'false');\n            } else if (status === false) {\n                tarteaucitron.userInterface.removeClass(key + 'Line', 'tarteaucitronIsAllowed');\n                tarteaucitron.userInterface.addClass(key + 'Line', 'tarteaucitronIsDenied');\n                document.getElementById(key + 'Allowed').setAttribute('aria-pressed', 'false');\n                document.getElementById(key + 'Denied').setAttribute('aria-pressed', 'true');\n            } else {\n                document.getElementById(key + 'Allowed').setAttribute('aria-pressed', 'false');\n                document.getElementById(key + 'Denied').setAttribute('aria-pressed', 'false');\n            }\n\n            // check if all services are allowed\n            var sumToRemove = 0;\n            for (index = 0; index < sum; index += 1) {\n\n                if (typeof s[tarteaucitron.job[index]].safeanalytic !== \"undefined\" && s[tarteaucitron.job[index]].safeanalytic === true) {\n                    sumToRemove += 1;\n                    continue;\n                }\n\n                if (tarteaucitron.state[tarteaucitron.job[index]] === false) {\n                    nbDenied += 1;\n                } else if (tarteaucitron.state[tarteaucitron.job[index]] === undefined) {\n                    nbPending += 1;\n                } else if (tarteaucitron.state[tarteaucitron.job[index]] === true) {\n                    nbAllowed += 1;\n                }\n            }\n            sum -= sumToRemove;\n\n            tarteaucitron.userInterface.css(c + 'DotGreen', 'width', ((100 / sum) * nbAllowed) + '%');\n            tarteaucitron.userInterface.css(c + 'DotYellow', 'width', ((100 / sum) * nbPending) + '%');\n            tarteaucitron.userInterface.css(c + 'DotRed', 'width', ((100 / sum) * nbDenied) + '%');\n\n            if (nbDenied === 0 && nbPending === 0) {\n                tarteaucitron.userInterface.removeClass(c + 'AllDenied', c + 'IsSelected');\n                tarteaucitron.userInterface.addClass(c + 'AllAllowed', c + 'IsSelected');\n\n                tarteaucitron.userInterface.addClass(c + 'MainLineOffset', c + 'IsAllowed');\n                tarteaucitron.userInterface.removeClass(c + 'MainLineOffset', c + 'IsDenied');\n\n                document.getElementById(c + 'AllDenied').setAttribute('aria-pressed', 'false');\n                document.getElementById(c + 'AllAllowed').setAttribute('aria-pressed', 'true');\n\n            } else if (nbAllowed === 0 && nbPending === 0) {\n                tarteaucitron.userInterface.removeClass(c + 'AllAllowed', c + 'IsSelected');\n                tarteaucitron.userInterface.addClass(c + 'AllDenied', c + 'IsSelected');\n\n                tarteaucitron.userInterface.removeClass(c + 'MainLineOffset', c + 'IsAllowed');\n                tarteaucitron.userInterface.addClass(c + 'MainLineOffset', c + 'IsDenied');\n\n                document.getElementById(c + 'AllDenied').setAttribute('aria-pressed', 'true');\n                document.getElementById(c + 'AllAllowed').setAttribute('aria-pressed', 'false');\n\n            } else {\n                tarteaucitron.userInterface.removeClass(c + 'AllAllowed', c + 'IsSelected');\n                tarteaucitron.userInterface.removeClass(c + 'AllDenied', c + 'IsSelected');\n\n                tarteaucitron.userInterface.removeClass(c + 'MainLineOffset', c + 'IsAllowed');\n                tarteaucitron.userInterface.removeClass(c + 'MainLineOffset', c + 'IsDenied');\n\n                document.getElementById(c + 'AllDenied').setAttribute('aria-pressed', 'false');\n                document.getElementById(c + 'AllAllowed').setAttribute('aria-pressed', 'false');\n            }\n\n            // close the alert if all service have been reviewed\n            if (nbPending === 0) {\n                tarteaucitron.userInterface.closeAlert();\n            }\n\n            if (tarteaucitron.services[key].cookies.length > 0 && status === false) {\n                tarteaucitron.cookie.purge(tarteaucitron.services[key].cookies);\n            }\n\n            if (status === true) {\n                if (document.getElementById('tacCL' + key) !== null) {\n                    document.getElementById('tacCL' + key).innerHTML = '...';\n                }\n                setTimeout(function () {\n                    tarteaucitron.cookie.checkCount(key);\n                }, 2500);\n            } else {\n                tarteaucitron.cookie.checkCount(key);\n            }\n\n            }\n\n\t    // groups\n            var cats = document.querySelectorAll('[id^=\"tarteaucitronServicesTitle_\"]')\n            Array.prototype.forEach.call(cats, function(item) {\n                var cat = item.getAttribute('id').replace(/^(tarteaucitronServicesTitle_)/, \"\"),\n                    total = document.getElementById(\"tarteaucitronServices_\"+cat).childElementCount;\n                var doc = document.getElementById(\"tarteaucitronServices_\"+cat),\n                    groupdenied = 0,\n                    groupallowed = 0;\n                for (var ii = 0; ii < doc.children.length; ii++) {\n                    if (doc.children[ii].className == \"tarteaucitronLine tarteaucitronIsDenied\") {\n                        groupdenied++;\n                    }\n                    if (doc.children[ii].className == \"tarteaucitronLine tarteaucitronIsAllowed\") {\n                        groupallowed++;\n                    }\n                }\n                if (total === groupallowed) {\n                    tarteaucitron.userInterface.removeClass('tarteaucitron-group-'+cat, 'tarteaucitronIsDenied');\n                    tarteaucitron.userInterface.addClass('tarteaucitron-group-'+cat, 'tarteaucitronIsAllowed');\n\n                    if (document.getElementById('tarteaucitron-reject-group-'+cat)) {\n                        document.getElementById('tarteaucitron-reject-group-'+cat).setAttribute('aria-pressed', 'false');\n                        document.getElementById('tarteaucitron-accept-group-'+cat).setAttribute('aria-pressed', 'true');\n                    }\n                }\n                if (total === groupdenied) {\n                    tarteaucitron.userInterface.addClass('tarteaucitron-group-'+cat, 'tarteaucitronIsDenied');\n                    tarteaucitron.userInterface.removeClass('tarteaucitron-group-'+cat, 'tarteaucitronIsAllowed');\n\n                    if (document.getElementById('tarteaucitron-reject-group-'+cat)) {\n                        document.getElementById('tarteaucitron-reject-group-'+cat).setAttribute('aria-pressed', 'true');\n                        document.getElementById('tarteaucitron-accept-group-'+cat).setAttribute('aria-pressed', 'false');\n                    }\n                }\n                if (total !== groupdenied && total !== groupallowed) {\n                    tarteaucitron.userInterface.removeClass('tarteaucitron-group-'+cat, 'tarteaucitronIsDenied');\n                    tarteaucitron.userInterface.removeClass('tarteaucitron-group-'+cat, 'tarteaucitronIsAllowed');\n\n                    if (document.getElementById('tarteaucitron-reject-group-'+cat)) {\n                        document.getElementById('tarteaucitron-reject-group-'+cat).setAttribute('aria-pressed', 'false');\n                        document.getElementById('tarteaucitron-accept-group-'+cat).setAttribute('aria-pressed', 'false');\n                    }\n                }\n                groupdenied = 0;\n                groupallowed = 0;\n\n                if (document.getElementById('tarteaucitronCounter-'+cat)) {\n                    document.getElementById('tarteaucitronCounter-'+cat).innerHTML = '('+document.getElementById(\"tarteaucitronServices_\"+cat).childElementCount+')';\n                }\n            });\n\n            setTimeout(function() {\n                if (document.getElementById('tarteaucitronCounter-all')) {\n                    document.getElementById('tarteaucitronCounter-all').innerHTML = '('+tarteaucitron.job.length+')';\n                }\n                if (document.getElementById('tarteaucitronCounter-list')) {\n\n                    var liPartners = \"\";\n                    var tarteaucitronPartnersCat = [];\n                    var titles = [];\n\n                    tarteaucitron.job.forEach(function (id) {\n                        if (tarteaucitronPartnersCat[tarteaucitron.services[id].type] === undefined) {\n                            tarteaucitronPartnersCat[tarteaucitron.services[id].type] = true;\n                            titles.push(tarteaucitron.lang[tarteaucitron.services[id].type].title);\n                        }\n                    });\n                    titles.sort();\n                    titles.forEach(function (title) {\n                        liPartners += \"<li>\" + title + \"</li>\";\n                    });\n\n                    document.getElementById('tarteaucitronCounter-list').innerHTML = liPartners;\n                }\n            }, 120);\n        },\n        \"openPanel\": function () {\n            \"use strict\";\n\n            tarteaucitron.userInterface.css('tarteaucitron', 'display', 'block');\n            tarteaucitron.userInterface.css('tarteaucitronBack', 'display', 'block');\n            tarteaucitron.userInterface.css('tarteaucitronCookiesListContainer', 'display', 'none');\n\n            document.getElementById('tarteaucitronClosePanel').focus();\n            if (document.getElementsByTagName('body')[0].classList !== undefined) {\n                document.getElementsByTagName('body')[0].classList.add('tarteaucitron-modal-open');\n            }\n            tarteaucitron.userInterface.focusTrap('tarteaucitron');\n            tarteaucitron.userInterface.jsSizing('main');\n\n            //ie compatibility\n            var tacOpenPanelEvent;\n            if(typeof(Event) === 'function') {\n                tacOpenPanelEvent = new Event(\"tac.open_panel\");\n            }else if (typeof(document.createEvent) === 'function'){\n                tacOpenPanelEvent = document.createEvent('Event');\n                tacOpenPanelEvent.initEvent(\"tac.open_panel\", true, true);\n            }\n            //end ie compatibility\n\n            if (typeof(window.dispatchEvent) === 'function') {window.dispatchEvent(tacOpenPanelEvent);}\n        },\n        \"closePanel\": function () {\n            \"use strict\";\n\n            if (document.location.hash === tarteaucitron.hashtag) {\n                if (window.history) {\n                    window.history.replaceState('', document.title, window.location.pathname + window.location.search);\n                } else {\n                    document.location.hash = '';\n                }\n            }\n            if (tarteaucitron.checkIfExist('tarteaucitron')) {\n                // accessibility: manage focus on close panel\n                if (tarteaucitron.checkIfExist('tarteaucitronCloseAlert')) {\n                    document.getElementById('tarteaucitronCloseAlert').focus();\n                } else if (tarteaucitron.checkIfExist('tarteaucitronManager')) {\n                    document.getElementById('tarteaucitronManager').focus();\n                } else if (tarteaucitron.customCloserId && tarteaucitron.checkIfExist(tarteaucitron.customCloserId)) {\n                    document.getElementById(tarteaucitron.customCloserId).focus();\n                }\n                tarteaucitron.userInterface.css('tarteaucitron', 'display', 'none');\n            }\n\n            if (tarteaucitron.checkIfExist('tarteaucitronCookiesListContainer') && tarteaucitron.checkIfExist('tarteaucitronCookiesNumber')) {\n                // accessibility: manage focus on close cookies list\n                document.getElementById('tarteaucitronCookiesNumber').focus();\n                document.getElementById('tarteaucitronCookiesNumber').setAttribute(\"aria-expanded\", \"false\");\n                tarteaucitron.userInterface.css('tarteaucitronCookiesListContainer', 'display', 'none');\n            }\n\n            tarteaucitron.fallback(['tarteaucitronInfoBox'], function (elem) {\n                elem.style.display = 'none';\n            }, true);\n\n            if (tarteaucitron.reloadThePage === true) {\n                window.location.reload();\n            } else {\n                tarteaucitron.userInterface.css('tarteaucitronBack', 'display', 'none');\n            }\n            if (document.getElementsByTagName('body')[0].classList !== undefined) {\n                document.getElementsByTagName('body')[0].classList.remove('tarteaucitron-modal-open');\n            }\n\n            //ie compatibility\n            var tacClosePanelEvent;\n            if(typeof(Event) === 'function') {\n                tacClosePanelEvent = new Event(\"tac.close_panel\");\n            }else if (typeof(document.createEvent) === 'function'){\n                tacClosePanelEvent = document.createEvent('Event');\n                tacClosePanelEvent.initEvent(\"tac.close_panel\", true, true);\n            }\n            //end ie compatibility\n\n            if (typeof(window.dispatchEvent) === 'function') {window.dispatchEvent(tacClosePanelEvent);}\n        },\n        \"focusTrap\": function(parentElement) {\n            \"use strict\";\n\n            var focusableEls,\n                firstFocusableEl,\n                lastFocusableEl,\n                filtered;\n\n            focusableEls = document.getElementById(parentElement).querySelectorAll('a[href], button');\n            filtered = [];\n\n            // get only visible items\n            for (var i = 0, max = focusableEls.length; i < max; i++) {\n                if (focusableEls[i].offsetHeight > 0) {\n                   filtered.push(focusableEls[i]);\n                }\n            }\n\n            firstFocusableEl = filtered[0];\n            lastFocusableEl = filtered[filtered.length - 1];\n\n            //loop focus inside tarteaucitron\n            document.getElementById(parentElement).addEventListener(\"keydown\", function (evt) {\n\n                if ( evt.key === 'Tab' || evt.keyCode === 9 ) {\n\n                    if ( evt.shiftKey ) /* shift + tab */ {\n                        if (document.activeElement === firstFocusableEl) {\n                            lastFocusableEl.focus();\n                            evt.preventDefault();\n                        }\n                    } else /* tab */ {\n                        if (document.activeElement === lastFocusableEl) {\n                            firstFocusableEl.focus();\n                            evt.preventDefault();\n                        }\n                    }\n                }\n            })\n        },\n        \"openAlert\": function () {\n            \"use strict\";\n            var c = 'tarteaucitron';\n            tarteaucitron.userInterface.css(c + 'Percentage', 'display', 'block');\n            tarteaucitron.userInterface.css(c + 'AlertSmall', 'display', 'none');\n            tarteaucitron.userInterface.css(c + 'Icon', 'display', 'none');\n            tarteaucitron.userInterface.css(c + 'AlertBig',   'display', 'block');\n            tarteaucitron.userInterface.addClass(c + 'Root',   'tarteaucitronBeforeVisible');\n\n            //ie compatibility\n            var tacOpenAlertEvent;\n            if(typeof(Event) === 'function') {\n                tacOpenAlertEvent = new Event(\"tac.open_alert\");\n            }else if (typeof(document.createEvent) === 'function'){\n                tacOpenAlertEvent = document.createEvent('Event');\n                tacOpenAlertEvent.initEvent(\"tac.open_alert\", true, true);\n            }\n            //end ie compatibility\n\n            if (document.getElementById('tarteaucitronAlertBig') !== null && tarteaucitron.parameters.orientation === 'middle') {\n                document.getElementById('tarteaucitronAlertBig').focus();\n            }\n\n            if (typeof(window.dispatchEvent) === 'function') {window.dispatchEvent(tacOpenAlertEvent);}\n        },\n        \"closeAlert\": function () {\n            \"use strict\";\n            var c = 'tarteaucitron';\n            tarteaucitron.userInterface.css(c + 'Percentage', 'display', 'none');\n            tarteaucitron.userInterface.css(c + 'AlertSmall', 'display', 'block');\n            tarteaucitron.userInterface.css(c + 'Icon', 'display', 'block');\n            tarteaucitron.userInterface.css(c + 'AlertBig',   'display', 'none');\n            tarteaucitron.userInterface.removeClass(c + 'Root',   'tarteaucitronBeforeVisible');\n            tarteaucitron.userInterface.jsSizing('box');\n\n            //ie compatibility\n            var tacCloseAlertEvent;\n            if(typeof(Event) === 'function') {\n                tacCloseAlertEvent = new Event(\"tac.close_alert\");\n            }else if (typeof(document.createEvent) === 'function'){\n                tacCloseAlertEvent = document.createEvent('Event');\n                tacCloseAlertEvent.initEvent(\"tac.close_alert\", true, true);\n            }\n            //end ie compatibility\n\n            if (typeof(window.dispatchEvent) === 'function') {window.dispatchEvent(tacCloseAlertEvent);}\n        },\n        \"toggleCookiesList\": function () {\n            \"use strict\";\n            var div = document.getElementById('tarteaucitronCookiesListContainer'),\n                togglediv = document.getElementById('tarteaucitronCookiesNumber');\n\n            if (div === null) {\n                return;\n            }\n\n            if (div.style.display !== 'block') {\n                tarteaucitron.cookie.number();\n                div.style.display = 'block';\n                togglediv.setAttribute(\"aria-expanded\", \"true\");\n                tarteaucitron.userInterface.jsSizing('cookie');\n                tarteaucitron.userInterface.css('tarteaucitron', 'display', 'none');\n                tarteaucitron.userInterface.css('tarteaucitronBack', 'display', 'block');\n                tarteaucitron.fallback(['tarteaucitronInfoBox'], function (elem) {\n                    elem.style.display = 'none';\n                }, true);\n            } else {\n                div.style.display = 'none';\n                togglediv.setAttribute(\"aria-expanded\", \"false\");\n                tarteaucitron.userInterface.css('tarteaucitron', 'display', 'none');\n                tarteaucitron.userInterface.css('tarteaucitronBack', 'display', 'none');\n            }\n        },\n        \"toggle\": function (id, closeClass) {\n            \"use strict\";\n            var div = document.getElementById(id);\n\n            if (div === null) {\n                return;\n            }\n\n            if (closeClass !== undefined) {\n                tarteaucitron.fallback([closeClass], function (elem) {\n                    if (elem.id !== id) {\n                        elem.style.display = 'none';\n                    }\n                }, true);\n            }\n\n            if (div.style.display !== 'block') {\n                div.style.display = 'block';\n            } else {\n                div.style.display = 'none';\n            }\n        },\n        \"order\": function (id) {\n            \"use strict\";\n            var main = document.getElementById('tarteaucitronServices_' + id),\n                allDivs,\n                store = [],\n                i;\n\n            if (main === null) {\n                return;\n            }\n\n            allDivs = main.childNodes;\n\n            if (typeof Array.prototype.map === 'function' && typeof Enumerable === 'undefined') {\n                Array.prototype.map.call(main.children, Object).sort(function (a, b) {\n                //var mainChildren = Array.from(main.children);\n                //mainChildren.sort(function (a, b) {\n                    if (tarteaucitron.services[a.id.replace(/Line/g, '')].name > tarteaucitron.services[b.id.replace(/Line/g, '')].name) { return 1; }\n                    if (tarteaucitron.services[a.id.replace(/Line/g, '')].name < tarteaucitron.services[b.id.replace(/Line/g, '')].name) { return -1; }\n                    return 0;\n                }).forEach(function (element) {\n                    main.appendChild(element);\n                });\n            }\n        },\n        \"jsSizing\": function (type) {\n            \"use strict\";\n            var scrollbarMarginRight = 10,\n                scrollbarWidthParent,\n                scrollbarWidthChild,\n                servicesHeight,\n                e = window,\n                a = 'inner',\n                windowInnerHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight,\n                mainTop,\n                mainHeight,\n                closeButtonHeight,\n                headerHeight,\n                cookiesListHeight,\n                cookiesCloseHeight,\n                cookiesTitleHeight,\n                paddingBox,\n                alertSmallHeight,\n                cookiesNumberHeight;\n\n            if (type === 'box') {\n                if (document.getElementById('tarteaucitronAlertSmall') !== null && document.getElementById('tarteaucitronCookiesNumber') !== null) {\n\n                    // reset\n                    tarteaucitron.userInterface.css('tarteaucitronCookiesNumber', 'padding', '0px 10px');\n\n                    // calculate\n                    alertSmallHeight = document.getElementById('tarteaucitronAlertSmall').offsetHeight;\n                    cookiesNumberHeight = document.getElementById('tarteaucitronCookiesNumber').offsetHeight;\n                    paddingBox = (alertSmallHeight - cookiesNumberHeight) / 2;\n\n                    // apply\n                    tarteaucitron.userInterface.css('tarteaucitronCookiesNumber', 'padding', paddingBox + 'px 10px');\n                }\n            } else if (type === 'main') {\n\n                // get the real window width for media query\n                if (window.innerWidth === undefined) {\n                    a = 'client';\n                    e = document.documentElement || document.body;\n                }\n\n                // height of the services list container\n                if (document.getElementById('tarteaucitron') !== null && document.getElementById('tarteaucitronClosePanel') !== null && document.getElementById('tarteaucitronMainLineOffset') !== null) {\n\n                    // reset\n                    tarteaucitron.userInterface.css('tarteaucitronServices', 'height', 'auto');\n\n                    // calculate\n                    mainHeight = document.getElementById('tarteaucitron').offsetHeight;\n                    closeButtonHeight = document.getElementById('tarteaucitronClosePanel').offsetHeight;\n\n                    // apply\n                    servicesHeight = (mainHeight - closeButtonHeight + 4);\n                    tarteaucitron.userInterface.css('tarteaucitronServices', 'height', servicesHeight + 'px');\n                    tarteaucitron.userInterface.css('tarteaucitronServices', 'overflow-x', 'auto');\n                }\n\n                // align the main allow/deny button depending on scrollbar width\n                if (document.getElementById('tarteaucitronServices') !== null && document.getElementById('tarteaucitronScrollbarChild') !== null) {\n\n                    // media query\n                    if (e[a + 'Width'] <= 479) {\n                        //tarteaucitron.userInterface.css('tarteaucitronScrollbarAdjust', 'marginLeft', '11px');\n                    } else if (e[a + 'Width'] <= 767) {\n                        scrollbarMarginRight = 12;\n                    }\n\n                    scrollbarWidthParent = document.getElementById('tarteaucitronServices').offsetWidth;\n                    scrollbarWidthChild = document.getElementById('tarteaucitronScrollbarChild').offsetWidth;\n                    //tarteaucitron.userInterface.css('tarteaucitronScrollbarAdjust', 'marginRight', ((scrollbarWidthParent - scrollbarWidthChild) + scrollbarMarginRight) + 'px');\n                }\n\n                // center the main panel\n                if (document.getElementById('tarteaucitron') !== null) {\n\n                    // media query\n                    if (e[a + 'Width'] <= 767) {\n                        mainTop = 0;\n                    } else {\n                        mainTop = ((windowInnerHeight - document.getElementById('tarteaucitron').offsetHeight) / 2) - 21;\n                    }\n\n                    if (document.getElementById('tarteaucitronMainLineOffset') !== null) {\n                        if (document.getElementById('tarteaucitron').offsetHeight < (windowInnerHeight / 2)) {\n                            mainTop -= document.getElementById('tarteaucitronMainLineOffset').offsetHeight;\n                        }\n                    }\n\n                    // correct\n                    if (mainTop < 0) {\n                        mainTop = 0;\n                    }\n\n                    // apply\n                    tarteaucitron.userInterface.css('tarteaucitron', 'top', mainTop + 'px');\n                }\n\n\n            } else if (type === 'cookie') {\n\n                // put cookies list at bottom\n                if (document.getElementById('tarteaucitronAlertSmall') !== null) {\n                    tarteaucitron.userInterface.css('tarteaucitronCookiesListContainer', 'bottom', (document.getElementById('tarteaucitronAlertSmall').offsetHeight) + 'px');\n                }\n\n                // height of cookies list\n                if (document.getElementById('tarteaucitronCookiesListContainer') !== null) {\n\n                    // reset\n                    tarteaucitron.userInterface.css('tarteaucitronCookiesList', 'height', 'auto');\n\n                    // calculate\n                    cookiesListHeight = document.getElementById('tarteaucitronCookiesListContainer').offsetHeight;\n                    cookiesCloseHeight = document.getElementById('tarteaucitronClosePanelCookie').offsetHeight;\n                    cookiesTitleHeight = document.getElementById('tarteaucitronCookiesTitle').offsetHeight;\n\n                    // apply\n                    tarteaucitron.userInterface.css('tarteaucitronCookiesList', 'height', (cookiesListHeight - cookiesCloseHeight - cookiesTitleHeight - 2) + 'px');\n                }\n            }\n        }\n    },\n    \"cookie\": {\n        \"owner\": {},\n        \"create\": function (key, status) {\n            \"use strict\";\n\n            if (tarteaucitronForceExpire !== '') {\n                // The number of day(s)/hour(s) can't be higher than 1 year\n                if ((tarteaucitronExpireInDay && tarteaucitronForceExpire < 365) || (!tarteaucitronExpireInDay && tarteaucitronForceExpire < 8760)) {\n                    if (tarteaucitronExpireInDay) {\n                        // Multiplication to tranform the number of days to milliseconds\n                        timeExpire = tarteaucitronForceExpire * 86400000;\n                    } else {\n                        // Multiplication to tranform the number of hours to milliseconds\n                        timeExpire = tarteaucitronForceExpire * 3600000;\n                    }\n                }\n            }\n\n            var d = new Date(),\n                time = d.getTime(),\n                expireTime = time + timeExpire, // 365 days\n                regex = new RegExp(\"!\" + key + \"=(wait|true|false)\", \"g\"),\n                cookie = tarteaucitron.cookie.read().replace(regex, \"\"),\n                value = tarteaucitron.parameters.cookieName + '=' + cookie + '!' + key + '=' + status,\n                domain = (tarteaucitron.parameters.cookieDomain !== undefined && tarteaucitron.parameters.cookieDomain !== '') ? '; domain=' + tarteaucitron.parameters.cookieDomain : '',\n                secure = location.protocol === 'https:' ? '; Secure' : '';\n\n            d.setTime(expireTime);\n            document.cookie = value + '; expires=' + d.toGMTString() + '; path=/' + domain + secure + '; samesite=lax';\n\n            tarteaucitron.sendEvent('tac.consent_updated');\n        },\n        \"read\": function () {\n            \"use strict\";\n            var nameEQ = tarteaucitron.parameters.cookieName + \"=\",\n                ca = document.cookie.split(';'),\n                i,\n                c;\n\n            for (i = 0; i < ca.length; i += 1) {\n                c = ca[i];\n                while (c.charAt(0) === ' ') {\n                    c = c.substring(1, c.length);\n                }\n                if (c.indexOf(nameEQ) === 0) {\n                    return c.substring(nameEQ.length, c.length);\n                }\n            }\n            return '';\n        },\n        \"purge\": function (arr) {\n            \"use strict\";\n            var i;\n\n            for (i = 0; i < arr.length; i += 1) {\n\n                var rgxpCookie = new RegExp(\"^(.*;)?\\\\s*\" + arr[i] + \"\\\\s*=\\\\s*[^;]+(.*)?$\");\n                if (document.cookie.match(rgxpCookie)) {\n                    document.cookie = arr[i] + '=; expires=Thu, 01 Jan 2000 00:00:00 GMT; path=/;';\n                    document.cookie = arr[i] + '=; expires=Thu, 01 Jan 2000 00:00:00 GMT; path=/; domain=.' + location.hostname + ';';\n                    document.cookie = arr[i] + '=; expires=Thu, 01 Jan 2000 00:00:00 GMT; path=/; domain=.' + location.hostname.split('.').slice(-2).join('.') + ';';\n                }\n            }\n        },\n        \"checkCount\": function (key) {\n            \"use strict\";\n            var arr = tarteaucitron.services[key].cookies,\n                nb = arr.length,\n                nbCurrent = 0,\n                html = '',\n                i,\n                status = document.cookie.indexOf(key + '=true'),\n                cookieLabel = \"cookie\";\n\n            if (tarteaucitron.getLanguage() === \"de\") {\n                cookieLabel = \"Cookie\";\n            }\n\n            if (status >= 0 && nb === 0) {\n                html += tarteaucitron.lang.useNoCookie;\n            } else if (status >= 0) {\n                for (i = 0; i < nb; i += 1) {\n                    if (document.cookie.indexOf(arr[i] + '=') !== -1) {\n                        nbCurrent += 1;\n                        if (tarteaucitron.cookie.owner[arr[i]] === undefined) {\n                            tarteaucitron.cookie.owner[arr[i]] = [];\n                        }\n                        if (tarteaucitron.cookie.crossIndexOf(tarteaucitron.cookie.owner[arr[i]], tarteaucitron.services[key].name) === false) {\n                            tarteaucitron.cookie.owner[arr[i]].push(tarteaucitron.services[key].name);\n                        }\n                    }\n                }\n\n                if (nbCurrent > 0) {\n                    html += tarteaucitron.lang.useCookieCurrent + ' ' + nbCurrent + ' ' + cookieLabel;\n                    if (nbCurrent > 1) {\n                        html += 's';\n                    }\n                    html += '.';\n                } else {\n                    html += tarteaucitron.lang.useNoCookie;\n                }\n            } else if (nb === 0) {\n                html = tarteaucitron.lang.noCookie;\n            } else {\n                html += tarteaucitron.lang.useCookie + ' ' + nb + ' ' + cookieLabel;\n                if (nb > 1) {\n                    html += 's';\n                }\n                html += '.';\n            }\n\n            if (document.getElementById('tacCL' + key) !== null) {\n                document.getElementById('tacCL' + key).innerHTML = html;\n            }\n        },\n        \"crossIndexOf\": function (arr, match) {\n            \"use strict\";\n            var i;\n            for (i = 0; i < arr.length; i += 1) {\n                if (arr[i] === match) {\n                    return true;\n                }\n            }\n            return false;\n        },\n        \"number\": function () {\n            \"use strict\";\n            var cookies = document.cookie.split(';'),\n                nb = (document.cookie !== '') ? cookies.length : 0,\n                html = '',\n                i,\n                name,\n                namea,\n                nameb,\n                c,\n                d,\n                s = (nb > 1) ? 's' : '',\n                savedname,\n                regex = /^https?\\:\\/\\/([^\\/?#]+)(?:[\\/?#]|$)/i,\n                regexedDomain = (tarteaucitron.cdn.match(regex) !== null) ? tarteaucitron.cdn.match(regex)[1] : tarteaucitron.cdn,\n                host = (tarteaucitron.domain !== undefined) ? tarteaucitron.domain : regexedDomain;\n\n            cookies = cookies.sort(function (a, b) {\n                namea = a.split('=', 1).toString().replace(/ /g, '');\n                nameb = b.split('=', 1).toString().replace(/ /g, '');\n                c = (tarteaucitron.cookie.owner[namea] !== undefined) ? tarteaucitron.cookie.owner[namea] : '0';\n                d = (tarteaucitron.cookie.owner[nameb] !== undefined) ? tarteaucitron.cookie.owner[nameb] : '0';\n                if (c + a > d + b) { return 1; }\n                if (c + a < d + b) { return -1; }\n                return 0;\n            });\n\n            if (document.cookie !== '') {\n                for (i = 0; i < nb; i += 1) {\n                    name = cookies[i].split('=', 1).toString().replace(/ /g, '');\n                    if (tarteaucitron.cookie.owner[name] !== undefined && tarteaucitron.cookie.owner[name].join(' // ') !== savedname) {\n                        savedname = tarteaucitron.cookie.owner[name].join(' // ');\n                        html += '<div class=\"tarteaucitronHidden\">';\n                        html += '     <span class=\"tarteaucitronTitle tarteaucitronH3\" role=\"heading\" aria-level=\"3\">';\n                        html += '        ' + tarteaucitron.cookie.owner[name].join(' // ');\n                        html += '    </span>';\n                        html += '</div><ul class=\"cookie-list\">';\n                    } else if (tarteaucitron.cookie.owner[name] === undefined && host !== savedname) {\n                        savedname = host;\n                        html += '<div class=\"tarteaucitronHidden\">';\n                        html += '     <span class=\"tarteaucitronTitle tarteaucitronH3\" role=\"heading\" aria-level=\"3\">';\n                        html += '        ' + host;\n                        html += '    </span>';\n                        html += '</div><ul class=\"cookie-list\">';\n                    }\n                    html += '<li class=\"tarteaucitronCookiesListMain\">';\n                    html += '    <div class=\"tarteaucitronCookiesListLeft\"><button type=\"button\" class=\"purgeBtn\" data-cookie=\"' + tarteaucitron.fixSelfXSS(cookies[i].split('=', 1)) + '\"><strong>&times;</strong></button> <strong>' + tarteaucitron.fixSelfXSS(name) + '</strong>';\n                    html += '    </div>';\n                    html += '    <div class=\"tarteaucitronCookiesListRight\">' + tarteaucitron.fixSelfXSS(cookies[i].split('=').slice(1).join('=')) + '</div>';\n                    html += '</li>';\n                }\n                html += '</ul>';\n            } else {\n                html += '<div class=\"tarteaucitronCookiesListMain\">';\n                html += '    <div class=\"tarteaucitronCookiesListLeft\"><strong>-</strong></div>';\n                html += '    <div class=\"tarteaucitronCookiesListRight\"></div>';\n                html += '</div>';\n            }\n\n            html += '<div class=\"tarteaucitronHidden tarteaucitron-spacer-20\"></div>';\n\n            if (document.getElementById('tarteaucitronCookiesList') !== null) {\n                document.getElementById('tarteaucitronCookiesList').innerHTML = html;\n            }\n\n            if (document.getElementById('tarteaucitronCookiesNumber') !== null) {\n                document.getElementById('tarteaucitronCookiesNumber').innerHTML = nb;\n                document.getElementById('tarteaucitronCookiesNumber').setAttribute(\"aria-label\", nb + ' cookie' + s + \" - \" + tarteaucitron.lang.toggleInfoBox);\n                document.getElementById('tarteaucitronCookiesNumber').setAttribute(\"title\", nb + ' cookie' + s + \" - \" + tarteaucitron.lang.toggleInfoBox);\n            }\n\n            if (document.getElementById('tarteaucitronCookiesNumberBis') !== null) {\n                document.getElementById('tarteaucitronCookiesNumberBis').innerHTML = nb + ' cookie' + s;\n            }\n\n            var purgeBtns = document.getElementsByClassName(\"purgeBtn\");\n            for (i = 0; i < purgeBtns.length; i++) {\n                tarteaucitron.addClickEventToElement(purgeBtns[i], function () {\n                    tarteaucitron.cookie.purge([this.dataset.cookie]);\n                    tarteaucitron.cookie.number();\n                    tarteaucitron.userInterface.jsSizing('cookie');\n                    return false;\n                });\n            }\n\n            for (i = 0; i < tarteaucitron.job.length; i += 1) {\n                tarteaucitron.cookie.checkCount(tarteaucitron.job[i]);\n            }\n        }\n    },\n    \"fixSelfXSS\": function(html) {\n        return html.toString().replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#039;\");\n    },\n    \"getLanguage\": function () {\n        \"use strict\";\n\n        var availableLanguages = 'ar,bg,ca,cn,cs,da,de,et,el,en,es,fi,fr,hr,hu,it,ja,ko,lb,lt,lv,nl,no,oc,pl,pt,ro,ru,se,sk,sv,tr,uk,vi,zh',\n            defaultLanguage = 'en';\n\n        if (tarteaucitronForceLanguage !== '') {\n            if (availableLanguages.indexOf(tarteaucitronForceLanguage) !== -1) {\n                return tarteaucitronForceLanguage;\n            }\n        }\n\n        // get the html lang\n        if (document.documentElement.getAttribute(\"lang\") !== undefined && document.documentElement.getAttribute(\"lang\") !== null && document.documentElement.getAttribute(\"lang\") !== \"\") {\n            if (availableLanguages.indexOf(document.documentElement.getAttribute(\"lang\").substr(0, 2)) !== -1) {\n                return document.documentElement.getAttribute(\"lang\").substr(0, 2);\n            }\n        }\n\n        if (!navigator) { return defaultLanguage; }\n\n        var lang = navigator.language || navigator.browserLanguage ||\n                navigator.systemLanguage || navigator.userLang || null,\n            userLanguage = lang ? lang.substr(0, 2) : null;\n\n        if (availableLanguages.indexOf(userLanguage) !== -1) {\n            return userLanguage;\n        }\n\n        return defaultLanguage;\n    },\n    \"getLocale\": function () {\n        \"use strict\";\n        if (!navigator) { return 'en_US'; }\n\n        var lang = navigator.language || navigator.browserLanguage ||\n                navigator.systemLanguage || navigator.userLang || null,\n            userLanguage = lang ? lang.substr(0, 2) : null;\n\n        if (userLanguage === 'fr') {\n            return 'fr_FR';\n        } else if (userLanguage === 'en') {\n            return 'en_US';\n        } else if (userLanguage === 'de') {\n            return 'de_DE';\n        } else if (userLanguage === 'es') {\n            return 'es_ES';\n        } else if (userLanguage === 'it') {\n            return 'it_IT';\n        } else if (userLanguage === 'pt') {\n            return 'pt_PT';\n        } else if (userLanguage === 'nl') {\n            return 'nl_NL';\n        } else if (userLanguage === 'el') {\n            return 'el_EL';\n        } else {\n            return 'en_US';\n        }\n    },\n    \"addScript\": function (url, id, callback, execute, attrName, attrVal, internal) {\n        \"use strict\";\n        var script,\n            done = false;\n\n        if (execute === false) {\n            if (typeof callback === 'function') {\n                callback();\n            }\n        } else {\n            script = document.createElement('script');\n            if (id !== undefined && id !== \"\") {\n                script.id = id;\n            }\n            script.async = true;\n            script.src = url;\n\n            if (attrName !== undefined && attrVal !== undefined) {\n                script.setAttribute(attrName, attrVal);\n            }\n\n            if (typeof callback === 'function') {\n                if ( !tarteaucitron.parameters.useExternalJs || !internal ) {\n                    script.onreadystatechange = script.onload = function () {\n                        var state = script.readyState;\n                        if (!done && (!state || /loaded|complete/.test(state))) {\n                            done = true;\n                            callback();\n                        }\n                    };\n                } else {\n                    callback();\n                }\n            }\n\n            if ( !tarteaucitron.parameters.useExternalJs || !internal ) {\n                document.getElementsByTagName('head')[0].appendChild(script);\n            }\n        }\n    },\n    \"addInternalScript\": function (url, id, callback, execute, attrName, attrVal) {\n        tarteaucitron.addScript(url, id, callback, execute, attrName, attrVal, true);\n    },\n    \"checkIfExist\": function (elemId) {\n        \"use strict\";\n        return document.getElementById(elemId) !== null && document.getElementById(elemId).offsetWidth !== 0 && document.getElementById(elemId).offsetHeight !== 0;\n    },\n    \"makeAsync\": {\n        \"antiGhost\": 0,\n        \"buffer\": '',\n        \"init\": function (url, id) {\n            \"use strict\";\n            var savedWrite = document.write,\n                savedWriteln = document.writeln;\n\n            document.write = function (content) {\n                tarteaucitron.makeAsync.buffer += content;\n            };\n            document.writeln = function (content) {\n                tarteaucitron.makeAsync.buffer += content.concat(\"\\n\");\n            };\n\n            setTimeout(function () {\n                document.write = savedWrite;\n                document.writeln = savedWriteln;\n            }, 20000);\n\n            tarteaucitron.makeAsync.getAndParse(url, id);\n        },\n        \"getAndParse\": function (url, id) {\n            \"use strict\";\n            if (tarteaucitron.makeAsync.antiGhost > 9) {\n                tarteaucitron.makeAsync.antiGhost = 0;\n                return;\n            }\n            tarteaucitron.makeAsync.antiGhost += 1;\n            tarteaucitron.addInternalScript(url, '', function () {\n                if (document.getElementById(id) !== null) {\n                    document.getElementById(id).innerHTML += \"<span class='tarteaucitron-display-none'>&nbsp;</span>\" + tarteaucitron.makeAsync.buffer;\n                    tarteaucitron.makeAsync.buffer = '';\n                    tarteaucitron.makeAsync.execJS(id);\n                }\n            });\n        },\n        \"execJS\": function (id) {\n            /* not strict because third party scripts may have errors */\n            var i,\n                scripts,\n                childId,\n                type;\n\n            if (document.getElementById(id) === null) {\n                return;\n            }\n\n            scripts = document.getElementById(id).getElementsByTagName('script');\n            for (i = 0; i < scripts.length; i += 1) {\n                type = (scripts[i].getAttribute('type') !== null) ? scripts[i].getAttribute('type') : '';\n                if (type === '') {\n                    type = (scripts[i].getAttribute('language') !== null) ? scripts[i].getAttribute('language') : '';\n                }\n                if (scripts[i].getAttribute('src') !== null && scripts[i].getAttribute('src') !== '') {\n                    childId = id + Math.floor(Math.random() * 99999999999);\n                    document.getElementById(id).innerHTML += '<div id=\"' + childId + '\"></div>';\n                    tarteaucitron.makeAsync.getAndParse(scripts[i].getAttribute('src'), childId);\n                } else if (type.indexOf('javascript') !== -1 || type === '') {\n                    eval(scripts[i].innerHTML);\n                }\n            }\n        }\n    },\n    \"fallback\": function (matchClass, content, noInner) {\n        \"use strict\";\n        var selector = matchClass.map(function(cls) {\n            return '.' + cls;\n        }).join(', ');\n\n        var elems = document.querySelectorAll(selector);\n\n        for (var i = 0; i < elems.length; i++) {\n            var elem = elems[i];\n            if (typeof content === 'function') {\n                if (noInner === true) {\n                    content(elem);\n                } else {\n                    elem.innerHTML = content(elem);\n                }\n            } else {\n                elem.innerHTML = content;\n            }\n        }\n    },\n    \"engage\": function (id) {\n        \"use strict\";\n        var html = '',\n            r = Math.floor(Math.random() * 100000),\n            engage = tarteaucitron.services[id].name + ' ' + tarteaucitron.lang.fallback;\n\n        if (tarteaucitron.lang['engage-' + id] !== undefined) {\n            engage = tarteaucitron.lang['engage-' + id];\n        }\n\n        html += '<div class=\"tac_activate tac_activate_' + id + '\">';\n        html += '   <div class=\"tac_float\">';\n        html += '      ' + engage;\n        html += '      <button type=\"button\" class=\"tarteaucitronAllow\" id=\"Eng' + r + 'ed' + id + '\">';\n        html += '          <span class=\"tarteaucitronCheck\" aria-hidden=\"true\"></span> ' + tarteaucitron.lang.allow;\n        html += '       </button>';\n        html += '   </div>';\n        html += '</div>';\n\n        return html;\n    },\n    \"extend\": function (a, b) {\n        \"use strict\";\n        var prop;\n        for (prop in b) {\n            if (b.hasOwnProperty(prop)) {\n                a[prop] = b[prop];\n            }\n        }\n    },\n    \"proTemp\": '',\n    \"proTimer\": function () {\n        \"use strict\";\n        setTimeout(tarteaucitron.proPing, (Math.floor(Math.random() * (1200 - 500 + 1)) + 500));\n    },\n    \"pro\": function (list) {\n        \"use strict\";\n        tarteaucitron.proTemp += list;\n        clearTimeout(tarteaucitron.proTimer);\n        tarteaucitron.proTimer = setTimeout(tarteaucitron.proPing, (Math.floor(Math.random() * (1200 - 500 + 1)) + 500));\n    },\n    \"proPing\": function () {\n        \"use strict\";\n        if (tarteaucitron.uuid !== '' && tarteaucitron.uuid !== undefined && tarteaucitron.proTemp !== '' && tarteaucitronStatsEnabled) {\n            var div = document.getElementById('tarteaucitronPremium'),\n                timestamp = new Date().getTime(),\n                url = 'https://tarteaucitron.io/log/?';\n\n            if (div === null) {\n                return;\n            }\n\n            url += 'account=' + tarteaucitron.uuid + '&';\n            url += 'domain=' + tarteaucitron.domain + '&';\n            url += 'status=' + encodeURIComponent(tarteaucitron.proTemp) + '&';\n            url += '_time=' + timestamp;\n\n            div.innerHTML = '<img src=\"' + url + '\" class=\"tarteaucitron-display-none\" alt=\"\" />';\n\n            tarteaucitron.proTemp = '';\n        }\n\n        tarteaucitron.cookie.number();\n    },\n    \"AddOrUpdate\" : function(source, custom){\n        /**\n         Utility function to Add or update the fields of obj1 with the ones in obj2\n         */\n        for(var key in custom){\n            if(custom[key] instanceof Object){\n                source[key] = tarteaucitron.AddOrUpdate(source[key], custom[key]);\n            }else{\n                source[key] = custom[key];\n            }\n        }\n        return source;\n    },\n    \"getElemWidth\": function(elem) {\n        return tarteaucitron.getElemAttr(elem, 'width') || elem.clientWidth;\n    },\n    \"getElemHeight\": function(elem) {\n        return tarteaucitron.getElemAttr(elem, 'height') || elem.clientHeight;\n    },\n    \"getElemAttr\": function (elem, attr) {\n        var attribute = elem.getAttribute('data-' + attr) || elem.getAttribute(attr);\n\n        if (typeof attribute === 'string') {\n            return tarteaucitron.fixSelfXSS(attribute);\n        }\n\n        return \"\";\n    },\n    \"addClickEventToId\": function (elemId, func) {\n        tarteaucitron.addClickEventToElement(document.getElementById(elemId), func);\n    },\n    \"addClickEventToElement\": function (e, func) {\n        if (e) {\n            if (e.addEventListener) {\n                e.addEventListener(\"click\", func);\n            } else {\n                e.attachEvent(\"onclick\", func);\n            }\n        }\n    },\n    \"triggerJobsAfterAjaxCall\": function() {\n        tarteaucitron.job.forEach(function(e) { tarteaucitron.job.push(e) });\n        var i;\n        var allowBtns = document.getElementsByClassName(\"tarteaucitronAllow\");\n        for (i = 0; i < allowBtns.length; i++) {\n            tarteaucitron.addClickEventToElement(allowBtns[i], function () {\n                tarteaucitron.userInterface.respond(this, true);\n            });\n        }\n        var denyBtns = document.getElementsByClassName(\"tarteaucitronDeny\");\n        for (i = 0; i < denyBtns.length; i++) {\n            tarteaucitron.addClickEventToElement(denyBtns[i], function () {\n                tarteaucitron.userInterface.respond(this, false);\n            });\n        }\n    }\n};", "output": {"vulnerability_count": 49, "vulnerabilities": [{"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 182}, {"description": "User controlled data in a `document.getElementById('tarteaucitronDisclaimerAlert').innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 182}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 773}, {"description": "User controlled data in a `div.innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 773}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 863}, {"description": "User controlled data in a `div.innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 863}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 872}, {"description": "User controlled data in a `closeButton.innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 872}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 904}, {"description": "User controlled data in a `ul.innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 904}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1129}, {"description": "User controlled data in a `document.getElementById('tarteaucitronServices_' + service.type).innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1129}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1331}, {"description": "User controlled data in a `itemStatusElem.innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1331}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1334}, {"description": "User controlled data in a `itemStatusElem.innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1334}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1379}, {"description": "User controlled data in a `itemStatusElem.innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1379}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1382}, {"description": "User controlled data in a `itemStatusElem.innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1382}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1536}, {"description": "User controlled data in a `document.getElementById('tarteaucitronCounter-'+cat).innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1536}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1542}, {"description": "User controlled data in a `document.getElementById('tarteaucitronCounter-all').innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1542}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1561}, {"description": "User controlled data in a `document.getElementById('tarteaucitronCounter-list').innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1561}, {"description": "RegExp() called with a `key` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1949}, {"description": "RegExp() called with a `arr` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1984}, {"description": "`document.cookie` is assigned twice; the first assignment is useless", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1986}, {"description": "`document.cookie` is assigned twice; the first assignment is useless", "risk": "Medium", "conceptual_fix": "Not provided", "line": 1987}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 2041}, {"description": "User controlled data in a `document.getElementById('tacCL' + key).innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 2041}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 2116}, {"description": "User controlled data in a `document.getElementById('tarteaucitronCookiesList').innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 2116}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 2120}, {"description": "User controlled data in a `document.getElementById('tarteaucitronCookiesNumber').innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 2120}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 2126}, {"description": "User controlled data in a `document.getElementById('tarteaucitronCookiesNumberBis').innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 2126}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 2284}, {"description": "User controlled data in a `document.getElementById(id).innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 2284}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 2309}, {"description": "User controlled data in a `document.getElementById(id).innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 2309}, {"description": "Detected the use of eval(). eval() can be dangerous if used to evaluate dynamic content. If this content can be input from outside the program, this may be a code injection vulnerability. Ensure evaluated content is not definable by external sources.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 2312}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 2331}, {"description": "User controlled data in a `elem.innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 2331}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 2334}, {"description": "User controlled data in a `elem.innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 2334}, {"description": "User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 2395}, {"description": "User controlled data in a `div.innerHTML` is an anti-pattern that can lead to XSS vulnerabilities", "risk": "Medium", "conceptual_fix": "Not provided", "line": 2395}]}}
{"CVE": "CVE-2025-31486", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "import path from 'node:path'\nimport fsp from 'node:fs/promises'\nimport { Buffer } from 'node:buffer'\nimport * as mrmime from 'mrmime'\nimport type { NormalizedOutputOptions, RenderedChunk } from 'rollup'\nimport MagicString from 'magic-string'\nimport colors from 'picocolors'\nimport {\n  createToImportMetaURLBasedRelativeRuntime,\n  toOutputFilePathInJS,\n} from '../build'\nimport type { Plugin, PluginContext } from '../plugin'\nimport type { ResolvedConfig } from '../config'\nimport { checkPublicFile } from '../publicDir'\nimport {\n  encodeURIPath,\n  getHash,\n  injectQuery,\n  joinUrlSegments,\n  normalizePath,\n  rawRE,\n  removeLeadingSlash,\n  removeUrlQuery,\n  urlRE,\n} from '../utils'\nimport { DEFAULT_ASSETS_INLINE_LIMIT, FS_PREFIX } from '../constants'\nimport {\n  cleanUrl,\n  splitFileAndPostfix,\n  withTrailingSlash,\n} from '../../shared/utils'\nimport type { Environment } from '../environment'\n\n// referenceId is base64url but replaces - with $\nexport const assetUrlRE = /__VITE_ASSET__([\\w$]+)__(?:\\$_(.*?)__)?/g\n\nconst jsSourceMapRE = /\\.[cm]?js\\.map$/\n\nexport const noInlineRE = /[?&]no-inline\\b/\nexport const inlineRE = /[?&]inline\\b/\nconst svgExtRE = /\\.svg(?:$|\\?)/\n\nconst assetCache = new WeakMap<Environment, Map<string, string>>()\n\n/** a set of referenceId for entry CSS assets for each environment */\nexport const cssEntriesMap = new WeakMap<Environment, Set<string>>()\n\n// add own dictionary entry by directly assigning mrmime\nexport function registerCustomMime(): void {\n  // https://github.com/lukeed/mrmime/issues/3\n  // instead of `image/vnd.microsoft.icon` which is registered on IANA Media Types DB\n  // image/x-icon should be used instead for better compatibility (https://github.com/h5bp/html5-boilerplate/issues/219)\n  mrmime.mimes['ico'] = 'image/x-icon'\n  // https://mimesniff.spec.whatwg.org/#matching-an-image-type-pattern\n  mrmime.mimes['cur'] = 'image/x-icon'\n  // https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Containers#flac\n  mrmime.mimes['flac'] = 'audio/flac'\n  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types\n  mrmime.mimes['eot'] = 'application/vnd.ms-fontobject'\n}\n\nexport function renderAssetUrlInJS(\n  pluginContext: PluginContext,\n  chunk: RenderedChunk,\n  opts: NormalizedOutputOptions,\n  code: string,\n): MagicString | undefined {\n  const { environment } = pluginContext\n  const toRelativeRuntime = createToImportMetaURLBasedRelativeRuntime(\n    opts.format,\n    environment.config.isWorker,\n  )\n\n  let match: RegExpExecArray | null\n  let s: MagicString | undefined\n\n  // Urls added with JS using e.g.\n  // imgElement.src = \"__VITE_ASSET__5aA0Ddc0__\" are using quotes\n\n  // Urls added in CSS that is imported in JS end up like\n  // var inlined = \".inlined{color:green;background:url(__VITE_ASSET__5aA0Ddc0__)}\\n\";\n\n  // In both cases, the wrapping should already be fine\n\n  assetUrlRE.lastIndex = 0\n  while ((match = assetUrlRE.exec(code))) {\n    s ||= new MagicString(code)\n    const [full, referenceId, postfix = ''] = match\n    const file = pluginContext.getFileName(referenceId)\n    chunk.viteMetadata!.importedAssets.add(cleanUrl(file))\n    const filename = file + postfix\n    const replacement = toOutputFilePathInJS(\n      environment,\n      filename,\n      'asset',\n      chunk.fileName,\n      'js',\n      toRelativeRuntime,\n    )\n    const replacementString =\n      typeof replacement === 'string'\n        ? JSON.stringify(encodeURIPath(replacement)).slice(1, -1)\n        : `\"+${replacement.runtime}+\"`\n    s.update(match.index, match.index + full.length, replacementString)\n  }\n\n  // Replace __VITE_PUBLIC_ASSET__5aA0Ddc0__ with absolute paths\n\n  const publicAssetUrlMap = publicAssetUrlCache.get(\n    environment.getTopLevelConfig(),\n  )!\n  publicAssetUrlRE.lastIndex = 0\n  while ((match = publicAssetUrlRE.exec(code))) {\n    s ||= new MagicString(code)\n    const [full, hash] = match\n    const publicUrl = publicAssetUrlMap.get(hash)!.slice(1)\n    const replacement = toOutputFilePathInJS(\n      environment,\n      publicUrl,\n      'public',\n      chunk.fileName,\n      'js',\n      toRelativeRuntime,\n    )\n    const replacementString =\n      typeof replacement === 'string'\n        ? JSON.stringify(encodeURIPath(replacement)).slice(1, -1)\n        : `\"+${replacement.runtime}+\"`\n    s.update(match.index, match.index + full.length, replacementString)\n  }\n\n  return s\n}\n\n/**\n * Also supports loading plain strings with import text from './foo.txt?raw'\n */\nexport function assetPlugin(config: ResolvedConfig): Plugin {\n  registerCustomMime()\n\n  return {\n    name: 'vite:asset',\n\n    perEnvironmentStartEndDuringDev: true,\n\n    buildStart() {\n      assetCache.set(this.environment, new Map())\n      cssEntriesMap.set(this.environment, new Set())\n    },\n\n    resolveId: {\n      handler(id) {\n        if (!config.assetsInclude(cleanUrl(id)) && !urlRE.test(id)) {\n          return\n        }\n        // imports to absolute urls pointing to files in /public\n        // will fail to resolve in the main resolver. handle them here.\n        const publicFile = checkPublicFile(id, config)\n        if (publicFile) {\n          return id\n        }\n      },\n    },\n\n    load: {\n      async handler(id) {\n        if (id[0] === '\\0') {\n          // Rollup convention, this id should be handled by the\n          // plugin that marked it with \\0\n          return\n        }\n\n        // raw requests, read from disk\n        if (rawRE.test(id)) {\n          const file = checkPublicFile(id, config) || cleanUrl(id)\n          this.addWatchFile(file)\n          // raw query, read file and return as string\n          return `export default ${JSON.stringify(\n            await fsp.readFile(file, 'utf-8'),\n          )}`\n        }\n\n        if (!urlRE.test(id) && !config.assetsInclude(cleanUrl(id))) {\n          return\n        }\n\n        id = removeUrlQuery(id)\n        let url = await fileToUrl(this, id)\n\n        // Inherit HMR timestamp if this asset was invalidated\n        if (!url.startsWith('data:') && this.environment.mode === 'dev') {\n          const mod = this.environment.moduleGraph.getModuleById(id)\n          if (mod && mod.lastHMRTimestamp > 0) {\n            url = injectQuery(url, `t=${mod.lastHMRTimestamp}`)\n          }\n        }\n\n        return {\n          code: `export default ${JSON.stringify(encodeURIPath(url))}`,\n          // Force rollup to keep this module from being shared between other entry points if it's an entrypoint.\n          // If the resulting chunk is empty, it will be removed in generateBundle.\n          moduleSideEffects:\n            config.command === 'build' && this.getModuleInfo(id)?.isEntry\n              ? 'no-treeshake'\n              : false,\n          meta: config.command === 'build' ? { 'vite:asset': true } : undefined,\n        }\n      },\n    },\n\n    renderChunk(code, chunk, opts) {\n      const s = renderAssetUrlInJS(this, chunk, opts, code)\n\n      if (s) {\n        return {\n          code: s.toString(),\n          map: this.environment.config.build.sourcemap\n            ? s.generateMap({ hires: 'boundary' })\n            : null,\n        }\n      } else {\n        return null\n      }\n    },\n\n    generateBundle(_, bundle) {\n      // Remove empty entry point file\n      for (const file in bundle) {\n        const chunk = bundle[file]\n        if (\n          chunk.type === 'chunk' &&\n          chunk.isEntry &&\n          chunk.moduleIds.length === 1 &&\n          config.assetsInclude(chunk.moduleIds[0]) &&\n          this.getModuleInfo(chunk.moduleIds[0])?.meta['vite:asset']\n        ) {\n          delete bundle[file]\n        }\n      }\n\n      // do not emit assets for SSR build\n      if (\n        config.command === 'build' &&\n        !this.environment.config.build.emitAssets\n      ) {\n        for (const file in bundle) {\n          if (\n            bundle[file].type === 'asset' &&\n            !file.endsWith('ssr-manifest.json') &&\n            !jsSourceMapRE.test(file)\n          ) {\n            delete bundle[file]\n          }\n        }\n      }\n    },\n  }\n}\n\nexport async function fileToUrl(\n  pluginContext: PluginContext,\n  id: string,\n): Promise<string> {\n  const { environment } = pluginContext\n  if (environment.config.command === 'serve') {\n    return fileToDevUrl(environment, id)\n  } else {\n    return fileToBuiltUrl(pluginContext, id)\n  }\n}\n\nexport async function fileToDevUrl(\n  environment: Environment,\n  id: string,\n  skipBase = false,\n): Promise<string> {\n  const config = environment.getTopLevelConfig()\n  const publicFile = checkPublicFile(id, config)\n\n  // If has inline query, unconditionally inline the asset\n  if (inlineRE.test(id)) {\n    const file = publicFile || cleanUrl(id)\n    const content = await fsp.readFile(file)\n    return assetToDataURL(environment, file, content)\n  }\n\n  // If is svg and it's inlined in build, also inline it in dev to match\n  // the behaviour in build due to quote handling differences.\n  if (svgExtRE.test(id)) {\n    const file = publicFile || cleanUrl(id)\n    const content = await fsp.readFile(file)\n    if (shouldInline(environment, file, id, content, undefined, undefined)) {\n      return assetToDataURL(environment, file, content)\n    }\n  }\n\n  let rtn: string\n  if (publicFile) {\n    // in public dir during dev, keep the url as-is\n    rtn = id\n  } else if (id.startsWith(withTrailingSlash(config.root))) {\n    // in project root, infer short public path\n    rtn = '/' + path.posix.relative(config.root, id)\n  } else {\n    // outside of project root, use absolute fs path\n    // (this is special handled by the serve static middleware\n    rtn = path.posix.join(FS_PREFIX, id)\n  }\n  if (skipBase) {\n    return rtn\n  }\n  const base = joinUrlSegments(config.server.origin ?? '', config.decodedBase)\n  return joinUrlSegments(base, removeLeadingSlash(rtn))\n}\n\nexport function getPublicAssetFilename(\n  hash: string,\n  config: ResolvedConfig,\n): string | undefined {\n  return publicAssetUrlCache.get(config)?.get(hash)\n}\n\nexport const publicAssetUrlCache = new WeakMap<\n  ResolvedConfig,\n  // hash -> url\n  Map<string, string>\n>()\n\nexport const publicAssetUrlRE = /__VITE_PUBLIC_ASSET__([a-z\\d]{8})__/g\n\nexport function publicFileToBuiltUrl(\n  url: string,\n  config: ResolvedConfig,\n): string {\n  if (config.command !== 'build') {\n    // We don't need relative base or renderBuiltUrl support during dev\n    return joinUrlSegments(config.decodedBase, url)\n  }\n  const hash = getHash(url)\n  let cache = publicAssetUrlCache.get(config)\n  if (!cache) {\n    cache = new Map<string, string>()\n    publicAssetUrlCache.set(config, cache)\n  }\n  if (!cache.get(hash)) {\n    cache.set(hash, url)\n  }\n  return `__VITE_PUBLIC_ASSET__${hash}__`\n}\n\nconst GIT_LFS_PREFIX = Buffer.from('version https://git-lfs.github.com')\nfunction isGitLfsPlaceholder(content: Buffer): boolean {\n  if (content.length < GIT_LFS_PREFIX.length) return false\n  // Check whether the content begins with the characteristic string of Git LFS placeholders\n  return GIT_LFS_PREFIX.compare(content, 0, GIT_LFS_PREFIX.length) === 0\n}\n\n/**\n * Register an asset to be emitted as part of the bundle (if necessary)\n * and returns the resolved public URL\n */\nasync function fileToBuiltUrl(\n  pluginContext: PluginContext,\n  id: string,\n  skipPublicCheck = false,\n  forceInline?: boolean,\n): Promise<string> {\n  const environment = pluginContext.environment\n  const topLevelConfig = environment.getTopLevelConfig()\n  if (!skipPublicCheck) {\n    const publicFile = checkPublicFile(id, topLevelConfig)\n    if (publicFile) {\n      if (inlineRE.test(id)) {\n        // If inline via query, re-assign the id so it can be read by the fs and inlined\n        id = publicFile\n      } else {\n        return publicFileToBuiltUrl(id, topLevelConfig)\n      }\n    }\n  }\n\n  const cache = assetCache.get(environment)!\n  const cached = cache.get(id)\n  if (cached) {\n    return cached\n  }\n\n  const { file, postfix } = splitFileAndPostfix(id)\n  const content = await fsp.readFile(file)\n\n  let url: string\n  if (\n    shouldInline(environment, file, id, content, pluginContext, forceInline)\n  ) {\n    url = assetToDataURL(environment, file, content)\n  } else {\n    // emit as asset\n    const originalFileName = normalizePath(\n      path.relative(environment.config.root, file),\n    )\n    const referenceId = pluginContext.emitFile({\n      type: 'asset',\n      // Ignore directory structure for asset file names\n      name: path.basename(file),\n      originalFileName,\n      source: content,\n    })\n    url = `__VITE_ASSET__${referenceId}__${postfix ? `$_${postfix}__` : ``}`\n  }\n\n  cache.set(id, url)\n  return url\n}\n\nexport async function urlToBuiltUrl(\n  pluginContext: PluginContext,\n  url: string,\n  importer: string,\n  forceInline?: boolean,\n): Promise<string> {\n  const topLevelConfig = pluginContext.environment.getTopLevelConfig()\n  if (checkPublicFile(url, topLevelConfig)) {\n    return publicFileToBuiltUrl(url, topLevelConfig)\n  }\n  const file =\n    url[0] === '/'\n      ? path.join(topLevelConfig.root, url)\n      : path.join(path.dirname(importer), url)\n  return fileToBuiltUrl(\n    pluginContext,\n    file,\n    // skip public check since we just did it above\n    true,\n    forceInline,\n  )\n}\n\nfunction shouldInline(\n  environment: Environment,\n  file: string,\n  id: string,\n  content: Buffer,\n  /** Should be passed only in build */\n  buildPluginContext: PluginContext | undefined,\n  forceInline: boolean | undefined,\n): boolean {\n  if (noInlineRE.test(id)) return false\n  if (inlineRE.test(id)) return true\n  // Do build only checks if passed the plugin context during build\n  if (buildPluginContext) {\n    if (environment.config.build.lib) return true\n    if (buildPluginContext.getModuleInfo(id)?.isEntry) return false\n  }\n  if (forceInline !== undefined) return forceInline\n  if (file.endsWith('.html')) return false\n  // Don't inline SVG with fragments, as they are meant to be reused\n  if (file.endsWith('.svg') && id.includes('#')) return false\n  let limit: number\n  const { assetsInlineLimit } = environment.config.build\n  if (typeof assetsInlineLimit === 'function') {\n    const userShouldInline = assetsInlineLimit(file, content)\n    if (userShouldInline != null) return userShouldInline\n    limit = DEFAULT_ASSETS_INLINE_LIMIT\n  } else {\n    limit = Number(assetsInlineLimit)\n  }\n  return content.length < limit && !isGitLfsPlaceholder(content)\n}\n\nfunction assetToDataURL(\n  environment: Environment,\n  file: string,\n  content: Buffer,\n) {\n  if (environment.config.build.lib && isGitLfsPlaceholder(content)) {\n    environment.logger.warn(\n      colors.yellow(`Inlined file ${file} was not downloaded via Git LFS`),\n    )\n  }\n\n  if (file.endsWith('.svg')) {\n    return svgToDataURL(content)\n  } else {\n    const mimeType = mrmime.lookup(file) ?? 'application/octet-stream'\n    // base64 inlined as a string\n    return `data:${mimeType};base64,${content.toString('base64')}`\n  }\n}\n\nconst nestedQuotesRE = /\"[^\"']*'[^\"]*\"|'[^'\"]*\"[^']*'/\n\n// Inspired by https://github.com/iconify/iconify/blob/main/packages/utils/src/svg/url.ts\nfunction svgToDataURL(content: Buffer): string {\n  const stringContent = content.toString()\n  // If the SVG contains some text or HTML, any transformation is unsafe, and given that double quotes would then\n  // need to be escaped, the gain to use a data URI would be ridiculous if not negative\n  if (\n    stringContent.includes('<text') ||\n    stringContent.includes('<foreignObject') ||\n    nestedQuotesRE.test(stringContent)\n  ) {\n    return `data:image/svg+xml;base64,${content.toString('base64')}`\n  } else {\n    return (\n      'data:image/svg+xml,' +\n      stringContent\n        .trim()\n        .replaceAll(/>\\s+</g, '><')\n        .replaceAll('\"', \"'\")\n        .replaceAll('%', '%25')\n        .replaceAll('#', '%23')\n        .replaceAll('<', '%3c')\n        .replaceAll('>', '%3e')\n        // Spaces are not valid in srcset it has some use cases\n        // it can make the uncompressed URI slightly higher than base64, but will compress way better\n        // https://github.com/vitejs/vite/pull/14643#issuecomment-1766288673\n        .replaceAll(/\\s+/g, '%20')\n    )\n  }\n}", "output": {"vulnerability_count": 5, "vulnerabilities": [{"description": "The string method replaceAll is not supported in all versions of javascript, and is not supported by older browser versions. Consider using replace() with a regex as the first argument instead like mystring.replace(/bad/g, \"good\") instead of mystring.replaceAll(\"bad\", \"good\") (https://discourse.threejs.org/t/replaceall-is-not-a-function/14585)", "risk": "Medium", "conceptual_fix": "Not provided", "line": 506}, {"description": "The string method replaceAll is not supported in all versions of javascript, and is not supported by older browser versions. Consider using replace() with a regex as the first argument instead like mystring.replace(/bad/g, \"good\") instead of mystring.replaceAll(\"bad\", \"good\") (https://discourse.threejs.org/t/replaceall-is-not-a-function/14585)", "risk": "Medium", "conceptual_fix": "Not provided", "line": 506}, {"description": "The string method replaceAll is not supported in all versions of javascript, and is not supported by older browser versions. Consider using replace() with a regex as the first argument instead like mystring.replace(/bad/g, \"good\") instead of mystring.replaceAll(\"bad\", \"good\") (https://discourse.threejs.org/t/replaceall-is-not-a-function/14585)", "risk": "Medium", "conceptual_fix": "Not provided", "line": 506}, {"description": "The string method replaceAll is not supported in all versions of javascript, and is not supported by older browser versions. Consider using replace() with a regex as the first argument instead like mystring.replace(/bad/g, \"good\") instead of mystring.replaceAll(\"bad\", \"good\") (https://discourse.threejs.org/t/replaceall-is-not-a-function/14585)", "risk": "Medium", "conceptual_fix": "Not provided", "line": 506}, {"description": "The string method replaceAll is not supported in all versions of javascript, and is not supported by older browser versions. Consider using replace() with a regex as the first argument instead like mystring.replace(/bad/g, \"good\") instead of mystring.replaceAll(\"bad\", \"good\") (https://discourse.threejs.org/t/replaceall-is-not-a-function/14585)", "risk": "Medium", "conceptual_fix": "Not provided", "line": 506}]}}
{"CVE": "CVE-2025-32014", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "import { type Temporal as LocalTemporal } from '@js-temporal/polyfill'\nimport {\n  type ArrayExpression,\n  type Expression,\n  type Identifier,\n  type ObjectExpression,\n  type Pattern,\n  type Property,\n  type SimpleLiteral\n} from 'estree'\n\n/**\n * Create an ESTree identifier node for a given name.\n *\n * @param name\n *   The name of the identifier.\n * @returns\n *   The identifier node.\n */\nfunction identifier(name: string): Identifier {\n  return { type: 'Identifier', name }\n}\n\n/**\n * Create an ESTree literal node for a given value.\n *\n * @param value\n *   The value for which to create a literal.\n * @returns\n *   The literal node.\n */\nfunction literal(value: SimpleLiteral['value']): SimpleLiteral {\n  return { type: 'Literal', value }\n}\n\n/**\n * Create an ESTree call expression on an object member.\n *\n * @param object\n *   The object to call the method on.\n * @param name\n *   The name of the method to call.\n * @param args\n *   Arguments to pass to the function call\n * @returns\n *   The call expression node.\n */\nfunction methodCall(object: Expression, name: string, args: Expression[]): Expression {\n  return {\n    type: 'CallExpression',\n    optional: false,\n    callee: {\n      type: 'MemberExpression',\n      computed: false,\n      optional: false,\n      object,\n      property: identifier(name)\n    },\n    arguments: args\n  }\n}\n\n/**\n * Turn a number or bigint into an ESTree expression. This handles positive and negative numbers and\n * bigints as well as special numbers.\n *\n * @param number\n *   The value to turn into an ESTree expression.\n * @returns\n *   An expression that represents the given value.\n */\nfunction processNumber(number: bigint | number): Expression {\n  if (number < 0 || Object.is(number, -0)) {\n    return {\n      type: 'UnaryExpression',\n      operator: '-',\n      prefix: true,\n      argument: processNumber(-number)\n    }\n  }\n\n  if (typeof number === 'bigint') {\n    return { type: 'Literal', bigint: String(number) }\n  }\n\n  if (number === Number.POSITIVE_INFINITY || Number.isNaN(number)) {\n    return identifier(String(number))\n  }\n\n  return literal(number)\n}\n\n/**\n * Process an array of numbers. This is a shortcut for iterables whose constructor takes an array of\n * numbers as input.\n *\n * @param numbers\n *   The numbers to add to the array expression.\n * @returns\n *   An ESTree array expression whose elements match the input numbers.\n */\nfunction processNumberArray(numbers: Iterable<bigint | number>): Expression {\n  const elements: Expression[] = []\n\n  for (const value of numbers) {\n    elements.push(processNumber(value))\n  }\n\n  return { type: 'ArrayExpression', elements }\n}\n\n/**\n * Check whether a value can be constructed from its string representation.\n *\n * @param value\n *   The value to check\n * @returns\n *   Whether or not the value can be constructed from its string representation.\n */\nfunction isStringReconstructable(value: unknown): value is URL | URLSearchParams {\n  return value instanceof URL || value instanceof URLSearchParams\n}\n\n/**\n * Check whether a value can be constructed from its `valueOf()` result.\n *\n * @param value\n *   The value to check\n * @returns\n *   Whether or not the value can be constructed from its `valueOf()` result.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction isValueReconstructable(value: unknown): value is Boolean | Date | Number | String {\n  return (\n    value instanceof Boolean ||\n    value instanceof Date ||\n    value instanceof Number ||\n    value instanceof String\n  )\n}\n\nconst wellKnownSymbols = new Map<symbol, string>()\nfor (const name of Reflect.ownKeys(Symbol) as (keyof typeof Symbol)[]) {\n  const value = Symbol[name]\n  if (typeof value === 'symbol') {\n    wellKnownSymbols.set(value, name)\n  }\n}\n\n/**\n * Check whether a value is a typed array.\n *\n * @param value\n *   The value to check\n * @returns\n *   Whether or not the value is a typed array.\n */\nfunction isTypedArray(\n  value: unknown\n): value is\n  | BigInt64Array\n  | BigUint64Array\n  | Float32Array\n  | Float64Array\n  | Int8Array\n  | Int16Array\n  | Int32Array\n  | Uint8Array\n  | Uint8ClampedArray\n  | Uint16Array\n  | Uint32Array {\n  return (\n    value instanceof BigInt64Array ||\n    value instanceof BigUint64Array ||\n    value instanceof Float32Array ||\n    value instanceof Float64Array ||\n    value instanceof Int8Array ||\n    value instanceof Int16Array ||\n    value instanceof Int32Array ||\n    value instanceof Uint8Array ||\n    value instanceof Uint8ClampedArray ||\n    value instanceof Uint16Array ||\n    value instanceof Uint32Array\n  )\n}\n\ninterface Context {\n  /**\n   * The assignment expression of the variable.\n   */\n  assignment?: Expression\n\n  /**\n   * The number of references to this value.\n   */\n  count: number\n\n  /**\n   * The variable name used to reference the value.\n   */\n  name?: string\n\n  /**\n   * Whether or not this value recursively references itself.\n   */\n  recursive: boolean\n\n  /**\n   * A set of values that reference the value in this context.\n   */\n  referencedBy: Set<unknown>\n\n  /**\n   * The value this context belongs to.\n   */\n  value: unknown\n}\n\n/**\n * Compare two value contexts for sorting them based on reference count.\n *\n * @param a\n *   The first context to compare.\n * @param b\n *   The second context to compare.\n * @returns\n *   The count of context a minus the count of context b.\n */\nfunction compareContexts(a: Context, b: Context): number {\n  const aReferencedByB = a.referencedBy.has(b.value)\n  const bReferencedByA = b.referencedBy.has(a.value)\n\n  if (aReferencedByB) {\n    if (bReferencedByA) {\n      return a.count - b.count\n    }\n    return -1\n  }\n  if (bReferencedByA) {\n    return 1\n  }\n\n  return a.count - b.count\n}\n\nexport interface Options {\n  /**\n   * If true, treat objects that have a prototype as plain objects.\n   *\n   * @default false\n   */\n  instanceAsObject?: boolean\n\n  /**\n   * If true, preserve references to the same object found within the input. This also allows to\n   * serialize recursive structures. If needed, the resulting expression will be an iife.\n   *\n   * @default false\n   */\n  preserveReferences?: boolean\n}\n\n/**\n * Replace the assigned right hand expression with the new expression.\n *\n * If there is no assignment expression, the original expression is returned. Otherwise the\n * assignment is modified and returned,\n *\n * @param expression\n *   The expression to use for the assignment.\n * @param assignment\n *   The existing assignmentexpression\n * @returns\n *   The new expression.\n */\nfunction replaceAssignment(expression: Expression, assignment: Expression | undefined): Expression {\n  if (!assignment || assignment.type !== 'AssignmentExpression') {\n    return expression\n  }\n\n  let node = assignment\n  while (node.right.type === 'AssignmentExpression') {\n    node = node.right\n  }\n  node.right = expression\n  return assignment\n}\n\n/**\n * Create an ESTree epxression to represent a symbol. Global and well-known symbols are supported.\n *\n * @param symbol\n *   THe symbol to represent.\n * @returns\n *   An ESTree expression to represent the symbol.\n */\nfunction symbolToEstree(symbol: symbol): Expression {\n  const name = wellKnownSymbols.get(symbol)\n  if (name) {\n    return {\n      type: 'MemberExpression',\n      computed: false,\n      optional: false,\n      object: identifier('Symbol'),\n      property: identifier(name)\n    }\n  }\n\n  if (symbol.description && symbol === Symbol.for(symbol.description)) {\n    return methodCall(identifier('Symbol'), 'for', [literal(symbol.description)])\n  }\n\n  throw new TypeError(`Only global symbols are supported, got: ${String(symbol)}`, {\n    cause: symbol\n  })\n}\n\n/**\n * Create an ESTree property from a key and a value expression.\n *\n * @param key\n *   The property key value\n * @param value\n *   The property value as an ESTree expression.\n * @returns\n *   The ESTree properry node.\n */\nfunction property(key: string | symbol, value: Expression): Property {\n  const computed = typeof key !== 'string'\n\n  return {\n    type: 'Property',\n    method: false,\n    shorthand: false,\n    computed,\n    kind: 'init',\n    key: computed ? symbolToEstree(key) : literal(key),\n    value\n  }\n}\n\n/**\n * Convert a Temporal value to a constructor call.\n *\n * @param name\n *   The name of the constructor.\n * @param values\n *   The numeric values to pass to the constructor.\n * @param calendar\n *   The calendar name to pass to the constructor.\n * @param defaultReferenceValue\n *   The default reference value of the temporal object.\n * @param referenceValue\n *   The reference value of the temporal object.\n * @returns\n *   An ESTree expression which represents the constructor call.\n */\nfunction temporalConstructor(\n  name: string,\n  values: (bigint | number | string)[],\n  calendar: LocalTemporal.CalendarProtocol | string = 'iso8601',\n  defaultReferenceValue?: number,\n  referenceValue?: number\n): Expression {\n  if (calendar && typeof calendar !== 'string') {\n    throw new Error(`Unsupported calendar: ${calendar}`, { cause: calendar })\n  }\n\n  const args: Expression[] = []\n\n  if (\n    referenceValue != null &&\n    (calendar !== 'iso8601' || referenceValue !== defaultReferenceValue)\n  ) {\n    args.push(literal(referenceValue))\n  }\n\n  if (calendar !== 'iso8601' || args.length !== 0) {\n    args.unshift(literal(calendar))\n  }\n\n  for (let index = values.length - 1; index >= 0; index -= 1) {\n    const value = values[index]\n    if ((value !== 0 && value !== 0n) || args.length !== 0) {\n      args.unshift(typeof value === 'string' ? literal(value) : processNumber(value))\n    }\n  }\n\n  return {\n    type: 'NewExpression',\n    callee: {\n      type: 'MemberExpression',\n      computed: false,\n      optional: false,\n      object: identifier('Temporal'),\n      property: identifier(name)\n    },\n    arguments: args\n  }\n}\n\n/**\n * Convert a value to an ESTree node.\n *\n * @param value\n *   The value to convert.\n * @param options\n *   Additional options to configure the output.\n * @returns\n *   The ESTree node.\n */\nexport function valueToEstree(value: unknown, options: Options = {}): Expression {\n  const stack: unknown[] = []\n  const collectedContexts = new Map<unknown, Context>()\n  const namedContexts: Context[] = []\n\n  /**\n   * Analyze a value and collect all reference contexts.\n   *\n   * @param val\n   *   The value to analyze.\n   */\n  function analyze(val: unknown): undefined {\n    if (typeof val === 'function') {\n      throw new TypeError(`Unsupported value: ${val}`, { cause: val })\n    }\n\n    if (typeof val !== 'object') {\n      return\n    }\n\n    if (val == null) {\n      return\n    }\n\n    const context = collectedContexts.get(val)\n    if (context) {\n      if (options.preserveReferences) {\n        context.count += 1\n      }\n      for (const ancestor of stack) {\n        context.referencedBy.add(ancestor)\n      }\n      if (stack.includes(val)) {\n        if (!options.preserveReferences) {\n          throw new Error(`Found circular reference: ${val}`, { cause: val })\n        }\n        const parent = stack.at(-1)!\n        const parentContext = collectedContexts.get(parent)!\n        parentContext.recursive = true\n        context.recursive = true\n      }\n      return\n    }\n\n    collectedContexts.set(val, {\n      count: 1,\n      recursive: false,\n      referencedBy: new Set(stack),\n      value: val\n    })\n\n    if (isTypedArray(val)) {\n      return\n    }\n\n    if (isStringReconstructable(val)) {\n      return\n    }\n\n    if (isValueReconstructable(val)) {\n      return\n    }\n\n    if (value instanceof RegExp) {\n      return\n    }\n\n    if (\n      typeof Temporal !== 'undefined' &&\n      (value instanceof Temporal.Duration ||\n        value instanceof Temporal.Instant ||\n        value instanceof Temporal.PlainDate ||\n        value instanceof Temporal.PlainDateTime ||\n        value instanceof Temporal.PlainYearMonth ||\n        value instanceof Temporal.PlainMonthDay ||\n        value instanceof Temporal.PlainTime ||\n        value instanceof Temporal.ZonedDateTime)\n    ) {\n      return\n    }\n\n    stack.push(val)\n    if (val instanceof Map) {\n      for (const pair of val) {\n        analyze(pair[0])\n        analyze(pair[1])\n      }\n    } else if (Array.isArray(val) || val instanceof Set) {\n      for (const entry of val) {\n        analyze(entry)\n      }\n    } else {\n      const proto = Object.getPrototypeOf(val)\n      if (proto != null && proto !== Object.prototype && !options.instanceAsObject) {\n        throw new TypeError(`Unsupported value: ${val}`, { cause: val })\n      }\n\n      for (const key of Reflect.ownKeys(val)) {\n        analyze((val as Record<string | symbol, unknown>)[key])\n      }\n    }\n    stack.pop()\n  }\n\n  /**\n   * Recursively generate the ESTree expression needed to reconstruct the value.\n   *\n   * @param val\n   *   The value to process.\n   * @param isDeclaration\n   *   Whether or not this is for a variable declaration.\n   * @returns\n   *   The ESTree expression to reconstruct the value.\n   */\n  function generate(val: unknown, isDeclaration?: boolean): Expression {\n    if (val === undefined) {\n      return identifier(String(val))\n    }\n\n    if (val == null || typeof val === 'string' || typeof val === 'boolean') {\n      return literal(val)\n    }\n\n    if (typeof val === 'bigint' || typeof val === 'number') {\n      return processNumber(val)\n    }\n\n    if (typeof val === 'symbol') {\n      return symbolToEstree(val)\n    }\n\n    const context = collectedContexts.get(val)\n    if (!isDeclaration && context?.name) {\n      return identifier(context.name)\n    }\n\n    if (isValueReconstructable(val)) {\n      return {\n        type: 'NewExpression',\n        callee: identifier(val.constructor.name),\n        arguments: [generate(val.valueOf())]\n      }\n    }\n\n    if (val instanceof RegExp) {\n      return {\n        type: 'Literal',\n        regex: { pattern: val.source, flags: val.flags }\n      }\n    }\n\n    if (typeof Buffer !== 'undefined' && Buffer.isBuffer(val)) {\n      return methodCall(identifier('Buffer'), 'from', [processNumberArray(val)])\n    }\n\n    if (isTypedArray(val)) {\n      return {\n        type: 'NewExpression',\n        callee: identifier(val.constructor.name),\n        arguments: [processNumberArray(val)]\n      }\n    }\n\n    if (isStringReconstructable(val)) {\n      return {\n        type: 'NewExpression',\n        callee: identifier(val.constructor.name),\n        arguments: [literal(String(val))]\n      }\n    }\n\n    if (typeof Temporal !== 'undefined') {\n      if (val instanceof Temporal.Duration) {\n        return temporalConstructor('Duration', [\n          val.years,\n          val.months,\n          val.weeks,\n          val.days,\n          val.hours,\n          val.minutes,\n          val.seconds,\n          val.milliseconds,\n          val.microseconds,\n          val.nanoseconds\n        ])\n      }\n\n      if (val instanceof Temporal.Instant) {\n        return temporalConstructor('Instant', [val.epochNanoseconds])\n      }\n\n      if (val instanceof Temporal.PlainDate) {\n        const iso = val.getISOFields()\n        return temporalConstructor(\n          'PlainDate',\n          [iso.isoYear, iso.isoMonth, iso.isoDay],\n          iso.calendar\n        )\n      }\n\n      if (val instanceof Temporal.PlainDateTime) {\n        const iso = val.getISOFields()\n        return temporalConstructor(\n          'PlainDateTime',\n          [\n            iso.isoYear,\n            iso.isoMonth,\n            iso.isoDay,\n            iso.isoHour,\n            iso.isoMinute,\n            iso.isoSecond,\n            iso.isoMillisecond,\n            iso.isoMicrosecond,\n            iso.isoNanosecond\n          ],\n          iso.calendar\n        )\n      }\n\n      if (val instanceof Temporal.PlainMonthDay) {\n        const iso = val.getISOFields()\n        return temporalConstructor(\n          'PlainMonthDay',\n          [iso.isoMonth, iso.isoDay],\n          iso.calendar,\n          1972,\n          iso.isoYear\n        )\n      }\n\n      if (val instanceof Temporal.PlainTime) {\n        const iso = val.getISOFields()\n        return temporalConstructor('PlainTime', [\n          iso.isoHour,\n          iso.isoMinute,\n          iso.isoSecond,\n          iso.isoMillisecond,\n          iso.isoMicrosecond,\n          iso.isoNanosecond\n        ])\n      }\n\n      if (val instanceof Temporal.PlainYearMonth) {\n        const iso = val.getISOFields()\n        return temporalConstructor(\n          'PlainYearMonth',\n          [iso.isoYear, iso.isoMonth],\n          iso.calendar,\n          1,\n          iso.isoDay\n        )\n      }\n\n      if (val instanceof Temporal.ZonedDateTime) {\n        const iso = val.getISOFields()\n        return temporalConstructor(\n          'ZonedDateTime',\n          [val.epochNanoseconds, val.timeZoneId],\n          iso.calendar\n        )\n      }\n    }\n\n    if (Array.isArray(val)) {\n      const elements: (Expression | null)[] = Array.from({ length: val.length })\n      let trimmable: number | undefined\n\n      for (let index = 0; index < val.length; index += 1) {\n        if (!(index in val)) {\n          elements[index] = null\n          trimmable = undefined\n          continue\n        }\n\n        const child = val[index]\n        const childContext = collectedContexts.get(child)\n        if (\n          context &&\n          childContext &&\n          namedContexts.indexOf(childContext) >= namedContexts.indexOf(context)\n        ) {\n          elements[index] = null\n          trimmable ||= index\n          childContext.assignment = {\n            type: 'AssignmentExpression',\n            operator: '=',\n            left: {\n              type: 'MemberExpression',\n              computed: true,\n              optional: false,\n              object: identifier(context.name!),\n              property: literal(index)\n            },\n            right: childContext.assignment || identifier(childContext.name!)\n          }\n        } else {\n          elements[index] = generate(child)\n          trimmable = undefined\n        }\n      }\n\n      if (trimmable != null) {\n        elements.splice(trimmable)\n      }\n\n      return {\n        type: 'ArrayExpression',\n        elements\n      }\n    }\n\n    if (val instanceof Set) {\n      const elements: Expression[] = []\n      let finalizer: Expression | undefined\n\n      for (const child of val) {\n        if (finalizer) {\n          finalizer = methodCall(finalizer, 'add', [generate(child)])\n        } else {\n          const childContext = collectedContexts.get(child)\n          if (\n            context &&\n            childContext &&\n            namedContexts.indexOf(childContext) >= namedContexts.indexOf(context)\n          ) {\n            finalizer = methodCall(identifier(context.name!), 'add', [generate(child)])\n          } else {\n            elements.push(generate(child))\n          }\n        }\n      }\n\n      if (context && finalizer) {\n        context.assignment = replaceAssignment(finalizer, context.assignment)\n      }\n\n      return {\n        type: 'NewExpression',\n        callee: identifier('Set'),\n        arguments: elements.length ? [{ type: 'ArrayExpression', elements }] : []\n      }\n    }\n\n    if (val instanceof Map) {\n      const elements: ArrayExpression[] = []\n      let finalizer: Expression | undefined\n\n      for (const [key, item] of val) {\n        if (finalizer) {\n          finalizer = methodCall(finalizer, 'set', [generate(key), generate(item)])\n        } else {\n          const keyContext = collectedContexts.get(key)\n          const itemContext = collectedContexts.get(item)\n\n          if (\n            context &&\n            ((keyContext && namedContexts.indexOf(keyContext) >= namedContexts.indexOf(context)) ||\n              (itemContext && namedContexts.indexOf(itemContext) >= namedContexts.indexOf(context)))\n          ) {\n            finalizer = methodCall(identifier(context.name!), 'set', [\n              generate(key),\n              generate(item)\n            ])\n          } else {\n            elements.push({\n              type: 'ArrayExpression',\n              elements: [generate(key), generate(item)]\n            })\n          }\n        }\n      }\n\n      if (context && finalizer) {\n        context.assignment = replaceAssignment(finalizer, context.assignment)\n      }\n\n      return {\n        type: 'NewExpression',\n        callee: identifier('Map'),\n        arguments: elements.length ? [{ type: 'ArrayExpression', elements }] : []\n      }\n    }\n\n    const properties: Property[] = []\n    if (Object.getPrototypeOf(val) == null) {\n      properties.push(property('__proto__', literal(null)))\n    }\n\n    const object = val as Record<string | symbol, unknown>\n    const propertyDescriptors: Property[] = []\n    for (const key of Reflect.ownKeys(val)) {\n      // TODO [>=4] Throw an error for getters.\n      const child = object[key]\n      const { configurable, enumerable, writable } = Object.getOwnPropertyDescriptor(val, key)!\n      const childContext = collectedContexts.get(child)\n      if (!configurable || !enumerable || !writable) {\n        const propertyDescriptor = [property('value', generate(child))]\n        if (configurable) {\n          propertyDescriptor.push(property('configurable', literal(true)))\n        }\n        if (enumerable) {\n          propertyDescriptor.push(property('enumerable', literal(true)))\n        }\n        if (writable) {\n          propertyDescriptor.push(property('writable', literal(true)))\n        }\n        propertyDescriptors.push(\n          property(key, {\n            type: 'ObjectExpression',\n            properties: propertyDescriptor\n          })\n        )\n      } else if (\n        context &&\n        childContext &&\n        namedContexts.indexOf(childContext) >= namedContexts.indexOf(context)\n      ) {\n        childContext.assignment = {\n          type: 'AssignmentExpression',\n          operator: '=',\n          left: {\n            type: 'MemberExpression',\n            computed: true,\n            optional: false,\n            object: identifier(context.name!),\n            property: generate(key)\n          },\n          right: childContext.assignment || generate(child)\n        }\n      } else {\n        properties.push(property(key, generate(child)))\n      }\n    }\n\n    const objectExpression: ObjectExpression = {\n      type: 'ObjectExpression',\n      properties\n    }\n\n    if (propertyDescriptors.length) {\n      if (!context) {\n        return methodCall(identifier('Object'), 'defineProperties', [\n          objectExpression,\n          {\n            type: 'ObjectExpression',\n            properties: propertyDescriptors\n          }\n        ])\n      }\n\n      context.assignment = replaceAssignment(\n        methodCall(identifier('Object'), 'defineProperties', [\n          identifier(context.name!),\n          {\n            type: 'ObjectExpression',\n            properties: propertyDescriptors\n          }\n        ]),\n        context.assignment\n      )\n    }\n\n    return objectExpression\n  }\n\n  analyze(value)\n\n  for (const [val, context] of collectedContexts) {\n    if (context.recursive || context.count > 1) {\n      // Assign reused or recursive references to a variable.\n      context.name = `$${namedContexts.length}`\n      namedContexts.push(context)\n    } else {\n      // Otherwise dont treat it as a reference.\n      collectedContexts.delete(val)\n    }\n  }\n\n  if (!namedContexts.length) {\n    return generate(value)\n  }\n\n  const params = namedContexts.sort(compareContexts).map<Pattern>((context) => ({\n    type: 'AssignmentPattern',\n    left: identifier(context.name!),\n    right: generate(context.value, true)\n  }))\n\n  const rootContext = collectedContexts.get(value)\n  const finalizers: Expression[] = []\n  for (const context of collectedContexts.values()) {\n    if (context !== rootContext && context.assignment) {\n      finalizers.push(context.assignment)\n    }\n  }\n  finalizers.push(\n    rootContext ? rootContext.assignment || identifier(rootContext.name!) : generate(value)\n  )\n\n  return {\n    type: 'CallExpression',\n    optional: false,\n    arguments: [],\n    callee: {\n      type: 'ArrowFunctionExpression',\n      expression: false,\n      params,\n      body: {\n        type: 'SequenceExpression',\n        expressions: finalizers\n      }\n    }\n  }\n}", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2025-32379", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "'use strict'\n\n/**\n * Module dependencies.\n */\n\nconst contentDisposition = require('content-disposition')\nconst getType = require('cache-content-type')\nconst onFinish = require('on-finished')\nconst escape = require('escape-html')\nconst typeis = require('type-is').is\nconst statuses = require('statuses')\nconst destroy = require('destroy')\nconst assert = require('assert')\nconst extname = require('path').extname\nconst vary = require('vary')\nconst isStream = require('./is-stream.js')\nconst only = require('./only.js')\nconst util = require('util')\nconst encodeUrl = require('encodeurl')\nconst deprecate = require('depd')('koa')\n\n/**\n * Prototype.\n */\n\nmodule.exports = {\n\n  /**\n   * Return the request socket.\n   *\n   * @return {Connection}\n   * @api public\n   */\n\n  get socket () {\n    return this.res.socket\n  },\n\n  /**\n   * Return response header.\n   *\n   * @return {Object}\n   * @api public\n   */\n\n  get header () {\n    const { res } = this\n    return typeof res.getHeaders === 'function'\n      ? res.getHeaders()\n      : res._headers || {} // Node < 7.7\n  },\n\n  /**\n   * Return response header, alias as response.header\n   *\n   * @return {Object}\n   * @api public\n   */\n\n  get headers () {\n    return this.header\n  },\n\n  /**\n   * Get response status code.\n   *\n   * @return {Number}\n   * @api public\n   */\n\n  get status () {\n    return this.res.statusCode\n  },\n\n  /**\n   * Set response status code.\n   *\n   * @param {Number} code\n   * @api public\n   */\n\n  set status (code) {\n    if (this.headerSent) return\n\n    assert(Number.isInteger(code), 'status code must be a number')\n    assert(code >= 100 && code <= 999, `invalid status code: ${code}`)\n    this._explicitStatus = true\n    this.res.statusCode = code\n    if (this.req.httpVersionMajor < 2) this.res.statusMessage = statuses.message[code]\n    if (this.body && statuses.empty[code]) this.body = null\n  },\n\n  /**\n   * Get response status message\n   *\n   * @return {String}\n   * @api public\n   */\n\n  get message () {\n    return this.res.statusMessage || statuses.message[this.status]\n  },\n\n  /**\n   * Set response status message\n   *\n   * @param {String} msg\n   * @api public\n   */\n\n  set message (msg) {\n    this.res.statusMessage = msg\n  },\n\n  /**\n   * Get response body.\n   *\n   * @return {Mixed}\n   * @api public\n   */\n\n  get body () {\n    return this._body\n  },\n\n  /**\n   * Set response body.\n   *\n   * @param {String|Buffer|Object|Stream|ReadableStream|Blob|Response} val\n   * @api public\n   */\n\n  set body (val) {\n    const original = this._body\n    this._body = val\n    // no content\n\n    if (val == null) {\n      if (!statuses.empty[this.status]) {\n        if (this.type === 'application/json') {\n          this._body = 'null'\n          return\n        }\n        this.status = 204\n      }\n      if (val === null) this._explicitNullBody = true\n      this.remove('Content-Type')\n      this.remove('Content-Length')\n      this.remove('Transfer-Encoding')\n      return\n    }\n\n    // set the status\n    if (!this._explicitStatus) this.status = 200\n\n    // set the content-type only if not yet set\n    const setType = !this.has('Content-Type')\n\n    // string\n    if (typeof val === 'string') {\n      if (setType) this.type = /^\\s*</.test(val) ? 'html' : 'text'\n      this.length = Buffer.byteLength(val)\n      return\n    }\n\n    // buffer\n    if (Buffer.isBuffer(val)) {\n      if (setType) this.type = 'bin'\n      this.length = val.length\n      return\n    }\n\n    // stream\n    if (isStream(val)) {\n      onFinish(this.res, destroy.bind(null, val))\n      if (original !== val) {\n        val.once('error', err => this.ctx.onerror(err))\n        // overwriting\n        if (original != null) this.remove('Content-Length')\n      }\n\n      if (setType) this.type = 'bin'\n      return\n    }\n\n    // ReadableStream\n    if (val instanceof ReadableStream) {\n      if (setType) this.type = 'bin'\n      return\n    }\n\n    // blob\n    if (val instanceof Blob) {\n      if (setType) this.type = 'bin'\n      this.length = val.size\n      return\n    }\n\n    // Response\n    if (val instanceof Response) {\n      this.status = val.status\n      if (setType) this.type = 'bin'\n      const headers = val.headers\n      for (const key of headers.keys()) {\n        this.set(key, headers.get(key))\n      }\n\n      return\n    }\n\n    // json\n    this.remove('Content-Length')\n    if (!this.type || !/\\bjson\\b/i.test(this.type)) this.type = 'json'\n  },\n\n  /**\n   * Set Content-Length field to `n`.\n   *\n   * @param {Number} n\n   * @api public\n   */\n\n  set length (n) {\n    if (!this.has('Transfer-Encoding')) {\n      this.set('Content-Length', n)\n    }\n  },\n\n  /**\n   * Return parsed response Content-Length when present.\n   *\n   * @return {Number}\n   * @api public\n   */\n\n  get length () {\n    if (this.has('Content-Length')) {\n      return parseInt(this.get('Content-Length'), 10) || 0\n    }\n\n    const { body } = this\n    if (!body || isStream(body)) return undefined\n    if (typeof body === 'string') return Buffer.byteLength(body)\n    if (Buffer.isBuffer(body)) return body.length\n    return Buffer.byteLength(JSON.stringify(body))\n  },\n\n  /**\n   * Check if a header has been written to the socket.\n   *\n   * @return {Boolean}\n   * @api public\n   */\n\n  get headerSent () {\n    return this.res.headersSent\n  },\n\n  /**\n   * Vary on `field`.\n   *\n   * @param {String|String[]} field\n   * @api public\n   */\n\n  vary (field) {\n    if (this.headerSent) return\n\n    vary(this.res, field)\n  },\n\n  /**\n   * Perform a 302 redirect to `url`.\n   *\n   * The string \"back\" is special-cased\n   * to provide Referrer support, when Referrer\n   * is not present `alt` or \"/\" is used.\n   *\n   * Examples:\n   *\n   *    this.redirect('back');\n   *    this.redirect('back', '/index.html');\n   *    this.redirect('/login');\n   *    this.redirect('http://google.com');\n   *\n   * @param {String} url\n   * @param {String} [alt]\n   * @api public\n   */\n\n  redirect (url, alt) {\n    // location\n    if (url === 'back') {\n      deprecate('Special-cased string \"back\" through redirect will be removed in v3, ' +\n        'consider migrating usage to ctx.back() instead.')\n      url = this.ctx.get('Referrer') || alt || '/'\n    }\n    if (/^https?:\\/\\//i.test(url)) {\n      // formatting url again avoid security escapes\n      url = new URL(url).toString()\n    }\n    this.set('Location', encodeUrl(url))\n\n    // status\n    if (!statuses.redirect[this.status]) this.status = 302\n\n    // html\n    if (this.ctx.accepts('html')) {\n      url = escape(url)\n      this.type = 'text/html; charset=utf-8'\n      this.body = `Redirecting to <a href=\"${url}\">${url}</a>.`\n      return\n    }\n\n    // text\n    this.type = 'text/plain; charset=utf-8'\n    this.body = `Redirecting to ${url}.`\n  },\n\n  /**\n   * Perform a special-cased \"back\" to provide Referrer support.\n   * When Referrer is not present, `alt` or \"/\" is used.\n   *\n   * Examples:\n   *\n   *    ctx.back()\n   *    ctx.back('/index.html')\n   *\n   * @param {String} [alt]\n   * @api public\n   */\n\n  back (alt) {\n    const url = this.ctx.get('Referrer') || alt || '/'\n    this.redirect(url)\n  },\n\n  /**\n   * Set Content-Disposition header to \"attachment\" with optional `filename`.\n   *\n   * @param {String} [filename]\n   * @param {object} [options]\n   * @param {string} [options.type=attachment]\n   * @param {string|boolean} [options.fallback=true]\n   * @api public\n   */\n\n  attachment (filename, options) {\n    if (filename) this.type = extname(filename)\n    this.set('Content-Disposition', contentDisposition(filename, options))\n  },\n\n  /**\n   * Set Content-Type response header with `type` through `mime.lookup()`\n   * when it does not contain a charset.\n   *\n   * Examples:\n   *\n   *     this.type = '.html';\n   *     this.type = 'html';\n   *     this.type = 'json';\n   *     this.type = 'application/json';\n   *     this.type = 'png';\n   *\n   * @param {String} type\n   * @api public\n   */\n\n  set type (type) {\n    type = getType(type)\n    if (type) {\n      this.set('Content-Type', type)\n    } else {\n      this.remove('Content-Type')\n    }\n  },\n\n  /**\n   * Set the Last-Modified date using a string or a Date.\n   *\n   *     this.response.lastModified = new Date();\n   *     this.response.lastModified = '2013-09-13';\n   *\n   * @param {String|Date} val\n   * @api public\n   */\n\n  set lastModified (val) {\n    if (typeof val === 'string') val = new Date(val)\n    this.set('Last-Modified', val.toUTCString())\n  },\n\n  /**\n   * Get the Last-Modified date in Date form, if it exists.\n   *\n   * @return {Date}\n   * @api public\n   */\n\n  get lastModified () {\n    const date = this.get('last-modified')\n    if (date) return new Date(date)\n  },\n\n  /**\n   * Set the ETag of a response.\n   * This will normalize the quotes if necessary.\n   *\n   *     this.response.etag = 'md5hashsum';\n   *     this.response.etag = '\"md5hashsum\"';\n   *     this.response.etag = 'W/\"123456789\"';\n   *\n   * @param {String} val\n   * @api public\n   */\n\n  set etag (val) {\n    if (!/^(W\\/)?\"/.test(val)) val = `\"${val}\"`\n    this.set('ETag', val)\n  },\n\n  /**\n   * Get the ETag of a response.\n   *\n   * @return {String}\n   * @api public\n   */\n\n  get etag () {\n    return this.get('ETag')\n  },\n\n  /**\n   * Return the response mime type void of\n   * parameters such as \"charset\".\n   *\n   * @return {String}\n   * @api public\n   */\n\n  get type () {\n    const type = this.get('Content-Type')\n    if (!type) return ''\n    return type.split(';', 1)[0]\n  },\n\n  /**\n   * Check whether the response is one of the listed types.\n   * Pretty much the same as `this.request.is()`.\n   *\n   * @param {String|String[]} [type]\n   * @param {String[]} [types]\n   * @return {String|false}\n   * @api public\n   */\n\n  is (type, ...types) {\n    return typeis(this.type, type, ...types)\n  },\n\n  /**\n   * Return response header.\n   *\n   * Examples:\n   *\n   *     this.get('Content-Type');\n   *     // => \"text/plain\"\n   *\n   *     this.get('content-type');\n   *     // => \"text/plain\"\n   *\n   * @param {String} field\n   * @return {any}\n   * @api public\n   */\n\n  get (field) {\n    return this.res.getHeader(field)\n  },\n\n  /**\n   * Returns true if the header identified by name is currently set in the outgoing headers.\n   * The header name matching is case-insensitive.\n   *\n   * Examples:\n   *\n   *     this.has('Content-Type');\n   *     // => true\n   *\n   *     this.get('content-type');\n   *     // => true\n   *\n   * @param {String} field\n   * @return {boolean}\n   * @api public\n   */\n\n  has (field) {\n    return typeof this.res.hasHeader === 'function'\n      ? this.res.hasHeader(field)\n      // Node < 7.7\n      : field.toLowerCase() in this.headers\n  },\n\n  /**\n   * Set header `field` to `val` or pass\n   * an object of header fields.\n   *\n   * Examples:\n   *\n   *    this.set('Foo', ['bar', 'baz']);\n   *    this.set('Accept', 'application/json');\n   *    this.set({ Accept: 'text/plain', 'X-API-Key': 'tobi' });\n   *\n   * @param {String|{ [k: string]: any }} field\n   * @param {any} [val]\n   * @api public\n   */\n\n  set (field, val) {\n    if (this.headerSent || !field) return\n\n    if (typeof field === 'string') {\n      this.res.setHeader(field, val)\n    } else {\n      Object.keys(field).forEach(header => this.res.setHeader(header, field[header]))\n    }\n  },\n\n  /**\n   * Append additional header `field` with value `val`.\n   *\n   * Examples:\n   *\n   * ```\n   * this.append('Link', ['<http://localhost/>', '<http://localhost:3000/>']);\n   * this.append('Set-Cookie', 'foo=bar; Path=/; HttpOnly');\n   * this.append('Warning', '199 Miscellaneous warning');\n   * ```\n   *\n   * @param {String} field\n   * @param {*} val\n   * @api public\n   */\n\n  append (field, val) {\n    const prev = this.get(field)\n\n    if (prev) {\n      val = Array.isArray(prev)\n        ? prev.concat(val)\n        : [prev].concat(val)\n    }\n\n    return this.set(field, val)\n  },\n\n  /**\n   * Remove header `field`.\n   *\n   * @param {String} field\n   * @api public\n   */\n\n  remove (field) {\n    if (this.headerSent) return\n\n    this.res.removeHeader(field)\n  },\n\n  /**\n   * Checks if the request is writable.\n   * Tests for the existence of the socket\n   * as node sometimes does not set it.\n   *\n   * @return {Boolean}\n   * @api private\n   */\n\n  get writable () {\n    // can't write any more after response finished\n    // response.writableEnded is available since Node > 12.9\n    // https://nodejs.org/api/http.html#http_response_writableended\n    // response.finished is undocumented feature of previous Node versions\n    // https://stackoverflow.com/questions/16254385/undocumented-response-finished-in-node-js\n    if (this.res.writableEnded || this.res.finished) return false\n\n    const socket = this.res.socket\n    // There are already pending outgoing res, but still writable\n    // https://github.com/nodejs/node/blob/v4.4.7/lib/_http_server.js#L486\n    if (!socket) return true\n    return socket.writable\n  },\n\n  /**\n   * Inspect implementation.\n   *\n   * @return {Object}\n   * @api public\n   */\n\n  inspect () {\n    if (!this.res) return\n    const o = this.toJSON()\n    o.body = this.body\n    return o\n  },\n\n  /**\n   * Return JSON representation.\n   *\n   * @return {Object}\n   * @api public\n   */\n\n  toJSON () {\n    return only(this, [\n      'status',\n      'message',\n      'header'\n    ])\n  },\n\n  /**\n   * Flush any set headers and begin the body\n   */\n\n  flushHeaders () {\n    this.res.flushHeaders()\n  }\n}\n\n/**\n * Custom inspection implementation for node 6+.\n *\n * @return {Object}\n * @api public\n */\n\n/* istanbul ignore else */\nif (util.inspect.custom) {\n  module.exports[util.inspect.custom] = module.exports.inspect\n}", "output": {"vulnerability_count": 1, "vulnerabilities": [{"description": "This template literal looks like HTML and has interpolated variables. These variables are not HTML-encoded by default. If the variables contain HTML tags, these may be interpreted by the browser, resulting in cross-site scripting (XSS).", "risk": "Medium", "conceptual_fix": "Not provided", "line": 312}]}}
{"CVE": "CVE-2025-4318", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "/*\n  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n */\nimport {\n  BoundStudioComponentProperty,\n  CollectionStudioComponentProperty,\n  ConcatenatedStudioComponentProperty,\n  ConditionalStudioComponentProperty,\n  FixedStudioComponentProperty,\n  StateStudioComponentProperty,\n  isAuthProperty,\n  RelationalOperator,\n  StudioComponent,\n  StudioComponentAuthProperty,\n  StudioComponentChild,\n  StudioComponentProperty,\n  StudioComponentEvent,\n  BoundStudioComponentEvent,\n  ActionStudioComponentEvent,\n  MutationActionSetStateParameter,\n  ComponentMetadata,\n  StudioComponentProperties,\n} from '@aws-amplify/codegen-ui';\n\nimport {\n  Expression,\n  factory,\n  JsxAttribute,\n  TemplateSpan,\n  StringLiteral,\n  SyntaxKind,\n  JsxExpression,\n  BinaryOperatorToken,\n  JsxChild,\n  PrimaryExpression,\n  ObjectLiteralExpression,\n  NumericLiteral,\n  BooleanLiteral,\n  NullLiteral,\n  ArrayLiteralExpression,\n} from 'typescript';\n\nimport {\n  DataFieldDataType,\n  FormMetadata,\n  FormStyleConfig,\n  GenericDataField,\n  StudioFormInputFieldProperty,\n} from '@aws-amplify/codegen-ui/lib/types';\nimport { ImportCollection } from './imports';\nimport { json, jsonToLiteral } from './react-studio-template-renderer-helper';\nimport { getChildPropMappingForComponentName } from './workflow/utils';\nimport nameReplacements from './name-replacements';\nimport keywords from './keywords';\nimport { buildAccessChain } from './forms/form-renderer-helper/form-state';\n\nexport function getFixedComponentPropValueExpression(prop: FixedStudioComponentProperty): StringLiteral {\n  return factory.createStringLiteral(prop.value.toString(), true);\n}\n\nexport function getComponentPropName(componentName?: string): string {\n  if (componentName !== undefined) {\n    return `${componentName}Props`;\n  }\n  return 'ComponentWithoutNameProps';\n}\n\nexport function isFixedPropertyWithValue(\n  prop: StudioComponentProperty | StudioFormInputFieldProperty,\n): prop is FixedStudioComponentProperty {\n  return typeof prop === 'object' && 'value' in prop;\n}\n\nexport function isBoundProperty(prop: StudioComponentProperty): prop is BoundStudioComponentProperty {\n  return typeof prop === 'object' && 'bindingProperties' in prop;\n}\n\nexport function isCollectionItemBoundProperty(\n  prop: StudioComponentProperty,\n): prop is CollectionStudioComponentProperty {\n  return typeof prop === 'object' && 'collectionBindingProperties' in prop;\n}\n\nexport function isConcatenatedProperty(prop: StudioComponentProperty): prop is ConcatenatedStudioComponentProperty {\n  return typeof prop === 'object' && 'concat' in prop;\n}\n\nexport function isConditionalProperty(prop: StudioComponentProperty): prop is ConditionalStudioComponentProperty {\n  return typeof prop === 'object' && 'condition' in prop;\n}\n\nexport function isStateProperty(property: StudioComponentProperty): property is StateStudioComponentProperty {\n  return typeof property === 'object' && 'componentName' in property && 'property' in property;\n}\n\nexport function isSetStateParameter(parameter: StudioComponentProperty): parameter is MutationActionSetStateParameter {\n  return typeof parameter === 'object' && 'componentName' in parameter && 'property' in parameter && 'set' in parameter;\n}\n\nexport function isDefaultValueOnly(\n  prop: StudioComponentProperty,\n): prop is CollectionStudioComponentProperty | BoundStudioComponentProperty {\n  return (\n    typeof prop === 'object' &&\n    'defaultValue' in prop &&\n    !(isCollectionItemBoundProperty(prop) || isBoundProperty(prop))\n  );\n}\n\nexport function isBoundEvent(event: StudioComponentEvent): event is BoundStudioComponentEvent {\n  return typeof event === 'object' && 'bindingEvent' in event;\n}\n\nexport function isActionEvent(event: StudioComponentEvent): event is ActionStudioComponentEvent {\n  return typeof event === 'object' && 'action' in event;\n}\n\n/**\n * case: has field => <prop.bindingProperties.property>?.<prop.bindingProperties.field>\n * case: no field =>  <prop.bindingProperties.property>\n */\nexport function buildBindingExpression(prop: BoundStudioComponentProperty): Expression {\n  const {\n    bindingProperties: { property },\n  } = prop;\n  const identifier = factory.createIdentifier(keywords.has(property) ? `${property}Prop` : property);\n  return prop.bindingProperties.field === undefined\n    ? identifier\n    : factory.createPropertyAccessChain(\n        identifier,\n        factory.createToken(SyntaxKind.QuestionDotToken),\n        prop.bindingProperties.field,\n      );\n}\n\nexport function buildBindingAttr(prop: BoundStudioComponentProperty, propName: string): JsxAttribute {\n  const expr = buildBindingExpression(prop);\n  return factory.createJsxAttribute(factory.createIdentifier(propName), factory.createJsxExpression(undefined, expr));\n}\n\nfunction buildAuthExpression(prop: StudioComponentAuthProperty): Expression {\n  return factory.createElementAccessExpression(\n    factory.createIdentifier('authAttributes'),\n    factory.createStringLiteral(prop.userAttribute),\n  );\n}\n\nexport function buildUserAuthAttr(prop: StudioComponentAuthProperty, propName: string): JsxAttribute {\n  return factory.createJsxAttribute(\n    factory.createIdentifier(propName),\n    factory.createJsxExpression(undefined, buildAuthExpression(prop)),\n  );\n}\n\nexport function buildBindingWithDefaultExpression(\n  prop: BoundStudioComponentProperty,\n  defaultValue: string,\n): Expression {\n  const rightExpr = factory.createStringLiteral(defaultValue);\n  const leftExpr =\n    prop.bindingProperties.field === undefined\n      ? factory.createIdentifier(prop.bindingProperties.property)\n      : factory.createPropertyAccessChain(\n          factory.createIdentifier(prop.bindingProperties.property),\n          factory.createToken(SyntaxKind.QuestionDotToken),\n          prop.bindingProperties.field,\n        );\n\n  return factory.createBinaryExpression(leftExpr, factory.createToken(SyntaxKind.BarBarToken), rightExpr);\n}\n\nexport function buildBindingAttrWithDefault(\n  prop: BoundStudioComponentProperty,\n  propName: string,\n  defaultValue: string,\n): JsxAttribute {\n  const binaryExpr = buildBindingWithDefaultExpression(prop, defaultValue);\n  return factory.createJsxAttribute(\n    factory.createIdentifier(propName),\n    factory.createJsxExpression(undefined, binaryExpr),\n  );\n}\n\nexport function buildFixedLiteralExpression(\n  prop: FixedStudioComponentProperty,\n): ObjectLiteralExpression | StringLiteral | NumericLiteral | BooleanLiteral | NullLiteral | ArrayLiteralExpression {\n  const { value, type } = prop;\n  switch (typeof value) {\n    case 'number':\n      return factory.createNumericLiteral(value, undefined);\n    case 'boolean':\n      return value ? factory.createTrue() : factory.createFalse();\n    case 'string':\n      return fixedPropertyWithTypeToLiteral(value, type);\n    case 'object':\n      if (value instanceof Date) {\n        throw new Error('Date object is not currently supported for fixed literal expression.');\n      }\n      return jsonToLiteral(value as json);\n    default:\n      throw new Error(`Invalid type ${typeof value} for \"${value}\"`);\n  }\n}\n\nexport function buildFixedJsxExpression(prop: FixedStudioComponentProperty): StringLiteral | JsxExpression {\n  const expression = buildFixedLiteralExpression(prop);\n\n  // do not wrap strings with brackets\n  if (expression.kind === SyntaxKind.StringLiteral) {\n    return expression;\n  }\n  return factory.createJsxExpression(undefined, buildFixedLiteralExpression(prop));\n}\n\nfunction fixedPropertyWithTypeToLiteral(strValue: string, type?: string) {\n  switch (type) {\n    case undefined:\n    case 'String':\n    case 'string':\n      return factory.createStringLiteral(strValue);\n    default:\n      try {\n        const parsedValue = JSON.parse(strValue);\n        if (type && typeof parsedValue !== type.toLowerCase()) {\n          throw new Error(`Parsed value type \"${typeof parsedValue}\" and specified type \"${type}\" mismatch`);\n        }\n\n        switch (typeof parsedValue) {\n          case 'number':\n            return factory.createNumericLiteral(parsedValue, undefined);\n          case 'boolean':\n            return parsedValue ? factory.createTrue() : factory.createFalse();\n          // object, array, and null\n          default:\n            return jsonToLiteral(parsedValue);\n        }\n      } catch (e) {\n        if (e instanceof SyntaxError) {\n          throw new Error(`Failed to parse value \"${strValue}\"`);\n        } else {\n          throw e;\n        }\n      }\n  }\n}\n\nexport function buildFixedAttr(prop: FixedStudioComponentProperty, propName: string): JsxAttribute {\n  const expr = buildFixedJsxExpression(prop);\n  return factory.createJsxAttribute(factory.createIdentifier(propName), expr);\n}\n\nexport function buildCollectionBindingExpression(prop: CollectionStudioComponentProperty): Expression {\n  return prop.collectionBindingProperties.field === undefined\n    ? factory.createIdentifier('item')\n    : factory.createPropertyAccessExpression(factory.createIdentifier('item'), prop.collectionBindingProperties.field);\n}\n\nexport function buildCollectionBindingAttr(prop: CollectionStudioComponentProperty, propName: string): JsxAttribute {\n  const expr = buildCollectionBindingExpression(prop);\n  const attr = factory.createJsxAttribute(\n    factory.createIdentifier(propName),\n    factory.createJsxExpression(undefined, expr),\n  );\n  return attr;\n}\n\nexport function buildCollectionBindingWithDefaultExpression(\n  prop: CollectionStudioComponentProperty,\n  defaultValue: string,\n): Expression {\n  const rightExpr = factory.createStringLiteral(defaultValue);\n  const leftExpr =\n    prop.collectionBindingProperties.field === undefined\n      ? factory.createIdentifier('item')\n      : factory.createPropertyAccessExpression(\n          factory.createIdentifier('item'),\n          prop.collectionBindingProperties.field,\n        );\n\n  return factory.createBinaryExpression(leftExpr, factory.createToken(SyntaxKind.BarBarToken), rightExpr);\n}\n\nexport function buildCollectionBindingAttrWithDefault(\n  prop: CollectionStudioComponentProperty,\n  propName: string,\n  defaultValue: string,\n): JsxAttribute {\n  const binaryExpr = buildCollectionBindingWithDefaultExpression(prop, defaultValue);\n  const attr = factory.createJsxAttribute(\n    factory.createIdentifier(propName),\n    factory.createJsxExpression(undefined, binaryExpr),\n  );\n  return attr;\n}\n\nexport function buildConcatExpression(prop: ConcatenatedStudioComponentProperty): Expression {\n  const expressions: Expression[] = [];\n  prop.concat.forEach((propItem) => {\n    if (isFixedPropertyWithValue(propItem)) {\n      expressions.push(buildFixedJsxExpression(propItem));\n    } else if (isBoundProperty(propItem)) {\n      const expr =\n        propItem.defaultValue === undefined\n          ? buildBindingExpression(propItem)\n          : buildBindingWithDefaultExpression(propItem, propItem.defaultValue);\n      expressions.push(expr);\n    } else if (isAuthProperty(propItem)) {\n      expressions.push(buildAuthExpression(propItem));\n    } else if (isCollectionItemBoundProperty(propItem)) {\n      const expr =\n        propItem.defaultValue === undefined\n          ? buildCollectionBindingExpression(propItem)\n          : buildCollectionBindingWithDefaultExpression(propItem, propItem.defaultValue);\n      expressions.push(expr);\n    } else if (isConcatenatedProperty(propItem)) {\n      expressions.push(buildConcatExpression(propItem));\n    }\n  });\n  const templateSpans: TemplateSpan[] = [];\n  expressions.forEach((expr, index) => {\n    const span =\n      index === expressions.length - 1\n        ? factory.createTemplateSpan(expr, factory.createTemplateTail('', ''))\n        : factory.createTemplateSpan(expr, factory.createTemplateMiddle('', ''));\n    templateSpans.push(span);\n  });\n  return factory.createTemplateExpression(factory.createTemplateHead('', ''), templateSpans);\n}\n\nexport function buildConcatAttr(prop: ConcatenatedStudioComponentProperty, propName: string): JsxAttribute {\n  const expr = buildConcatExpression(prop);\n  return factory.createJsxAttribute(factory.createIdentifier(propName), factory.createJsxExpression(undefined, expr));\n}\n\nexport function buildStateExpression(\n  componentMetadata: ComponentMetadata,\n  { componentName, property }: StateStudioComponentProperty,\n): Expression {\n  const childrenPropMapping = getChildPropMappingForComponentName(componentMetadata, componentName);\n  const mappedSyntheticProperty = property === childrenPropMapping ? 'children' : property;\n  return factory.createIdentifier(getStateName({ componentName, property: mappedSyntheticProperty }));\n}\n\nexport function buildStateAttr(\n  componentMetadata: ComponentMetadata,\n  prop: StateStudioComponentProperty,\n  propName: string,\n): JsxAttribute {\n  const expr = buildStateExpression(componentMetadata, prop);\n  return factory.createJsxAttribute(factory.createIdentifier(propName), factory.createJsxExpression(undefined, expr));\n}\n\nexport function propertyToExpression(\n  componentMetadata: ComponentMetadata,\n  property: StudioComponentProperty | undefined,\n): Expression {\n  if (property === undefined) {\n    return factory.createIdentifier('undefined');\n  }\n\n  if (isFixedPropertyWithValue(property)) {\n    return buildFixedLiteralExpression(property);\n  }\n\n  if (isBoundProperty(property)) {\n    return property.defaultValue === undefined\n      ? buildBindingExpression(property)\n      : buildBindingWithDefaultExpression(property, property.defaultValue);\n  }\n\n  if (isConcatenatedProperty(property)) {\n    return buildConcatExpression(property);\n  }\n\n  if (isConditionalProperty(property)) {\n    return buildConditionalExpression(componentMetadata, property);\n  }\n\n  if (isStateProperty(property)) {\n    return buildStateExpression(componentMetadata, property);\n  }\n\n  if (isAuthProperty(property)) {\n    return buildAuthExpression(property);\n  }\n\n  throw new Error(`Invalid property: ${JSON.stringify(property)}.`);\n}\n\nexport function resolvePropToExpression(\n  componentMetadata: ComponentMetadata,\n  prop: StudioComponentProperty,\n): Expression {\n  if (isFixedPropertyWithValue(prop)) {\n    const propValue = prop.value;\n    switch (typeof propValue) {\n      case 'number':\n        return factory.createNumericLiteral(propValue, undefined);\n      case 'boolean':\n        return propValue ? factory.createTrue() : factory.createFalse();\n      default:\n        return factory.createStringLiteral(propValue.toString(), undefined);\n    }\n  }\n  if (isBoundProperty(prop)) {\n    const expr =\n      prop.defaultValue === undefined\n        ? buildBindingExpression(prop)\n        : buildBindingWithDefaultExpression(prop, prop.defaultValue);\n    return expr;\n  }\n\n  if (isAuthProperty(prop)) {\n    return buildAuthExpression(prop);\n  }\n  if (isCollectionItemBoundProperty(prop)) {\n    const expr =\n      prop.defaultValue === undefined\n        ? buildCollectionBindingExpression(prop)\n        : buildCollectionBindingWithDefaultExpression(prop, prop.defaultValue);\n    return expr;\n  }\n  if (isConcatenatedProperty(prop)) {\n    return buildConcatExpression(prop);\n  }\n  if (isConditionalProperty(prop)) {\n    return buildConditionalExpression(componentMetadata, prop);\n  }\n  if (isStateProperty(prop)) {\n    return buildStateExpression(componentMetadata, prop);\n  }\n  return factory.createVoidZero();\n}\n\nexport function getSyntaxKindToken(operator: RelationalOperator): BinaryOperatorToken | undefined {\n  switch (operator) {\n    case 'eq':\n      return factory.createToken(SyntaxKind.EqualsEqualsToken);\n    case 'ne':\n      return factory.createToken(SyntaxKind.ExclamationEqualsToken);\n    case 'le':\n      return factory.createToken(SyntaxKind.LessThanEqualsToken);\n    case 'lt':\n      return factory.createToken(SyntaxKind.LessThanToken);\n    case 'ge':\n      return factory.createToken(SyntaxKind.GreaterThanEqualsToken);\n    case 'gt':\n      return factory.createToken(SyntaxKind.GreaterThanToken);\n    /* istanbul ignore next */\n    default:\n      return undefined;\n  }\n}\n\nexport function parseNumberOperand(operand: string | number | boolean, dataField: GenericDataField | undefined) {\n  if (dataField) {\n    const numberOperandType: DataFieldDataType[] = ['Int', 'Float'];\n    if (numberOperandType.includes(dataField.dataType)) {\n      const parsedOperand = parseFloat(`${operand}`);\n      if (!Number.isNaN(parsedOperand) && Number.isFinite(parsedOperand)) {\n        return parsedOperand;\n      }\n    }\n  }\n  return operand;\n}\n\nexport function getConditionalOperandExpression(\n  operand: string | number | boolean,\n  operandType: string | undefined,\n): Expression {\n  if (typeof operand === 'string' && operandType && operandType !== 'string') {\n    return stringValueToTypedLiteral(operand, operandType);\n  }\n  return typedValueToJsxLiteral(operand);\n}\n\nfunction stringValueToTypedLiteral(value: any, valueType: string): PrimaryExpression {\n  try {\n    const typedVal = JSON.parse(value);\n    if (valueType === typeof typedVal) {\n      return typedValueToJsxLiteral(typedVal);\n    }\n    throw Error(`Parsed value ${value} and type ${valueType} mismatch`);\n  } catch (err) {\n    if (err instanceof SyntaxError) {\n      return factory.createStringLiteral(value);\n    }\n    throw err;\n  }\n}\n\nfunction typedValueToJsxLiteral(value: any): PrimaryExpression {\n  switch (typeof value) {\n    case 'number':\n      return factory.createNumericLiteral(value);\n    case 'boolean':\n      return value ? factory.createTrue() : factory.createFalse();\n    default:\n      return factory.createStringLiteral(value);\n  }\n}\n\nexport function buildConditionalExpression(\n  componentMetadata: ComponentMetadata,\n  prop: ConditionalStudioComponentProperty,\n): Expression {\n  const { property, field, operand, operandType, operator, then } = prop.condition;\n  const elseBlock = prop.condition.else;\n  const operatorToken = getSyntaxKindToken(operator);\n\n  if (operatorToken === undefined) {\n    return factory.createJsxExpression(undefined, undefined);\n  }\n\n  const propertyAccess =\n    field !== undefined\n      ? factory.createPropertyAccessChain(\n          factory.createIdentifier(property),\n          factory.createToken(SyntaxKind.QuestionDotToken),\n          factory.createIdentifier(field),\n        )\n      : factory.createIdentifier(property);\n\n  return factory.createConditionalExpression(\n    factory.createBinaryExpression(\n      propertyAccess,\n      operatorToken,\n      getConditionalOperandExpression(operand, operandType),\n    ),\n    factory.createToken(SyntaxKind.QuestionToken),\n    resolvePropToExpression(componentMetadata, then),\n    factory.createToken(SyntaxKind.ColonToken),\n    resolvePropToExpression(componentMetadata, elseBlock),\n  );\n}\n\nexport function buildConditionalAttr(\n  componentMetadata: ComponentMetadata,\n  prop: ConditionalStudioComponentProperty,\n  propName: string,\n): JsxAttribute {\n  const expr = buildConditionalExpression(componentMetadata, prop);\n  return factory.createJsxAttribute(factory.createIdentifier(propName), factory.createJsxExpression(undefined, expr));\n}\n\nexport function buildChildElement(\n  componentMetadata: ComponentMetadata,\n  prop?: StudioComponentProperty,\n): JsxChild | undefined {\n  if (!prop) {\n    return undefined;\n  }\n  let expression: Expression | undefined;\n  if (isFixedPropertyWithValue(prop)) {\n    expression = buildFixedJsxExpression(prop);\n  }\n  if (isBoundProperty(prop)) {\n    expression =\n      prop.defaultValue === undefined\n        ? buildBindingExpression(prop)\n        : buildBindingWithDefaultExpression(prop, prop.defaultValue);\n  }\n  if (isCollectionItemBoundProperty(prop)) {\n    expression =\n      prop.defaultValue === undefined\n        ? buildCollectionBindingExpression(prop)\n        : buildCollectionBindingWithDefaultExpression(prop, prop.defaultValue);\n  }\n  if (isConcatenatedProperty(prop)) {\n    expression = buildConcatExpression(prop);\n  }\n  if (isConditionalProperty(prop)) {\n    expression = buildConditionalExpression(componentMetadata, prop);\n  }\n  return expression && factory.createJsxExpression(undefined, expression);\n}\n\nexport function buildOpeningElementProperties(\n  componentMetadata: ComponentMetadata,\n  prop: StudioComponentProperty,\n  name: string,\n): JsxAttribute {\n  if (isFixedPropertyWithValue(prop)) {\n    return buildFixedAttr(prop, name);\n  }\n  if (isBoundProperty(prop)) {\n    return prop.defaultValue === undefined\n      ? buildBindingAttr(prop, name)\n      : buildBindingAttrWithDefault(prop, name, prop.defaultValue);\n  }\n  if (isAuthProperty(prop)) {\n    return buildUserAuthAttr(prop, name);\n  }\n  if (isCollectionItemBoundProperty(prop)) {\n    return prop.defaultValue === undefined\n      ? buildCollectionBindingAttr(prop, name)\n      : buildCollectionBindingAttrWithDefault(prop, name, prop.defaultValue);\n  }\n  if (isConcatenatedProperty(prop)) {\n    return buildConcatAttr(prop, name);\n  }\n  if (isConditionalProperty(prop)) {\n    return buildConditionalAttr(componentMetadata, prop, name);\n  }\n  if (isStateProperty(prop)) {\n    return buildStateAttr(componentMetadata, prop, name);\n  }\n  return factory.createJsxAttribute(factory.createIdentifier(name), undefined);\n}\n\nfunction buildFixedOrTokenRefAttribute(styleConfig: FormStyleConfig, propName: string): JsxAttribute | undefined {\n  if (styleConfig.value) {\n    return buildFixedAttr({ value: styleConfig.value }, propName);\n  }\n  if (styleConfig.tokenReference) {\n    const tokenReference = ['tokens', ...styleConfig.tokenReference.split('.')];\n\n    return factory.createJsxAttribute(\n      factory.createIdentifier(propName),\n      factory.createJsxExpression(\n        undefined,\n        factory.createPropertyAccessExpression(buildAccessChain(tokenReference, false), 'value'),\n      ),\n    );\n  }\n  return undefined;\n}\n\nexport function buildFormLayoutProperties(formMetadata: FormMetadata | undefined): JsxAttribute[] {\n  const propMap: Record<string, string> = {\n    horizontalGap: 'rowGap',\n    verticalGap: 'columnGap',\n    outerPadding: 'padding',\n  };\n\n  return Object.entries(formMetadata?.layoutConfigs ?? {}).reduce<JsxAttribute[]>((acc, value) => {\n    const mappedProp = propMap[value[0]];\n\n    if (!mappedProp) {\n      return acc;\n    }\n\n    const mappedAttribute = buildFixedOrTokenRefAttribute(value[1], mappedProp);\n    if (mappedAttribute) {\n      acc.push(mappedAttribute);\n    }\n\n    return acc;\n  }, []);\n}\n\nexport function buildCtaLayoutProperties(formMetadata: FormMetadata): JsxAttribute | undefined {\n  return buildFixedOrTokenRefAttribute(formMetadata.layoutConfigs.verticalGap, 'gap');\n}\n\nexport function addBindingPropertiesImports(\n  component: StudioComponent | StudioComponentChild,\n  importCollection: ImportCollection,\n) {\n  if (typeof component === 'object' && 'bindingProperties' in component) {\n    Object.entries(component.bindingProperties).forEach(([, binding]) => {\n      if (typeof binding === 'object' && 'bindingProperties' in binding && 'model' in binding.bindingProperties) {\n        importCollection.addModelImport(binding.bindingProperties.model);\n      }\n    });\n  }\n}\n\n// Scrub all non-alphanum characters, and any leading numbers so we can generate a legal\n// variable name.\nexport function sanitizeName(componentName: string): string {\n  return nameReplacements\n    .reduce((name, [character, replacement]) => name.replace(character, replacement), componentName)\n    .replace(/[^a-zA-Z]/g, ''); // remove any stray non alpha characters\n}\n\nexport function getStateName(stateReference: StateStudioComponentProperty): string {\n  const { componentName, property } = stateReference;\n  const rawStateName = [\n    componentName.charAt(0).toLowerCase() + componentName.slice(1),\n    property.charAt(0).toUpperCase() + property.slice(1),\n  ].join('');\n  return sanitizeName(rawStateName);\n}\n\nexport function getSetStateName(stateReference: StateStudioComponentProperty): string {\n  const stateName = getStateName(stateReference);\n  return ['set', stateName.charAt(0).toUpperCase() + stateName.slice(1)].join('');\n}\n\nexport function hasChildrenProp(componentProperties: StudioComponentProperties): boolean {\n  return !!(\n    typeof componentProperties === 'object' &&\n    'children' in componentProperties &&\n    componentProperties.children\n  );\n}", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2025-46338", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "<template>\n  <div id=\"page-wrapper\" class=\"page p-1 sm:p-6 overflow-y-auto\" :class=\"streamLibraryItem ? 'streaming' : ''\">\n    <div class=\"w-full max-w-6xl mx-auto\">\n      <!-- Library & folder picker -->\n      <div class=\"flex flex-wrap my-6 md:-mx-2\">\n        <div class=\"w-full md:w-1/5 px-2\">\n          <ui-dropdown v-model=\"selectedLibraryId\" :items=\"libraryItems\" :label=\"$strings.LabelLibrary\" :disabled=\"!!items.length\" @input=\"libraryChanged\" />\n        </div>\n        <div class=\"w-full md:w-3/5 px-2\">\n          <ui-dropdown v-model=\"selectedFolderId\" :items=\"folderItems\" :disabled=\"!selectedLibraryId || !!items.length\" :label=\"$strings.LabelFolder\" />\n        </div>\n        <div class=\"w-full md:w-1/5 px-2\">\n          <ui-text-input-with-label :value=\"selectedLibraryMediaType\" readonly :label=\"$strings.LabelMediaType\" />\n        </div>\n      </div>\n\n      <div v-if=\"!selectedLibraryIsPodcast\" class=\"flex items-center mb-6 px-2 md:px-0\">\n        <label class=\"flex cursor-pointer pt-4\">\n          <ui-toggle-switch v-model=\"fetchMetadata.enabled\" class=\"inline-flex\" />\n          <span class=\"pl-2 text-base\">{{ $strings.LabelAutoFetchMetadata }}</span>\n        </label>\n        <ui-tooltip :text=\"$strings.LabelAutoFetchMetadataHelp\" class=\"inline-flex pt-4\">\n          <span class=\"pl-1 material-symbols icon-text text-sm cursor-pointer\">info</span>\n        </ui-tooltip>\n\n        <div class=\"grow ml-4\">\n          <ui-dropdown v-model=\"fetchMetadata.provider\" :items=\"providers\" :label=\"$strings.LabelProvider\" />\n        </div>\n      </div>\n\n      <widgets-alert v-if=\"error\" type=\"error\">\n        <p class=\"text-lg\">{{ error }}</p>\n      </widgets-alert>\n\n      <!-- Picker display -->\n      <div v-if=\"!items.length && !ignoredFiles.length\" class=\"w-full mx-auto border border-white/20 px-4 md:px-12 pt-12 pb-4 my-12 relative\" :class=\"isDragging ? 'bg-primary/40' : 'border-dashed'\">\n        <p class=\"text-2xl text-center\">{{ isDragging ? $strings.LabelUploaderDropFiles : isIOS ? $strings.LabelUploaderDragAndDropFilesOnly : $strings.LabelUploaderDragAndDrop }}</p>\n        <p class=\"text-center text-sm my-5\">{{ $strings.MessageOr }}</p>\n        <div class=\"w-full max-w-xl mx-auto\">\n          <div class=\"flex\">\n            <ui-btn class=\"w-full mx-1\" @click=\"openFilePicker\">{{ $strings.ButtonChooseFiles }}</ui-btn>\n            <ui-btn v-if=\"!isIOS\" class=\"w-full mx-1\" @click=\"openFolderPicker\">{{ $strings.ButtonChooseAFolder }} </ui-btn>\n          </div>\n        </div>\n        <div class=\"pt-8 text-center\">\n          <p class=\"text-xs text-white/50 font-mono mb-4\">\n            <strong>{{ $strings.LabelSupportedFileTypes }}: </strong>{{ inputAccept.join(', ') }}\n          </p>\n\n          <p class=\"text-sm text-white/70\">\n            <span v-if=\"!isIOS\">{{ $strings.NoteUploaderFoldersWithMediaFiles }}</span> <span v-if=\"selectedLibraryMediaType === 'book'\">{{ $strings.NoteUploaderOnlyAudioFiles }}</span>\n          </p>\n        </div>\n      </div>\n      <!-- Item list header -->\n      <div v-else class=\"w-full flex items-center pb-4 border-b border-white/10\">\n        <p class=\"text-lg lowercase\">{{ items.length === 1 ? `1 ${$strings.LabelItem}` : $getString('LabelXItems', [items.length]) }}</p>\n        <div class=\"grow\" />\n        <ui-btn :disabled=\"processing\" small @click=\"reset\">{{ $strings.ButtonReset }}</ui-btn>\n      </div>\n\n      <!-- Alerts -->\n      <widgets-alert v-if=\"!items.length && !uploadReady\" type=\"error\" class=\"my-4\">\n        <p class=\"text-lg\">{{ $strings.MessageNoItemsFound }}</p>\n      </widgets-alert>\n      <widgets-alert v-if=\"ignoredFiles.length\" type=\"warning\" class=\"my-4\">\n        <div class=\"w-full pr-12\">\n          <p class=\"text-base mb-1\">{{ $strings.NoteUploaderUnsupportedFiles }}</p>\n          <tables-uploaded-files-table :files=\"ignoredFiles\" :title=\"$strings.HeaderIgnoredFiles\" class=\"text-white\" />\n          <p class=\"text-xs text-white/50 font-mono pt-1\">\n            <strong>{{ $strings.LabelSupportedFileTypes }}: </strong>{{ inputAccept.join(', ') }}\n          </p>\n        </div>\n      </widgets-alert>\n\n      <!-- Item Upload cards -->\n      <cards-item-upload-card v-for=\"item in items\" :key=\"item.index\" :ref=\"`itemCard-${item.index}`\" :media-type=\"selectedLibraryMediaType\" :item=\"item\" :provider=\"fetchMetadata.provider\" :processing=\"processing\" @remove=\"removeItem(item)\" />\n\n      <!-- Upload/Reset btns -->\n      <div v-show=\"items.length\" class=\"flex justify-end pb-8 pt-4\">\n        <ui-btn v-if=\"!uploadFinished\" color=\"bg-success\" :loading=\"processing\" @click=\"submit\">{{ $strings.ButtonUpload }}</ui-btn>\n        <ui-btn v-else @click=\"reset\">{{ $strings.ButtonReset }}</ui-btn>\n      </div>\n    </div>\n\n    <input ref=\"fileInput\" type=\"file\" multiple :accept=\"isIOS ? '' : inputAccept\" class=\"hidden\" @change=\"inputChanged\" />\n    <input ref=\"fileFolderInput\" type=\"file\" webkitdirectory multiple :accept=\"inputAccept\" class=\"hidden\" @change=\"inputChanged\" v-if=\"!isIOS\" />\n  </div>\n</template>\n\n<script>\nimport Path from 'path'\nimport uploadHelpers from '@/mixins/uploadHelpers'\n\nexport default {\n  mixins: [uploadHelpers],\n  data() {\n    return {\n      isDragging: false,\n      error: '',\n      items: [],\n      ignoredFiles: [],\n      selectedLibraryId: null,\n      selectedFolderId: null,\n      processing: false,\n      uploadFinished: false,\n      fetchMetadata: {\n        enabled: false,\n        provider: null\n      }\n    }\n  },\n  watch: {\n    selectedLibrary(newVal) {\n      if (newVal && !this.selectedFolderId) {\n        this.setDefaultFolder()\n        this.setMetadataProvider()\n      }\n    }\n  },\n  computed: {\n    inputAccept() {\n      var extensions = []\n      Object.values(this.$constants.SupportedFileTypes).forEach((types) => {\n        extensions = extensions.concat(types.map((t) => `.${t}`))\n      })\n      return extensions\n    },\n    isIOS() {\n      const ua = window.navigator.userAgent\n      return /iPad|iPhone|iPod/.test(ua) && !window.MSStream\n    },\n    streamLibraryItem() {\n      return this.$store.state.streamLibraryItem\n    },\n    libraries() {\n      return this.$store.state.libraries.libraries\n    },\n    libraryItems() {\n      return this.libraries.map((lib) => {\n        return {\n          value: lib.id,\n          text: lib.name\n        }\n      })\n    },\n    selectedLibrary() {\n      return this.libraries.find((lib) => lib.id === this.selectedLibraryId)\n    },\n    selectedLibraryMediaType() {\n      return this.selectedLibrary ? this.selectedLibrary.mediaType : null\n    },\n    selectedLibraryIsPodcast() {\n      return this.selectedLibraryMediaType === 'podcast'\n    },\n    providers() {\n      if (this.selectedLibraryIsPodcast) return this.$store.state.scanners.podcastProviders\n      return this.$store.state.scanners.providers\n    },\n    canFetchMetadata() {\n      return !this.selectedLibraryIsPodcast && this.fetchMetadata.enabled\n    },\n    selectedFolder() {\n      if (!this.selectedLibrary) return null\n      return this.selectedLibrary.folders.find((fold) => fold.id === this.selectedFolderId)\n    },\n    folderItems() {\n      if (!this.selectedLibrary) return []\n      return this.selectedLibrary.folders.map((fold) => {\n        return {\n          value: fold.id,\n          text: fold.fullPath\n        }\n      })\n    },\n    uploadReady() {\n      return !this.items.length && !this.ignoredFiles.length && !this.uploadFinished\n    }\n  },\n  methods: {\n    libraryChanged() {\n      if (!this.selectedLibrary && this.selectedFolderId) {\n        this.selectedFolderId = null\n      } else if (this.selectedFolderId) {\n        if (!this.selectedLibrary.folders.find((fold) => fold.id === this.selectedFolderId)) {\n          this.selectedFolderId = null\n        }\n      }\n      this.setDefaultFolder()\n      this.setMetadataProvider()\n    },\n    setDefaultFolder() {\n      if (!this.selectedFolderId && this.selectedLibrary && this.selectedLibrary.folders.length) {\n        this.selectedFolderId = this.selectedLibrary.folders[0].id\n      }\n    },\n    setMetadataProvider() {\n      this.fetchMetadata.provider ||= this.$store.getters['libraries/getLibraryProvider'](this.selectedLibraryId)\n    },\n    removeItem(item) {\n      this.items = this.items.filter((b) => b.index !== item.index)\n      if (!this.items.length) {\n        this.reset()\n      }\n    },\n    reset() {\n      this.error = ''\n      this.items = []\n      this.ignoredFiles = []\n      this.uploadFinished = false\n      if (this.$refs.fileInput) this.$refs.fileInput.value = ''\n      if (this.$refs.fileFolderInput) this.$refs.fileFolderInput.value = ''\n    },\n    openFilePicker() {\n      if (this.$refs.fileInput) this.$refs.fileInput.click()\n    },\n    openFolderPicker() {\n      if (this.$refs.fileFolderInput) this.$refs.fileFolderInput.click()\n    },\n    isDraggingFile(e) {\n      // Checks dragging file or folder and not an element on the page\n      var dt = e.dataTransfer || {}\n      return dt.types && dt.types.indexOf('Files') >= 0\n    },\n    dragenter(e) {\n      e.preventDefault()\n      if (this.uploadReady && this.isDraggingFile(e) && !this.isDragging) {\n        this.isDragging = true\n      }\n    },\n    dragleave(e) {\n      e.preventDefault()\n      if (!e.fromElement && this.isDragging) {\n        this.isDragging = false\n      }\n    },\n    dragover(e) {\n      // This is required to catch the drop event\n      e.preventDefault()\n    },\n    async drop(e) {\n      e.preventDefault()\n      this.isDragging = false\n      var items = e.dataTransfer.items || []\n\n      var itemResults = await this.uploadHelpers.getItemsFromDrop(items, this.selectedLibraryMediaType)\n      this.onItemsSelected(itemResults)\n    },\n    inputChanged(e) {\n      if (!e.target || !e.target.files) return\n      var _files = Array.from(e.target.files)\n      if (_files && _files.length) {\n        var itemResults = this.uploadHelpers.getItemsFromPicker(_files, this.selectedLibraryMediaType)\n        this.onItemsSelected(itemResults)\n      }\n    },\n    onItemsSelected(itemResults) {\n      if (this.itemSelectionSuccessful(itemResults)) {\n        // setTimeout ensures the new item ref is attached before this method is called\n        setTimeout(this.attemptMetadataFetch, 0)\n      }\n    },\n    itemSelectionSuccessful(itemResults) {\n      console.log('Upload results', itemResults)\n\n      if (itemResults.error) {\n        this.error = itemResults.error\n        this.items = []\n        this.ignoredFiles = []\n        return false\n      }\n\n      this.error = ''\n      this.items = itemResults.items\n      this.ignoredFiles = itemResults.ignoredFiles\n      return true\n    },\n    attemptMetadataFetch() {\n      if (!this.canFetchMetadata) {\n        return false\n      }\n\n      this.items.forEach((item) => {\n        let itemRef = this.$refs[`itemCard-${item.index}`]\n\n        if (itemRef?.length) {\n          itemRef[0].fetchMetadata(this.fetchMetadata.provider)\n        }\n      })\n    },\n    updateItemCardStatus(index, status) {\n      var ref = this.$refs[`itemCard-${index}`]\n      if (ref && ref.length) ref = ref[0]\n      if (!ref) {\n        console.error('Book card ref not found', index, this.$refs)\n      } else {\n        ref.setUploadStatus(status)\n      }\n    },\n    async uploadItem(item) {\n      var form = new FormData()\n      form.set('title', item.title)\n      if (!this.selectedLibraryIsPodcast) {\n        form.set('author', item.author || '')\n        form.set('series', item.series || '')\n      }\n      form.set('library', this.selectedLibraryId)\n      form.set('folder', this.selectedFolderId)\n\n      var index = 0\n      item.files.forEach((file) => {\n        form.set(`${index++}`, file)\n      })\n\n      return this.$axios\n        .$post('/api/upload', form)\n        .then(() => true)\n        .catch((error) => {\n          console.error('Failed', error)\n          var errorMessage = error.response && error.response.data ? error.response.data : 'Oops, something went wrong...'\n          this.$toast.error(errorMessage)\n          return false\n        })\n    },\n    validateItems() {\n      var itemData = []\n      for (var item of this.items) {\n        var itemref = this.$refs[`itemCard-${item.index}`]\n        if (itemref && itemref.length) itemref = itemref[0]\n\n        if (!itemref) {\n          console.error('Invalid item index no ref', item.index, this.$refs.itemCard)\n          return false\n        } else {\n          var data = itemref.getData()\n          if (!data) {\n            return false\n          }\n          itemData.push(data)\n        }\n      }\n      return itemData\n    },\n    async submit() {\n      if (!this.selectedFolderId || !this.selectedLibraryId) {\n        this.$toast.error('Must select library and folder')\n        document.getElementById('page-wrapper').scroll({ top: 0, left: 0, behavior: 'smooth' })\n        return\n      }\n\n      const items = this.validateItems()\n      if (!items) {\n        this.$toast.error('Some invalid items')\n        return\n      }\n      this.processing = true\n\n      const itemsToUpload = []\n\n      // Check if path already exists before starting upload\n      //  uploading fails if path already exists\n      for (const item of items) {\n        const filepath = Path.join(this.selectedFolder.fullPath, item.directory)\n        const exists = await this.$axios\n          .$post(`/api/filesystem/pathexists`, { filepath, directory: item.directory, folderPath: this.selectedFolder.fullPath })\n          .then((data) => {\n            if (data.exists) {\n              if (data.libraryItemTitle) {\n                this.$toast.error(this.$getString('ToastUploaderItemExistsInSubdirectoryError', [data.libraryItemTitle]))\n              } else {\n                this.$toast.error(this.$getString('ToastUploaderFilepathExistsError', [filepath]))\n              }\n            }\n            return data.exists\n          })\n          .catch((error) => {\n            console.error('Failed to check if filepath exists', error)\n            return false\n          })\n        if (!exists) {\n          itemsToUpload.push(item)\n        }\n      }\n\n      let itemsUploaded = 0\n      let itemsFailed = 0\n      for (const item of itemsToUpload) {\n        this.updateItemCardStatus(item.index, 'uploading')\n        const result = await this.uploadItem(item)\n        if (result) itemsUploaded++\n        else itemsFailed++\n        this.updateItemCardStatus(item.index, result ? 'success' : 'failed')\n      }\n      this.processing = false\n      this.uploadFinished = true\n    }\n  },\n  mounted() {\n    this.selectedLibraryId = this.$store.state.libraries.currentLibraryId\n    this.setMetadataProvider()\n\n    this.setDefaultFolder()\n    window.addEventListener('dragenter', this.dragenter)\n    window.addEventListener('dragleave', this.dragleave)\n    window.addEventListener('dragover', this.dragover)\n    window.addEventListener('drop', this.drop)\n  },\n  beforeDestroy() {\n    window.removeEventListener('dragenter', this.dragenter)\n    window.removeEventListener('dragleave', this.dragleave)\n    window.removeEventListener('dragover', this.dragover)\n    window.removeEventListener('drop', this.drop)\n  }\n}\n</script>", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2025-46343", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "import { BinaryDataQueryDto, BinaryDataSignedQueryDto } from '@n8n/api-types';\nimport { Request, Response } from 'express';\nimport { JsonWebTokenError } from 'jsonwebtoken';\nimport { BinaryDataService, FileNotFoundError, isValidNonDefaultMode } from 'n8n-core';\n\nimport { Get, Query, RestController } from '@/decorators';\nimport { BadRequestError } from '@/errors/response-errors/bad-request.error';\n\n@RestController('/binary-data')\nexport class BinaryDataController {\n\tconstructor(private readonly binaryDataService: BinaryDataService) {}\n\n\t@Get('/')\n\tasync get(\n\t\t_: Request,\n\t\tres: Response,\n\t\t@Query { id: binaryDataId, action, fileName, mimeType }: BinaryDataQueryDto,\n\t) {\n\t\ttry {\n\t\t\tthis.validateBinaryDataId(binaryDataId);\n\t\t\tawait this.setContentHeaders(binaryDataId, action, res, fileName, mimeType);\n\t\t\treturn await this.binaryDataService.getAsStream(binaryDataId);\n\t\t} catch (error) {\n\t\t\tif (error instanceof FileNotFoundError) return res.status(404).end();\n\t\t\tif (error instanceof BadRequestError) return res.status(400).end(error.message);\n\t\t\telse throw error;\n\t\t}\n\t}\n\n\t@Get('/signed', { skipAuth: true })\n\tasync getSigned(_: Request, res: Response, @Query { token }: BinaryDataSignedQueryDto) {\n\t\ttry {\n\t\t\tconst binaryDataId = this.binaryDataService.validateSignedToken(token);\n\t\t\tthis.validateBinaryDataId(binaryDataId);\n\t\t\tawait this.setContentHeaders(binaryDataId, 'download', res);\n\t\t\treturn await this.binaryDataService.getAsStream(binaryDataId);\n\t\t} catch (error) {\n\t\t\tif (error instanceof FileNotFoundError) return res.status(404).end();\n\t\t\tif (error instanceof BadRequestError || error instanceof JsonWebTokenError)\n\t\t\t\treturn res.status(400).end(error.message);\n\t\t\telse throw error;\n\t\t}\n\t}\n\n\tprivate validateBinaryDataId(binaryDataId: string) {\n\t\tif (!binaryDataId) {\n\t\t\tthrow new BadRequestError('Missing binary data ID');\n\t\t}\n\n\t\tif (!binaryDataId.includes(':')) {\n\t\t\tthrow new BadRequestError('Missing binary data mode');\n\t\t}\n\n\t\tconst [mode] = binaryDataId.split(':');\n\t\tif (!isValidNonDefaultMode(mode)) {\n\t\t\tthrow new BadRequestError('Invalid binary data mode');\n\t\t}\n\t}\n\n\tprivate async setContentHeaders(\n\t\tbinaryDataId: string,\n\t\taction: 'view' | 'download',\n\t\tres: Response,\n\t\tfileName?: string,\n\t\tmimeType?: string,\n\t) {\n\t\tif (!fileName || !mimeType) {\n\t\t\ttry {\n\t\t\t\tconst metadata = await this.binaryDataService.getMetadata(binaryDataId);\n\t\t\t\tfileName = metadata.fileName;\n\t\t\t\tmimeType = metadata.mimeType;\n\t\t\t\tres.setHeader('Content-Length', metadata.fileSize);\n\t\t\t} catch {}\n\t\t}\n\n\t\tif (mimeType) {\n\t\t\tres.setHeader('Content-Type', mimeType);\n\n\t\t\t// Sandbox html files when viewed in a browser\n\t\t\tif (mimeType.includes('html') && action === 'view') {\n\t\t\t\tres.header('Content-Security-Policy', 'sandbox');\n\t\t\t}\n\t\t}\n\n\t\tif (action === 'download' && fileName) {\n\t\t\tconst encodedFilename = encodeURIComponent(fileName);\n\t\t\tres.setHeader('Content-Disposition', `attachment; filename=\"${encodedFilename}\"`);\n\t\t}\n\t}\n}", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2025-46565", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "import path from 'node:path'\nimport fsp from 'node:fs/promises'\nimport type { ServerResponse } from 'node:http'\nimport type { Connect } from 'dep-types/connect'\nimport colors from 'picocolors'\nimport type { ExistingRawSourceMap } from 'rollup'\nimport type { ViteDevServer } from '..'\nimport {\n  createDebugger,\n  fsPathFromId,\n  injectQuery,\n  isImportRequest,\n  isJSRequest,\n  normalizePath,\n  prettifyUrl,\n  removeImportQuery,\n  removeTimestampQuery,\n} from '../../utils'\nimport { send } from '../send'\nimport {\n  ERR_DENIED_ID,\n  ERR_LOAD_URL,\n  transformRequest,\n} from '../transformRequest'\nimport { applySourcemapIgnoreList } from '../sourcemap'\nimport { isHTMLProxy } from '../../plugins/html'\nimport {\n  DEP_VERSION_RE,\n  ERR_FILE_NOT_FOUND_IN_OPTIMIZED_DEP_DIR,\n  ERR_OPTIMIZE_DEPS_PROCESSING_ERROR,\n  FS_PREFIX,\n} from '../../constants'\nimport {\n  isCSSRequest,\n  isDirectCSSRequest,\n  isDirectRequest,\n} from '../../plugins/css'\nimport { ERR_CLOSED_SERVER } from '../pluginContainer'\nimport { cleanUrl, unwrapId, withTrailingSlash } from '../../../shared/utils'\nimport {\n  ERR_OUTDATED_OPTIMIZED_DEP,\n  NULL_BYTE_PLACEHOLDER,\n} from '../../../shared/constants'\nimport { ensureServingAccess } from './static'\n\nconst debugCache = createDebugger('vite:cache')\n\nconst knownIgnoreList = new Set(['/', '/favicon.ico'])\nconst trailingQuerySeparatorsRE = /[?&]+$/\n\n// TODO: consolidate this regex pattern with the url, raw, and inline checks in plugins\nconst urlRE = /[?&]url\\b/\nconst rawRE = /[?&]raw\\b/\nconst inlineRE = /[?&]inline\\b/\nconst svgRE = /\\.svg\\b/\n\nfunction deniedServingAccessForTransform(\n  url: string,\n  server: ViteDevServer,\n  res: ServerResponse,\n  next: Connect.NextFunction,\n) {\n  return (\n    (rawRE.test(url) ||\n      urlRE.test(url) ||\n      inlineRE.test(url) ||\n      svgRE.test(url)) &&\n    !ensureServingAccess(url, server, res, next)\n  )\n}\n\n/**\n * A middleware that short-circuits the middleware chain to serve cached transformed modules\n */\nexport function cachedTransformMiddleware(\n  server: ViteDevServer,\n): Connect.NextHandleFunction {\n  // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`\n  return function viteCachedTransformMiddleware(req, res, next) {\n    const environment = server.environments.client\n\n    // check if we can return 304 early\n    const ifNoneMatch = req.headers['if-none-match']\n    if (ifNoneMatch) {\n      const moduleByEtag = environment.moduleGraph.getModuleByEtag(ifNoneMatch)\n      if (\n        moduleByEtag?.transformResult?.etag === ifNoneMatch &&\n        moduleByEtag.url === req.url\n      ) {\n        // For CSS requests, if the same CSS file is imported in a module,\n        // the browser sends the request for the direct CSS request with the etag\n        // from the imported CSS module. We ignore the etag in this case.\n        const maybeMixedEtag = isCSSRequest(req.url!)\n        if (!maybeMixedEtag) {\n          debugCache?.(`[304] ${prettifyUrl(req.url!, server.config.root)}`)\n          res.statusCode = 304\n          return res.end()\n        }\n      }\n    }\n\n    next()\n  }\n}\n\nexport function transformMiddleware(\n  server: ViteDevServer,\n): Connect.NextHandleFunction {\n  // Keep the named function. The name is visible in debug logs via `DEBUG=connect:dispatcher ...`\n\n  // check if public dir is inside root dir\n  const { root, publicDir } = server.config\n  const publicDirInRoot = publicDir.startsWith(withTrailingSlash(root))\n  const publicPath = `${publicDir.slice(root.length)}/`\n\n  return async function viteTransformMiddleware(req, res, next) {\n    const environment = server.environments.client\n\n    if (req.method !== 'GET' || knownIgnoreList.has(req.url!)) {\n      return next()\n    }\n\n    let url: string\n    try {\n      url = decodeURI(removeTimestampQuery(req.url!)).replace(\n        NULL_BYTE_PLACEHOLDER,\n        '\\0',\n      )\n    } catch (e) {\n      if (e instanceof URIError) {\n        server.config.logger.warn(\n          colors.yellow('Malformed URI sequence in request URL'),\n        )\n        return next()\n      }\n      return next(e)\n    }\n\n    const withoutQuery = cleanUrl(url)\n\n    try {\n      const isSourceMap = withoutQuery.endsWith('.map')\n      // since we generate source map references, handle those requests here\n      if (isSourceMap) {\n        const depsOptimizer = environment.depsOptimizer\n        if (depsOptimizer?.isOptimizedDepUrl(url)) {\n          // If the browser is requesting a source map for an optimized dep, it\n          // means that the dependency has already been pre-bundled and loaded\n          const sourcemapPath = url.startsWith(FS_PREFIX)\n            ? fsPathFromId(url)\n            : normalizePath(path.resolve(server.config.root, url.slice(1)))\n          try {\n            const map = JSON.parse(\n              await fsp.readFile(sourcemapPath, 'utf-8'),\n            ) as ExistingRawSourceMap\n\n            applySourcemapIgnoreList(\n              map,\n              sourcemapPath,\n              server.config.server.sourcemapIgnoreList,\n              server.config.logger,\n            )\n\n            return send(req, res, JSON.stringify(map), 'json', {\n              headers: server.config.server.headers,\n            })\n          } catch {\n            // Outdated source map request for optimized deps, this isn't an error\n            // but part of the normal flow when re-optimizing after missing deps\n            // Send back an empty source map so the browser doesn't issue warnings\n            const dummySourceMap = {\n              version: 3,\n              file: sourcemapPath.replace(/\\.map$/, ''),\n              sources: [],\n              sourcesContent: [],\n              names: [],\n              mappings: ';;;;;;;;;',\n            }\n            return send(req, res, JSON.stringify(dummySourceMap), 'json', {\n              cacheControl: 'no-cache',\n              headers: server.config.server.headers,\n            })\n          }\n        } else {\n          const originalUrl = url.replace(/\\.map($|\\?)/, '$1')\n          const map = (\n            await environment.moduleGraph.getModuleByUrl(originalUrl)\n          )?.transformResult?.map\n          if (map) {\n            return send(req, res, JSON.stringify(map), 'json', {\n              headers: server.config.server.headers,\n            })\n          } else {\n            return next()\n          }\n        }\n      }\n\n      if (publicDirInRoot && url.startsWith(publicPath)) {\n        warnAboutExplicitPublicPathInUrl(url)\n      }\n\n      const urlWithoutTrailingQuerySeparators = url.replace(\n        trailingQuerySeparatorsRE,\n        '',\n      )\n      if (\n        deniedServingAccessForTransform(\n          urlWithoutTrailingQuerySeparators,\n          server,\n          res,\n          next,\n        )\n      ) {\n        return\n      }\n\n      if (\n        req.headers['sec-fetch-dest'] === 'script' ||\n        isJSRequest(url) ||\n        isImportRequest(url) ||\n        isCSSRequest(url) ||\n        isHTMLProxy(url)\n      ) {\n        // strip ?import\n        url = removeImportQuery(url)\n        // Strip valid id prefix. This is prepended to resolved Ids that are\n        // not valid browser import specifiers by the importAnalysis plugin.\n        url = unwrapId(url)\n\n        // for CSS, we differentiate between normal CSS requests and imports\n        if (isCSSRequest(url)) {\n          if (\n            req.headers.accept?.includes('text/css') &&\n            !isDirectRequest(url)\n          ) {\n            url = injectQuery(url, 'direct')\n          }\n\n          // check if we can return 304 early for CSS requests. These aren't handled\n          // by the cachedTransformMiddleware due to the browser possibly mixing the\n          // etags of direct and imported CSS\n          const ifNoneMatch = req.headers['if-none-match']\n          if (\n            ifNoneMatch &&\n            (await environment.moduleGraph.getModuleByUrl(url))?.transformResult\n              ?.etag === ifNoneMatch\n          ) {\n            debugCache?.(`[304] ${prettifyUrl(url, server.config.root)}`)\n            res.statusCode = 304\n            return res.end()\n          }\n        }\n\n        // resolve, load and transform using the plugin container\n        const result = await transformRequest(environment, url, {\n          html: req.headers.accept?.includes('text/html'),\n          allowId(id) {\n            return !deniedServingAccessForTransform(id, server, res, next)\n          },\n        })\n        if (result) {\n          const depsOptimizer = environment.depsOptimizer\n          const type = isDirectCSSRequest(url) ? 'css' : 'js'\n          const isDep =\n            DEP_VERSION_RE.test(url) || depsOptimizer?.isOptimizedDepUrl(url)\n          return send(req, res, result.code, type, {\n            etag: result.etag,\n            // allow browser to cache npm deps!\n            cacheControl: isDep ? 'max-age=31536000,immutable' : 'no-cache',\n            headers: server.config.server.headers,\n            map: result.map,\n          })\n        }\n      }\n    } catch (e) {\n      if (e?.code === ERR_OPTIMIZE_DEPS_PROCESSING_ERROR) {\n        // Skip if response has already been sent\n        if (!res.writableEnded) {\n          res.statusCode = 504 // status code request timeout\n          res.statusMessage = 'Optimize Deps Processing Error'\n          res.end()\n        }\n        // This timeout is unexpected\n        server.config.logger.error(e.message)\n        return\n      }\n      if (e?.code === ERR_OUTDATED_OPTIMIZED_DEP) {\n        // Skip if response has already been sent\n        if (!res.writableEnded) {\n          res.statusCode = 504 // status code request timeout\n          res.statusMessage = 'Outdated Optimize Dep'\n          res.end()\n        }\n        // We don't need to log an error in this case, the request\n        // is outdated because new dependencies were discovered and\n        // the new pre-bundle dependencies have changed.\n        // A full-page reload has been issued, and these old requests\n        // can't be properly fulfilled. This isn't an unexpected\n        // error but a normal part of the missing deps discovery flow\n        return\n      }\n      if (e?.code === ERR_CLOSED_SERVER) {\n        // Skip if response has already been sent\n        if (!res.writableEnded) {\n          res.statusCode = 504 // status code request timeout\n          res.statusMessage = 'Outdated Request'\n          res.end()\n        }\n        // We don't need to log an error in this case, the request\n        // is outdated because new dependencies were discovered and\n        // the new pre-bundle dependencies have changed.\n        // A full-page reload has been issued, and these old requests\n        // can't be properly fulfilled. This isn't an unexpected\n        // error but a normal part of the missing deps discovery flow\n        return\n      }\n      if (e?.code === ERR_FILE_NOT_FOUND_IN_OPTIMIZED_DEP_DIR) {\n        // Skip if response has already been sent\n        if (!res.writableEnded) {\n          res.statusCode = 404\n          res.end()\n        }\n        server.config.logger.warn(colors.yellow(e.message))\n        return\n      }\n      if (e?.code === ERR_LOAD_URL) {\n        // Let other middleware handle if we can't load the url via transformRequest\n        return next()\n      }\n      if (e?.code === ERR_DENIED_ID) {\n        // next() is called in ensureServingAccess\n        return\n      }\n      return next(e)\n    }\n\n    next()\n  }\n\n  function warnAboutExplicitPublicPathInUrl(url: string) {\n    let warning: string\n\n    if (isImportRequest(url)) {\n      const rawUrl = removeImportQuery(url)\n      if (urlRE.test(url)) {\n        warning =\n          `Assets in the public directory are served at the root path.\\n` +\n          `Instead of ${colors.cyan(rawUrl)}, use ${colors.cyan(\n            rawUrl.replace(publicPath, '/'),\n          )}.`\n      } else {\n        warning =\n          'Assets in public directory cannot be imported from JavaScript.\\n' +\n          `If you intend to import that asset, put the file in the src directory, and use ${colors.cyan(\n            rawUrl.replace(publicPath, '/src/'),\n          )} instead of ${colors.cyan(rawUrl)}.\\n` +\n          `If you intend to use the URL of that asset, use ${colors.cyan(\n            injectQuery(rawUrl.replace(publicPath, '/'), 'url'),\n          )}.`\n      }\n    } else {\n      warning =\n        `Files in the public directory are served at the root path.\\n` +\n        `Instead of ${colors.cyan(url)}, use ${colors.cyan(\n          url.replace(publicPath, '/'),\n        )}.`\n    }\n\n    server.config.logger.warn(colors.yellow(warning))\n  }\n}", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
{"CVE": "CVE-2025-46654", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "'use strict'\n\nconst fs = require('fs')\nconst Router = require('express').Router\nconst formidable = require('formidable')\n\nconst config = require('../config')\nconst logger = require('../logger')\nconst response = require('../response')\n\nconst imageRouter = module.exports = Router()\n\n// upload image\nimageRouter.post('/uploadimage', function (req, res) {\n  var form = new formidable.IncomingForm()\n\n  form.keepExtensions = true\n\n  form.parse(req, function (err, fields, files) {\n    if (err || !files.image || !files.image.path) {\n      response.errorForbidden(req, res)\n    } else {\n      if (config.debug) {\n        logger.info('SERVER received uploadimage: ' + JSON.stringify(files.image))\n      }\n\n      const uploadProvider = require('./' + config.imageUploadType)\n      uploadProvider.uploadImage(files.image.path, function (err, url) {\n        // remove temporary upload file, and ignore any error\n        fs.unlink(files.image.path, () => {})\n        if (err !== null) {\n          logger.error(err)\n          return res.status(500).end('upload image error')\n        }\n        res.send({\n          link: url\n        })\n      })\n    }\n  })\n})", "output": {"vulnerability_count": 1, "vulnerabilities": [{"description": "Detected that function argument `files` has entered the fs module. An attacker could potentially control the location of this file, to include going backwards in the directory with '../'. To address this, ensure that user-controlled variables in file paths are validated.", "risk": "Medium", "conceptual_fix": "Not provided", "line": 30}]}}
{"CVE": "CVE-2025-47934", "instruction": "Detect whether the following code contains vulnerabilities.", "input": "// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3.0 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nimport { isArrayStream, cancel as streamCancel, readToEnd as streamReadToEnd, fromAsync as streamFromAsync, transformPair as streamTransformPair, getWriter as streamGetWriter, getReader as streamGetReader } from '@openpgp/web-stream-tools';\nimport { armor, unarmor } from './encoding/armor';\nimport { Argon2OutOfMemoryError } from './type/s2k';\nimport defaultConfig from './config';\nimport { generateSessionKey } from './crypto';\nimport enums from './enums';\nimport util from './util';\nimport { Signature } from './signature';\nimport { getPreferredCipherSuite, createSignaturePacket } from './key';\nimport {\n  PacketList,\n  LiteralDataPacket,\n  CompressedDataPacket,\n  AEADEncryptedDataPacket,\n  SymEncryptedIntegrityProtectedDataPacket,\n  SymmetricallyEncryptedDataPacket,\n  PublicKeyEncryptedSessionKeyPacket,\n  SymEncryptedSessionKeyPacket,\n  OnePassSignaturePacket,\n  SignaturePacket\n} from './packet';\n\n// A Message can contain the following packets\nconst allowedMessagePackets = /*#__PURE__*/ util.constructAllowedPackets([\n  LiteralDataPacket,\n  CompressedDataPacket,\n  AEADEncryptedDataPacket,\n  SymEncryptedIntegrityProtectedDataPacket,\n  SymmetricallyEncryptedDataPacket,\n  PublicKeyEncryptedSessionKeyPacket,\n  SymEncryptedSessionKeyPacket,\n  OnePassSignaturePacket,\n  SignaturePacket\n]);\n// A SKESK packet can contain the following packets\nconst allowedSymSessionKeyPackets = /*#__PURE__*/ util.constructAllowedPackets([SymEncryptedSessionKeyPacket]);\n// A detached signature can contain the following packets\nconst allowedDetachedSignaturePackets = /*#__PURE__*/ util.constructAllowedPackets([SignaturePacket]);\n\n/**\n * Class that represents an OpenPGP message.\n * Can be an encrypted message, signed message, compressed message or literal message\n * See {@link https://tools.ietf.org/html/rfc4880#section-11.3}\n */\nexport class Message {\n  /**\n   * @param {PacketList} packetlist - The packets that form this message\n   */\n  constructor(packetlist) {\n    this.packets = packetlist || new PacketList();\n  }\n\n  /**\n   * Returns the key IDs of the keys to which the session key is encrypted\n   * @returns {Array<module:type/keyid~KeyID>} Array of keyID objects.\n   */\n  getEncryptionKeyIDs() {\n    const keyIDs = [];\n    const pkESKeyPacketlist = this.packets.filterByTag(enums.packet.publicKeyEncryptedSessionKey);\n    pkESKeyPacketlist.forEach(function(packet) {\n      keyIDs.push(packet.publicKeyID);\n    });\n    return keyIDs;\n  }\n\n  /**\n   * Returns the key IDs of the keys that signed the message\n   * @returns {Array<module:type/keyid~KeyID>} Array of keyID objects.\n   */\n  getSigningKeyIDs() {\n    const msg = this.unwrapCompressed();\n    // search for one pass signatures\n    const onePassSigList = msg.packets.filterByTag(enums.packet.onePassSignature);\n    if (onePassSigList.length > 0) {\n      return onePassSigList.map(packet => packet.issuerKeyID);\n    }\n    // if nothing found look for signature packets\n    const signatureList = msg.packets.filterByTag(enums.packet.signature);\n    return signatureList.map(packet => packet.issuerKeyID);\n  }\n\n  /**\n   * Decrypt the message. Either a private key, a session key, or a password must be specified.\n   * @param {Array<PrivateKey>} [decryptionKeys] - Private keys with decrypted secret data\n   * @param {Array<String>} [passwords] - Passwords used to decrypt\n   * @param {Array<Object>} [sessionKeys] - Session keys in the form: { data:Uint8Array, algorithm:String, [aeadAlgorithm:String] }\n   * @param {Date} [date] - Use the given date for key verification instead of the current time\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Message>} New message with decrypted content.\n   * @async\n   */\n  async decrypt(decryptionKeys, passwords, sessionKeys, date = new Date(), config = defaultConfig) {\n    const symEncryptedPacketlist = this.packets.filterByTag(\n      enums.packet.symmetricallyEncryptedData,\n      enums.packet.symEncryptedIntegrityProtectedData,\n      enums.packet.aeadEncryptedData\n    );\n\n    if (symEncryptedPacketlist.length === 0) {\n      throw new Error('No encrypted data found');\n    }\n\n    const symEncryptedPacket = symEncryptedPacketlist[0];\n    const expectedSymmetricAlgorithm = symEncryptedPacket.cipherAlgorithm;\n\n    const sessionKeyObjects = sessionKeys || await this.decryptSessionKeys(decryptionKeys, passwords, expectedSymmetricAlgorithm, date, config);\n\n    let exception = null;\n    const decryptedPromise = Promise.all(sessionKeyObjects.map(async ({ algorithm: algorithmName, data }) => {\n      if (!util.isUint8Array(data) || (!symEncryptedPacket.cipherAlgorithm && !util.isString(algorithmName))) {\n        throw new Error('Invalid session key for decryption.');\n      }\n\n      try {\n        const algo = symEncryptedPacket.cipherAlgorithm || enums.write(enums.symmetric, algorithmName);\n        await symEncryptedPacket.decrypt(algo, data, config);\n      } catch (e) {\n        util.printDebugError(e);\n        exception = e;\n      }\n    }));\n    // We don't await stream.cancel here because it only returns when the other copy is canceled too.\n    streamCancel(symEncryptedPacket.encrypted); // Don't keep copy of encrypted data in memory.\n    symEncryptedPacket.encrypted = null;\n    await decryptedPromise;\n\n    if (!symEncryptedPacket.packets || !symEncryptedPacket.packets.length) {\n      throw exception || new Error('Decryption failed.');\n    }\n\n    const resultMsg = new Message(symEncryptedPacket.packets);\n    symEncryptedPacket.packets = new PacketList(); // remove packets after decryption\n\n    return resultMsg;\n  }\n\n  /**\n   * Decrypt encrypted session keys either with private keys or passwords.\n   * @param {Array<PrivateKey>} [decryptionKeys] - Private keys with decrypted secret data\n   * @param {Array<String>} [passwords] - Passwords used to decrypt\n   * @param {enums.symmetric} [expectedSymmetricAlgorithm] - The symmetric algorithm the SEIPDv2 / AEAD packet is encrypted with (if applicable)\n   * @param {Date} [date] - Use the given date for key verification, instead of current time\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Array<{\n   *   data: Uint8Array,\n   *   algorithm: String\n   * }>>} array of object with potential sessionKey, algorithm pairs\n   * @async\n   */\n  async decryptSessionKeys(decryptionKeys, passwords, expectedSymmetricAlgorithm, date = new Date(), config = defaultConfig) {\n    let decryptedSessionKeyPackets = [];\n\n    let exception;\n    if (passwords) {\n      const skeskPackets = this.packets.filterByTag(enums.packet.symEncryptedSessionKey);\n      if (skeskPackets.length === 0) {\n        throw new Error('No symmetrically encrypted session key packet found.');\n      }\n      await Promise.all(passwords.map(async function(password, i) {\n        let packets;\n        if (i) {\n          packets = await PacketList.fromBinary(skeskPackets.write(), allowedSymSessionKeyPackets, config);\n        } else {\n          packets = skeskPackets;\n        }\n        await Promise.all(packets.map(async function(skeskPacket) {\n          try {\n            await skeskPacket.decrypt(password);\n            decryptedSessionKeyPackets.push(skeskPacket);\n          } catch (err) {\n            util.printDebugError(err);\n            if (err instanceof Argon2OutOfMemoryError) {\n              exception = err;\n            }\n          }\n        }));\n      }));\n    } else if (decryptionKeys) {\n      const pkeskPackets = this.packets.filterByTag(enums.packet.publicKeyEncryptedSessionKey);\n      if (pkeskPackets.length === 0) {\n        throw new Error('No public key encrypted session key packet found.');\n      }\n      await Promise.all(pkeskPackets.map(async function(pkeskPacket) {\n        await Promise.all(decryptionKeys.map(async function(decryptionKey) {\n          let decryptionKeyPackets;\n          try {\n            // do not check key expiration to allow decryption of old messages\n            decryptionKeyPackets = (await decryptionKey.getDecryptionKeys(pkeskPacket.publicKeyID, null, undefined, config)).map(key => key.keyPacket);\n          } catch (err) {\n            exception = err;\n            return;\n          }\n\n          let algos = [\n            enums.symmetric.aes256, // Old OpenPGP.js default fallback\n            enums.symmetric.aes128, // RFC4880bis fallback\n            enums.symmetric.tripledes, // RFC4880 fallback\n            enums.symmetric.cast5 // Golang OpenPGP fallback\n          ];\n          try {\n            const selfCertification = await decryptionKey.getPrimarySelfSignature(date, undefined, config); // TODO: Pass userID from somewhere.\n            if (selfCertification.preferredSymmetricAlgorithms) {\n              algos = algos.concat(selfCertification.preferredSymmetricAlgorithms);\n            }\n          } catch (e) {}\n\n          await Promise.all(decryptionKeyPackets.map(async function(decryptionKeyPacket) {\n            if (!decryptionKeyPacket.isDecrypted()) {\n              throw new Error('Decryption key is not decrypted.');\n            }\n\n            // To hinder CCA attacks against PKCS1, we carry out a constant-time decryption flow if the `constantTimePKCS1Decryption` config option is set.\n            const doConstantTimeDecryption = config.constantTimePKCS1Decryption && (\n              pkeskPacket.publicKeyAlgorithm === enums.publicKey.rsaEncrypt ||\n              pkeskPacket.publicKeyAlgorithm === enums.publicKey.rsaEncryptSign ||\n              pkeskPacket.publicKeyAlgorithm === enums.publicKey.rsaSign ||\n              pkeskPacket.publicKeyAlgorithm === enums.publicKey.elgamal\n            );\n\n            if (doConstantTimeDecryption) {\n              // The goal is to not reveal whether PKESK decryption (specifically the PKCS1 decoding step) failed, hence, we always proceed to decrypt the message,\n              // either with the successfully decrypted session key, or with a randomly generated one.\n              // Since the SEIP/AEAD's symmetric algorithm and key size are stored in the encrypted portion of the PKESK, and the execution flow cannot depend on\n              // the decrypted payload, we always assume the message to be encrypted with one of the symmetric algorithms specified in `config.constantTimePKCS1DecryptionSupportedSymmetricAlgorithms`:\n              // - If the PKESK decryption succeeds, and the session key cipher is in the supported set, then we try to decrypt the data with the decrypted session key as well as with the\n              // randomly generated keys of the remaining key types.\n              // - If the PKESK decryptions fails, or if it succeeds but support for the cipher is not enabled, then we discard the session key and try to decrypt the data using only the randomly\n              // generated session keys.\n              // NB: as a result, if the data is encrypted with a non-suported cipher, decryption will always fail.\n\n              const serialisedPKESK = pkeskPacket.write(); // make copies to be able to decrypt the PKESK packet multiple times\n              await Promise.all((\n                expectedSymmetricAlgorithm ?\n                  [expectedSymmetricAlgorithm] :\n                  Array.from(config.constantTimePKCS1DecryptionSupportedSymmetricAlgorithms)\n              ).map(async sessionKeyAlgorithm => {\n                const pkeskPacketCopy = new PublicKeyEncryptedSessionKeyPacket();\n                pkeskPacketCopy.read(serialisedPKESK);\n                const randomSessionKey = {\n                  sessionKeyAlgorithm,\n                  sessionKey: generateSessionKey(sessionKeyAlgorithm)\n                };\n                try {\n                  await pkeskPacketCopy.decrypt(decryptionKeyPacket, randomSessionKey);\n                  decryptedSessionKeyPackets.push(pkeskPacketCopy);\n                } catch (err) {\n                  // `decrypt` can still throw some non-security-sensitive errors\n                  util.printDebugError(err);\n                  exception = err;\n                }\n              }));\n\n            } else {\n              try {\n                await pkeskPacket.decrypt(decryptionKeyPacket);\n                const symmetricAlgorithm = expectedSymmetricAlgorithm || pkeskPacket.sessionKeyAlgorithm;\n                if (symmetricAlgorithm && !algos.includes(enums.write(enums.symmetric, symmetricAlgorithm))) {\n                  throw new Error('A non-preferred symmetric algorithm was used.');\n                }\n                decryptedSessionKeyPackets.push(pkeskPacket);\n              } catch (err) {\n                util.printDebugError(err);\n                exception = err;\n              }\n            }\n          }));\n        }));\n        streamCancel(pkeskPacket.encrypted); // Don't keep copy of encrypted data in memory.\n        pkeskPacket.encrypted = null;\n      }));\n    } else {\n      throw new Error('No key or password specified.');\n    }\n\n    if (decryptedSessionKeyPackets.length > 0) {\n      // Return only unique session keys\n      if (decryptedSessionKeyPackets.length > 1) {\n        const seen = new Set();\n        decryptedSessionKeyPackets = decryptedSessionKeyPackets.filter(item => {\n          const k = item.sessionKeyAlgorithm + util.uint8ArrayToString(item.sessionKey);\n          if (seen.has(k)) {\n            return false;\n          }\n          seen.add(k);\n          return true;\n        });\n      }\n\n      return decryptedSessionKeyPackets.map(packet => ({\n        data: packet.sessionKey,\n        algorithm: packet.sessionKeyAlgorithm && enums.read(enums.symmetric, packet.sessionKeyAlgorithm)\n      }));\n    }\n    throw exception || new Error('Session key decryption failed.');\n  }\n\n  /**\n   * Get literal data that is the body of the message\n   * @returns {(Uint8Array|null)} Literal body of the message as Uint8Array.\n   */\n  getLiteralData() {\n    const msg = this.unwrapCompressed();\n    const literal = msg.packets.findPacket(enums.packet.literalData);\n    return (literal && literal.getBytes()) || null;\n  }\n\n  /**\n   * Get filename from literal data packet\n   * @returns {(String|null)} Filename of literal data packet as string.\n   */\n  getFilename() {\n    const msg = this.unwrapCompressed();\n    const literal = msg.packets.findPacket(enums.packet.literalData);\n    return (literal && literal.getFilename()) || null;\n  }\n\n  /**\n   * Get literal data as text\n   * @returns {(String|null)} Literal body of the message interpreted as text.\n   */\n  getText() {\n    const msg = this.unwrapCompressed();\n    const literal = msg.packets.findPacket(enums.packet.literalData);\n    if (literal) {\n      return literal.getText();\n    }\n    return null;\n  }\n\n  /**\n   * Generate a new session key object, taking the algorithm preferences of the passed encryption keys into account, if any.\n   * @param {Array<PublicKey>} [encryptionKeys] - Public key(s) to select algorithm preferences for\n   * @param {Date} [date] - Date to select algorithm preferences at\n   * @param {Array<Object>} [userIDs] - User IDs to select algorithm preferences for\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<{ data: Uint8Array, algorithm: String, aeadAlgorithm: undefined|String }>} Object with session key data and algorithms.\n   * @async\n   */\n  static async generateSessionKey(encryptionKeys = [], date = new Date(), userIDs = [], config = defaultConfig) {\n    const { symmetricAlgo, aeadAlgo } = await getPreferredCipherSuite(encryptionKeys, date, userIDs, config);\n    const symmetricAlgoName = enums.read(enums.symmetric, symmetricAlgo);\n    const aeadAlgoName = aeadAlgo ? enums.read(enums.aead, aeadAlgo) : undefined;\n\n    await Promise.all(encryptionKeys.map(key => key.getEncryptionKey()\n      .catch(() => null) // ignore key strength requirements\n      .then(maybeKey => {\n        if (maybeKey && (maybeKey.keyPacket.algorithm === enums.publicKey.x25519 || maybeKey.keyPacket.algorithm === enums.publicKey.x448) &&\n          !aeadAlgoName && !util.isAES(symmetricAlgo)) { // if AEAD is defined, then PKESK v6 are used, and the algo info is encrypted\n          throw new Error('Could not generate a session key compatible with the given `encryptionKeys`: X22519 and X448 keys can only be used to encrypt AES session keys; change `config.preferredSymmetricAlgorithm` accordingly.');\n        }\n      })\n    ));\n\n    const sessionKeyData = generateSessionKey(symmetricAlgo);\n    return { data: sessionKeyData, algorithm: symmetricAlgoName, aeadAlgorithm: aeadAlgoName };\n  }\n\n  /**\n   * Encrypt the message either with public keys, passwords, or both at once.\n   * @param {Array<PublicKey>} [encryptionKeys] - Public key(s) for message encryption\n   * @param {Array<String>} [passwords] - Password(s) for message encryption\n   * @param {Object} [sessionKey] - Session key in the form: { data:Uint8Array, algorithm:String, [aeadAlgorithm:String] }\n   * @param {Boolean} [wildcard] - Use a key ID of 0 instead of the public key IDs\n   * @param {Array<module:type/keyid~KeyID>} [encryptionKeyIDs] - Array of key IDs to use for encryption. Each encryptionKeyIDs[i] corresponds to keys[i]\n   * @param {Date} [date] - Override the creation date of the literal package\n   * @param {Array<Object>} [userIDs] - User IDs to encrypt for, e.g. [{ name:'Robert Receiver', email:'robert@openpgp.org' }]\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Message>} New message with encrypted content.\n   * @async\n   */\n  async encrypt(encryptionKeys, passwords, sessionKey, wildcard = false, encryptionKeyIDs = [], date = new Date(), userIDs = [], config = defaultConfig) {\n    if (sessionKey) {\n      if (!util.isUint8Array(sessionKey.data) || !util.isString(sessionKey.algorithm)) {\n        throw new Error('Invalid session key for encryption.');\n      }\n    } else if (encryptionKeys && encryptionKeys.length) {\n      sessionKey = await Message.generateSessionKey(encryptionKeys, date, userIDs, config);\n    } else if (passwords && passwords.length) {\n      sessionKey = await Message.generateSessionKey(undefined, undefined, undefined, config);\n    } else {\n      throw new Error('No keys, passwords, or session key provided.');\n    }\n\n    const { data: sessionKeyData, algorithm: algorithmName, aeadAlgorithm: aeadAlgorithmName } = sessionKey;\n\n    const msg = await Message.encryptSessionKey(sessionKeyData, algorithmName, aeadAlgorithmName, encryptionKeys, passwords, wildcard, encryptionKeyIDs, date, userIDs, config);\n\n    const symEncryptedPacket = SymEncryptedIntegrityProtectedDataPacket.fromObject({\n      version: aeadAlgorithmName ? 2 : 1,\n      aeadAlgorithm: aeadAlgorithmName ? enums.write(enums.aead, aeadAlgorithmName) : null\n    });\n    symEncryptedPacket.packets = this.packets;\n\n    const algorithm = enums.write(enums.symmetric, algorithmName);\n    await symEncryptedPacket.encrypt(algorithm, sessionKeyData, config);\n\n    msg.packets.push(symEncryptedPacket);\n    symEncryptedPacket.packets = new PacketList(); // remove packets after encryption\n    return msg;\n  }\n\n  /**\n   * Encrypt a session key either with public keys, passwords, or both at once.\n   * @param {Uint8Array} sessionKey - session key for encryption\n   * @param {String} algorithmName - session key algorithm\n   * @param {String} [aeadAlgorithmName] - AEAD algorithm, e.g. 'eax' or 'ocb'\n   * @param {Array<PublicKey>} [encryptionKeys] - Public key(s) for message encryption\n   * @param {Array<String>} [passwords] - For message encryption\n   * @param {Boolean} [wildcard] - Use a key ID of 0 instead of the public key IDs\n   * @param {Array<module:type/keyid~KeyID>} [encryptionKeyIDs] - Array of key IDs to use for encryption. Each encryptionKeyIDs[i] corresponds to encryptionKeys[i]\n   * @param {Date} [date] - Override the date\n   * @param {Array} [userIDs] - User IDs to encrypt for, e.g. [{ name:'Robert Receiver', email:'robert@openpgp.org' }]\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Message>} New message with encrypted content.\n   * @async\n   */\n  static async encryptSessionKey(sessionKey, algorithmName, aeadAlgorithmName, encryptionKeys, passwords, wildcard = false, encryptionKeyIDs = [], date = new Date(), userIDs = [], config = defaultConfig) {\n    const packetlist = new PacketList();\n    const symmetricAlgorithm = enums.write(enums.symmetric, algorithmName);\n    const aeadAlgorithm = aeadAlgorithmName && enums.write(enums.aead, aeadAlgorithmName);\n\n    if (encryptionKeys) {\n      const results = await Promise.all(encryptionKeys.map(async function(primaryKey, i) {\n        const encryptionKey = await primaryKey.getEncryptionKey(encryptionKeyIDs[i], date, userIDs, config);\n\n        const pkESKeyPacket = PublicKeyEncryptedSessionKeyPacket.fromObject({\n          version: aeadAlgorithm ? 6 : 3,\n          encryptionKeyPacket: encryptionKey.keyPacket,\n          anonymousRecipient: wildcard,\n          sessionKey,\n          sessionKeyAlgorithm: symmetricAlgorithm\n        });\n\n        await pkESKeyPacket.encrypt(encryptionKey.keyPacket);\n        delete pkESKeyPacket.sessionKey; // delete plaintext session key after encryption\n        return pkESKeyPacket;\n      }));\n      packetlist.push(...results);\n    }\n    if (passwords) {\n      const testDecrypt = async function(keyPacket, password) {\n        try {\n          await keyPacket.decrypt(password);\n          return 1;\n        } catch (e) {\n          return 0;\n        }\n      };\n\n      const sum = (accumulator, currentValue) => accumulator + currentValue;\n\n      const encryptPassword = async function(sessionKey, algorithm, aeadAlgorithm, password) {\n        const symEncryptedSessionKeyPacket = new SymEncryptedSessionKeyPacket(config);\n        symEncryptedSessionKeyPacket.sessionKey = sessionKey;\n        symEncryptedSessionKeyPacket.sessionKeyAlgorithm = algorithm;\n        if (aeadAlgorithm) {\n          symEncryptedSessionKeyPacket.aeadAlgorithm = aeadAlgorithm;\n        }\n        await symEncryptedSessionKeyPacket.encrypt(password, config);\n\n        if (config.passwordCollisionCheck) {\n          const results = await Promise.all(passwords.map(pwd => testDecrypt(symEncryptedSessionKeyPacket, pwd)));\n          if (results.reduce(sum) !== 1) {\n            return encryptPassword(sessionKey, algorithm, password);\n          }\n        }\n\n        delete symEncryptedSessionKeyPacket.sessionKey; // delete plaintext session key after encryption\n        return symEncryptedSessionKeyPacket;\n      };\n\n      const results = await Promise.all(passwords.map(pwd => encryptPassword(sessionKey, symmetricAlgorithm, aeadAlgorithm, pwd)));\n      packetlist.push(...results);\n    }\n\n    return new Message(packetlist);\n  }\n\n  /**\n   * Sign the message (the literal data packet of the message)\n   * @param {Array<PrivateKey>} signingKeys - private keys with decrypted secret key data for signing\n   * @param {Array<Key>} recipientKeys - recipient keys to get the signing preferences from\n   * @param {Signature} [signature] - Any existing detached signature to add to the message\n   * @param {Array<module:type/keyid~KeyID>} [signingKeyIDs] - Array of key IDs to use for signing. Each signingKeyIDs[i] corresponds to signingKeys[i]\n   * @param {Date} [date] - Override the creation time of the signature\n   * @param {Array<UserID>} [signingUserIDs] - User IDs to sign with, e.g. [{ name:'Steve Sender', email:'steve@openpgp.org' }]\n   * @param {Array<UserID>} [recipientUserIDs] - User IDs associated with `recipientKeys` to get the signing preferences from\n   * @param {Array} [notations] - Notation Data to add to the signatures, e.g. [{ name: 'test@example.org', value: new TextEncoder().encode('test'), humanReadable: true, critical: false }]\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Message>} New message with signed content.\n   * @async\n   */\n  async sign(signingKeys = [], recipientKeys = [], signature = null, signingKeyIDs = [], date = new Date(), signingUserIDs = [], recipientUserIDs = [], notations = [], config = defaultConfig) {\n    const packetlist = new PacketList();\n\n    const literalDataPacket = this.packets.findPacket(enums.packet.literalData);\n    if (!literalDataPacket) {\n      throw new Error('No literal data packet to sign.');\n    }\n\n    const signaturePackets = await createSignaturePackets(literalDataPacket, signingKeys, recipientKeys, signature, signingKeyIDs, date, signingUserIDs, recipientUserIDs, notations, false, config); // this returns the existing signature packets as well\n    const onePassSignaturePackets = signaturePackets.map(\n      (signaturePacket, i) => OnePassSignaturePacket.fromSignaturePacket(signaturePacket, i === 0))\n      .reverse(); // innermost OPS refers to the first signature packet\n\n    packetlist.push(...onePassSignaturePackets);\n    packetlist.push(literalDataPacket);\n    packetlist.push(...signaturePackets);\n\n    return new Message(packetlist);\n  }\n\n  /**\n   * Compresses the message (the literal and -if signed- signature data packets of the message)\n   * @param {module:enums.compression} algo - compression algorithm\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Message} New message with compressed content.\n   */\n  compress(algo, config = defaultConfig) {\n    if (algo === enums.compression.uncompressed) {\n      return this;\n    }\n\n    const compressed = new CompressedDataPacket(config);\n    compressed.algorithm = algo;\n    compressed.packets = this.packets;\n\n    const packetList = new PacketList();\n    packetList.push(compressed);\n\n    return new Message(packetList);\n  }\n\n  /**\n   * Create a detached signature for the message (the literal data packet of the message)\n   * @param {Array<PrivateKey>} signingKeys - private keys with decrypted secret key data for signing\n   * @param {Array<Key>} recipientKeys - recipient keys to get the signing preferences from\n   * @param {Signature} [signature] - Any existing detached signature\n   * @param {Array<module:type/keyid~KeyID>} [signingKeyIDs] - Array of key IDs to use for signing. Each signingKeyIDs[i] corresponds to signingKeys[i]\n   * @param {Date} [date] - Override the creation time of the signature\n   * @param {Array<UserID>} [signingUserIDs] - User IDs to sign with, e.g. [{ name:'Steve Sender', email:'steve@openpgp.org' }]\n   * @param {Array<UserID>} [recipientUserIDs] - User IDs associated with `recipientKeys` to get the signing preferences from\n   * @param {Array} [notations] - Notation Data to add to the signatures, e.g. [{ name: 'test@example.org', value: new TextEncoder().encode('test'), humanReadable: true, critical: false }]\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Signature>} New detached signature of message content.\n   * @async\n   */\n  async signDetached(signingKeys = [], recipientKeys = [], signature = null, signingKeyIDs = [], recipientKeyIDs = [], date = new Date(), userIDs = [], notations = [], config = defaultConfig) {\n    const literalDataPacket = this.packets.findPacket(enums.packet.literalData);\n    if (!literalDataPacket) {\n      throw new Error('No literal data packet to sign.');\n    }\n    return new Signature(await createSignaturePackets(literalDataPacket, signingKeys, recipientKeys, signature, signingKeyIDs, recipientKeyIDs, date, userIDs, notations, true, config));\n  }\n\n  /**\n   * Verify message signatures\n   * @param {Array<PublicKey>} verificationKeys - Array of public keys to verify signatures\n   * @param {Date} [date] - Verify the signature against the given date, i.e. check signature creation time < date < expiration time\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Array<{\n   *   keyID: module:type/keyid~KeyID,\n   *   signature: Promise<Signature>,\n   *   verified: Promise<true>\n   * }>>} List of signer's keyID and validity of signatures.\n   * @async\n   */\n  async verify(verificationKeys, date = new Date(), config = defaultConfig) {\n    const msg = this.unwrapCompressed();\n    const literalDataList = msg.packets.filterByTag(enums.packet.literalData);\n    if (literalDataList.length !== 1) {\n      throw new Error('Can only verify message with one literal data packet.');\n    }\n    let packets = msg.packets;\n    if (isArrayStream(packets.stream)) {\n      packets = packets.concat(await streamReadToEnd(packets.stream, _ => _ || []));\n    }\n    const onePassSigList = packets.filterByTag(enums.packet.onePassSignature).reverse();\n    const signatureList = packets.filterByTag(enums.packet.signature);\n    if (onePassSigList.length && !signatureList.length && util.isStream(packets.stream) && !isArrayStream(packets.stream)) {\n      await Promise.all(onePassSigList.map(async onePassSig => {\n        onePassSig.correspondingSig = new Promise((resolve, reject) => {\n          onePassSig.correspondingSigResolve = resolve;\n          onePassSig.correspondingSigReject = reject;\n        });\n        onePassSig.signatureData = streamFromAsync(async () => (await onePassSig.correspondingSig).signatureData);\n        onePassSig.hashed = streamReadToEnd(await onePassSig.hash(onePassSig.signatureType, literalDataList[0], undefined, false));\n        onePassSig.hashed.catch(() => {});\n      }));\n      packets.stream = streamTransformPair(packets.stream, async (readable, writable) => {\n        const reader = streamGetReader(readable);\n        const writer = streamGetWriter(writable);\n        try {\n          for (let i = 0; i < onePassSigList.length; i++) {\n            const { value: signature } = await reader.read();\n            onePassSigList[i].correspondingSigResolve(signature);\n          }\n          await reader.readToEnd();\n          await writer.ready;\n          await writer.close();\n        } catch (e) {\n          onePassSigList.forEach(onePassSig => {\n            onePassSig.correspondingSigReject(e);\n          });\n          await writer.abort(e);\n        }\n      });\n      return createVerificationObjects(onePassSigList, literalDataList, verificationKeys, date, false, config);\n    }\n    return createVerificationObjects(signatureList, literalDataList, verificationKeys, date, false, config);\n  }\n\n  /**\n   * Verify detached message signature\n   * @param {Array<PublicKey>} verificationKeys - Array of public keys to verify signatures\n   * @param {Signature} signature\n   * @param {Date} date - Verify the signature against the given date, i.e. check signature creation time < date < expiration time\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {Promise<Array<{\n   *   keyID: module:type/keyid~KeyID,\n   *   signature: Promise<Signature>,\n   *   verified: Promise<true>\n   * }>>} List of signer's keyID and validity of signature.\n   * @async\n   */\n  verifyDetached(signature, verificationKeys, date = new Date(), config = defaultConfig) {\n    const msg = this.unwrapCompressed();\n    const literalDataList = msg.packets.filterByTag(enums.packet.literalData);\n    if (literalDataList.length !== 1) {\n      throw new Error('Can only verify message with one literal data packet.');\n    }\n    const signatureList = signature.packets.filterByTag(enums.packet.signature); // drop UnparsablePackets\n    return createVerificationObjects(signatureList, literalDataList, verificationKeys, date, true, config);\n  }\n\n  /**\n   * Unwrap compressed message\n   * @returns {Message} Message Content of compressed message.\n   */\n  unwrapCompressed() {\n    const compressed = this.packets.filterByTag(enums.packet.compressedData);\n    if (compressed.length) {\n      return new Message(compressed[0].packets);\n    }\n    return this;\n  }\n\n  /**\n   * Append signature to unencrypted message object\n   * @param {String|Uint8Array} detachedSignature - The detached ASCII-armored or Uint8Array PGP signature\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   */\n  async appendSignature(detachedSignature, config = defaultConfig) {\n    await this.packets.read(\n      util.isUint8Array(detachedSignature) ? detachedSignature : (await unarmor(detachedSignature)).data,\n      allowedDetachedSignaturePackets,\n      config\n    );\n  }\n\n  /**\n   * Returns binary encoded message\n   * @returns {ReadableStream<Uint8Array>} Binary message.\n   */\n  write() {\n    return this.packets.write();\n  }\n\n  /**\n   * Returns ASCII armored text of message\n   * @param {Object} [config] - Full configuration, defaults to openpgp.config\n   * @returns {ReadableStream<String>} ASCII armor.\n   */\n  armor(config = defaultConfig) {\n    const trailingPacket = this.packets[this.packets.length - 1];\n    // An ASCII-armored Encrypted Message packet sequence that ends in an v2 SEIPD packet MUST NOT contain a CRC24 footer.\n    // An ASCII-armored sequence of Signature packets that only includes v6 Signature packets MUST NOT contain a CRC24 footer.\n    const emitChecksum = trailingPacket.constructor.tag === SymEncryptedIntegrityProtectedDataPacket.tag ?\n      trailingPacket.version !== 2 :\n      this.packets.some(packet => packet.constructor.tag === SignaturePacket.tag && packet.version !== 6);\n    return armor(enums.armor.message, this.write(), null, null, null, emitChecksum, config);\n  }\n}\n\n/**\n * Create signature packets for the message\n * @param {LiteralDataPacket} literalDataPacket - the literal data packet to sign\n * @param {Array<PrivateKey>} [signingKeys] - private keys with decrypted secret key data for signing\n * @param {Array<Key>} [recipientKeys] - recipient keys to get the signing preferences from\n * @param {Signature} [signature] - Any existing detached signature to append\n * @param {Array<module:type/keyid~KeyID>} [signingKeyIDs] - Array of key IDs to use for signing. Each signingKeyIDs[i] corresponds to signingKeys[i]\n * @param {Date} [date] - Override the creationtime of the signature\n * @param {Array<UserID>} [signingUserIDs] - User IDs to sign to, e.g. [{ name:'Steve Sender', email:'steve@openpgp.org' }]\n * @param {Array<UserID>} [recipientUserIDs] - User IDs associated with `recipientKeys` to get the signing preferences from\n * @param {Array} [notations] - Notation Data to add to the signatures, e.g. [{ name: 'test@example.org', value: new TextEncoder().encode('test'), humanReadable: true, critical: false }]\n * @param {Array} [signatureSalts] - A list of signature salts matching the number of signingKeys that should be used for v6 signatures\n * @param {Boolean} [detached] - Whether to create detached signature packets\n * @param {Object} [config] - Full configuration, defaults to openpgp.config\n * @returns {Promise<PacketList>} List of signature packets.\n * @async\n * @private\n */\nexport async function createSignaturePackets(literalDataPacket, signingKeys, recipientKeys = [], signature = null, signingKeyIDs = [], date = new Date(), signingUserIDs = [], recipientUserIDs = [], notations = [], detached = false, config = defaultConfig) {\n  const packetlist = new PacketList();\n\n  // If data packet was created from Uint8Array, use binary, otherwise use text\n  const signatureType = literalDataPacket.text === null ?\n    enums.signature.binary : enums.signature.text;\n\n  await Promise.all(signingKeys.map(async (primaryKey, i) => {\n    const signingUserID = signingUserIDs[i];\n    if (!primaryKey.isPrivate()) {\n      throw new Error('Need private key for signing');\n    }\n    const signingKey = await primaryKey.getSigningKey(signingKeyIDs[i], date, signingUserID, config);\n    return createSignaturePacket(literalDataPacket, recipientKeys.length ? recipientKeys : [primaryKey], signingKey.keyPacket, { signatureType }, date, recipientUserIDs, notations, detached, config);\n  })).then(signatureList => {\n    packetlist.push(...signatureList);\n  });\n\n  if (signature) {\n    const existingSigPacketlist = signature.packets.filterByTag(enums.packet.signature);\n    packetlist.push(...existingSigPacketlist);\n  }\n  return packetlist;\n}\n\n/**\n * Create object containing signer's keyID and validity of signature\n * @param {SignaturePacket} signature - Signature packet\n * @param {Array<LiteralDataPacket>} literalDataList - Array of literal data packets\n * @param {Array<PublicKey>} verificationKeys - Array of public keys to verify signatures\n * @param {Date} [date] - Check signature validity with respect to the given date\n * @param {Boolean} [detached] - Whether to verify detached signature packets\n * @param {Object} [config] - Full configuration, defaults to openpgp.config\n * @returns {Promise<{\n *   keyID: module:type/keyid~KeyID,\n *   signature: Promise<Signature>,\n *   verified: Promise<true>\n * }>} signer's keyID and validity of signature\n * @async\n * @private\n */\nasync function createVerificationObject(signature, literalDataList, verificationKeys, date = new Date(), detached = false, config = defaultConfig) {\n  let primaryKey;\n  let unverifiedSigningKey;\n\n  for (const key of verificationKeys) {\n    const issuerKeys = key.getKeys(signature.issuerKeyID);\n    if (issuerKeys.length > 0) {\n      primaryKey = key;\n      unverifiedSigningKey = issuerKeys[0];\n      break;\n    }\n  }\n\n  const isOnePassSignature = signature instanceof OnePassSignaturePacket;\n  const signaturePacketPromise = isOnePassSignature ? signature.correspondingSig : signature;\n\n  const verifiedSig = {\n    keyID: signature.issuerKeyID,\n    verified: (async () => {\n      if (!unverifiedSigningKey) {\n        throw new Error(`Could not find signing key with key ID ${signature.issuerKeyID.toHex()}`);\n      }\n\n      await signature.verify(unverifiedSigningKey.keyPacket, signature.signatureType, literalDataList[0], date, detached, config);\n      const signaturePacket = await signaturePacketPromise;\n      if (unverifiedSigningKey.getCreationTime() > signaturePacket.created) {\n        throw new Error('Key is newer than the signature');\n      }\n      // We pass the signature creation time to check whether the key was expired at the time of signing.\n      // We check this after signature verification because for streamed one-pass signatures, the creation time is not available before\n      try {\n        await primaryKey.getSigningKey(unverifiedSigningKey.getKeyID(), signaturePacket.created, undefined, config);\n      } catch (e) {\n        // If a key was reformatted then the self-signatures of the signing key might be in the future compared to the message signature,\n        // making the key invalid at the time of signing.\n        // However, if the key is valid at the given `date`, we still allow using it provided the relevant `config` setting is enabled.\n        // Note: we do not support the edge case of a key that was reformatted and it has expired.\n        if (config.allowInsecureVerificationWithReformattedKeys && e.message.match(/Signature creation time is in the future/)) {\n          await primaryKey.getSigningKey(unverifiedSigningKey.getKeyID(), date, undefined, config);\n        } else {\n          throw e;\n        }\n      }\n      return true;\n    })(),\n    signature: (async () => {\n      const signaturePacket = await signaturePacketPromise;\n      const packetlist = new PacketList();\n      signaturePacket && packetlist.push(signaturePacket);\n      return new Signature(packetlist);\n    })()\n  };\n\n  // Mark potential promise rejections as \"handled\". This is needed because in\n  // some cases, we reject them before the user has a reasonable chance to\n  // handle them (e.g. `await readToEnd(result.data); await result.verified` and\n  // the data stream errors).\n  verifiedSig.signature.catch(() => {});\n  verifiedSig.verified.catch(() => {});\n\n  return verifiedSig;\n}\n\n/**\n * Create list of objects containing signer's keyID and validity of signature\n * @param {Array<SignaturePacket>} signatureList - Array of signature packets\n * @param {Array<LiteralDataPacket>} literalDataList - Array of literal data packets\n * @param {Array<PublicKey>} verificationKeys - Array of public keys to verify signatures\n * @param {Date} date - Verify the signature against the given date,\n *                    i.e. check signature creation time < date < expiration time\n * @param {Boolean} [detached] - Whether to verify detached signature packets\n * @param {Object} [config] - Full configuration, defaults to openpgp.config\n * @returns {Promise<Array<{\n *   keyID: module:type/keyid~KeyID,\n *   signature: Promise<Signature>,\n *   verified: Promise<true>\n * }>>} list of signer's keyID and validity of signatures (one entry per signature packet in input)\n * @async\n * @private\n */\nexport async function createVerificationObjects(signatureList, literalDataList, verificationKeys, date = new Date(), detached = false, config = defaultConfig) {\n  return Promise.all(signatureList.filter(function(signature) {\n    return ['text', 'binary'].includes(enums.read(enums.signature, signature.signatureType));\n  }).map(async function(signature) {\n    return createVerificationObject(signature, literalDataList, verificationKeys, date, detached, config);\n  }));\n}\n\n/**\n * Reads an (optionally armored) OpenPGP message and returns a Message object\n * @param {Object} options\n * @param {String | ReadableStream<String>} [options.armoredMessage] - Armored message to be parsed\n * @param {Uint8Array | ReadableStream<Uint8Array>} [options.binaryMessage] - Binary to be parsed\n * @param {Object} [options.config] - Custom configuration settings to overwrite those in [config]{@link module:config}\n * @returns {Promise<Message>} New message object.\n * @async\n * @static\n */\nexport async function readMessage({ armoredMessage, binaryMessage, config, ...rest }) {\n  config = { ...defaultConfig, ...config };\n  let input = armoredMessage || binaryMessage;\n  if (!input) {\n    throw new Error('readMessage: must pass options object containing `armoredMessage` or `binaryMessage`');\n  }\n  if (armoredMessage && !util.isString(armoredMessage) && !util.isStream(armoredMessage)) {\n    throw new Error('readMessage: options.armoredMessage must be a string or stream');\n  }\n  if (binaryMessage && !util.isUint8Array(binaryMessage) && !util.isStream(binaryMessage)) {\n    throw new Error('readMessage: options.binaryMessage must be a Uint8Array or stream');\n  }\n  const unknownOptions = Object.keys(rest); if (unknownOptions.length > 0) throw new Error(`Unknown option: ${unknownOptions.join(', ')}`);\n\n  const streamType = util.isStream(input);\n  if (armoredMessage) {\n    const { type, data } = await unarmor(input, config);\n    if (type !== enums.armor.message) {\n      throw new Error('Armored text not of type message');\n    }\n    input = data;\n  }\n  const packetlist = await PacketList.fromBinary(input, allowedMessagePackets, config);\n  const message = new Message(packetlist);\n  message.fromStream = streamType;\n  return message;\n}\n\n/**\n * Creates new message object from text or binary data.\n * @param {Object} options\n * @param {String | ReadableStream<String>} [options.text] - The text message contents\n * @param {Uint8Array | ReadableStream<Uint8Array>} [options.binary] - The binary message contents\n * @param {String} [options.filename=\"\"] - Name of the file (if any)\n * @param {Date} [options.date=current date] - Date of the message, or modification date of the file\n * @param {'utf8'|'binary'|'text'|'mime'} [options.format='utf8' if text is passed, 'binary' otherwise] - Data packet type\n * @returns {Promise<Message>} New message object.\n * @async\n * @static\n */\nexport async function createMessage({ text, binary, filename, date = new Date(), format = text !== undefined ? 'utf8' : 'binary', ...rest }) {\n  const input = text !== undefined ? text : binary;\n  if (input === undefined) {\n    throw new Error('createMessage: must pass options object containing `text` or `binary`');\n  }\n  if (text && !util.isString(text) && !util.isStream(text)) {\n    throw new Error('createMessage: options.text must be a string or stream');\n  }\n  if (binary && !util.isUint8Array(binary) && !util.isStream(binary)) {\n    throw new Error('createMessage: options.binary must be a Uint8Array or stream');\n  }\n  const unknownOptions = Object.keys(rest); if (unknownOptions.length > 0) throw new Error(`Unknown option: ${unknownOptions.join(', ')}`);\n\n  const streamType = util.isStream(input);\n  const literalDataPacket = new LiteralDataPacket(date);\n  if (text !== undefined) {\n    literalDataPacket.setText(input, enums.write(enums.literal, format));\n  } else {\n    literalDataPacket.setBytes(input, enums.write(enums.literal, format));\n  }\n  if (filename !== undefined) {\n    literalDataPacket.setFilename(filename);\n  }\n  const literalDataPacketlist = new PacketList();\n  literalDataPacketlist.push(literalDataPacket);\n  const message = new Message(literalDataPacketlist);\n  message.fromStream = streamType;\n  return message;\n}", "output": {"vulnerability_count": 0, "vulnerabilities": []}}
